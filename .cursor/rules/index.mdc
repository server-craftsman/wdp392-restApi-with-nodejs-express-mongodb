---
description: 
globs: 
alwaysApply: true
---
Repository: server-craftsman/wdp392-restapi-with-nodejs-express-mongodb
Files analyzed: 407

Estimated tokens: 393.6k

Directory structure:
└── server-craftsman-wdp392-restapi-with-nodejs-express-mongodb/
    ├── README.md
    ├── Dockerfile
    ├── fly.toml
    ├── package.json
    ├── pnpm-lock.yaml
    ├── README-VERCEL-OPTIMIZATION.md
    ├── render.yaml
    ├── swagger.yaml
    ├── tsconfig.json
    ├── vercel.json
    ├── web.config
    ├── webpack.config.js
    ├── .eslintrc
    ├── .lintstagedrc
    ├── .prettierrc
    ├── assets/
    │   └── fonts/
    │       ├── NotoSans-Bold.ttf
    │       ├── NotoSans-BoldItalic.ttf
    │       ├── NotoSans-Italic.ttf
    │       ├── NotoSans-Regular.ttf
    │       └── Noto_Sans/
    │           ├── NotoSans-Italic-VariableFont_wdth,wght.ttf
    │           ├── NotoSans-VariableFont_wdth,wght.ttf
    │           ├── OFL.txt
    │           ├── README.txt
    │           └── static/
    │               ├── NotoSans-Black.ttf
    │               ├── NotoSans-BlackItalic.ttf
    │               ├── NotoSans-Bold.ttf
    │               ├── NotoSans-BoldItalic.ttf
    │               ├── NotoSans-ExtraBold.ttf
    │               ├── NotoSans-ExtraBoldItalic.ttf
    │               ├── NotoSans-ExtraLight.ttf
    │               ├── NotoSans-ExtraLightItalic.ttf
    │               ├── NotoSans-Italic.ttf
    │               ├── NotoSans-Light.ttf
    │               ├── NotoSans-LightItalic.ttf
    │               ├── NotoSans-Medium.ttf
    │               ├── NotoSans-MediumItalic.ttf
    │               ├── NotoSans-Regular.ttf
    │               ├── NotoSans-SemiBold.ttf
    │               ├── NotoSans-SemiBoldItalic.ttf
    │               ├── NotoSans-Thin.ttf
    │               ├── NotoSans-ThinItalic.ttf
    │               ├── NotoSans_Condensed-Black.ttf
    │               ├── NotoSans_Condensed-BlackItalic.ttf
    │               ├── NotoSans_Condensed-Bold.ttf
    │               ├── NotoSans_Condensed-BoldItalic.ttf
    │               ├── NotoSans_Condensed-ExtraBold.ttf
    │               ├── NotoSans_Condensed-ExtraBoldItalic.ttf
    │               ├── NotoSans_Condensed-ExtraLight.ttf
    │               ├── NotoSans_Condensed-ExtraLightItalic.ttf
    │               ├── NotoSans_Condensed-Italic.ttf
    │               ├── NotoSans_Condensed-Light.ttf
    │               ├── NotoSans_Condensed-LightItalic.ttf
    │               ├── NotoSans_Condensed-Medium.ttf
    │               ├── NotoSans_Condensed-MediumItalic.ttf
    │               ├── NotoSans_Condensed-Regular.ttf
    │               ├── NotoSans_Condensed-SemiBold.ttf
    │               ├── NotoSans_Condensed-SemiBoldItalic.ttf
    │               ├── NotoSans_Condensed-Thin.ttf
    │               ├── NotoSans_Condensed-ThinItalic.ttf
    │               ├── NotoSans_ExtraCondensed-Black.ttf
    │               ├── NotoSans_ExtraCondensed-BlackItalic.ttf
    │               ├── NotoSans_ExtraCondensed-Bold.ttf
    │               ├── NotoSans_ExtraCondensed-BoldItalic.ttf
    │               ├── NotoSans_ExtraCondensed-ExtraBold.ttf
    │               ├── NotoSans_ExtraCondensed-ExtraBoldItalic.ttf
    │               ├── NotoSans_ExtraCondensed-ExtraLight.ttf
    │               ├── NotoSans_ExtraCondensed-ExtraLightItalic.ttf
    │               ├── NotoSans_ExtraCondensed-Italic.ttf
    │               ├── NotoSans_ExtraCondensed-Light.ttf
    │               ├── NotoSans_ExtraCondensed-LightItalic.ttf
    │               ├── NotoSans_ExtraCondensed-Medium.ttf
    │               ├── NotoSans_ExtraCondensed-MediumItalic.ttf
    │               ├── NotoSans_ExtraCondensed-Regular.ttf
    │               ├── NotoSans_ExtraCondensed-SemiBold.ttf
    │               ├── NotoSans_ExtraCondensed-SemiBoldItalic.ttf
    │               ├── NotoSans_ExtraCondensed-Thin.ttf
    │               ├── NotoSans_ExtraCondensed-ThinItalic.ttf
    │               ├── NotoSans_SemiCondensed-Black.ttf
    │               ├── NotoSans_SemiCondensed-BlackItalic.ttf
    │               ├── NotoSans_SemiCondensed-Bold.ttf
    │               ├── NotoSans_SemiCondensed-BoldItalic.ttf
    │               ├── NotoSans_SemiCondensed-ExtraBold.ttf
    │               ├── NotoSans_SemiCondensed-ExtraBoldItalic.ttf
    │               ├── NotoSans_SemiCondensed-ExtraLight.ttf
    │               ├── NotoSans_SemiCondensed-ExtraLightItalic.ttf
    │               ├── NotoSans_SemiCondensed-Italic.ttf
    │               ├── NotoSans_SemiCondensed-Light.ttf
    │               ├── NotoSans_SemiCondensed-LightItalic.ttf
    │               ├── NotoSans_SemiCondensed-Medium.ttf
    │               ├── NotoSans_SemiCondensed-MediumItalic.ttf
    │               ├── NotoSans_SemiCondensed-Regular.ttf
    │               ├── NotoSans_SemiCondensed-SemiBold.ttf
    │               ├── NotoSans_SemiCondensed-SemiBoldItalic.ttf
    │               ├── NotoSans_SemiCondensed-Thin.ttf
    │               └── NotoSans_SemiCondensed-ThinItalic.ttf
    ├── src/
    │   ├── app.ts
    │   ├── server.ts
    │   ├── swagger.ts
    │   ├── .eslintrc.js
    │   ├── core/
    │   │   ├── constants/
    │   │   │   ├── collection.constant.ts
    │   │   │   ├── common.constant.ts
    │   │   │   ├── date.constant.ts
    │   │   │   ├── index.ts
    │   │   │   ├── path.constant.ts
    │   │   │   └── prefix.constant.ts
    │   │   ├── enums/
    │   │   │   ├── http.enum.ts
    │   │   │   └── index.ts
    │   │   ├── exceptions/
    │   │   │   ├── http.exception.ts
    │   │   │   └── index.ts
    │   │   ├── interfaces/
    │   │   │   ├── error.interface.ts
    │   │   │   ├── index.ts
    │   │   │   ├── mail.interface.ts
    │   │   │   └── routes.interface.ts
    │   │   ├── middleware/
    │   │   │   ├── auth.middleware.ts
    │   │   │   ├── cache.middleware.ts
    │   │   │   ├── error.middleware.ts
    │   │   │   ├── index.ts
    │   │   │   ├── upload.middleware.ts
    │   │   │   └── validation.middleware.ts
    │   │   ├── models/
    │   │   │   ├── index.ts
    │   │   │   ├── pagination.model.ts
    │   │   │   └── searchPagination.model.ts
    │   │   └── utils/
    │   │       ├── aws.config.ts
    │   │       ├── helpers.ts
    │   │       ├── index.ts
    │   │       ├── logger.ts
    │   │       ├── password.ts
    │   │       ├── performance.ts
    │   │       ├── query.ts
    │   │       ├── s3Upload.ts
    │   │       ├── sendMail.ts
    │   │       ├── service.ts
    │   │       ├── token.ts
    │   │       ├── validateEnv.ts
    │   │       └── validation.ts
    │   ├── modules/
    │   │   ├── administrative_cases/
    │   │   │   ├── administrative_cases.controller.ts
    │   │   │   ├── administrative_cases.enum.ts
    │   │   │   ├── administrative_cases.interface.ts
    │   │   │   ├── administrative_cases.model.ts
    │   │   │   ├── administrative_cases.route.ts
    │   │   │   ├── administrative_cases.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── dtos/
    │   │   │   │   └── commonAdminCases.dto.ts
    │   │   │   └── swagger/
    │   │   │       └── swagger.js
    │   │   ├── appointment/
    │   │   │   ├── appointment.constant.ts
    │   │   │   ├── appointment.controller.ts
    │   │   │   ├── appointment.enum.ts
    │   │   │   ├── appointment.interface.ts
    │   │   │   ├── appointment.model.ts
    │   │   │   ├── appointment.repository.ts
    │   │   │   ├── appointment.route.ts
    │   │   │   ├── appointment.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── assign-staff.dto.ts
    │   │   │   │   ├── confirm-appointment.dto.ts
    │   │   │   │   ├── createAppointment.dto.ts
    │   │   │   │   └── search-appointment.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── appointment.schema.js
    │   │   │       └── appointment.swagger.js
    │   │   ├── appointment_log/
    │   │   │   ├── appointment_log.constant.ts
    │   │   │   ├── appointment_log.controller.ts
    │   │   │   ├── appointment_log.enum.ts
    │   │   │   ├── appointment_log.interface.ts
    │   │   │   ├── appointment_log.model.ts
    │   │   │   ├── appointment_log.repository.ts
    │   │   │   ├── appointment_log.route.ts
    │   │   │   ├── appointment_log.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── dtos/
    │   │   │   │   └── createAppointmentLog.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── appointment_log.schema.js
    │   │   │       └── appointment_log.swagger.js
    │   │   ├── auth/
    │   │   │   ├── auth.controller.ts
    │   │   │   ├── auth.interface.ts
    │   │   │   ├── auth.repository.ts
    │   │   │   ├── auth.route.ts
    │   │   │   ├── auth.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── emai.dto.ts
    │   │   │   │   ├── login.dto.ts
    │   │   │   │   ├── loginGoogle.dto.ts
    │   │   │   │   └── verifiedToken.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── auth.schema.js
    │   │   │       └── auth.swagger.js
    │   │   ├── blog/
    │   │   │   ├── blog.controller.ts
    │   │   │   ├── blog.interface.ts
    │   │   │   ├── blog.model.ts
    │   │   │   ├── blog.repository.ts
    │   │   │   ├── blog.route.ts
    │   │   │   ├── blog.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── dtos/
    │   │   │   │   └── blog.dto.ts
    │   │   │   ├── log/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── log.controller.ts
    │   │   │   │   ├── log.interface.ts
    │   │   │   │   ├── log.model.ts
    │   │   │   │   ├── log.repository.ts
    │   │   │   │   ├── log.route.ts
    │   │   │   │   ├── log.service.ts
    │   │   │   │   ├── dtos/
    │   │   │   │   │   └── log.dto.ts
    │   │   │   │   └── swagger/
    │   │   │   │       └── log.swagger.js
    │   │   │   └── swagger/
    │   │   │       └── blog.swagger.js
    │   │   ├── blog_category/
    │   │   │   ├── blog_category.controller.ts
    │   │   │   ├── blog_category.interface.ts
    │   │   │   ├── blog_category.model.ts
    │   │   │   ├── blog_category.repository.ts
    │   │   │   ├── blog_category.route.ts
    │   │   │   ├── blog_category.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── dtos/
    │   │   │   │   └── blog_category.dto.ts
    │   │   │   └── swagger/
    │   │   │       └── blog_category.swagger.js
    │   │   ├── department/
    │   │   │   ├── department.controller.ts
    │   │   │   ├── department.interface.ts
    │   │   │   ├── department.model.ts
    │   │   │   ├── department.repository.ts
    │   │   │   ├── department.route.ts
    │   │   │   ├── department.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createDepartment.dto.ts
    │   │   │   │   └── updateDepartment.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── department.schema.js
    │   │   │       └── department.swagger.js
    │   │   ├── docs/
    │   │   │   ├── docs.route.ts
    │   │   │   └── index.ts
    │   │   ├── index/
    │   │   │   ├── index.controller.ts
    │   │   │   ├── index.route.ts
    │   │   │   ├── index.ts
    │   │   │   └── view/
    │   │   │       └── index.ejs
    │   │   ├── kit/
    │   │   │   ├── index.ts
    │   │   │   ├── kit.constant.ts
    │   │   │   ├── kit.controller.ts
    │   │   │   ├── kit.enum.ts
    │   │   │   ├── kit.interface.ts
    │   │   │   ├── kit.model.ts
    │   │   │   ├── kit.repository.ts
    │   │   │   ├── kit.route.ts
    │   │   │   ├── kit.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── assignKit.dto.ts
    │   │   │   │   ├── createKit.dto.ts
    │   │   │   │   ├── returnKit.dto.ts
    │   │   │   │   ├── searchKit.dto.ts
    │   │   │   │   └── updateKit.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── kit.schema.js
    │   │   │       └── kit.swagger.js
    │   │   ├── payment/
    │   │   │   ├── index.ts
    │   │   │   ├── payment.constant.ts
    │   │   │   ├── payment.controller.ts
    │   │   │   ├── payment.enum.ts
    │   │   │   ├── payment.interface.ts
    │   │   │   ├── payment.model.ts
    │   │   │   ├── payment.route.ts
    │   │   │   ├── payment.service.ts
    │   │   │   ├── payment.util.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createAppointmentPayment.dto.ts
    │   │   │   │   ├── createPayosPayment.dto.ts
    │   │   │   │   ├── createSamplePayment.dto.ts
    │   │   │   │   └── createWebhook.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── payment-webhook.md
    │   │   │       ├── payment.schema.js
    │   │   │       ├── payment.swagger.js
    │   │   │       └── payment.tag.js
    │   │   ├── refund/
    │   │   │   ├── index.ts
    │   │   │   ├── refund.constant.ts
    │   │   │   ├── refund.enum.ts
    │   │   │   ├── refund.interface.ts
    │   │   │   └── refund.model.ts
    │   │   ├── registration_form/
    │   │   │   ├── index.ts
    │   │   │   ├── registration_form.controller.ts
    │   │   │   ├── registration_form.interface.ts
    │   │   │   ├── registration_form.model.ts
    │   │   │   ├── registration_form.repository.ts
    │   │   │   ├── registration_form.route.ts
    │   │   │   ├── registration_form.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createRegistrationForm.dto.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   └── updateRegistrationForm.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── registrationForm.schema.js
    │   │   │       └── registrationForm.swagger.js
    │   │   ├── result/
    │   │   │   ├── index.ts
    │   │   │   ├── result.constant.ts
    │   │   │   ├── result.controller.ts
    │   │   │   ├── result.enum.ts
    │   │   │   ├── result.interface.ts
    │   │   │   ├── result.model.ts
    │   │   │   ├── result.repository.ts
    │   │   │   ├── result.route.ts
    │   │   │   ├── result.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createResult.dto.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── startTesting.dto.ts
    │   │   │   │   └── updateResult.dto.ts
    │   │   │   ├── services/
    │   │   │   │   └── reportGenerator.service.ts
    │   │   │   ├── swagger/
    │   │   │   │   ├── result.schema.js
    │   │   │   │   └── result.swagger.js
    │   │   │   └── utils/
    │   │   │       └── pdfGenerator.util.ts
    │   │   ├── review/
    │   │   │   ├── index.ts
    │   │   │   ├── review.controller.ts
    │   │   │   ├── review.interface.ts
    │   │   │   ├── review.model.ts
    │   │   │   ├── review.repository.ts
    │   │   │   ├── review.route.ts
    │   │   │   ├── review.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createReview.dto.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   └── updateReview.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── review.schema.js
    │   │   │       └── review.swagger.js
    │   │   ├── sample/
    │   │   │   ├── index.ts
    │   │   │   ├── sample.constant.ts
    │   │   │   ├── sample.controller.ts
    │   │   │   ├── sample.enum.ts
    │   │   │   ├── sample.interface.ts
    │   │   │   ├── sample.model.ts
    │   │   │   ├── sample.repository.ts
    │   │   │   ├── sample.route.ts
    │   │   │   ├── sample.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── addSample.dto.ts
    │   │   │   │   ├── addSampleForFacility.dto.ts
    │   │   │   │   ├── addSampleWithMultiplePersonInfo.dto.ts
    │   │   │   │   ├── batchReceiveSamples.dto.ts
    │   │   │   │   ├── batchSubmitSamples.dto.ts
    │   │   │   │   ├── collect-sample.dto.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── receiveSample.dto.ts
    │   │   │   │   ├── searchSamples.dto.ts
    │   │   │   │   ├── submitSample.dto.ts
    │   │   │   │   └── uploadPersonImage.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── sample.schema.js
    │   │   │       ├── sample.swagger.js
    │   │   │       └── sample.tag.js
    │   │   ├── service/
    │   │   │   ├── index.ts
    │   │   │   ├── service.constant.ts
    │   │   │   ├── service.controller.ts
    │   │   │   ├── service.enum.ts
    │   │   │   ├── service.interface.ts
    │   │   │   ├── service.model.ts
    │   │   │   ├── service.repository.ts
    │   │   │   ├── service.route.ts
    │   │   │   ├── service.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createService.dto.ts
    │   │   │   │   └── updateService.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── service.schema.js
    │   │   │       └── service.swagger.js
    │   │   ├── slot/
    │   │   │   ├── index.ts
    │   │   │   ├── slot.constant.ts
    │   │   │   ├── slot.controller.ts
    │   │   │   ├── slot.enum.ts
    │   │   │   ├── slot.interface.ts
    │   │   │   ├── slot.model.ts
    │   │   │   ├── slot.repository.ts
    │   │   │   ├── slot.route.ts
    │   │   │   ├── slot.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createSlot.dto.ts
    │   │   │   │   ├── timeSlot.dto.ts
    │   │   │   │   └── updateSlot.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── slot.schema.js
    │   │   │       └── slot.swagger.js
    │   │   ├── staff_profile/
    │   │   │   ├── index.ts
    │   │   │   ├── staff_profile.constant.ts
    │   │   │   ├── staff_profile.controller.ts
    │   │   │   ├── staff_profile.enum.ts
    │   │   │   ├── staff_profile.interface.ts
    │   │   │   ├── staff_profile.model.ts
    │   │   │   ├── staff_profile.repository.ts
    │   │   │   ├── staff_profile.route.ts
    │   │   │   ├── staff_profile.service.ts
    │   │   │   ├── dtos/
    │   │   │   │   ├── createStaffProfile.dto.ts
    │   │   │   │   └── updateStaffProfile.dto.ts
    │   │   │   └── swagger/
    │   │   │       ├── staff_profile.schema.js
    │   │   │       └── staff_profile.swagger.js
    │   │   ├── transaction/
    │   │   │   ├── index.ts
    │   │   │   ├── transaction.constant.ts
    │   │   │   ├── transaction.enum.ts
    │   │   │   ├── transaction.interface.ts
    │   │   │   ├── transaction.model.ts
    │   │   │   └── swagger/
    │   │   │       ├── transaction.schema.js
    │   │   │       └── transaction.tag.js
    │   │   └── user/
    │   │       ├── index.ts
    │   │       ├── user.constant.ts
    │   │       ├── user.controller.ts
    │   │       ├── user.enum.ts
    │   │       ├── user.interface.ts
    │   │       ├── user.model.ts
    │   │       ├── user.repository.ts
    │   │       ├── user.route.ts
    │   │       ├── user.service.ts
    │   │       ├── dtos/
    │   │       │   ├── changePassword.dto.ts
    │   │       │   ├── changeRole.dto.ts
    │   │       │   ├── changeStatus.dto.ts
    │   │       │   ├── register.dto.ts
    │   │       │   ├── reviewProfileDto.ts
    │   │       │   ├── searchPaginationUser.dto.ts
    │   │       │   ├── searchUser.dto.ts
    │   │       │   └── updateUser.dto.ts
    │   │       └── swagger/
    │   │           ├── user.schema.js
    │   │           └── user.swagger.js
    │   └── types/
    │       ├── express.d.ts
    │       └── express/
    │           └── index.d.ts
    ├── .cursor/
    │   ├── README.md
    │   ├── rules.json
    │   ├── settings.json
    │   └── rules/
    │       ├── code-style.json
    │       ├── dna-testing.mdc
    │       ├── eslint-typescript.json
    │       ├── module-structure.json
    │       ├── performance.json
    │       └── security.json
    └── .husky/
        └── pre-commit


================================================
FILE: README.md
================================================
# Node.js API Starter with TypeScript, PNPM, MongoDB

![Node.js](mdc:https:/img.shields.io/badge/Node.js-20.x-brightgreen?logo=node.js)
![PNPM](mdc:https:/img.shields.io/badge/PNPM-10.x-orange?logo=pnpm)
![TypeScript](mdc:https:/img.shields.io/badge/TypeScript-Enabled-blue?logo=typescript)
![MongoDB](mdc:https:/img.shields.io/badge/MongoDB-Connected-success?logo=mongodb)

---

## Requirements

- `node --version`: **v20.18.1**
- `npm --version`: **10.8.2**
- `pnpm --version`: **10.10.0**

---

## Installation

1. **Install Node.js, NPM and PNPM** if not already:
    ```bash
    # Node & npm
    https://nodejs.org/

    # pnpm
    npm install -g pnpm
    ```

2. **Create a `.env` file** in the project root with the following fields:

    ```env
    - NODE_ENV: development
    - JWT_TOKEN_SECRET: set the secret token as you like
    - PORT: set the port as you like (should be 8080)
    - MONGODB_URI: get the mongoDB uri of the link to your account
    - EMAIL_USER: set email for admin
    - EMAIL_PASSWORD: set email_password for admin
    - DOMAIN_FE: domain default send mail
    ```

---

## Running the Project

```bash
# Install dependencies
pnpm install

# Run development server
pnpm run dev
```

> Or if using npm:

```bash
npm install
npm run dev
```

The backend API runs on:

- `http://localhost:8080/`
- (Optional) Frontend or client: `http://localhost:3000/`

---

## 📚 References

- [Morgan middleware (Logging)](mdc:https:/expressjs.com/en/resources/middleware/morgan.html)
- [TypeScript Configuration](mdc:https:/www.typescriptlang.org/tsconfig)
- [Winston Logger](mdc:https:/github.com/winstonjs/winston)

---

## Code Quality Tools

### ESLint Rules

This project uses ESLint to enforce code quality and maintain consistent coding standards. The rules are specifically configured for the `src` directory with special configurations for different module types.

To run the linter:
```bash
npm run lint        # Check for linting errors
npm run lint:fix    # Fix linting errors automatically
```

### Key Linting Rules

- **TypeScript Safety**: Strict type checking with no `any` type allowed
- **Module Structure**: Enforced import ordering and module boundaries
- **Naming Conventions**: 
  - Interfaces must start with `I` and use PascalCase
  - Models must follow PascalCase
  - Type aliases must use PascalCase
- **Code Organization**: Different rules for controllers, services, routes, and models

### Prettier

Code formatting is handled by Prettier. To format your code:
```bash
npm run format       # Format all TypeScript files
npm run format:check # Check formatting without changing files
```

### Pre-commit Hooks

This project uses Husky and lint-staged to run linters and formatters before each commit, ensuring that only quality code is committed to the repository.

### © 2025 Bản quyền thuộc về Nguyễn Đan Huy | [fb/danhuyspm](mdc:https:/facebook.com/danhuyspm)


================================================
FILE: Dockerfile
================================================
# Build stage
FROM node:20-alpine AS builder

# Install pnpm globally
RUN npm install -g pnpm@10.10.0

# Set working directory
WORKDIR /app

# Copy package.json and pnpm-lock.yaml
COPY package.json pnpm-lock.yaml ./

# Install dependencies
RUN pnpm install --frozen-lockfile

# Copy source code
COPY . .

# Build the application
RUN pnpm run build

# Production stage
FROM node:20-alpine AS production

# Install pnpm globally
RUN npm install -g pnpm@10.10.0

# Create app directory
WORKDIR /app

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Copy package.json and pnpm-lock.yaml
COPY package.json pnpm-lock.yaml ./

# Install only production dependencies
RUN pnpm install --frozen-lockfile --prod

# Copy built application from builder stage
COPY --from=builder /app/dist ./dist

# Copy necessary static files
COPY --from=builder /app/swagger.yaml ./
COPY --from=builder /app/assets ./assets
COPY --from=builder /app/src/modules/index/view ./src/modules/index/view

# Create public directory for images
RUN mkdir -p public/images

# Change ownership to nodejs user
RUN chown -R nodejs:nodejs /app
USER nodejs

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:8080/api-docs', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# Start the application
CMD ["pnpm", "start"] 


================================================
FILE: fly.toml
================================================
# fly.toml app configuration file generated for restapi-bloodline-dna on 2024-12-19T10:00:00.000Z
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.

app = 'wdp392-restapi-with-nodejs-express-mongodb'
primary_region = 'sin'  # Singapore region for better performance in Asia

[build]

[deploy]
  release_command = 'echo "Deployment starting..."'

[env]
  NODE_ENV = 'production'
  WEBSITES_PORT = '8080'

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 1
  processes = ['app']

  [[http_service.checks]]
    grace_period = '10s'
    interval = '30s'
    method = 'GET'
    timeout = '5s'
    path = '/api-docs'

[vm]
  cpu_kind = 'shared'
  cpus = 1
  memory_mb = 512

[[vm.http_service.concurrency]]
  hard_limit = 25
  soft_limit = 20
  type = 'connections'

[metrics]
  port = 9091
  path = '/metrics'

# Enable process restart on failure
[processes]
  app = 'pnpm start'

# Machine restart policy
[restart]
  policy = 'on-failure'


================================================
FILE: package.json
================================================
{
  "name": "restApi-with-nodejs-express-mongodb",
  "version": "2.0.0",
  "description": "",
  "main": "src/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "postinstall": "npm run build",
    "lint": "eslint --ext .ts src/",
    "lint:fix": "eslint --ext .ts src/ --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "lint-staged": "lint-staged"
  },
  "keywords": [],
  "author": "Nguyen Dan Huy",
  "license": "ISC",
  "packageManager": "pnpm@10.10.0",
  "dependencies": {
    "@aws-sdk/client-s3": "^3.821.0",
    "@aws-sdk/s3-request-presigner": "^3.821.0",
    "@payos/node": "^1.0.10",
    "aws-sdk": "^2.1692.0",
    "axios": "^1.9.0",
    "bcryptjs": "^3.0.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "compression": "^1.8.0",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.5.0",
    "ejs": "^3.1.10",
    "envalid": "^8.0.0",
    "express": "^5.1.0",
    "google-auth-library": "^9.15.1",
    "helmet": "^8.1.0",
    "hpp": "^0.2.3",
    "jsonwebtoken": "^9.0.2",
    "moment": "^2.30.1",
    "mongoose": "^8.14.3",
    "morgan": "^1.10.0",
    "multer": "^2.0.0",
    "nodemailer": "^7.0.3",
    "path": "^0.12.7",
    "pdfkit": "^0.14.0",
    "reflect-metadata": "^0.2.2",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-dist": "^5.21.0",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^11.1.0",
    "winston": "^3.17.0",
    "yamljs": "^0.3.0"
  },
  "devDependencies": {
    "@types/aws-sdk": "^2.7.4",
    "@types/bcryptjs": "^3.0.0",
    "@types/compression": "^1.8.0",
    "@types/cors": "^2.8.18",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/hpp": "^0.2.6",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.12",
    "@types/node": "^22.15.18",
    "@types/nodemailer": "^6.4.17",
    "@types/pdfkit": "^0.13.9",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/yamljs": "^0.2.34",
    "eslint": "^9.26.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-import": "^2.31.0",
    "husky": "^9.1.7",
    "lint-staged": "^16.0.0",
    "prettier": "^3.5.3",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3"
  }
}


================================================
FILE: pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      '@aws-sdk/client-s3':
        specifier: ^3.821.0
        version: 3.821.0
      '@aws-sdk/s3-request-presigner':
        specifier: ^3.821.0
        version: 3.821.0
      '@payos/node':
        specifier: ^1.0.10
        version: 1.0.10
      aws-sdk:
        specifier: ^2.1692.0
        version: 2.1692.0
      axios:
        specifier: ^1.9.0
        version: 1.9.0
      bcryptjs:
        specifier: ^3.0.2
        version: 3.0.2
      class-transformer:
        specifier: ^0.5.1
        version: 0.5.1
      class-validator:
        specifier: ^0.14.2
        version: 0.14.2
      compression:
        specifier: ^1.8.0
        version: 1.8.0
      cors:
        specifier: ^2.8.5
        version: 2.8.5
      date-fns:
        specifier: ^4.1.0
        version: 4.1.0
      dotenv:
        specifier: ^16.5.0
        version: 16.5.0
      ejs:
        specifier: ^3.1.10
        version: 3.1.10
      envalid:
        specifier: ^8.0.0
        version: 8.0.0
      express:
        specifier: ^5.1.0
        version: 5.1.0
      google-auth-library:
        specifier: ^9.15.1
        version: 9.15.1
      helmet:
        specifier: ^8.1.0
        version: 8.1.0
      hpp:
        specifier: ^0.2.3
        version: 0.2.3
      jsonwebtoken:
        specifier: ^9.0.2
        version: 9.0.2
      moment:
        specifier: ^2.30.1
        version: 2.30.1
      mongoose:
        specifier: ^8.14.3
        version: 8.14.3
      morgan:
        specifier: ^1.10.0
        version: 1.10.0
      multer:
        specifier: ^2.0.0
        version: 2.0.0
      nodemailer:
        specifier: ^7.0.3
        version: 7.0.3
      path:
        specifier: ^0.12.7
        version: 0.12.7
      pdfkit:
        specifier: ^0.14.0
        version: 0.14.0
      reflect-metadata:
        specifier: ^0.2.2
        version: 0.2.2
      swagger-jsdoc:
        specifier: ^6.2.8
        version: 6.2.8(openapi-types@12.1.3)
      swagger-ui-dist:
        specifier: ^5.21.0
        version: 5.21.0
      swagger-ui-express:
        specifier: ^5.0.1
        version: 5.0.1(express@5.1.0)
      uuid:
        specifier: ^11.1.0
        version: 11.1.0
      winston:
        specifier: ^3.17.0
        version: 3.17.0
      yamljs:
        specifier: ^0.3.0
        version: 0.3.0
    devDependencies:
      '@types/aws-sdk':
        specifier: ^2.7.4
        version: 2.7.4
      '@types/bcryptjs':
        specifier: ^3.0.0
        version: 3.0.0
      '@types/compression':
        specifier: ^1.8.0
        version: 1.8.0
      '@types/cors':
        specifier: ^2.8.18
        version: 2.8.18
      '@types/dotenv':
        specifier: ^8.2.3
        version: 8.2.3
      '@types/express':
        specifier: ^5.0.1
        version: 5.0.1
      '@types/hpp':
        specifier: ^0.2.6
        version: 0.2.6
      '@types/jsonwebtoken':
        specifier: ^9.0.9
        version: 9.0.9
      '@types/morgan':
        specifier: ^1.9.9
        version: 1.9.9
      '@types/multer':
        specifier: ^1.4.12
        version: 1.4.12
      '@types/node':
        specifier: ^22.15.18
        version: 22.15.18
      '@types/nodemailer':
        specifier: ^6.4.17
        version: 6.4.17
      '@types/pdfkit':
        specifier: ^0.13.9
        version: 0.13.9
      '@types/swagger-jsdoc':
        specifier: ^6.0.4
        version: 6.0.4
      '@types/swagger-ui-express':
        specifier: ^4.1.8
        version: 4.1.8
      '@types/yamljs':
        specifier: ^0.2.34
        version: 0.2.34
      eslint:
        specifier: ^9.26.0
        version: 9.26.0
      eslint-config-prettier:
        specifier: ^10.1.5
        version: 10.1.5(eslint@9.26.0)
      eslint-plugin-import:
        specifier: ^2.31.0
        version: 2.31.0(eslint@9.26.0)
      husky:
        specifier: ^9.1.7
        version: 9.1.7
      lint-staged:
        specifier: ^16.0.0
        version: 16.0.0
      prettier:
        specifier: ^3.5.3
        version: 3.5.3
      ts-node-dev:
        specifier: ^2.0.0
        version: 2.0.0(@types/node@22.15.18)(typescript@5.8.3)
      typescript:
        specifier: ^5.8.3
        version: 5.8.3

packages:

  '@apidevtools/json-schema-ref-parser@9.1.2':
    resolution: {integrity: sha512-r1w81DpR+KyRWd3f+rk6TNqMgedmAxZP5v5KWlXQWlgMUUtyEJch0DKEci1SorPMiSeM8XPl7MZ3miJ60JIpQg==}

  '@apidevtools/openapi-schemas@2.1.0':
    resolution: {integrity: sha512-Zc1AlqrJlX3SlpupFGpiLi2EbteyP7fXmUOGup6/DnkRgjP9bgMM/ag+n91rsv0U1Gpz0H3VILA/o3bW7Ua6BQ==}
    engines: {node: '>=10'}

  '@apidevtools/swagger-methods@3.0.2':
    resolution: {integrity: sha512-QAkD5kK2b1WfjDS/UQn/qQkbwF31uqRjPTrsCs5ZG9BQGAkjwvqGFjjPqAuzac/IYzpPtRzjCP1WrTuAIjMrXg==}

  '@apidevtools/swagger-parser@10.0.3':
    resolution: {integrity: sha512-sNiLY51vZOmSPFZA5TF35KZ2HbgYklQnTSDnkghamzLb3EkNtcQnrBQEj5AOCxHpTtXpqMCRM1CrmV2rG6nw4g==}
    peerDependencies:
      openapi-types: '>=7'

  '@aws-crypto/crc32@5.2.0':
    resolution: {integrity: sha512-nLbCWqQNgUiwwtFsen1AdzAtvuLRsQS8rYgMuxCrdKf9kOssamGLuPwyTY9wyYblNr9+1XM8v6zoDTPPSIeANg==}
    engines: {node: '>=16.0.0'}

  '@aws-crypto/crc32c@5.2.0':
    resolution: {integrity: sha512-+iWb8qaHLYKrNvGRbiYRHSdKRWhto5XlZUEBwDjYNf+ly5SVYG6zEoYIdxvf5R3zyeP16w4PLBn3rH1xc74Rag==}

  '@aws-crypto/sha1-browser@5.2.0':
    resolution: {integrity: sha512-OH6lveCFfcDjX4dbAvCFSYUjJZjDr/3XJ3xHtjn3Oj5b9RjojQo8npoLeA/bNwkOkrSQ0wgrHzXk4tDRxGKJeg==}

  '@aws-crypto/sha256-browser@5.2.0':
    resolution: {integrity: sha512-AXfN/lGotSQwu6HNcEsIASo7kWXZ5HYWvfOmSNKDsEqC4OashTp8alTmaz+F7TC2L083SFv5RdB+qU3Vs1kZqw==}

  '@aws-crypto/sha256-js@5.2.0':
    resolution: {integrity: sha512-FFQQyu7edu4ufvIZ+OadFpHHOt+eSTBaYaki44c+akjg7qZg9oOQeLlk77F6tSYqjDAFClrHJk9tMf0HdVyOvA==}
    engines: {node: '>=16.0.0'}

  '@aws-crypto/supports-web-crypto@5.2.0':
    resolution: {integrity: sha512-iAvUotm021kM33eCdNfwIN//F77/IADDSs58i+MDaOqFrVjZo9bAal0NK7HurRuWLLpF1iLX7gbWrjHjeo+YFg==}

  '@aws-crypto/util@5.2.0':
    resolution: {integrity: sha512-4RkU9EsI6ZpBve5fseQlGNUWKMa1RLPQ1dnjnQoe07ldfIzcsGb5hC5W0Dm7u423KWzawlrpbjXBrXCEv9zazQ==}

  '@aws-sdk/client-s3@3.821.0':
    resolution: {integrity: sha512-enlFiONQD+oCaV+C6hMsAJvyQRT3wZmCtXXq7qjxX8BiLgXsHQ9HHS+Nhoq08Ya6mtd1Y1qHOOYpnD8yyUzTMQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/client-sso@3.821.0':
    resolution: {integrity: sha512-aDEBZUKUd/+Tvudi0d9KQlqt2OW2P27LATZX0jkNC8yVk4145bAPS04EYoqdKLuyUn/U33DibEOgKUpxZB12jQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/core@3.821.0':
    resolution: {integrity: sha512-8eB3wKbmfciQFmxFq7hAjy7mXdUs7vBOR5SwT0ZtQBg0Txc18Lc9tMViqqdO6/KU7OukA6ib2IAVSjIJJEN7FQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-env@3.821.0':
    resolution: {integrity: sha512-C+s/A72pd7CXwEsJj9+Uq9T726iIfIF18hGRY8o82xcIEfOyakiPnlisku8zZOaAu+jm0CihbbYN4NyYNQ+HZQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-http@3.821.0':
    resolution: {integrity: sha512-gIRzTLnAsRfRSNarCag7G7rhcHagz4x5nNTWRihQs5cwTOghEExDy7Tj5m4TEkv3dcTAsNn+l4tnR4nZXo6R+Q==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-ini@3.821.0':
    resolution: {integrity: sha512-VRTrmsca8kBHtY1tTek1ce+XkK/H0fzodBKcilM/qXjTyumMHPAzVAxKZfSvGC+28/pXyQzhOEyxZfw7giCiWA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-node@3.821.0':
    resolution: {integrity: sha512-oBgbcgOXWMgknAfhIdTeHSSVIv+k2LXN9oTbxu1r++o4WWBWrEQ8mHU0Zo9dfr7Uaoqi3pezYZznsBkXnMLEOg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-process@3.821.0':
    resolution: {integrity: sha512-e18ucfqKB3ICNj5RP/FEdvUfhVK6E9MALOsl8pKP13mwegug46p/1BsZWACD5n+Zf9ViiiHxIO7td03zQixfwA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-sso@3.821.0':
    resolution: {integrity: sha512-Dt+pheBLom4O/egO4L75/72k9C1qtUOLl0F0h6lmqZe4Mvhz+wDtjoO/MdGC/P1q0kcIX/bBKr0NQ3cIvAH8pA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-web-identity@3.821.0':
    resolution: {integrity: sha512-FF5wnRJkxSQaCVVvWNv53K1MhTMgH8d+O+MHTbkv51gVIgVATrtfFQMKBLcEAxzXrgAliIO3LiNv+1TqqBZ+BA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-bucket-endpoint@3.821.0':
    resolution: {integrity: sha512-cebgeytKlWOgGczLo3BPvNY9XlzAzGZQANSysgJ2/8PSldmUpXRIF+GKPXDVhXeInWYHIfB8zZi3RqrPoXcNYQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-expect-continue@3.821.0':
    resolution: {integrity: sha512-zAOoSZKe1njOrtynvK6ZORU57YGv5I7KP4+rwOvUN3ZhJbQ7QPf8gKtFUCYAPRMegaXCKF/ADPtDZBAmM+zZ9g==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-flexible-checksums@3.821.0':
    resolution: {integrity: sha512-C56sBHXq1fEsLfIAup+w/7SKtb6d8Mb3YBec94r2ludVn1s3ypYWRovFE/6VhUzvwUbTQaxfrA2ewy5GQ1/DJQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-host-header@3.821.0':
    resolution: {integrity: sha512-xSMR+sopSeWGx5/4pAGhhfMvGBHioVBbqGvDs6pG64xfNwM5vq5s5v6D04e2i+uSTj4qGa71dLUs5I0UzAK3sw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-location-constraint@3.821.0':
    resolution: {integrity: sha512-sKrm80k0t3R0on8aA/WhWFoMaAl4yvdk+riotmMElLUpcMcRXAd1+600uFVrxJqZdbrKQ0mjX0PjT68DlkYXLg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-logger@3.821.0':
    resolution: {integrity: sha512-0cvI0ipf2tGx7fXYEEN5fBeZDz2RnHyb9xftSgUsEq7NBxjV0yTZfLJw6Za5rjE6snC80dRN8+bTNR1tuG89zA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-recursion-detection@3.821.0':
    resolution: {integrity: sha512-efmaifbhBoqKG3bAoEfDdcM8hn1psF+4qa7ykWuYmfmah59JBeqHLfz5W9m9JoTwoKPkFcVLWZxnyZzAnVBOIg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-sdk-s3@3.821.0':
    resolution: {integrity: sha512-D469De1d4NtcCTVHzUL2Q0tGvPFr7mk2j4+oCYpVyd5awSSOyl8Adkxse8qayZj9ROmuMlsoU5VhBvcc9Hoo2w==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-ssec@3.821.0':
    resolution: {integrity: sha512-YYi1Hhr2AYiU/24cQc8HIB+SWbQo6FBkMYojVuz/zgrtkFmALxENGF/21OPg7f/QWd+eadZJRxCjmRwh5F2Cxg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-user-agent@3.821.0':
    resolution: {integrity: sha512-rw8q3TxygMg3VrofN04QyWVCCyGwz3bVthYmBZZseENPWG3Krz1OCKcyqjkTcAxMQlEywOske+GIiOasGKnJ3w==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/nested-clients@3.821.0':
    resolution: {integrity: sha512-2IuHcUsWw44ftSEDYU4dvktTEqgyDvkOcfpoGC/UmT4Qo6TVCP3U5tWEGpNK9nN+7nLvekruxxG/jaMt5/oWVw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/region-config-resolver@3.821.0':
    resolution: {integrity: sha512-t8og+lRCIIy5nlId0bScNpCkif8sc0LhmtaKsbm0ZPm3sCa/WhCbSZibjbZ28FNjVCV+p0D9RYZx0VDDbtWyjw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/s3-request-presigner@3.821.0':
    resolution: {integrity: sha512-VLM0pWQxEBf80uKirU4B1hQz3ZYX5OaPFrRSciUkkKYdqPFrnjQ7NyIQRjF1MVmXwsKgBxJVWl+p0BKcsHR+rQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/signature-v4-multi-region@3.821.0':
    resolution: {integrity: sha512-UjfyVR/PB/TP9qe1x6tv7qLlD8/0eiSLDkkBUgBmddkkX0l17oy9c2SJINuV3jy1fbx6KORZ6gyvRZ2nb8dtMw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/token-providers@3.821.0':
    resolution: {integrity: sha512-qJ7wgKhdxGbPg718zWXbCYKDuSWZNU3TSw64hPRW6FtbZrIyZxObpiTKC6DKwfsVoZZhHEoP/imGykN1OdOTJA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/types@3.821.0':
    resolution: {integrity: sha512-Znroqdai1a90TlxGaJ+FK1lwC0fHpo97Xjsp5UKGR5JODYm7f9+/fF17ebO1KdoBr/Rm0UIFiF5VmI8ts9F1eA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-arn-parser@3.804.0':
    resolution: {integrity: sha512-wmBJqn1DRXnZu3b4EkE6CWnoWMo1ZMvlfkqU5zPz67xx1GMaXlDCchFvKAXMjk4jn/L1O3tKnoFDNsoLV1kgNQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-endpoints@3.821.0':
    resolution: {integrity: sha512-Uknt/zUZnLE76zaAAPEayOeF5/4IZ2puTFXvcSCWHsi9m3tqbb9UozlnlVqvCZLCRWfQryZQoG2W4XSS3qgk5A==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-format-url@3.821.0':
    resolution: {integrity: sha512-h+xqmPToxDrZ0a7rxE1a8Oh4zpWfZe9oiQUphGtfiGFA6j75UiURH5J3MmGHa/G4t15I3iLLbYtUXxvb1i7evg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-locate-window@3.804.0':
    resolution: {integrity: sha512-zVoRfpmBVPodYlnMjgVjfGoEZagyRF5IPn3Uo6ZvOZp24chnW/FRstH7ESDHDDRga4z3V+ElUQHKpFDXWyBW5A==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-user-agent-browser@3.821.0':
    resolution: {integrity: sha512-irWZHyM0Jr1xhC+38OuZ7JB6OXMLPZlj48thElpsO1ZSLRkLZx5+I7VV6k3sp2yZ7BYbKz/G2ojSv4wdm7XTLw==}

  '@aws-sdk/util-user-agent-node@3.821.0':
    resolution: {integrity: sha512-YwMXc9EvuzJgnLBTyiQly2juPujXwDgcMHB0iSN92tHe7Dd1jJ1feBmTgdClaaqCeHFUaFpw+3JU/ZUJ6LjR+A==}
    engines: {node: '>=18.0.0'}
    peerDependencies:
      aws-crt: '>=1.0.0'
    peerDependenciesMeta:
      aws-crt:
        optional: true

  '@aws-sdk/xml-builder@3.821.0':
    resolution: {integrity: sha512-DIIotRnefVL6DiaHtO6/21DhJ4JZnnIwdNbpwiAhdt/AVbttcE4yw925gsjur0OGv5BTYXQXU3YnANBYnZjuQA==}
    engines: {node: '>=18.0.0'}

  '@colors/colors@1.6.0':
    resolution: {integrity: sha512-Ir+AOibqzrIsL6ajt3Rz3LskB7OiMVHqltZmspbW/TJuTVuyOMirVqAkjfY6JISiLHgyNqicAC8AyHHGzNd/dA==}
    engines: {node: '>=0.1.90'}

  '@cspotcode/source-map-support@0.8.1':
    resolution: {integrity: sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==}
    engines: {node: '>=12'}

  '@dabh/diagnostics@2.0.3':
    resolution: {integrity: sha512-hrlQOIi7hAfzsMqlGSFyVucrx38O+j6wiGOf//H2ecvIEqYN4ADBSS2iLMh5UFyDunCNniUIPk/q3riFv45xRA==}

  '@eslint-community/eslint-utils@4.7.0':
    resolution: {integrity: sha512-dyybb3AcajC7uha6CvhdVRJqaKyn7w2YKqKyAN37NKYgZT36w+iRb0Dymmc5qEJ549c/S31cMMSFd75bteCpCw==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
    peerDependencies:
      eslint: ^6.0.0 || ^7.0.0 || >=8.0.0

  '@eslint-community/regexpp@4.12.1':
    resolution: {integrity: sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==}
    engines: {node: ^12.0.0 || ^14.0.0 || >=16.0.0}

  '@eslint/config-array@0.20.0':
    resolution: {integrity: sha512-fxlS1kkIjx8+vy2SjuCB94q3htSNrufYTXubwiBFeaQHbH6Ipi43gFJq2zCMt6PHhImH3Xmr0NksKDvchWlpQQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/config-helpers@0.2.2':
    resolution: {integrity: sha512-+GPzk8PlG0sPpzdU5ZvIRMPidzAnZDl/s9L+y13iodqvb8leL53bTannOrQ/Im7UkpsmFU5Ily5U60LWixnmLg==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/core@0.13.0':
    resolution: {integrity: sha512-yfkgDw1KR66rkT5A8ci4irzDysN7FRpq3ttJolR88OqQikAWqwA8j5VZyas+vjyBNFIJ7MfybJ9plMILI2UrCw==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/eslintrc@3.3.1':
    resolution: {integrity: sha512-gtF186CXhIl1p4pJNGZw8Yc6RlshoePRvE0X91oPGb3vZ8pM3qOS9W9NGPat9LziaBV7XrJWGylNQXkGcnM3IQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/js@9.26.0':
    resolution: {integrity: sha512-I9XlJawFdSMvWjDt6wksMCrgns5ggLNfFwFvnShsleWruvXM514Qxk8V246efTw+eo9JABvVz+u3q2RiAowKxQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/object-schema@2.1.6':
    resolution: {integrity: sha512-RBMg5FRL0I0gs51M/guSAj5/e14VQ4tpZnQNWwuDT66P14I43ItmPfIZRhO9fUVIPOAQXU47atlywZ/czoqFPA==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/plugin-kit@0.2.8':
    resolution: {integrity: sha512-ZAoA40rNMPwSm+AeHpCq8STiNAwzWLJuP8Xv4CHIc9wv/PSuExjMrmjfYNj682vW0OOiZ1HKxzvjQr9XZIisQA==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@humanfs/core@0.19.1':
    resolution: {integrity: sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==}
    engines: {node: '>=18.18.0'}

  '@humanfs/node@0.16.6':
    resolution: {integrity: sha512-YuI2ZHQL78Q5HbhDiBA1X4LmYdXCKCMQIfw0pw7piHJwyREFebJUvrQN4cMssyES6x+vfUbx1CIpaQUKYdQZOw==}
    engines: {node: '>=18.18.0'}

  '@humanwhocodes/module-importer@1.0.1':
    resolution: {integrity: sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==}
    engines: {node: '>=12.22'}

  '@humanwhocodes/retry@0.3.1':
    resolution: {integrity: sha512-JBxkERygn7Bv/GbN5Rv8Ul6LVknS+5Bp6RgDC/O8gEBU/yeH5Ui5C/OlWrTb6qct7LjjfT6Re2NxB0ln0yYybA==}
    engines: {node: '>=18.18'}

  '@humanwhocodes/retry@0.4.3':
    resolution: {integrity: sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==}
    engines: {node: '>=18.18'}

  '@jridgewell/resolve-uri@3.1.2':
    resolution: {integrity: sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/sourcemap-codec@1.5.0':
    resolution: {integrity: sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==}

  '@jridgewell/trace-mapping@0.3.9':
    resolution: {integrity: sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==}

  '@jsdevtools/ono@7.1.3':
    resolution: {integrity: sha512-4JQNk+3mVzK3xh2rqd6RB4J46qUR19azEHBneZyTZM+c456qOrbbM/5xcR8huNCCcbVt7+UmizG6GuUvPvKUYg==}

  '@modelcontextprotocol/sdk@1.11.2':
    resolution: {integrity: sha512-H9vwztj5OAqHg9GockCQC06k1natgcxWQSRpQcPJf6i5+MWBzfKkRtxGbjQf0X2ihii0ffLZCRGbYV2f2bjNCQ==}
    engines: {node: '>=18'}

  '@mongodb-js/saslprep@1.2.2':
    resolution: {integrity: sha512-EB0O3SCSNRUFk66iRCpI+cXzIjdswfCs7F6nOC3RAGJ7xr5YhaicvsRwJ9eyzYvYRlCSDUO/c7g4yNulxKC1WA==}

  '@payos/node@1.0.10':
    resolution: {integrity: sha512-dY+WHd6pLa558a1G8yv6oKfVe5QLTNyYnQBaSQtwvMAm/p0faKAnfXt04LNIwO9/4buas4ES+sDxc1bfX/mVbQ==}

  '@rtsao/scc@1.1.0':
    resolution: {integrity: sha512-zt6OdqaDoOnJ1ZYsCYGt9YmWzDXl4vQdKTyJev62gFhRGKdx7mcT54V9KIjg+d2wi9EXsPvAPKe7i7WjfVWB8g==}

  '@scarf/scarf@1.4.0':
    resolution: {integrity: sha512-xxeapPiUXdZAE3che6f3xogoJPeZgig6omHEy1rIY5WVsB3H2BHNnZH+gHG6x91SCWyQCzWGsuL2Hh3ClO5/qQ==}

  '@smithy/abort-controller@4.0.4':
    resolution: {integrity: sha512-gJnEjZMvigPDQWHrW3oPrFhQtkrgqBkyjj3pCIdF3A5M6vsZODG93KNlfJprv6bp4245bdT32fsHK4kkH3KYDA==}
    engines: {node: '>=18.0.0'}

  '@smithy/chunked-blob-reader-native@4.0.0':
    resolution: {integrity: sha512-R9wM2yPmfEMsUmlMlIgSzOyICs0x9uu7UTHoccMyt7BWw8shcGM8HqB355+BZCPBcySvbTYMs62EgEQkNxz2ig==}
    engines: {node: '>=18.0.0'}

  '@smithy/chunked-blob-reader@5.0.0':
    resolution: {integrity: sha512-+sKqDBQqb036hh4NPaUiEkYFkTUGYzRsn3EuFhyfQfMy6oGHEUJDurLP9Ufb5dasr/XiAmPNMr6wa9afjQB+Gw==}
    engines: {node: '>=18.0.0'}

  '@smithy/config-resolver@4.1.4':
    resolution: {integrity: sha512-prmU+rDddxHOH0oNcwemL+SwnzcG65sBF2yXRO7aeXIn/xTlq2pX7JLVbkBnVLowHLg4/OL4+jBmv9hVrVGS+w==}
    engines: {node: '>=18.0.0'}

  '@smithy/core@3.5.1':
    resolution: {integrity: sha512-xSw7bZEFKwOKrm/iv8e2BLt2ur98YZdrRD6nII8ditQeUsY2Q1JmIQ0rpILOhaLKYxxG2ivnoOpokzr9qLyDWA==}
    engines: {node: '>=18.0.0'}

  '@smithy/credential-provider-imds@4.0.6':
    resolution: {integrity: sha512-hKMWcANhUiNbCJouYkZ9V3+/Qf9pteR1dnwgdyzR09R4ODEYx8BbUysHwRSyex4rZ9zapddZhLFTnT4ZijR4pw==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-codec@4.0.4':
    resolution: {integrity: sha512-7XoWfZqWb/QoR/rAU4VSi0mWnO2vu9/ltS6JZ5ZSZv0eovLVfDfu0/AX4ub33RsJTOth3TiFWSHS5YdztvFnig==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-browser@4.0.4':
    resolution: {integrity: sha512-3fb/9SYaYqbpy/z/H3yIi0bYKyAa89y6xPmIqwr2vQiUT2St+avRt8UKwsWt9fEdEasc5d/V+QjrviRaX1JRFA==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-config-resolver@4.1.2':
    resolution: {integrity: sha512-JGtambizrWP50xHgbzZI04IWU7LdI0nh/wGbqH3sJesYToMi2j/DcoElqyOcqEIG/D4tNyxgRuaqBXWE3zOFhQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-node@4.0.4':
    resolution: {integrity: sha512-RD6UwNZ5zISpOWPuhVgRz60GkSIp0dy1fuZmj4RYmqLVRtejFqQ16WmfYDdoSoAjlp1LX+FnZo+/hkdmyyGZ1w==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-universal@4.0.4':
    resolution: {integrity: sha512-UeJpOmLGhq1SLox79QWw/0n2PFX+oPRE1ZyRMxPIaFEfCqWaqpB7BU9C8kpPOGEhLF7AwEqfFbtwNxGy4ReENA==}
    engines: {node: '>=18.0.0'}

  '@smithy/fetch-http-handler@5.0.4':
    resolution: {integrity: sha512-AMtBR5pHppYMVD7z7G+OlHHAcgAN7v0kVKEpHuTO4Gb199Gowh0taYi9oDStFeUhetkeP55JLSVlTW1n9rFtUw==}
    engines: {node: '>=18.0.0'}

  '@smithy/hash-blob-browser@4.0.4':
    resolution: {integrity: sha512-WszRiACJiQV3QG6XMV44i5YWlkrlsM5Yxgz4jvsksuu7LDXA6wAtypfPajtNTadzpJy3KyJPoWehYpmZGKUFIQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/hash-node@4.0.4':
    resolution: {integrity: sha512-qnbTPUhCVnCgBp4z4BUJUhOEkVwxiEi1cyFM+Zj6o+aY8OFGxUQleKWq8ltgp3dujuhXojIvJWdoqpm6dVO3lQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/hash-stream-node@4.0.4':
    resolution: {integrity: sha512-wHo0d8GXyVmpmMh/qOR0R7Y46/G1y6OR8U+bSTB4ppEzRxd1xVAQ9xOE9hOc0bSjhz0ujCPAbfNLkLrpa6cevg==}
    engines: {node: '>=18.0.0'}

  '@smithy/invalid-dependency@4.0.4':
    resolution: {integrity: sha512-bNYMi7WKTJHu0gn26wg8OscncTt1t2b8KcsZxvOv56XA6cyXtOAAAaNP7+m45xfppXfOatXF3Sb1MNsLUgVLTw==}
    engines: {node: '>=18.0.0'}

  '@smithy/is-array-buffer@2.2.0':
    resolution: {integrity: sha512-GGP3O9QFD24uGeAXYUjwSTXARoqpZykHadOmA8G5vfJPK0/DC67qa//0qvqrJzL1xc8WQWX7/yc7fwudjPHPhA==}
    engines: {node: '>=14.0.0'}

  '@smithy/is-array-buffer@4.0.0':
    resolution: {integrity: sha512-saYhF8ZZNoJDTvJBEWgeBccCg+yvp1CX+ed12yORU3NilJScfc6gfch2oVb4QgxZrGUx3/ZJlb+c/dJbyupxlw==}
    engines: {node: '>=18.0.0'}

  '@smithy/md5-js@4.0.4':
    resolution: {integrity: sha512-uGLBVqcOwrLvGh/v/jw423yWHq/ofUGK1W31M2TNspLQbUV1Va0F5kTxtirkoHawODAZcjXTSGi7JwbnPcDPJg==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-content-length@4.0.4':
    resolution: {integrity: sha512-F7gDyfI2BB1Kc+4M6rpuOLne5LOcEknH1n6UQB69qv+HucXBR1rkzXBnQTB2q46sFy1PM/zuSJOB532yc8bg3w==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-endpoint@4.1.9':
    resolution: {integrity: sha512-AjDgX4UjORLltD/LZCBQTwjQqEfyrx/GeDTHcYLzIgf87pIT70tMWnN87NQpJru1K4ITirY2htSOxNECZJCBOg==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-retry@4.1.10':
    resolution: {integrity: sha512-RyhcA3sZIIvAo6r48b2Nx2qfg0OnyohlaV0fw415xrQyx5HQ2bvHl9vs/WBiDXIP49mCfws5wX4308c9Pi/isw==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-serde@4.0.8':
    resolution: {integrity: sha512-iSSl7HJoJaGyMIoNn2B7czghOVwJ9nD7TMvLhMWeSB5vt0TnEYyRRqPJu/TqW76WScaNvYYB8nRoiBHR9S1Ddw==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-stack@4.0.4':
    resolution: {integrity: sha512-kagK5ggDrBUCCzI93ft6DjteNSfY8Ulr83UtySog/h09lTIOAJ/xUSObutanlPT0nhoHAkpmW9V5K8oPyLh+QA==}
    engines: {node: '>=18.0.0'}

  '@smithy/node-config-provider@4.1.3':
    resolution: {integrity: sha512-HGHQr2s59qaU1lrVH6MbLlmOBxadtzTsoO4c+bF5asdgVik3I8o7JIOzoeqWc5MjVa+vD36/LWE0iXKpNqooRw==}
    engines: {node: '>=18.0.0'}

  '@smithy/node-http-handler@4.0.6':
    resolution: {integrity: sha512-NqbmSz7AW2rvw4kXhKGrYTiJVDHnMsFnX4i+/FzcZAfbOBauPYs2ekuECkSbtqaxETLLTu9Rl/ex6+I2BKErPA==}
    engines: {node: '>=18.0.0'}

  '@smithy/property-provider@4.0.4':
    resolution: {integrity: sha512-qHJ2sSgu4FqF4U/5UUp4DhXNmdTrgmoAai6oQiM+c5RZ/sbDwJ12qxB1M6FnP+Tn/ggkPZf9ccn4jqKSINaquw==}
    engines: {node: '>=18.0.0'}

  '@smithy/protocol-http@5.1.2':
    resolution: {integrity: sha512-rOG5cNLBXovxIrICSBm95dLqzfvxjEmuZx4KK3hWwPFHGdW3lxY0fZNXfv2zebfRO7sJZ5pKJYHScsqopeIWtQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/querystring-builder@4.0.4':
    resolution: {integrity: sha512-SwREZcDnEYoh9tLNgMbpop+UTGq44Hl9tdj3rf+yeLcfH7+J8OXEBaMc2kDxtyRHu8BhSg9ADEx0gFHvpJgU8w==}
    engines: {node: '>=18.0.0'}

  '@smithy/querystring-parser@4.0.4':
    resolution: {integrity: sha512-6yZf53i/qB8gRHH/l2ZwUG5xgkPgQF15/KxH0DdXMDHjesA9MeZje/853ifkSY0x4m5S+dfDZ+c4x439PF0M2w==}
    engines: {node: '>=18.0.0'}

  '@smithy/service-error-classification@4.0.5':
    resolution: {integrity: sha512-LvcfhrnCBvCmTee81pRlh1F39yTS/+kYleVeLCwNtkY8wtGg8V/ca9rbZZvYIl8OjlMtL6KIjaiL/lgVqHD2nA==}
    engines: {node: '>=18.0.0'}

  '@smithy/shared-ini-file-loader@4.0.4':
    resolution: {integrity: sha512-63X0260LoFBjrHifPDs+nM9tV0VMkOTl4JRMYNuKh/f5PauSjowTfvF3LogfkWdcPoxsA9UjqEOgjeYIbhb7Nw==}
    engines: {node: '>=18.0.0'}

  '@smithy/signature-v4@5.1.2':
    resolution: {integrity: sha512-d3+U/VpX7a60seHziWnVZOHuEgJlclufjkS6zhXvxcJgkJq4UWdH5eOBLzHRMx6gXjsdT9h6lfpmLzbrdupHgQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/smithy-client@4.4.1':
    resolution: {integrity: sha512-XPbcHRfd0iwx8dY5XCBCGyI7uweMW0oezYezxXcG8ANgvZ5YPuC6Ylh+n0bTHpdU3SCMZOnhzgVklYz+p3fIhw==}
    engines: {node: '>=18.0.0'}

  '@smithy/types@4.3.1':
    resolution: {integrity: sha512-UqKOQBL2x6+HWl3P+3QqFD4ncKq0I8Nuz9QItGv5WuKuMHuuwlhvqcZCoXGfc+P1QmfJE7VieykoYYmrOoFJxA==}
    engines: {node: '>=18.0.0'}

  '@smithy/url-parser@4.0.4':
    resolution: {integrity: sha512-eMkc144MuN7B0TDA4U2fKs+BqczVbk3W+qIvcoCY6D1JY3hnAdCuhCZODC+GAeaxj0p6Jroz4+XMUn3PCxQQeQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-base64@4.0.0':
    resolution: {integrity: sha512-CvHfCmO2mchox9kjrtzoHkWHxjHZzaFojLc8quxXY7WAAMAg43nuxwv95tATVgQFNDwd4M9S1qFzj40Ul41Kmg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-body-length-browser@4.0.0':
    resolution: {integrity: sha512-sNi3DL0/k64/LO3A256M+m3CDdG6V7WKWHdAiBBMUN8S3hK3aMPhwnPik2A/a2ONN+9doY9UxaLfgqsIRg69QA==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-body-length-node@4.0.0':
    resolution: {integrity: sha512-q0iDP3VsZzqJyje8xJWEJCNIu3lktUGVoSy1KB0UWym2CL1siV3artm+u1DFYTLejpsrdGyCSWBdGNjJzfDPjg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-buffer-from@2.2.0':
    resolution: {integrity: sha512-IJdWBbTcMQ6DA0gdNhh/BwrLkDR+ADW5Kr1aZmd4k3DIF6ezMV4R2NIAmT08wQJ3yUK82thHWmC/TnK/wpMMIA==}
    engines: {node: '>=14.0.0'}

  '@smithy/util-buffer-from@4.0.0':
    resolution: {integrity: sha512-9TOQ7781sZvddgO8nxueKi3+yGvkY35kotA0Y6BWRajAv8jjmigQ1sBwz0UX47pQMYXJPahSKEKYFgt+rXdcug==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-config-provider@4.0.0':
    resolution: {integrity: sha512-L1RBVzLyfE8OXH+1hsJ8p+acNUSirQnWQ6/EgpchV88G6zGBTDPdXiiExei6Z1wR2RxYvxY/XLw6AMNCCt8H3w==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-defaults-mode-browser@4.0.17':
    resolution: {integrity: sha512-HXq5181qnXmIwB7VrwqwP8rsJybHMoYuJnNoXy4PROs2pfSI4sWDMASF2i+7Lo+u64Y6xowhegcdxczowgJtZg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-defaults-mode-node@4.0.17':
    resolution: {integrity: sha512-RfU2A5LjFhEHw4Nwl1GZNitK4AUWu5jGtigAUDoQtfDUvYHpQxcuLw2QGAdKDtKRflIiHSZ8wXBDR36H9R2Ang==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-endpoints@3.0.6':
    resolution: {integrity: sha512-YARl3tFL3WgPuLzljRUnrS2ngLiUtkwhQtj8PAL13XZSyUiNLQxwG3fBBq3QXFqGFUXepIN73pINp3y8c2nBmA==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-hex-encoding@4.0.0':
    resolution: {integrity: sha512-Yk5mLhHtfIgW2W2WQZWSg5kuMZCVbvhFmC7rV4IO2QqnZdbEFPmQnCcGMAX2z/8Qj3B9hYYNjZOhWym+RwhePw==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-middleware@4.0.4':
    resolution: {integrity: sha512-9MLKmkBmf4PRb0ONJikCbCwORACcil6gUWojwARCClT7RmLzF04hUR4WdRprIXal7XVyrddadYNfp2eF3nrvtQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-retry@4.0.5':
    resolution: {integrity: sha512-V7MSjVDTlEt/plmOFBn1762Dyu5uqMrV2Pl2X0dYk4XvWfdWJNe9Bs5Bzb56wkCuiWjSfClVMGcsuKrGj7S/yg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-stream@4.2.2':
    resolution: {integrity: sha512-aI+GLi7MJoVxg24/3J1ipwLoYzgkB4kUfogZfnslcYlynj3xsQ0e7vk4TnTro9hhsS5PvX1mwmkRqqHQjwcU7w==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-uri-escape@4.0.0':
    resolution: {integrity: sha512-77yfbCbQMtgtTylO9itEAdpPXSog3ZxMe09AEhm0dU0NLTalV70ghDZFR+Nfi1C60jnJoh/Re4090/DuZh2Omg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-utf8@2.3.0':
    resolution: {integrity: sha512-R8Rdn8Hy72KKcebgLiv8jQcQkXoLMOGGv5uI1/k0l+snqkOzQ1R0ChUBCxWMlBsFMekWjq0wRudIweFs7sKT5A==}
    engines: {node: '>=14.0.0'}

  '@smithy/util-utf8@4.0.0':
    resolution: {integrity: sha512-b+zebfKCfRdgNJDknHCob3O7FpeYQN6ZG6YLExMcasDHsCXlsXCEuiPZeLnJLpwa5dvPetGlnGCiMHuLwGvFow==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-waiter@4.0.5':
    resolution: {integrity: sha512-4QvC49HTteI1gfemu0I1syWovJgPvGn7CVUoN9ZFkdvr/cCFkrEL7qNCdx/2eICqDWEGnnr68oMdSIPCLAriSQ==}
    engines: {node: '>=18.0.0'}

  '@swc/helpers@0.3.17':
    resolution: {integrity: sha512-tb7Iu+oZ+zWJZ3HJqwx8oNwSDIU440hmVMDPhpACWQWnrZHK99Bxs70gT1L2dnr5Hg50ZRWEFkQCAnOVVV0z1Q==}

  '@tsconfig/node10@1.0.11':
    resolution: {integrity: sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==}

  '@tsconfig/node12@1.0.11':
    resolution: {integrity: sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==}

  '@tsconfig/node14@1.0.3':
    resolution: {integrity: sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==}

  '@tsconfig/node16@1.0.4':
    resolution: {integrity: sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==}

  '@types/aws-sdk@2.7.4':
    resolution: {integrity: sha512-BdGaQDSow2hYmHbn7RV/Lg9rvh/JBD6gFRKAeCh3eqjc2eAjaz5m+cjuX1lpaWOisMeb0ep8sZBhtOLHHZ8qAA==}
    deprecated: This is a stub types definition. aws-sdk provides its own type definitions, so you do not need this installed.

  '@types/bcryptjs@3.0.0':
    resolution: {integrity: sha512-WRZOuCuaz8UcZZE4R5HXTco2goQSI2XxjGY3hbM/xDvwmqFWd4ivooImsMx65OKM6CtNKbnZ5YL+YwAwK7c1dg==}
    deprecated: This is a stub types definition. bcryptjs provides its own type definitions, so you do not need this installed.

  '@types/body-parser@1.19.5':
    resolution: {integrity: sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==}

  '@types/compression@1.8.0':
    resolution: {integrity: sha512-g4vmPIwbTii9dX1HVioHbOolubEaf4re4vDxuzpKrzz9uI7uarBExi9begX0cXyIB85jXZ5X2A/v8rsHZxSAPw==}

  '@types/connect@3.4.38':
    resolution: {integrity: sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==}

  '@types/cors@2.8.18':
    resolution: {integrity: sha512-nX3d0sxJW41CqQvfOzVG1NCTXfFDrDWIghCZncpHeWlVFd81zxB/DLhg7avFg6eHLCRX7ckBmoIIcqa++upvJA==}

  '@types/dotenv@8.2.3':
    resolution: {integrity: sha512-g2FXjlDX/cYuc5CiQvyU/6kkbP1JtmGzh0obW50zD7OKeILVL0NSpPWLXVfqoAGQjom2/SLLx9zHq0KXvD6mbw==}
    deprecated: This is a stub types definition. dotenv provides its own type definitions, so you do not need this installed.

  '@types/estree@1.0.7':
    resolution: {integrity: sha512-w28IoSUCJpidD/TGviZwwMJckNESJZXFu7NBZ5YJ4mEUnNraUn9Pm8HSZm/jDF1pDWYKspWE7oVphigUPRakIQ==}

  '@types/express-serve-static-core@5.0.6':
    resolution: {integrity: sha512-3xhRnjJPkULekpSzgtoNYYcTWgEZkp4myc+Saevii5JPnHNvHMRlBSHDbs7Bh1iPPoVTERHEZXyhyLbMEsExsA==}

  '@types/express@5.0.1':
    resolution: {integrity: sha512-UZUw8vjpWFXuDnjFTh7/5c2TWDlQqeXHi6hcN7F2XSVT5P+WmUnnbFS3KA6Jnc6IsEqI2qCVu2bK0R0J4A8ZQQ==}

  '@types/hpp@0.2.6':
    resolution: {integrity: sha512-6gn1RuHA1/XFCVCqCkSV+AWy07YwtGg4re4SHhLMoiARTg9XlrbYMtVR+Uvws0VlERXzzcA+1UYvxEV6O+sgPg==}

  '@types/http-errors@2.0.4':
    resolution: {integrity: sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==}

  '@types/json-schema@7.0.15':
    resolution: {integrity: sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==}

  '@types/json5@0.0.29':
    resolution: {integrity: sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==}

  '@types/jsonwebtoken@9.0.9':
    resolution: {integrity: sha512-uoe+GxEuHbvy12OUQct2X9JenKM3qAscquYymuQN4fMWG9DBQtykrQEFcAbVACF7qaLw9BePSodUL0kquqBJpQ==}

  '@types/mime@1.3.5':
    resolution: {integrity: sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==}

  '@types/morgan@1.9.9':
    resolution: {integrity: sha512-iRYSDKVaC6FkGSpEVVIvrRGw0DfJMiQzIn3qr2G5B3C//AWkulhXgaBd7tS9/J79GWSYMTHGs7PfI5b3Y8m+RQ==}

  '@types/ms@2.1.0':
    resolution: {integrity: sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==}

  '@types/multer@1.4.12':
    resolution: {integrity: sha512-pQ2hoqvXiJt2FP9WQVLPRO+AmiIm/ZYkavPlIQnx282u4ZrVdztx0pkh3jjpQt0Kz+YI0YhSG264y08UJKoUQg==}

  '@types/node@22.15.18':
    resolution: {integrity: sha512-v1DKRfUdyW+jJhZNEI1PYy29S2YRxMV5AOO/x/SjKmW0acCIOqmbj6Haf9eHAhsPmrhlHSxEhv/1WszcLWV4cg==}

  '@types/nodemailer@6.4.17':
    resolution: {integrity: sha512-I9CCaIp6DTldEg7vyUTZi8+9Vo0hi1/T8gv3C89yk1rSAAzoKQ8H8ki/jBYJSFoH/BisgLP8tkZMlQ91CIquww==}

  '@types/pdfkit@0.13.9':
    resolution: {integrity: sha512-RDG8Yb1zT7I01FfpwK7nMSA433XWpblMqSCtA5vJlSyavWZb303HUYPCel6JTiDDFqwGLvtAnYbH8N/e0Cb89g==}

  '@types/qs@6.9.18':
    resolution: {integrity: sha512-kK7dgTYDyGqS+e2Q4aK9X3D7q234CIZ1Bv0q/7Z5IwRDoADNU81xXJK/YVyLbLTZCoIwUoDoffFeF+p/eIklAA==}

  '@types/range-parser@1.2.7':
    resolution: {integrity: sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==}

  '@types/send@0.17.4':
    resolution: {integrity: sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==}

  '@types/serve-static@1.15.7':
    resolution: {integrity: sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==}

  '@types/strip-bom@3.0.0':
    resolution: {integrity: sha512-xevGOReSYGM7g/kUBZzPqCrR/KYAo+F0yiPc85WFTJa0MSLtyFTVTU6cJu/aV4mid7IffDIWqo69THF2o4JiEQ==}

  '@types/strip-json-comments@0.0.30':
    resolution: {integrity: sha512-7NQmHra/JILCd1QqpSzl8+mJRc8ZHz3uDm8YV1Ks9IhK0epEiTw8aIErbvH9PI+6XbqhyIQy3462nEsn7UVzjQ==}

  '@types/swagger-jsdoc@6.0.4':
    resolution: {integrity: sha512-W+Xw5epcOZrF/AooUM/PccNMSAFOKWZA5dasNyMujTwsBkU74njSJBpvCCJhHAJ95XRMzQrrW844Btu0uoetwQ==}

  '@types/swagger-ui-express@4.1.8':
    resolution: {integrity: sha512-AhZV8/EIreHFmBV5wAs0gzJUNq9JbbSXgJLQubCC0jtIo6prnI9MIRRxnU4MZX9RB9yXxF1V4R7jtLl/Wcj31g==}

  '@types/triple-beam@1.3.5':
    resolution: {integrity: sha512-6WaYesThRMCl19iryMYP7/x2OVgCtbIVflDGFpWnb9irXI3UjYE4AzmYuiUKY1AJstGijoY+MgUszMgRxIYTYw==}

  '@types/validator@13.15.0':
    resolution: {integrity: sha512-nh7nrWhLr6CBq9ldtw0wx+z9wKnnv/uTVLA9g/3/TcOYxbpOSZE+MhKPmWqU+K0NvThjhv12uD8MuqijB0WzEA==}

  '@types/webidl-conversions@7.0.3':
    resolution: {integrity: sha512-CiJJvcRtIgzadHCYXw7dqEnMNRjhGZlYK05Mj9OyktqV8uVT8fD2BFOB7S1uwBE3Kj2Z+4UyPmFw/Ixgw/LAlA==}

  '@types/whatwg-url@11.0.5':
    resolution: {integrity: sha512-coYR071JRaHa+xoEvvYqvnIHaVqaYrLPbsufM9BF63HkwI5Lgmy2QR8Q5K/lYDYo5AK82wOvSOS0UsLTpTG7uQ==}

  '@types/yamljs@0.2.34':
    resolution: {integrity: sha512-gJvfRlv9ErxdOv7ux7UsJVePtX54NAvQyd8ncoiFqK8G5aeHIfQfGH2fbruvjAQ9657HwAaO54waS+Dsk2QTUQ==}

  accepts@2.0.0:
    resolution: {integrity: sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==}
    engines: {node: '>= 0.6'}

  acorn-jsx@5.3.2:
    resolution: {integrity: sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==}
    peerDependencies:
      acorn: ^6.0.0 || ^7.0.0 || ^8.0.0

  acorn-walk@8.3.4:
    resolution: {integrity: sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==}
    engines: {node: '>=0.4.0'}

  acorn@8.14.1:
    resolution: {integrity: sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==}
    engines: {node: '>=0.4.0'}
    hasBin: true

  agent-base@7.1.3:
    resolution: {integrity: sha512-jRR5wdylq8CkOe6hei19GGZnxM6rBGwFl3Bg0YItGDimvjGtAvdZk4Pu6Cl4u4Igsws4a1fd1Vq3ezrhn4KmFw==}
    engines: {node: '>= 14'}

  ajv@6.12.6:
    resolution: {integrity: sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==}

  ansi-escapes@7.0.0:
    resolution: {integrity: sha512-GdYO7a61mR0fOlAsvC9/rIHf7L96sBc6dEWzeOu+KAea5bZyQRPIpojrVoI4AXGJS/ycu/fBTdLrUkA4ODrvjw==}
    engines: {node: '>=18'}

  ansi-regex@6.1.0:
    resolution: {integrity: sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==}
    engines: {node: '>=12'}

  ansi-styles@4.3.0:
    resolution: {integrity: sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==}
    engines: {node: '>=8'}

  ansi-styles@6.2.1:
    resolution: {integrity: sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==}
    engines: {node: '>=12'}

  anymatch@3.1.3:
    resolution: {integrity: sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==}
    engines: {node: '>= 8'}

  append-field@1.0.0:
    resolution: {integrity: sha512-klpgFSWLW1ZEs8svjfb7g4qWY0YS5imI82dTg+QahUvJ8YqAY0P10Uk8tTyh9ZGuYEZEMaeJYCF5BFuX552hsw==}

  arg@4.1.3:
    resolution: {integrity: sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==}

  argparse@1.0.10:
    resolution: {integrity: sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==}

  argparse@2.0.1:
    resolution: {integrity: sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==}

  array-buffer-byte-length@1.0.2:
    resolution: {integrity: sha512-LHE+8BuR7RYGDKvnrmcuSq3tDcKv9OFEXQt/HpbZhY7V6h0zlUXutnAD82GiFx9rdieCMjkvtcsPqBwgUl1Iiw==}
    engines: {node: '>= 0.4'}

  array-includes@3.1.8:
    resolution: {integrity: sha512-itaWrbYbqpGXkGhZPGUulwnhVf5Hpy1xiCFsGqyIGglbBxmG5vSjxQen3/WGOjPpNEv1RtBLKxbmVXm8HpJStQ==}
    engines: {node: '>= 0.4'}

  array.prototype.findlastindex@1.2.6:
    resolution: {integrity: sha512-F/TKATkzseUExPlfvmwQKGITM3DGTK+vkAsCZoDc5daVygbJBnjEUCbgkAvVFsgfXfX4YIqZ/27G3k3tdXrTxQ==}
    engines: {node: '>= 0.4'}

  array.prototype.flat@1.3.3:
    resolution: {integrity: sha512-rwG/ja1neyLqCuGZ5YYrznA62D4mZXg0i1cIskIUKSiqF3Cje9/wXAls9B9s1Wa2fomMsIv8czB8jZcPmxCXFg==}
    engines: {node: '>= 0.4'}

  array.prototype.flatmap@1.3.3:
    resolution: {integrity: sha512-Y7Wt51eKJSyi80hFrJCePGGNo5ktJCslFuboqJsbf57CCPcm5zztluPlc4/aD8sWsKvlwatezpV4U1efk8kpjg==}
    engines: {node: '>= 0.4'}

  arraybuffer.prototype.slice@1.0.4:
    resolution: {integrity: sha512-BNoCY6SXXPQ7gF2opIP4GBE+Xw7U+pHMYKuzjgCN3GwiaIR09UUeKfheyIry77QtrCBlC0KK0q5/TER/tYh3PQ==}
    engines: {node: '>= 0.4'}

  async-function@1.0.0:
    resolution: {integrity: sha512-hsU18Ae8CDTR6Kgu9DYf0EbCr/a5iGL0rytQDobUcdpYOKokk8LEjVphnXkDkgpi0wYVsqrXuP0bZxJaTqdgoA==}
    engines: {node: '>= 0.4'}

  async@3.2.6:
    resolution: {integrity: sha512-htCUDlxyyCLMgaM3xXg0C0LW2xqfuQ6p05pCEIsXuyQ+a1koYKTuBMzRNwmybfLgvJDMd0r1LTn4+E0Ti6C2AA==}

  asynckit@0.4.0:
    resolution: {integrity: sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==}

  available-typed-arrays@1.0.7:
    resolution: {integrity: sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==}
    engines: {node: '>= 0.4'}

  aws-sdk@2.1692.0:
    resolution: {integrity: sha512-x511uiJ/57FIsbgUe5csJ13k3uzu25uWQE+XqfBis/sB0SFoiElJWXRkgEAUh0U6n40eT3ay5Ue4oPkRMu1LYw==}
    engines: {node: '>= 10.0.0'}

  axios@1.9.0:
    resolution: {integrity: sha512-re4CqKTJaURpzbLHtIi6XpDv20/CnpXOtjRY5/CU32L8gU8ek9UIivcfvSWvmKEngmVbrUtPpdDwWDWL7DNHvg==}

  balanced-match@1.0.2:
    resolution: {integrity: sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==}

  base64-js@0.0.8:
    resolution: {integrity: sha512-3XSA2cR/h/73EzlXXdU6YNycmYI7+kicTxks4eJg2g39biHR84slg2+des+p7iHYhbRg/udIS4TD53WabcOUkw==}
    engines: {node: '>= 0.4'}

  base64-js@1.5.1:
    resolution: {integrity: sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==}

  basic-auth@2.0.1:
    resolution: {integrity: sha512-NF+epuEdnUYVlGuhaxbbq+dvJttwLnGY+YixlXlME5KpQ5W3CnXA5cVTneY3SPbPDRkcjMbifrwmFYcClgOZeg==}
    engines: {node: '>= 0.8'}

  bcryptjs@3.0.2:
    resolution: {integrity: sha512-k38b3XOZKv60C4E2hVsXTolJWfkGRMbILBIe2IBITXciy5bOsTKot5kDrf3ZfufQtQOUN5mXceUEpU1rTl9Uog==}
    hasBin: true

  bignumber.js@9.3.0:
    resolution: {integrity: sha512-EM7aMFTXbptt/wZdMlBv2t8IViwQL+h6SLHosp8Yf0dqJMTnY6iL32opnAB6kAdL0SZPuvcAzFr31o0c/R3/RA==}

  binary-extensions@2.3.0:
    resolution: {integrity: sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==}
    engines: {node: '>=8'}

  body-parser@2.2.0:
    resolution: {integrity: sha512-02qvAaxv8tp7fBa/mw1ga98OGm+eCbqzJOKoRt70sLmfEEi+jyBYVTDGfCL/k06/4EMk/z01gCe7HoCH/f2LTg==}
    engines: {node: '>=18'}

  bowser@2.11.0:
    resolution: {integrity: sha512-AlcaJBi/pqqJBIQ8U9Mcpc9i8Aqxn88Skv5d+xBX006BY5u8N3mGLHa5Lgppa7L/HfwgwLgZ6NYs+Ag6uUmJRA==}

  brace-expansion@1.1.11:
    resolution: {integrity: sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==}

  brace-expansion@2.0.1:
    resolution: {integrity: sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==}

  braces@3.0.3:
    resolution: {integrity: sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==}
    engines: {node: '>=8'}

  brotli@1.3.3:
    resolution: {integrity: sha512-oTKjJdShmDuGW94SyyaoQvAjf30dZaHnjJ8uAF+u2/vGJkJbJPJAT1gDiOJP5v1Zb6f9KEyW/1HpuaWIXtGHPg==}

  bson@6.10.3:
    resolution: {integrity: sha512-MTxGsqgYTwfshYWTRdmZRC+M7FnG1b4y7RO7p2k3X24Wq0yv1m77Wsj0BzlPzd/IowgESfsruQCUToa7vbOpPQ==}
    engines: {node: '>=16.20.1'}

  buffer-equal-constant-time@1.0.1:
    resolution: {integrity: sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==}

  buffer-from@1.1.2:
    resolution: {integrity: sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==}

  buffer@4.9.2:
    resolution: {integrity: sha512-xq+q3SRMOxGivLhBNaUdC64hDTQwejJ+H0T/NB1XMtTVEwNTrfFF3gAxiyW0Bu/xWEGhjVKgUcMhCrUy2+uCWg==}

  busboy@1.6.0:
    resolution: {integrity: sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==}
    engines: {node: '>=10.16.0'}

  bytes@3.1.2:
    resolution: {integrity: sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==}
    engines: {node: '>= 0.8'}

  call-bind-apply-helpers@1.0.2:
    resolution: {integrity: sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==}
    engines: {node: '>= 0.4'}

  call-bind@1.0.8:
    resolution: {integrity: sha512-oKlSFMcMwpUg2ednkhQ454wfWiU/ul3CkJe/PEHcTKuiX6RpbehUiFMXu13HalGZxfUwCQzZG747YXBn1im9ww==}
    engines: {node: '>= 0.4'}

  call-bound@1.0.4:
    resolution: {integrity: sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==}
    engines: {node: '>= 0.4'}

  call-me-maybe@1.0.2:
    resolution: {integrity: sha512-HpX65o1Hnr9HH25ojC1YGs7HCQLq0GCOibSaWER0eNpgJ/Z1MZv2mTc7+xh6WOPxbRVcmgbv4hGU+uSQ/2xFZQ==}

  callsites@3.1.0:
    resolution: {integrity: sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==}
    engines: {node: '>=6'}

  chalk@4.1.2:
    resolution: {integrity: sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==}
    engines: {node: '>=10'}

  chalk@5.4.1:
    resolution: {integrity: sha512-zgVZuo2WcZgfUEmsn6eO3kINexW8RAE4maiQ8QNs8CtpPCSyMiYsULR3HQYkm3w8FIA3SberyMJMSldGsW+U3w==}
    engines: {node: ^12.17.0 || ^14.13 || >=16.0.0}

  chokidar@3.6.0:
    resolution: {integrity: sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==}
    engines: {node: '>= 8.10.0'}

  class-transformer@0.5.1:
    resolution: {integrity: sha512-SQa1Ws6hUbfC98vKGxZH3KFY0Y1lm5Zm0SY8XX9zbK7FJCyVEac3ATW0RIpwzW+oOfmHE5PMPufDG9hCfoEOMw==}

  class-validator@0.14.2:
    resolution: {integrity: sha512-3kMVRF2io8N8pY1IFIXlho9r8IPUUIfHe2hYVtiebvAzU2XeQFXTv+XI4WX+TnXmtwXMDcjngcpkiPM0O9PvLw==}

  cli-cursor@5.0.0:
    resolution: {integrity: sha512-aCj4O5wKyszjMmDT4tZj93kxyydN/K5zPWSCe6/0AV/AA1pqe5ZBIw0a2ZfPQV7lL5/yb5HsUreJ6UFAF1tEQw==}
    engines: {node: '>=18'}

  cli-truncate@4.0.0:
    resolution: {integrity: sha512-nPdaFdQ0h/GEigbPClz11D0v/ZJEwxmeVZGeMo3Z5StPtUTkA9o1lD6QwoirYiSDzbcwn2XcjwmCp68W1IS4TA==}
    engines: {node: '>=18'}

  clone@2.1.2:
    resolution: {integrity: sha512-3Pe/CF1Nn94hyhIYpjtiLhdCoEoz0DqQ+988E9gmeEdQZlojxnOb74wctFyuwWQHzqyf9X7C7MG8juUpqBJT8w==}
    engines: {node: '>=0.8'}

  color-convert@1.9.3:
    resolution: {integrity: sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==}

  color-convert@2.0.1:
    resolution: {integrity: sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==}
    engines: {node: '>=7.0.0'}

  color-name@1.1.3:
    resolution: {integrity: sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==}

  color-name@1.1.4:
    resolution: {integrity: sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==}

  color-string@1.9.1:
    resolution: {integrity: sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==}

  color@3.2.1:
    resolution: {integrity: sha512-aBl7dZI9ENN6fUGC7mWpMTPNHmWUSNan9tuWN6ahh5ZLNk9baLJOnSMlrQkHcrfFgz2/RigjUVAjdx36VcemKA==}

  colorette@2.0.20:
    resolution: {integrity: sha512-IfEDxwoWIjkeXL1eXcDiow4UbKjhLdq6/EuSVR9GMN7KVH3r9gQ83e73hsz1Nd1T3ijd5xv1wcWRYO+D6kCI2w==}

  colorspace@1.1.4:
    resolution: {integrity: sha512-BgvKJiuVu1igBUF2kEjRCZXol6wiiGbY5ipL/oVPwm0BL9sIpMIzM8IK7vwuxIIzOXMV3Ey5w+vxhm0rR/TN8w==}

  combined-stream@1.0.8:
    resolution: {integrity: sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==}
    engines: {node: '>= 0.8'}

  commander@13.1.0:
    resolution: {integrity: sha512-/rFeCpNJQbhSZjGVwO9RFV3xPqbnERS8MmIQzCtD/zl6gpJuV/bMLuN92oG3F7d8oDEHHRrujSXNUr8fpjntKw==}
    engines: {node: '>=18'}

  commander@6.2.0:
    resolution: {integrity: sha512-zP4jEKbe8SHzKJYQmq8Y9gYjtO/POJLgIdKgV7B9qNmABVFVc+ctqSX6iXh4mCpJfRBOabiZ2YKPg8ciDw6C+Q==}
    engines: {node: '>= 6'}

  commander@9.5.0:
    resolution: {integrity: sha512-KRs7WVDKg86PWiuAqhDrAQnTXZKraVcCc6vFdL14qrZ/DcWwuRo7VoiYXalXO7S5GKpqYiVEwCbgFDfxNHKJBQ==}
    engines: {node: ^12.20.0 || >=14}

  compressible@2.0.18:
    resolution: {integrity: sha512-AF3r7P5dWxL8MxyITRMlORQNaOA2IkAFaTr4k7BUumjPtRpGDTZpl0Pb1XCO6JeDCBdp126Cgs9sMxqSjgYyRg==}
    engines: {node: '>= 0.6'}

  compression@1.8.0:
    resolution: {integrity: sha512-k6WLKfunuqCYD3t6AsuPGvQWaKwuLLh2/xHNcX4qE+vIfDNXpSqnrhwA7O53R7WVQUnt8dVAIW+YHr7xTgOgGA==}
    engines: {node: '>= 0.8.0'}

  concat-map@0.0.1:
    resolution: {integrity: sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==}

  concat-stream@1.6.2:
    resolution: {integrity: sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==}
    engines: {'0': node >= 0.8}

  content-disposition@1.0.0:
    resolution: {integrity: sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==}
    engines: {node: '>= 0.6'}

  content-type@1.0.5:
    resolution: {integrity: sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==}
    engines: {node: '>= 0.6'}

  cookie-signature@1.2.2:
    resolution: {integrity: sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==}
    engines: {node: '>=6.6.0'}

  cookie@0.7.2:
    resolution: {integrity: sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==}
    engines: {node: '>= 0.6'}

  core-util-is@1.0.3:
    resolution: {integrity: sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==}

  cors@2.8.5:
    resolution: {integrity: sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==}
    engines: {node: '>= 0.10'}

  create-require@1.1.1:
    resolution: {integrity: sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==}

  cross-spawn@7.0.6:
    resolution: {integrity: sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==}
    engines: {node: '>= 8'}

  crypto-js@4.2.0:
    resolution: {integrity: sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q==}

  crypto@1.0.1:
    resolution: {integrity: sha512-VxBKmeNcqQdiUQUW2Tzq0t377b54N2bMtXO/qiLa+6eRRmmC4qT3D4OnTGoT/U6O9aklQ/jTwbOtRMTTY8G0Ig==}
    deprecated: This package is no longer supported. It's now a built-in Node module. If you've depended on crypto, you should switch to the one that's built-in.

  data-view-buffer@1.0.2:
    resolution: {integrity: sha512-EmKO5V3OLXh1rtK2wgXRansaK1/mtVdTUEiEI0W8RkvgT05kfxaH29PliLnpLP73yYO6142Q72QNa8Wx/A5CqQ==}
    engines: {node: '>= 0.4'}

  data-view-byte-length@1.0.2:
    resolution: {integrity: sha512-tuhGbE6CfTM9+5ANGf+oQb72Ky/0+s3xKUpHvShfiz2RxMFgFPjsXuRLBVMtvMs15awe45SRb83D6wH4ew6wlQ==}
    engines: {node: '>= 0.4'}

  data-view-byte-offset@1.0.1:
    resolution: {integrity: sha512-BS8PfmtDGnrgYdOonGZQdLZslWIeCGFP9tpan0hi1Co2Zr2NKADsvGYA8XxuG/4UWgJ6Cjtv+YJnB6MM69QGlQ==}
    engines: {node: '>= 0.4'}

  date-fns@4.1.0:
    resolution: {integrity: sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==}

  debug@2.6.9:
    resolution: {integrity: sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  debug@3.2.7:
    resolution: {integrity: sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  debug@4.4.1:
    resolution: {integrity: sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  deep-equal@2.2.3:
    resolution: {integrity: sha512-ZIwpnevOurS8bpT4192sqAowWM76JDKSHYzMLty3BZGSswgq6pBaH3DhCSW5xVAZICZyKdOBPjwww5wfgT/6PA==}
    engines: {node: '>= 0.4'}

  deep-is@0.1.4:
    resolution: {integrity: sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==}

  define-data-property@1.1.4:
    resolution: {integrity: sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==}
    engines: {node: '>= 0.4'}

  define-properties@1.2.1:
    resolution: {integrity: sha512-8QmQKqEASLd5nx0U1B1okLElbUuuttJ/AnYmRXbbbGDWh6uS208EjD4Xqq/I9wK7u0v6O08XhTWnt5XtEbR6Dg==}
    engines: {node: '>= 0.4'}

  delayed-stream@1.0.0:
    resolution: {integrity: sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==}
    engines: {node: '>=0.4.0'}

  depd@2.0.0:
    resolution: {integrity: sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==}
    engines: {node: '>= 0.8'}

  dfa@1.2.0:
    resolution: {integrity: sha512-ED3jP8saaweFTjeGX8HQPjeC1YYyZs98jGNZx6IiBvxW7JG5v492kamAQB3m2wop07CvU/RQmzcKr6bgcC5D/Q==}

  diff@4.0.2:
    resolution: {integrity: sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==}
    engines: {node: '>=0.3.1'}

  doctrine@2.1.0:
    resolution: {integrity: sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==}
    engines: {node: '>=0.10.0'}

  doctrine@3.0.0:
    resolution: {integrity: sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==}
    engines: {node: '>=6.0.0'}

  dotenv@16.5.0:
    resolution: {integrity: sha512-m/C+AwOAr9/W1UOIZUo232ejMNnJAJtYQjUbHoNTBNTJSvqzzDh7vnrei3o3r3m9blf6ZoDkvcw0VmozNRFJxg==}
    engines: {node: '>=12'}

  dunder-proto@1.0.1:
    resolution: {integrity: sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==}
    engines: {node: '>= 0.4'}

  dynamic-dedupe@0.3.0:
    resolution: {integrity: sha512-ssuANeD+z97meYOqd50e04Ze5qp4bPqo8cCkI4TRjZkzAUgIDTrXV1R8QCdINpiI+hw14+rYazvTRdQrz0/rFQ==}

  ecdsa-sig-formatter@1.0.11:
    resolution: {integrity: sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==}

  ee-first@1.1.1:
    resolution: {integrity: sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==}

  ejs@3.1.10:
    resolution: {integrity: sha512-UeJmFfOrAQS8OJWPZ4qtgHyWExa088/MtK5UEyoJGFH67cDEXkZSviOiKRCZ4Xij0zxI3JECgYs3oKx+AizQBA==}
    engines: {node: '>=0.10.0'}
    hasBin: true

  emoji-regex@10.4.0:
    resolution: {integrity: sha512-EC+0oUMY1Rqm4O6LLrgjtYDvcVYTy7chDnM4Q7030tP4Kwj3u/pR6gP9ygnp2CJMK5Gq+9Q2oqmrFJAz01DXjw==}

  enabled@2.0.0:
    resolution: {integrity: sha512-AKrN98kuwOzMIdAizXGI86UFBoo26CL21UM763y1h/GMSJ4/OHU9k2YlsmBpyScFo/wbLzWQJBMCW4+IO3/+OQ==}

  encodeurl@2.0.0:
    resolution: {integrity: sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==}
    engines: {node: '>= 0.8'}

  envalid@8.0.0:
    resolution: {integrity: sha512-PGeYJnJB5naN0ME6SH8nFcDj9HVbLpYIfg1p5lAyM9T4cH2lwtu2fLbozC/bq+HUUOIFxhX/LP0/GmlqPHT4tQ==}
    engines: {node: '>=8.12'}

  environment@1.1.0:
    resolution: {integrity: sha512-xUtoPkMggbz0MPyPiIWr1Kp4aeWJjDZ6SMvURhimjdZgsRuDplF5/s9hcgGhyXMhs+6vpnuoiZ2kFiu3FMnS8Q==}
    engines: {node: '>=18'}

  es-abstract@1.23.9:
    resolution: {integrity: sha512-py07lI0wjxAC/DcfK1S6G7iANonniZwTISvdPzk9hzeH0IZIshbuuFxLIU96OyF89Yb9hiqWn8M/bY83KY5vzA==}
    engines: {node: '>= 0.4'}

  es-define-property@1.0.1:
    resolution: {integrity: sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==}
    engines: {node: '>= 0.4'}

  es-errors@1.3.0:
    resolution: {integrity: sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==}
    engines: {node: '>= 0.4'}

  es-get-iterator@1.1.3:
    resolution: {integrity: sha512-sPZmqHBe6JIiTfN5q2pEi//TwxmAFHwj/XEuYjTuse78i8KxaqMTTzxPoFKuzRpDpTJ+0NAbpfenkmH2rePtuw==}

  es-object-atoms@1.1.1:
    resolution: {integrity: sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==}
    engines: {node: '>= 0.4'}

  es-set-tostringtag@2.1.0:
    resolution: {integrity: sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==}
    engines: {node: '>= 0.4'}

  es-shim-unscopables@1.1.0:
    resolution: {integrity: sha512-d9T8ucsEhh8Bi1woXCf+TIKDIROLG5WCkxg8geBCbvk22kzwC5G2OnXVMO6FUsvQlgUUXQ2itephWDLqDzbeCw==}
    engines: {node: '>= 0.4'}

  es-to-primitive@1.3.0:
    resolution: {integrity: sha512-w+5mJ3GuFL+NjVtJlvydShqE1eN3h3PbI7/5LAsYJP/2qtuMXjfL2LpHSRqo4b4eSF5K/DH1JXKUAHSB2UW50g==}
    engines: {node: '>= 0.4'}

  escape-html@1.0.3:
    resolution: {integrity: sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==}

  escape-string-regexp@4.0.0:
    resolution: {integrity: sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==}
    engines: {node: '>=10'}

  eslint-config-prettier@10.1.5:
    resolution: {integrity: sha512-zc1UmCpNltmVY34vuLRV61r1K27sWuX39E+uyUnY8xS2Bex88VV9cugG+UZbRSRGtGyFboj+D8JODyme1plMpw==}
    hasBin: true
    peerDependencies:
      eslint: '>=7.0.0'

  eslint-import-resolver-node@0.3.9:
    resolution: {integrity: sha512-WFj2isz22JahUv+B788TlO3N6zL3nNJGU8CcZbPZvVEkBPaJdCV4vy5wyghty5ROFbCRnm132v8BScu5/1BQ8g==}

  eslint-module-utils@2.12.0:
    resolution: {integrity: sha512-wALZ0HFoytlyh/1+4wuZ9FJCD/leWHQzzrxJ8+rebyReSLk7LApMyd3WJaLVoN+D5+WIdJyDK1c6JnE65V4Zyg==}
    engines: {node: '>=4'}
    peerDependencies:
      '@typescript-eslint/parser': '*'
      eslint: '*'
      eslint-import-resolver-node: '*'
      eslint-import-resolver-typescript: '*'
      eslint-import-resolver-webpack: '*'
    peerDependenciesMeta:
      '@typescript-eslint/parser':
        optional: true
      eslint:
        optional: true
      eslint-import-resolver-node:
        optional: true
      eslint-import-resolver-typescript:
        optional: true
      eslint-import-resolver-webpack:
        optional: true

  eslint-plugin-import@2.31.0:
    resolution: {integrity: sha512-ixmkI62Rbc2/w8Vfxyh1jQRTdRTF52VxwRVHl/ykPAmqG+Nb7/kNn+byLP0LxPgI7zWA16Jt82SybJInmMia3A==}
    engines: {node: '>=4'}
    peerDependencies:
      '@typescript-eslint/parser': '*'
      eslint: ^2 || ^3 || ^4 || ^5 || ^6 || ^7.2.0 || ^8 || ^9
    peerDependenciesMeta:
      '@typescript-eslint/parser':
        optional: true

  eslint-scope@8.3.0:
    resolution: {integrity: sha512-pUNxi75F8MJ/GdeKtVLSbYg4ZI34J6C0C7sbL4YOp2exGwen7ZsuBqKzUhXd0qMQ362yET3z+uPwKeg/0C2XCQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  eslint-visitor-keys@3.4.3:
    resolution: {integrity: sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  eslint-visitor-keys@4.2.0:
    resolution: {integrity: sha512-UyLnSehNt62FFhSwjZlHmeokpRK59rcz29j+F1/aDgbkbRTk7wIc9XzdoasMUbRNKDM0qQt/+BJ4BrpFeABemw==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  eslint@9.26.0:
    resolution: {integrity: sha512-Hx0MOjPh6uK9oq9nVsATZKE/Wlbai7KFjfCuw9UHaguDW3x+HF0O5nIi3ud39TWgrTjTO5nHxmL3R1eANinWHQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
    hasBin: true
    peerDependencies:
      jiti: '*'
    peerDependenciesMeta:
      jiti:
        optional: true

  espree@10.3.0:
    resolution: {integrity: sha512-0QYC8b24HWY8zjRnDTL6RiHfDbAWn63qb4LMj1Z4b076A4une81+z03Kg7l7mn/48PUTqoLptSXez8oknU8Clg==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  esquery@1.6.0:
    resolution: {integrity: sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==}
    engines: {node: '>=0.10'}

  esrecurse@4.3.0:
    resolution: {integrity: sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==}
    engines: {node: '>=4.0'}

  estraverse@5.3.0:
    resolution: {integrity: sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==}
    engines: {node: '>=4.0'}

  esutils@2.0.3:
    resolution: {integrity: sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==}
    engines: {node: '>=0.10.0'}

  etag@1.8.1:
    resolution: {integrity: sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==}
    engines: {node: '>= 0.6'}

  eventemitter3@5.0.1:
    resolution: {integrity: sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==}

  events@1.1.1:
    resolution: {integrity: sha512-kEcvvCBByWXGnZy6JUlgAp2gBIUjfCAV6P6TgT1/aaQKcmuAEC4OZTV1I4EWQLz2gxZw76atuVyvHhTxvi0Flw==}
    engines: {node: '>=0.4.x'}

  eventsource-parser@3.0.1:
    resolution: {integrity: sha512-VARTJ9CYeuQYb0pZEPbzi740OWFgpHe7AYJ2WFZVnUDUQp5Dk2yJUgF36YsZ81cOyxT0QxmXD2EQpapAouzWVA==}
    engines: {node: '>=18.0.0'}

  eventsource@3.0.7:
    resolution: {integrity: sha512-CRT1WTyuQoD771GW56XEZFQ/ZoSfWid1alKGDYMmkt2yl8UXrVR4pspqWNEcqKvVIzg6PAltWjxcSSPrboA4iA==}
    engines: {node: '>=18.0.0'}

  express-rate-limit@7.5.0:
    resolution: {integrity: sha512-eB5zbQh5h+VenMPM3fh+nw1YExi5nMr6HUCR62ELSP11huvxm/Uir1H1QEyTkk5QX6A58pX6NmaTMceKZ0Eodg==}
    engines: {node: '>= 16'}
    peerDependencies:
      express: ^4.11 || 5 || ^5.0.0-beta.1

  express@5.1.0:
    resolution: {integrity: sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==}
    engines: {node: '>= 18'}

  extend@3.0.2:
    resolution: {integrity: sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==}

  fast-deep-equal@3.1.3:
    resolution: {integrity: sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==}

  fast-json-stable-stringify@2.1.0:
    resolution: {integrity: sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==}

  fast-levenshtein@2.0.6:
    resolution: {integrity: sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==}

  fast-xml-parser@4.4.1:
    resolution: {integrity: sha512-xkjOecfnKGkSsOwtZ5Pz7Us/T6mrbPQrq0nh+aCO5V9nk5NLWmasAHumTKjiPJPWANe+kAZ84Jc8ooJkzZ88Sw==}
    hasBin: true

  fecha@4.2.3:
    resolution: {integrity: sha512-OP2IUU6HeYKJi3i0z4A19kHMQoLVs4Hc+DPqqxI2h/DPZHTm/vjsfC6P0b4jCMy14XizLBqvndQ+UilD7707Jw==}

  file-entry-cache@8.0.0:
    resolution: {integrity: sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==}
    engines: {node: '>=16.0.0'}

  filelist@1.0.4:
    resolution: {integrity: sha512-w1cEuf3S+DrLCQL7ET6kz+gmlJdbq9J7yXCSjK/OZCPA+qEN1WyF4ZAf0YYJa4/shHJra2t/d/r8SV4Ji+x+8Q==}

  fill-range@7.1.1:
    resolution: {integrity: sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==}
    engines: {node: '>=8'}

  finalhandler@2.1.0:
    resolution: {integrity: sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==}
    engines: {node: '>= 0.8'}

  find-up@5.0.0:
    resolution: {integrity: sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==}
    engines: {node: '>=10'}

  flat-cache@4.0.1:
    resolution: {integrity: sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==}
    engines: {node: '>=16'}

  flatted@3.3.3:
    resolution: {integrity: sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==}

  fn.name@1.1.0:
    resolution: {integrity: sha512-GRnmB5gPyJpAhTQdSZTSp9uaPSvl09KoYcMQtsB9rQoOmzs9dH6ffeccH+Z+cv6P68Hu5bC6JjRh4Ah/mHSNRw==}

  follow-redirects@1.15.9:
    resolution: {integrity: sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ==}
    engines: {node: '>=4.0'}
    peerDependencies:
      debug: '*'
    peerDependenciesMeta:
      debug:
        optional: true

  fontkit@1.9.0:
    resolution: {integrity: sha512-HkW/8Lrk8jl18kzQHvAw9aTHe1cqsyx5sDnxncx652+CIfhawokEPkeM3BoIC+z/Xv7a0yMr0f3pRRwhGH455g==}

  for-each@0.3.5:
    resolution: {integrity: sha512-dKx12eRCVIzqCxFGplyFKJMPvLEWgmNtUrpTiJIR5u97zEhRG8ySrtboPHZXx7daLxQVrl643cTzbab2tkQjxg==}
    engines: {node: '>= 0.4'}

  form-data@4.0.2:
    resolution: {integrity: sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==}
    engines: {node: '>= 6'}

  forwarded@0.2.0:
    resolution: {integrity: sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==}
    engines: {node: '>= 0.6'}

  fresh@2.0.0:
    resolution: {integrity: sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==}
    engines: {node: '>= 0.8'}

  fs.realpath@1.0.0:
    resolution: {integrity: sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  function-bind@1.1.2:
    resolution: {integrity: sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==}

  function.prototype.name@1.1.8:
    resolution: {integrity: sha512-e5iwyodOHhbMr/yNrc7fDYG4qlbIvI5gajyzPnb5TCwyhjApznQh1BMFou9b30SevY43gCJKXycoCBjMbsuW0Q==}
    engines: {node: '>= 0.4'}

  functions-have-names@1.2.3:
    resolution: {integrity: sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==}

  gaxios@6.7.1:
    resolution: {integrity: sha512-LDODD4TMYx7XXdpwxAVRAIAuB0bzv0s+ywFonY46k126qzQHT9ygyoa9tncmOiQmmDrik65UYsEkv3lbfqQ3yQ==}
    engines: {node: '>=14'}

  gcp-metadata@6.1.1:
    resolution: {integrity: sha512-a4tiq7E0/5fTjxPAaH4jpjkSv/uCaU2p5KC6HVGrvl0cDjA8iBZv4vv1gyzlmK0ZUKqwpOyQMKzZQe3lTit77A==}
    engines: {node: '>=14'}

  get-east-asian-width@1.3.0:
    resolution: {integrity: sha512-vpeMIQKxczTD/0s2CdEWHcb0eeJe6TFjxb+J5xgX7hScxqrGuyjmv4c1D4A/gelKfyox0gJJwIHF+fLjeaM8kQ==}
    engines: {node: '>=18'}

  get-intrinsic@1.3.0:
    resolution: {integrity: sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==}
    engines: {node: '>= 0.4'}

  get-proto@1.0.1:
    resolution: {integrity: sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==}
    engines: {node: '>= 0.4'}

  get-symbol-description@1.1.0:
    resolution: {integrity: sha512-w9UMqWwJxHNOvoNzSJ2oPF5wvYcvP7jUvYzhp67yEhTi17ZDBBC1z9pTdGuzjD+EFIqLSYRweZjqfiPzQ06Ebg==}
    engines: {node: '>= 0.4'}

  glob-parent@5.1.2:
    resolution: {integrity: sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==}
    engines: {node: '>= 6'}

  glob-parent@6.0.2:
    resolution: {integrity: sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==}
    engines: {node: '>=10.13.0'}

  glob@7.1.6:
    resolution: {integrity: sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==}
    deprecated: Glob versions prior to v9 are no longer supported

  glob@7.2.3:
    resolution: {integrity: sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==}
    deprecated: Glob versions prior to v9 are no longer supported

  globals@14.0.0:
    resolution: {integrity: sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==}
    engines: {node: '>=18'}

  globalthis@1.0.4:
    resolution: {integrity: sha512-DpLKbNU4WylpxJykQujfCcwYWiV/Jhm50Goo0wrVILAv5jOr9d+H+UR3PhSCD2rCCEIg0uc+G+muBTwD54JhDQ==}
    engines: {node: '>= 0.4'}

  google-auth-library@9.15.1:
    resolution: {integrity: sha512-Jb6Z0+nvECVz+2lzSMt9u98UsoakXxA2HGHMCxh+so3n90XgYWkq5dur19JAJV7ONiJY22yBTyJB1TSkvPq9Ng==}
    engines: {node: '>=14'}

  google-logging-utils@0.0.2:
    resolution: {integrity: sha512-NEgUnEcBiP5HrPzufUkBzJOD/Sxsco3rLNo1F1TNf7ieU8ryUzBhqba8r756CjLX7rn3fHl6iLEwPYuqpoKgQQ==}
    engines: {node: '>=14'}

  gopd@1.2.0:
    resolution: {integrity: sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==}
    engines: {node: '>= 0.4'}

  gtoken@7.1.0:
    resolution: {integrity: sha512-pCcEwRi+TKpMlxAQObHDQ56KawURgyAf6jtIY046fJ5tIv3zDe/LEIubckAO8fj6JnAxLdmWkUfNyulQ2iKdEw==}
    engines: {node: '>=14.0.0'}

  has-bigints@1.1.0:
    resolution: {integrity: sha512-R3pbpkcIqv2Pm3dUwgjclDRVmWpTJW2DcMzcIhEXEx1oh/CEMObMm3KLmRJOdvhM7o4uQBnwr8pzRK2sJWIqfg==}
    engines: {node: '>= 0.4'}

  has-flag@4.0.0:
    resolution: {integrity: sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==}
    engines: {node: '>=8'}

  has-property-descriptors@1.0.2:
    resolution: {integrity: sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==}

  has-proto@1.2.0:
    resolution: {integrity: sha512-KIL7eQPfHQRC8+XluaIw7BHUwwqL19bQn4hzNgdr+1wXoU0KKj6rufu47lhY7KbJR2C6T6+PfyN0Ea7wkSS+qQ==}
    engines: {node: '>= 0.4'}

  has-symbols@1.1.0:
    resolution: {integrity: sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==}
    engines: {node: '>= 0.4'}

  has-tostringtag@1.0.2:
    resolution: {integrity: sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==}
    engines: {node: '>= 0.4'}

  hasown@2.0.2:
    resolution: {integrity: sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==}
    engines: {node: '>= 0.4'}

  helmet@8.1.0:
    resolution: {integrity: sha512-jOiHyAZsmnr8LqoPGmCjYAaiuWwjAPLgY8ZX2XrmHawt99/u1y6RgrZMTeoPfpUbV96HOalYgz1qzkRbw54Pmg==}
    engines: {node: '>=18.0.0'}

  hpp@0.2.3:
    resolution: {integrity: sha512-4zDZypjQcxK/8pfFNR7jaON7zEUpXZxz4viyFmqjb3kWNWAHsLEUmWXcdn25c5l76ISvnD6hbOGO97cXUI3Ryw==}
    engines: {node: '>=0.10.0'}

  http-errors@2.0.0:
    resolution: {integrity: sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==}
    engines: {node: '>= 0.8'}

  https-proxy-agent@7.0.6:
    resolution: {integrity: sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==}
    engines: {node: '>= 14'}

  husky@9.1.7:
    resolution: {integrity: sha512-5gs5ytaNjBrh5Ow3zrvdUUY+0VxIuWVL4i9irt6friV+BqdCfmV11CQTWMiBYWHbXhco+J1kHfTOUkePhCDvMA==}
    engines: {node: '>=18'}
    hasBin: true

  iconv-lite@0.6.3:
    resolution: {integrity: sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==}
    engines: {node: '>=0.10.0'}

  ieee754@1.1.13:
    resolution: {integrity: sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg==}

  ignore@5.3.2:
    resolution: {integrity: sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==}
    engines: {node: '>= 4'}

  import-fresh@3.3.1:
    resolution: {integrity: sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==}
    engines: {node: '>=6'}

  imurmurhash@0.1.4:
    resolution: {integrity: sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==}
    engines: {node: '>=0.8.19'}

  inflight@1.0.6:
    resolution: {integrity: sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==}
    deprecated: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.

  inherits@2.0.3:
    resolution: {integrity: sha512-x00IRNXNy63jwGkJmzPigoySHbaqpNuzKbBOmzK+g2OdZpQ9w+sxCN+VSB3ja7IAge2OP2qpfxTjeNcyjmW1uw==}

  inherits@2.0.4:
    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}

  internal-slot@1.1.0:
    resolution: {integrity: sha512-4gd7VpWNQNB4UKKCFFVcp1AVv+FMOgs9NKzjHKusc8jTMhd5eL1NqQqOpE0KzMds804/yHlglp3uxgluOqAPLw==}
    engines: {node: '>= 0.4'}

  ipaddr.js@1.9.1:
    resolution: {integrity: sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==}
    engines: {node: '>= 0.10'}

  is-arguments@1.2.0:
    resolution: {integrity: sha512-7bVbi0huj/wrIAOzb8U1aszg9kdi3KN/CyU19CTI7tAoZYEZoL9yCDXpbXN+uPsuWnP02cyug1gleqq+TU+YCA==}
    engines: {node: '>= 0.4'}

  is-array-buffer@3.0.5:
    resolution: {integrity: sha512-DDfANUiiG2wC1qawP66qlTugJeL5HyzMpfr8lLK+jMQirGzNod0B12cFB/9q838Ru27sBwfw78/rdoU7RERz6A==}
    engines: {node: '>= 0.4'}

  is-arrayish@0.3.2:
    resolution: {integrity: sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ==}

  is-async-function@2.1.1:
    resolution: {integrity: sha512-9dgM/cZBnNvjzaMYHVoxxfPj2QXt22Ev7SuuPrs+xav0ukGB0S6d4ydZdEiM48kLx5kDV+QBPrpVnFyefL8kkQ==}
    engines: {node: '>= 0.4'}

  is-bigint@1.1.0:
    resolution: {integrity: sha512-n4ZT37wG78iz03xPRKJrHTdZbe3IicyucEtdRsV5yglwc3GyUfbAfpSeD0FJ41NbUNSt5wbhqfp1fS+BgnvDFQ==}
    engines: {node: '>= 0.4'}

  is-binary-path@2.1.0:
    resolution: {integrity: sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==}
    engines: {node: '>=8'}

  is-boolean-object@1.2.2:
    resolution: {integrity: sha512-wa56o2/ElJMYqjCjGkXri7it5FbebW5usLw/nPmCMs5DeZ7eziSYZhSmPRn0txqeW4LnAmQQU7FgqLpsEFKM4A==}
    engines: {node: '>= 0.4'}

  is-callable@1.2.7:
    resolution: {integrity: sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==}
    engines: {node: '>= 0.4'}

  is-core-module@2.16.1:
    resolution: {integrity: sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==}
    engines: {node: '>= 0.4'}

  is-data-view@1.0.2:
    resolution: {integrity: sha512-RKtWF8pGmS87i2D6gqQu/l7EYRlVdfzemCJN/P3UOs//x1QE7mfhvzHIApBTRf7axvT6DMGwSwBXYCT0nfB9xw==}
    engines: {node: '>= 0.4'}

  is-date-object@1.1.0:
    resolution: {integrity: sha512-PwwhEakHVKTdRNVOw+/Gyh0+MzlCl4R6qKvkhuvLtPMggI1WAHt9sOwZxQLSGpUaDnrdyDsomoRgNnCfKNSXXg==}
    engines: {node: '>= 0.4'}

  is-extglob@2.1.1:
    resolution: {integrity: sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==}
    engines: {node: '>=0.10.0'}

  is-finalizationregistry@1.1.1:
    resolution: {integrity: sha512-1pC6N8qWJbWoPtEjgcL2xyhQOP491EQjeUo3qTKcmV8YSDDJrOepfG8pcC7h/QgnQHYSv0mJ3Z/ZWxmatVrysg==}
    engines: {node: '>= 0.4'}

  is-fullwidth-code-point@4.0.0:
    resolution: {integrity: sha512-O4L094N2/dZ7xqVdrXhh9r1KODPJpFms8B5sGdJLPy664AgvXsreZUyCQQNItZRDlYug4xStLjNp/sz3HvBowQ==}
    engines: {node: '>=12'}

  is-fullwidth-code-point@5.0.0:
    resolution: {integrity: sha512-OVa3u9kkBbw7b8Xw5F9P+D/T9X+Z4+JruYVNapTjPYZYUznQ5YfWeFkOj606XYYW8yugTfC8Pj0hYqvi4ryAhA==}
    engines: {node: '>=18'}

  is-generator-function@1.1.0:
    resolution: {integrity: sha512-nPUB5km40q9e8UfN/Zc24eLlzdSf9OfKByBw9CIdw4H1giPMeA0OIJvbchsCu4npfI2QcMVBsGEBHKZ7wLTWmQ==}
    engines: {node: '>= 0.4'}

  is-glob@4.0.3:
    resolution: {integrity: sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==}
    engines: {node: '>=0.10.0'}

  is-map@2.0.3:
    resolution: {integrity: sha512-1Qed0/Hr2m+YqxnM09CjA2d/i6YZNfF6R2oRAOj36eUdS6qIV/huPJNSEpKbupewFs+ZsJlxsjjPbc0/afW6Lw==}
    engines: {node: '>= 0.4'}

  is-number-object@1.1.1:
    resolution: {integrity: sha512-lZhclumE1G6VYD8VHe35wFaIif+CTy5SJIi5+3y4psDgWu4wPDoBhF8NxUOinEc7pHgiTsT6MaBb92rKhhD+Xw==}
    engines: {node: '>= 0.4'}

  is-number@7.0.0:
    resolution: {integrity: sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==}
    engines: {node: '>=0.12.0'}

  is-promise@4.0.0:
    resolution: {integrity: sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==}

  is-regex@1.2.1:
    resolution: {integrity: sha512-MjYsKHO5O7mCsmRGxWcLWheFqN9DJ/2TmngvjKXihe6efViPqc274+Fx/4fYj/r03+ESvBdTXK0V6tA3rgez1g==}
    engines: {node: '>= 0.4'}

  is-set@2.0.3:
    resolution: {integrity: sha512-iPAjerrse27/ygGLxw+EBR9agv9Y6uLeYVJMu+QNCoouJ1/1ri0mGrcWpfCqFZuzzx3WjtwxG098X+n4OuRkPg==}
    engines: {node: '>= 0.4'}

  is-shared-array-buffer@1.0.4:
    resolution: {integrity: sha512-ISWac8drv4ZGfwKl5slpHG9OwPNty4jOWPRIhBpxOoD+hqITiwuipOQ2bNthAzwA3B4fIjO4Nln74N0S9byq8A==}
    engines: {node: '>= 0.4'}

  is-stream@2.0.1:
    resolution: {integrity: sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==}
    engines: {node: '>=8'}

  is-string@1.1.1:
    resolution: {integrity: sha512-BtEeSsoaQjlSPBemMQIrY1MY0uM6vnS1g5fmufYOtnxLGUZM2178PKbhsk7Ffv58IX+ZtcvoGwccYsh0PglkAA==}
    engines: {node: '>= 0.4'}

  is-symbol@1.1.1:
    resolution: {integrity: sha512-9gGx6GTtCQM73BgmHQXfDmLtfjjTUDSyoxTCbp5WtoixAhfgsDirWIcVQ/IHpvI5Vgd5i/J5F7B9cN/WlVbC/w==}
    engines: {node: '>= 0.4'}

  is-typed-array@1.1.15:
    resolution: {integrity: sha512-p3EcsicXjit7SaskXHs1hA91QxgTw46Fv6EFKKGS5DRFLD8yKnohjF3hxoju94b/OcMZoQukzpPpBE9uLVKzgQ==}
    engines: {node: '>= 0.4'}

  is-weakmap@2.0.2:
    resolution: {integrity: sha512-K5pXYOm9wqY1RgjpL3YTkF39tni1XajUIkawTLUo9EZEVUFga5gSQJF8nNS7ZwJQ02y+1YCNYcMh+HIf1ZqE+w==}
    engines: {node: '>= 0.4'}

  is-weakref@1.1.1:
    resolution: {integrity: sha512-6i9mGWSlqzNMEqpCp93KwRS1uUOodk2OJ6b+sq7ZPDSy2WuI5NFIxp/254TytR8ftefexkWn5xNiHUNpPOfSew==}
    engines: {node: '>= 0.4'}

  is-weakset@2.0.4:
    resolution: {integrity: sha512-mfcwb6IzQyOKTs84CQMrOwW4gQcaTOAWJ0zzJCl2WSPDrWk/OzDaImWFH3djXhb24g4eudZfLRozAvPGw4d9hQ==}
    engines: {node: '>= 0.4'}

  isarray@1.0.0:
    resolution: {integrity: sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==}

  isarray@2.0.5:
    resolution: {integrity: sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==}

  isexe@2.0.0:
    resolution: {integrity: sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==}

  jake@10.9.2:
    resolution: {integrity: sha512-2P4SQ0HrLQ+fw6llpLnOaGAvN2Zu6778SJMrCUwns4fOoG9ayrTiZk3VV8sCPkVZF8ab0zksVpS8FDY5pRCNBA==}
    engines: {node: '>=10'}
    hasBin: true

  jmespath@0.16.0:
    resolution: {integrity: sha512-9FzQjJ7MATs1tSpnco1K6ayiYE3figslrXA72G2HQ/n76RzvYlofyi5QM+iX4YRs/pu3yzxlVQSST23+dMDknw==}
    engines: {node: '>= 0.6.0'}

  js-yaml@4.1.0:
    resolution: {integrity: sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==}
    hasBin: true

  json-bigint@1.0.0:
    resolution: {integrity: sha512-SiPv/8VpZuWbvLSMtTDU8hEfrZWg/mH/nV/b4o0CYbSxu1UIQPLdwKOCIyLQX+VIPO5vrLX3i8qtqFyhdPSUSQ==}

  json-buffer@3.0.1:
    resolution: {integrity: sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==}

  json-schema-traverse@0.4.1:
    resolution: {integrity: sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==}

  json-stable-stringify-without-jsonify@1.0.1:
    resolution: {integrity: sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==}

  json5@1.0.2:
    resolution: {integrity: sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==}
    hasBin: true

  jsonwebtoken@9.0.2:
    resolution: {integrity: sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==}
    engines: {node: '>=12', npm: '>=6'}

  jwa@1.4.2:
    resolution: {integrity: sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==}

  jwa@2.0.1:
    resolution: {integrity: sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==}

  jws@3.2.2:
    resolution: {integrity: sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==}

  jws@4.0.0:
    resolution: {integrity: sha512-KDncfTmOZoOMTFG4mBlG0qUIOlc03fmzH+ru6RgYVZhPkyiy/92Owlt/8UEN+a4TXR1FQetfIpJE8ApdvdVxTg==}

  kareem@2.6.3:
    resolution: {integrity: sha512-C3iHfuGUXK2u8/ipq9LfjFfXFxAZMQJJq7vLS45r3D9Y2xQ/m4S8zaR4zMLFWh9AsNPXmcFfUDhTEO8UIC/V6Q==}
    engines: {node: '>=12.0.0'}

  keyv@4.5.4:
    resolution: {integrity: sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==}

  kuler@2.0.0:
    resolution: {integrity: sha512-Xq9nH7KlWZmXAtodXDDRE7vs6DU1gTU8zYDHDiWLSip45Egwq3plLHzPn27NgvzL2r1LMPC1vdqh98sQxtqj4A==}

  levn@0.4.1:
    resolution: {integrity: sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==}
    engines: {node: '>= 0.8.0'}

  libphonenumber-js@1.12.8:
    resolution: {integrity: sha512-f1KakiQJa9tdc7w1phC2ST+DyxWimy9c3g3yeF+84QtEanJr2K77wAmBPP22riU05xldniHsvXuflnLZ4oysqA==}

  lilconfig@3.1.3:
    resolution: {integrity: sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==}
    engines: {node: '>=14'}

  linebreak@1.1.0:
    resolution: {integrity: sha512-MHp03UImeVhB7XZtjd0E4n6+3xr5Dq/9xI/5FptGk5FrbDR3zagPa2DS6U8ks/3HjbKWG9Q1M2ufOzxV2qLYSQ==}

  lint-staged@16.0.0:
    resolution: {integrity: sha512-sUCprePs6/rbx4vKC60Hez6X10HPkpDJaGcy3D1NdwR7g1RcNkWL8q9mJMreOqmHBTs+1sNFp+wOiX9fr+hoOQ==}
    engines: {node: '>=20.18'}
    hasBin: true

  listr2@8.3.3:
    resolution: {integrity: sha512-LWzX2KsqcB1wqQ4AHgYb4RsDXauQiqhjLk+6hjbaeHG4zpjjVAB6wC/gz6X0l+Du1cN3pUB5ZlrvTbhGSNnUQQ==}
    engines: {node: '>=18.0.0'}

  locate-path@6.0.0:
    resolution: {integrity: sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==}
    engines: {node: '>=10'}

  lodash.get@4.4.2:
    resolution: {integrity: sha512-z+Uw/vLuy6gQe8cfaFWD7p0wVv8fJl3mbzXh33RS+0oW2wvUqiRXiQ69gLWSLpgB5/6sU+r6BlQR0MBILadqTQ==}
    deprecated: This package is deprecated. Use the optional chaining (?.) operator instead.

  lodash.includes@4.3.0:
    resolution: {integrity: sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==}

  lodash.isboolean@3.0.3:
    resolution: {integrity: sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==}

  lodash.isequal@4.5.0:
    resolution: {integrity: sha512-pDo3lu8Jhfjqls6GkMgpahsF9kCyayhgykjyLMNFTKWrpVdAQtYyB4muAMWozBB4ig/dtWAmsMxLEI8wuz+DYQ==}
    deprecated: This package is deprecated. Use require('node:util').isDeepStrictEqual instead.

  lodash.isinteger@4.0.4:
    resolution: {integrity: sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==}

  lodash.isnumber@3.0.3:
    resolution: {integrity: sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==}

  lodash.isplainobject@4.0.6:
    resolution: {integrity: sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==}

  lodash.isstring@4.0.1:
    resolution: {integrity: sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==}

  lodash.merge@4.6.2:
    resolution: {integrity: sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==}

  lodash.mergewith@4.6.2:
    resolution: {integrity: sha512-GK3g5RPZWTRSeLSpgP8Xhra+pnjBC56q9FZYe1d5RN3TJ35dbkGy3YqBSMbyCrlbi+CM9Z3Jk5yTL7RCsqboyQ==}

  lodash.once@4.1.1:
    resolution: {integrity: sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==}

  lodash@4.17.21:
    resolution: {integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==}

  log-update@6.1.0:
    resolution: {integrity: sha512-9ie8ItPR6tjY5uYJh8K/Zrv/RMZ5VOlOWvtZdEHYSTFKZfIBPQa9tOAEeAWhd+AnIneLJ22w5fjOYtoutpWq5w==}
    engines: {node: '>=18'}

  logform@2.7.0:
    resolution: {integrity: sha512-TFYA4jnP7PVbmlBIfhlSe+WKxs9dklXMTEGcBCIvLhE/Tn3H6Gk1norupVW7m5Cnd4bLcr08AytbyV/xj7f/kQ==}
    engines: {node: '>= 12.0.0'}

  make-error@1.3.6:
    resolution: {integrity: sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==}

  math-intrinsics@1.1.0:
    resolution: {integrity: sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==}
    engines: {node: '>= 0.4'}

  media-typer@0.3.0:
    resolution: {integrity: sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==}
    engines: {node: '>= 0.6'}

  media-typer@1.1.0:
    resolution: {integrity: sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==}
    engines: {node: '>= 0.8'}

  memory-pager@1.5.0:
    resolution: {integrity: sha512-ZS4Bp4r/Zoeq6+NLJpP+0Zzm0pR8whtGPf1XExKLJBAczGMnSi3It14OiNCStjQjM6NU1okjQGSxgEZN8eBYKg==}

  merge-descriptors@2.0.0:
    resolution: {integrity: sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==}
    engines: {node: '>=18'}

  micromatch@4.0.8:
    resolution: {integrity: sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==}
    engines: {node: '>=8.6'}

  mime-db@1.52.0:
    resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
    engines: {node: '>= 0.6'}

  mime-db@1.54.0:
    resolution: {integrity: sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==}
    engines: {node: '>= 0.6'}

  mime-types@2.1.35:
    resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}
    engines: {node: '>= 0.6'}

  mime-types@3.0.1:
    resolution: {integrity: sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==}
    engines: {node: '>= 0.6'}

  mimic-function@5.0.1:
    resolution: {integrity: sha512-VP79XUPxV2CigYP3jWwAUFSku2aKqBH7uTAapFWCBqutsbmDo96KY5o8uh6U+/YSIn5OxJnXp73beVkpqMIGhA==}
    engines: {node: '>=18'}

  minimatch@3.1.2:
    resolution: {integrity: sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==}

  minimatch@5.1.6:
    resolution: {integrity: sha512-lKwV/1brpG6mBUFHtb7NUmtABCb2WZZmm2wNiOA5hAb8VdCS4B3dtMWyvcoViccwAW/COERjXLt0zP1zXUN26g==}
    engines: {node: '>=10'}

  minimist@1.2.8:
    resolution: {integrity: sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==}

  mkdirp@0.5.6:
    resolution: {integrity: sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==}
    hasBin: true

  mkdirp@1.0.4:
    resolution: {integrity: sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==}
    engines: {node: '>=10'}
    hasBin: true

  moment@2.30.1:
    resolution: {integrity: sha512-uEmtNhbDOrWPFS+hdjFCBfy9f2YoyzRpwcl+DqpC6taX21FzsTLQVbMV/W7PzNSX6x/bhC1zA3c2UQ5NzH6how==}

  mongodb-connection-string-url@3.0.2:
    resolution: {integrity: sha512-rMO7CGo/9BFwyZABcKAWL8UJwH/Kc2x0g72uhDWzG48URRax5TCIcJ7Rc3RZqffZzO/Gwff/jyKwCU9TN8gehA==}

  mongodb@6.16.0:
    resolution: {integrity: sha512-D1PNcdT0y4Grhou5Zi/qgipZOYeWrhLEpk33n3nm6LGtz61jvO88WlrWCK/bigMjpnOdAUKKQwsGIl0NtWMyYw==}
    engines: {node: '>=16.20.1'}
    peerDependencies:
      '@aws-sdk/credential-providers': ^3.188.0
      '@mongodb-js/zstd': ^1.1.0 || ^2.0.0
      gcp-metadata: ^5.2.0
      kerberos: ^2.0.1
      mongodb-client-encryption: '>=6.0.0 <7'
      snappy: ^7.2.2
      socks: ^2.7.1
    peerDependenciesMeta:
      '@aws-sdk/credential-providers':
        optional: true
      '@mongodb-js/zstd':
        optional: true
      gcp-metadata:
        optional: true
      kerberos:
        optional: true
      mongodb-client-encryption:
        optional: true
      snappy:
        optional: true
      socks:
        optional: true

  mongoose@8.14.3:
    resolution: {integrity: sha512-BiIQK4mZiStUgnNep1YJMMYTiC4K893+Dj/Sr3lvxXutqy4+yZMVhlHq60xRH3r/l6eXkQXO3tXJnVOE5g592Q==}
    engines: {node: '>=16.20.1'}

  morgan@1.10.0:
    resolution: {integrity: sha512-AbegBVI4sh6El+1gNwvD5YIck7nSA36weD7xvIxG4in80j/UoK8AEGaWnnz8v1GxonMCltmlNs5ZKbGvl9b1XQ==}
    engines: {node: '>= 0.8.0'}

  mpath@0.9.0:
    resolution: {integrity: sha512-ikJRQTk8hw5DEoFVxHG1Gn9T/xcjtdnOKIU1JTmGjZZlg9LST2mBLmcX3/ICIbgJydT2GOc15RnNy5mHmzfSew==}
    engines: {node: '>=4.0.0'}

  mquery@5.0.0:
    resolution: {integrity: sha512-iQMncpmEK8R8ncT8HJGsGc9Dsp8xcgYMVSbs5jgnm1lFHTZqMJTUWTDx1LBO8+mK3tPNZWFLBghQEIOULSTHZg==}
    engines: {node: '>=14.0.0'}

  ms@2.0.0:
    resolution: {integrity: sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==}

  ms@2.1.3:
    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}

  multer@2.0.0:
    resolution: {integrity: sha512-bS8rPZurbAuHGAnApbM9d4h1wSoYqrOqkE+6a64KLMK9yWU7gJXBDDVklKQ3TPi9DRb85cRs6yXaC0+cjxRtRg==}
    engines: {node: '>= 10.16.0'}

  nano-spawn@1.0.1:
    resolution: {integrity: sha512-BfcvzBlUTxSDWfT+oH7vd6CbUV+rThLLHCIym/QO6GGLBsyVXleZs00fto2i2jzC/wPiBYk5jyOmpXWg4YopiA==}
    engines: {node: '>=20.18'}

  natural-compare@1.4.0:
    resolution: {integrity: sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==}

  negotiator@0.6.4:
    resolution: {integrity: sha512-myRT3DiWPHqho5PrJaIRyaMv2kgYf0mUVgBNOYMuCH5Ki1yEiQaf/ZJuQ62nvpc44wL5WDbTX7yGJi1Neevw8w==}
    engines: {node: '>= 0.6'}

  negotiator@1.0.0:
    resolution: {integrity: sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==}
    engines: {node: '>= 0.6'}

  node-fetch@2.7.0:
    resolution: {integrity: sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==}
    engines: {node: 4.x || >=6.0.0}
    peerDependencies:
      encoding: ^0.1.0
    peerDependenciesMeta:
      encoding:
        optional: true

  nodemailer@7.0.3:
    resolution: {integrity: sha512-Ajq6Sz1x7cIK3pN6KesGTah+1gnwMnx5gKl3piQlQQE/PwyJ4Mbc8is2psWYxK3RJTVeqsDaCv8ZzXLCDHMTZw==}
    engines: {node: '>=6.0.0'}

  normalize-path@3.0.0:
    resolution: {integrity: sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==}
    engines: {node: '>=0.10.0'}

  object-assign@4.1.1:
    resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
    engines: {node: '>=0.10.0'}

  object-inspect@1.13.4:
    resolution: {integrity: sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==}
    engines: {node: '>= 0.4'}

  object-is@1.1.6:
    resolution: {integrity: sha512-F8cZ+KfGlSGi09lJT7/Nd6KJZ9ygtvYC0/UYYLI9nmQKLMnydpB9yvbv9K1uSkEu7FU9vYPmVwLg328tX+ot3Q==}
    engines: {node: '>= 0.4'}

  object-keys@1.1.1:
    resolution: {integrity: sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==}
    engines: {node: '>= 0.4'}

  object.assign@4.1.7:
    resolution: {integrity: sha512-nK28WOo+QIjBkDduTINE4JkF/UJJKyf2EJxvJKfblDpyg0Q+pkOHNTL0Qwy6NP6FhE/EnzV73BxxqcJaXY9anw==}
    engines: {node: '>= 0.4'}

  object.fromentries@2.0.8:
    resolution: {integrity: sha512-k6E21FzySsSK5a21KRADBd/NGneRegFO5pLHfdQLpRDETUNJueLXs3WCzyQ3tFRDYgbq3KHGXfTbi2bs8WQ6rQ==}
    engines: {node: '>= 0.4'}

  object.groupby@1.0.3:
    resolution: {integrity: sha512-+Lhy3TQTuzXI5hevh8sBGqbmurHbbIjAi0Z4S63nthVLmLxfbj4T54a4CfZrXIrt9iP4mVAPYMo/v99taj3wjQ==}
    engines: {node: '>= 0.4'}

  object.values@1.2.1:
    resolution: {integrity: sha512-gXah6aZrcUxjWg2zR2MwouP2eHlCBzdV4pygudehaKXSGW4v2AsRQUK+lwwXhii6KFZcunEnmSUoYp5CXibxtA==}
    engines: {node: '>= 0.4'}

  on-finished@2.3.0:
    resolution: {integrity: sha512-ikqdkGAAyf/X/gPhXGvfgAytDZtDbr+bkNUJ0N9h5MI/dmdgCs3l6hoHrcUv41sRKew3jIwrp4qQDXiK99Utww==}
    engines: {node: '>= 0.8'}

  on-finished@2.4.1:
    resolution: {integrity: sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==}
    engines: {node: '>= 0.8'}

  on-headers@1.0.2:
    resolution: {integrity: sha512-pZAE+FJLoyITytdqK0U5s+FIpjN0JP3OzFi/u8Rx+EV5/W+JTWGXG8xFzevE7AjBfDqHv/8vL8qQsIhHnqRkrA==}
    engines: {node: '>= 0.8'}

  once@1.4.0:
    resolution: {integrity: sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==}

  one-time@1.0.0:
    resolution: {integrity: sha512-5DXOiRKwuSEcQ/l0kGCF6Q3jcADFv5tSmRaJck/OqkVFcOzutB134KRSfF0xDrL39MNnqxbHBbUUcjZIhTgb2g==}

  onetime@7.0.0:
    resolution: {integrity: sha512-VXJjc87FScF88uafS3JllDgvAm+c/Slfz06lorj2uAY34rlUu0Nt+v8wreiImcrgAjjIHp1rXpTDlLOGw29WwQ==}
    engines: {node: '>=18'}

  openapi-types@12.1.3:
    resolution: {integrity: sha512-N4YtSYJqghVu4iek2ZUvcN/0aqH1kRDuNqzcycDxhOUpg7GdvLa2F3DgS6yBNhInhv2r/6I0Flkn7CqL8+nIcw==}

  optionator@0.9.4:
    resolution: {integrity: sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==}
    engines: {node: '>= 0.8.0'}

  own-keys@1.0.1:
    resolution: {integrity: sha512-qFOyK5PjiWZd+QQIh+1jhdb9LpxTF0qs7Pm8o5QHYZ0M3vKqSqzsZaEB6oWlxZ+q2sJBMI/Ktgd2N5ZwQoRHfg==}
    engines: {node: '>= 0.4'}

  p-limit@3.1.0:
    resolution: {integrity: sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==}
    engines: {node: '>=10'}

  p-locate@5.0.0:
    resolution: {integrity: sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==}
    engines: {node: '>=10'}

  pako@0.2.9:
    resolution: {integrity: sha512-NUcwaKxUxWrZLpDG+z/xZaCgQITkA/Dv4V/T6bw7VON6l1Xz/VnrBqrYjZQ12TamKHzITTfOEIYUj48y2KXImA==}

  parent-module@1.0.1:
    resolution: {integrity: sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==}
    engines: {node: '>=6'}

  parseurl@1.3.3:
    resolution: {integrity: sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==}
    engines: {node: '>= 0.8'}

  path-exists@4.0.0:
    resolution: {integrity: sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==}
    engines: {node: '>=8'}

  path-is-absolute@1.0.1:
    resolution: {integrity: sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==}
    engines: {node: '>=0.10.0'}

  path-key@3.1.1:
    resolution: {integrity: sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==}
    engines: {node: '>=8'}

  path-parse@1.0.7:
    resolution: {integrity: sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==}

  path-to-regexp@8.2.0:
    resolution: {integrity: sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==}
    engines: {node: '>=16'}

  path@0.12.7:
    resolution: {integrity: sha512-aXXC6s+1w7otVF9UletFkFcDsJeO7lSZBPUQhtb5O0xJe8LtYhj/GxldoL09bBj9+ZmE2hNoHqQSFMN5fikh4Q==}

  pdfkit@0.14.0:
    resolution: {integrity: sha512-Hnor8/78jhHm6ONrxWhrqOwAVALlBnFyWOF8sstBZMiqHZgZ5A6RU+Q3yahhw82plxpT7LOfH3b3qcOX6rzMQg==}

  picomatch@2.3.1:
    resolution: {integrity: sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==}
    engines: {node: '>=8.6'}

  pidtree@0.6.0:
    resolution: {integrity: sha512-eG2dWTVw5bzqGRztnHExczNxt5VGsE6OwTeCG3fdUf9KBsZzO3R5OIIIzWR+iZA0NtZ+RDVdaoE2dK1cn6jH4g==}
    engines: {node: '>=0.10'}
    hasBin: true

  pkce-challenge@5.0.0:
    resolution: {integrity: sha512-ueGLflrrnvwB3xuo/uGob5pd5FN7l0MsLf0Z87o/UQmRtwjvfylfc9MurIxRAWywCYTgrvpXBcqjV4OfCYGCIQ==}
    engines: {node: '>=16.20.0'}

  png-js@1.0.0:
    resolution: {integrity: sha512-k+YsbhpA9e+EFfKjTCH3VW6aoKlyNYI6NYdTfDL4CIvFnvsuO84ttonmZE7rc+v23SLTH8XX+5w/Ak9v0xGY4g==}

  possible-typed-array-names@1.1.0:
    resolution: {integrity: sha512-/+5VFTchJDoVj3bhoqi6UeymcD00DAwb1nJwamzPvHEszJ4FpF6SNNbUbOS8yI56qHzdV8eK0qEfOSiodkTdxg==}
    engines: {node: '>= 0.4'}

  prelude-ls@1.2.1:
    resolution: {integrity: sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==}
    engines: {node: '>= 0.8.0'}

  prettier@3.5.3:
    resolution: {integrity: sha512-QQtaxnoDJeAkDvDKWCLiwIXkTgRhwYDEQCghU9Z6q03iyek/rxRh/2lC3HB7P8sWT2xC/y5JDctPLBIGzHKbhw==}
    engines: {node: '>=14'}
    hasBin: true

  process-nextick-args@2.0.1:
    resolution: {integrity: sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag==}

  process@0.11.10:
    resolution: {integrity: sha512-cdGef/drWFoydD1JsMzuFf8100nZl+GT+yacc2bEced5f9Rjk4z+WtFUTBu9PhOi9j/jfmBPu0mMEY4wIdAF8A==}
    engines: {node: '>= 0.6.0'}

  proxy-addr@2.0.7:
    resolution: {integrity: sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==}
    engines: {node: '>= 0.10'}

  proxy-from-env@1.1.0:
    resolution: {integrity: sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==}

  punycode@1.3.2:
    resolution: {integrity: sha512-RofWgt/7fL5wP1Y7fxE7/EmTLzQVnB0ycyibJ0OOHIlJqTNzglYFxVwETOcIoJqJmpDXJ9xImDv+Fq34F/d4Dw==}

  punycode@2.3.1:
    resolution: {integrity: sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==}
    engines: {node: '>=6'}

  qs@6.14.0:
    resolution: {integrity: sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==}
    engines: {node: '>=0.6'}

  querystring@0.2.0:
    resolution: {integrity: sha512-X/xY82scca2tau62i9mDyU9K+I+djTMUsvwf7xnUX5GLvVzgJybOJf4Y6o9Zx3oJK/LSXg5tTZBjwzqVPaPO2g==}
    engines: {node: '>=0.4.x'}
    deprecated: The querystring API is considered Legacy. new code should use the URLSearchParams API instead.

  range-parser@1.2.1:
    resolution: {integrity: sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==}
    engines: {node: '>= 0.6'}

  raw-body@3.0.0:
    resolution: {integrity: sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==}
    engines: {node: '>= 0.8'}

  readable-stream@2.3.8:
    resolution: {integrity: sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==}

  readable-stream@3.6.2:
    resolution: {integrity: sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==}
    engines: {node: '>= 6'}

  readdirp@3.6.0:
    resolution: {integrity: sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==}
    engines: {node: '>=8.10.0'}

  reflect-metadata@0.2.2:
    resolution: {integrity: sha512-urBwgfrvVP/eAyXx4hluJivBKzuEbSQs9rKWCrCkbSxNv8mxPcUZKeuoF3Uy4mJl3Lwprp6yy5/39VWigZ4K6Q==}

  reflect.getprototypeof@1.0.10:
    resolution: {integrity: sha512-00o4I+DVrefhv+nX0ulyi3biSHCPDe+yLv5o/p6d/UVlirijB8E16FtfwSAi4g3tcqrQ4lRAqQSoFEZJehYEcw==}
    engines: {node: '>= 0.4'}

  regexp.prototype.flags@1.5.4:
    resolution: {integrity: sha512-dYqgNSZbDwkaJ2ceRd9ojCGjBq+mOm9LmtXnAnEGyHhN/5R7iDW2TRw3h+o/jCFxus3P2LfWIIiwowAjANm7IA==}
    engines: {node: '>= 0.4'}

  resolve-from@4.0.0:
    resolution: {integrity: sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==}
    engines: {node: '>=4'}

  resolve@1.22.10:
    resolution: {integrity: sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==}
    engines: {node: '>= 0.4'}
    hasBin: true

  restore-cursor@5.1.0:
    resolution: {integrity: sha512-oMA2dcrw6u0YfxJQXm342bFKX/E4sG9rbTzO9ptUcR/e8A33cHuvStiYOwH7fszkZlZ1z/ta9AAoPk2F4qIOHA==}
    engines: {node: '>=18'}

  restructure@2.0.1:
    resolution: {integrity: sha512-e0dOpjm5DseomnXx2M5lpdZ5zoHqF1+bqdMJUohoYVVQa7cBdnk7fdmeI6byNWP/kiME72EeTiSypTCVnpLiDg==}

  rfdc@1.4.1:
    resolution: {integrity: sha512-q1b3N5QkRUWUl7iyylaaj3kOpIT0N2i9MqIEQXP73GVsN9cw3fdx8X63cEmWhJGi2PPCF23Ijp7ktmd39rawIA==}

  rimraf@2.7.1:
    resolution: {integrity: sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==}
    deprecated: Rimraf versions prior to v4 are no longer supported
    hasBin: true

  router@2.2.0:
    resolution: {integrity: sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==}
    engines: {node: '>= 18'}

  safe-array-concat@1.1.3:
    resolution: {integrity: sha512-AURm5f0jYEOydBj7VQlVvDrjeFgthDdEF5H1dP+6mNpoXOMo1quQqJ4wvJDyRZ9+pO3kGWoOdmV08cSv2aJV6Q==}
    engines: {node: '>=0.4'}

  safe-buffer@5.1.2:
    resolution: {integrity: sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==}

  safe-buffer@5.2.1:
    resolution: {integrity: sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==}

  safe-push-apply@1.0.0:
    resolution: {integrity: sha512-iKE9w/Z7xCzUMIZqdBsp6pEQvwuEebH4vdpjcDWnyzaI6yl6O9FHvVpmGelvEHNsoY6wGblkxR6Zty/h00WiSA==}
    engines: {node: '>= 0.4'}

  safe-regex-test@1.1.0:
    resolution: {integrity: sha512-x/+Cz4YrimQxQccJf5mKEbIa1NzeCRNI5Ecl/ekmlYaampdNLPalVyIcCZNNH3MvmqBugV5TMYZXv0ljslUlaw==}
    engines: {node: '>= 0.4'}

  safe-stable-stringify@2.5.0:
    resolution: {integrity: sha512-b3rppTKm9T+PsVCBEOUR46GWI7fdOs00VKZ1+9c1EWDaDMvjQc6tUwuFyIprgGgTcWoVHSKrU8H31ZHA2e0RHA==}
    engines: {node: '>=10'}

  safer-buffer@2.1.2:
    resolution: {integrity: sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==}

  sax@1.2.1:
    resolution: {integrity: sha512-8I2a3LovHTOpm7NV5yOyO8IHqgVsfK4+UuySrXU8YXkSRX7k6hCV9b3HrkKCr3nMpgj+0bmocaJJWpvp1oc7ZA==}

  semver@6.3.1:
    resolution: {integrity: sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==}
    hasBin: true

  semver@7.7.2:
    resolution: {integrity: sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==}
    engines: {node: '>=10'}
    hasBin: true

  send@1.2.0:
    resolution: {integrity: sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==}
    engines: {node: '>= 18'}

  serve-static@2.2.0:
    resolution: {integrity: sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==}
    engines: {node: '>= 18'}

  set-function-length@1.2.2:
    resolution: {integrity: sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==}
    engines: {node: '>= 0.4'}

  set-function-name@2.0.2:
    resolution: {integrity: sha512-7PGFlmtwsEADb0WYyvCMa1t+yke6daIG4Wirafur5kcf+MhUnPms1UeR0CKQdTZD81yESwMHbtn+TR+dMviakQ==}
    engines: {node: '>= 0.4'}

  set-proto@1.0.0:
    resolution: {integrity: sha512-RJRdvCo6IAnPdsvP/7m6bsQqNnn1FCBX5ZNtFL98MmFF/4xAIJTIg1YbHW5DC2W5SKZanrC6i4HsJqlajw/dZw==}
    engines: {node: '>= 0.4'}

  setprototypeof@1.2.0:
    resolution: {integrity: sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==}

  shebang-command@2.0.0:
    resolution: {integrity: sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==}
    engines: {node: '>=8'}

  shebang-regex@3.0.0:
    resolution: {integrity: sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==}
    engines: {node: '>=8'}

  side-channel-list@1.0.0:
    resolution: {integrity: sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==}
    engines: {node: '>= 0.4'}

  side-channel-map@1.0.1:
    resolution: {integrity: sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==}
    engines: {node: '>= 0.4'}

  side-channel-weakmap@1.0.2:
    resolution: {integrity: sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==}
    engines: {node: '>= 0.4'}

  side-channel@1.1.0:
    resolution: {integrity: sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==}
    engines: {node: '>= 0.4'}

  sift@17.1.3:
    resolution: {integrity: sha512-Rtlj66/b0ICeFzYTuNvX/EF1igRbbnGSvEyT79McoZa/DeGhMyC5pWKOEsZKnpkqtSeovd5FL/bjHWC3CIIvCQ==}

  signal-exit@4.1.0:
    resolution: {integrity: sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==}
    engines: {node: '>=14'}

  simple-swizzle@0.2.2:
    resolution: {integrity: sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==}

  slice-ansi@5.0.0:
    resolution: {integrity: sha512-FC+lgizVPfie0kkhqUScwRu1O/lF6NOgJmlCgK+/LYxDCTk8sGelYaHDhFcDN+Sn3Cv+3VSa4Byeo+IMCzpMgQ==}
    engines: {node: '>=12'}

  slice-ansi@7.1.0:
    resolution: {integrity: sha512-bSiSngZ/jWeX93BqeIAbImyTbEihizcwNjFoRUIY/T1wWQsfsm2Vw1agPKylXvQTU7iASGdHhyqRlqQzfz+Htg==}
    engines: {node: '>=18'}

  source-map-support@0.5.21:
    resolution: {integrity: sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==}

  source-map@0.6.1:
    resolution: {integrity: sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==}
    engines: {node: '>=0.10.0'}

  sparse-bitfield@3.0.3:
    resolution: {integrity: sha512-kvzhi7vqKTfkh0PZU+2D2PIllw2ymqJKujUcyPMd9Y75Nv4nPbGJZXNhxsgdQab2BmlDct1YnfQCguEvHr7VsQ==}

  sprintf-js@1.0.3:
    resolution: {integrity: sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==}

  stack-trace@0.0.10:
    resolution: {integrity: sha512-KGzahc7puUKkzyMt+IqAep+TVNbKP+k2Lmwhub39m1AsTSkaDutx56aDCo+HLDzf/D26BIHTJWNiTG1KAJiQCg==}

  statuses@2.0.1:
    resolution: {integrity: sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==}
    engines: {node: '>= 0.8'}

  stop-iteration-iterator@1.1.0:
    resolution: {integrity: sha512-eLoXW/DHyl62zxY4SCaIgnRhuMr6ri4juEYARS8E6sCEqzKpOiE521Ucofdx+KnDZl5xmvGYaaKCk5FEOxJCoQ==}
    engines: {node: '>= 0.4'}

  streamsearch@1.1.0:
    resolution: {integrity: sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==}
    engines: {node: '>=10.0.0'}

  string-argv@0.3.2:
    resolution: {integrity: sha512-aqD2Q0144Z+/RqG52NeHEkZauTAUWJO8c6yTftGJKO3Tja5tUgIfmIl6kExvhtxSDP7fXB6DvzkfMpCd/F3G+Q==}
    engines: {node: '>=0.6.19'}

  string-width@7.2.0:
    resolution: {integrity: sha512-tsaTIkKW9b4N+AEj+SVA+WhJzV7/zMhcSu78mLKWSk7cXMOSHsBKFWUs0fWwq8QyK3MgJBQRX6Gbi4kYbdvGkQ==}
    engines: {node: '>=18'}

  string.prototype.trim@1.2.10:
    resolution: {integrity: sha512-Rs66F0P/1kedk5lyYyH9uBzuiI/kNRmwJAR9quK6VOtIpZ2G+hMZd+HQbbv25MgCA6gEffoMZYxlTod4WcdrKA==}
    engines: {node: '>= 0.4'}

  string.prototype.trimend@1.0.9:
    resolution: {integrity: sha512-G7Ok5C6E/j4SGfyLCloXTrngQIQU3PWtXGst3yM7Bea9FRURf1S42ZHlZZtsNque2FN2PoUhfZXYLNWwEr4dLQ==}
    engines: {node: '>= 0.4'}

  string.prototype.trimstart@1.0.8:
    resolution: {integrity: sha512-UXSH262CSZY1tfu3G3Secr6uGLCFVPMhIqHjlgCUtCCcgihYc/xKs9djMTMUOb2j1mVSeU8EU6NWc/iQKU6Gfg==}
    engines: {node: '>= 0.4'}

  string_decoder@1.1.1:
    resolution: {integrity: sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==}

  string_decoder@1.3.0:
    resolution: {integrity: sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==}

  strip-ansi@7.1.0:
    resolution: {integrity: sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==}
    engines: {node: '>=12'}

  strip-bom@3.0.0:
    resolution: {integrity: sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==}
    engines: {node: '>=4'}

  strip-json-comments@2.0.1:
    resolution: {integrity: sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==}
    engines: {node: '>=0.10.0'}

  strip-json-comments@3.1.1:
    resolution: {integrity: sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==}
    engines: {node: '>=8'}

  strnum@1.1.2:
    resolution: {integrity: sha512-vrN+B7DBIoTTZjnPNewwhx6cBA/H+IS7rfW68n7XxC1y7uoiGQBxaKzqucGUgavX15dJgiGztLJ8vxuEzwqBdA==}

  supports-color@7.2.0:
    resolution: {integrity: sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==}
    engines: {node: '>=8'}

  supports-preserve-symlinks-flag@1.0.0:
    resolution: {integrity: sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==}
    engines: {node: '>= 0.4'}

  swagger-jsdoc@6.2.8:
    resolution: {integrity: sha512-VPvil1+JRpmJ55CgAtn8DIcpBs0bL5L3q5bVQvF4tAW/k/9JYSj7dCpaYCAv5rufe0vcCbBRQXGvzpkWjvLklQ==}
    engines: {node: '>=12.0.0'}
    hasBin: true

  swagger-parser@10.0.3:
    resolution: {integrity: sha512-nF7oMeL4KypldrQhac8RyHerJeGPD1p2xDh900GPvc+Nk7nWP6jX2FcC7WmkinMoAmoO774+AFXcWsW8gMWEIg==}
    engines: {node: '>=10'}

  swagger-ui-dist@5.21.0:
    resolution: {integrity: sha512-E0K3AB6HvQd8yQNSMR7eE5bk+323AUxjtCz/4ZNKiahOlPhPJxqn3UPIGs00cyY/dhrTDJ61L7C/a8u6zhGrZg==}

  swagger-ui-express@5.0.1:
    resolution: {integrity: sha512-SrNU3RiBGTLLmFU8GIJdOdanJTl4TOmT27tt3bWWHppqYmAZ6IDuEuBvMU6nZq0zLEe6b/1rACXCgLZqO6ZfrA==}
    engines: {node: '>= v0.10.32'}
    peerDependencies:
      express: '>=4.0.0 || >=5.0.0-beta'

  text-hex@1.0.0:
    resolution: {integrity: sha512-uuVGNWzgJ4yhRaNSiubPY7OjISw4sw4E5Uv0wbjp+OzcbmVU/rsT8ujgcXJhn9ypzsgr5vlzpPqP+MBBKcGvbg==}

  tiny-inflate@1.0.3:
    resolution: {integrity: sha512-pkY1fj1cKHb2seWDy0B16HeWyczlJA9/WW3u3c4z/NiWDsO3DOU5D7nhTLE9CF0yXv/QZFY7sEJmj24dK+Rrqw==}

  to-regex-range@5.0.1:
    resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
    engines: {node: '>=8.0'}

  toidentifier@1.0.1:
    resolution: {integrity: sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==}
    engines: {node: '>=0.6'}

  tr46@0.0.3:
    resolution: {integrity: sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==}

  tr46@5.1.1:
    resolution: {integrity: sha512-hdF5ZgjTqgAntKkklYw0R03MG2x/bSzTtkxmIRw/sTNV8YXsCJ1tfLAX23lhxhHJlEf3CRCOCGGWw3vI3GaSPw==}
    engines: {node: '>=18'}

  tree-kill@1.2.2:
    resolution: {integrity: sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==}
    hasBin: true

  triple-beam@1.4.1:
    resolution: {integrity: sha512-aZbgViZrg1QNcG+LULa7nhZpJTZSLm/mXnHXnbAbjmN5aSa0y7V+wvv6+4WaBtpISJzThKy+PIPxc1Nq1EJ9mg==}
    engines: {node: '>= 14.0.0'}

  ts-node-dev@2.0.0:
    resolution: {integrity: sha512-ywMrhCfH6M75yftYvrvNarLEY+SUXtUvU8/0Z6llrHQVBx12GiFk5sStF8UdfE/yfzk9IAq7O5EEbTQsxlBI8w==}
    engines: {node: '>=0.8.0'}
    hasBin: true
    peerDependencies:
      node-notifier: '*'
      typescript: '*'
    peerDependenciesMeta:
      node-notifier:
        optional: true

  ts-node@10.9.2:
    resolution: {integrity: sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==}
    hasBin: true
    peerDependencies:
      '@swc/core': '>=1.2.50'
      '@swc/wasm': '>=1.2.50'
      '@types/node': '*'
      typescript: '>=2.7'
    peerDependenciesMeta:
      '@swc/core':
        optional: true
      '@swc/wasm':
        optional: true

  tsconfig-paths@3.15.0:
    resolution: {integrity: sha512-2Ac2RgzDe/cn48GvOe3M+o82pEFewD3UPbyoUHHdKasHwJKjds4fLXWf/Ux5kATBKN20oaFGu+jbElp1pos0mg==}

  tsconfig@7.0.0:
    resolution: {integrity: sha512-vZXmzPrL+EmC4T/4rVlT2jNVMWCi/O4DIiSj3UHg1OE5kCKbk4mfrXc6dZksLgRM/TZlKnousKH9bbTazUWRRw==}

  tslib@2.6.2:
    resolution: {integrity: sha512-AEYxH93jGFPn/a2iVAwW87VuUIkR1FVUKB77NwMF7nBTDkDrrT/Hpt/IrCJ0QXhW27jTBDcf5ZY7w6RiqTMw2Q==}

  type-check@0.4.0:
    resolution: {integrity: sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==}
    engines: {node: '>= 0.8.0'}

  type-is@1.6.18:
    resolution: {integrity: sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==}
    engines: {node: '>= 0.6'}

  type-is@2.0.1:
    resolution: {integrity: sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==}
    engines: {node: '>= 0.6'}

  typed-array-buffer@1.0.3:
    resolution: {integrity: sha512-nAYYwfY3qnzX30IkA6AQZjVbtK6duGontcQm1WSG1MD94YLqK0515GNApXkoxKOWMusVssAHWLh9SeaoefYFGw==}
    engines: {node: '>= 0.4'}

  typed-array-byte-length@1.0.3:
    resolution: {integrity: sha512-BaXgOuIxz8n8pIq3e7Atg/7s+DpiYrxn4vdot3w9KbnBhcRQq6o3xemQdIfynqSeXeDrF32x+WvfzmOjPiY9lg==}
    engines: {node: '>= 0.4'}

  typed-array-byte-offset@1.0.4:
    resolution: {integrity: sha512-bTlAFB/FBYMcuX81gbL4OcpH5PmlFHqlCCpAl8AlEzMz5k53oNDvN8p1PNOWLEmI2x4orp3raOFB51tv9X+MFQ==}
    engines: {node: '>= 0.4'}

  typed-array-length@1.0.7:
    resolution: {integrity: sha512-3KS2b+kL7fsuk/eJZ7EQdnEmQoaho/r6KUef7hxvltNA5DR8NAUM+8wJMbJyZ4G9/7i3v5zPBIMN5aybAh2/Jg==}
    engines: {node: '>= 0.4'}

  typedarray@0.0.6:
    resolution: {integrity: sha512-/aCDEGatGvZ2BIk+HmLf4ifCJFwvKFNb9/JeZPMulfgFracn9QFcAf5GO8B/mweUjSoblS5In0cWhqpfs/5PQA==}

  typescript@5.8.3:
    resolution: {integrity: sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  unbox-primitive@1.1.0:
    resolution: {integrity: sha512-nWJ91DjeOkej/TA8pXQ3myruKpKEYgqvpw9lz4OPHj/NWFNluYrjbz9j01CJ8yKQd2g4jFoOkINCTW2I5LEEyw==}
    engines: {node: '>= 0.4'}

  undici-types@6.21.0:
    resolution: {integrity: sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==}

  unicode-properties@1.4.1:
    resolution: {integrity: sha512-CLjCCLQ6UuMxWnbIylkisbRj31qxHPAurvena/0iwSVbQ2G1VY5/HjV0IRabOEbDHlzZlRdCrD4NhB0JtU40Pg==}

  unicode-trie@2.0.0:
    resolution: {integrity: sha512-x7bc76x0bm4prf1VLg79uhAzKw8DVboClSN5VxJuQ+LKDOVEW9CdH+VY7SP+vX7xCYQqzzgQpFqz15zeLvAtZQ==}

  unpipe@1.0.0:
    resolution: {integrity: sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==}
    engines: {node: '>= 0.8'}

  uri-js@4.4.1:
    resolution: {integrity: sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==}

  url@0.10.3:
    resolution: {integrity: sha512-hzSUW2q06EqL1gKM/a+obYHLIO6ct2hwPuviqTTOcfFVc61UbfJ2Q32+uGL/HCPxKqrdGB5QUwIe7UqlDgwsOQ==}

  util-deprecate@1.0.2:
    resolution: {integrity: sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==}

  util@0.10.4:
    resolution: {integrity: sha512-0Pm9hTQ3se5ll1XihRic3FDIku70C+iHUdT/W926rSgHV5QgXsYbKZN8MSC3tJtSkhuROzvsQjAaFENRXr+19A==}

  util@0.12.5:
    resolution: {integrity: sha512-kZf/K6hEIrWHI6XqOFUiiMa+79wE/D8Q+NCNAWclkyg3b4d2k7s0QGepNjiABc+aR3N1PAyHL7p6UcLY6LmrnA==}

  uuid@11.1.0:
    resolution: {integrity: sha512-0/A9rDy9P7cJ+8w1c9WD9V//9Wj15Ce2MPz8Ri6032usz+NfePxx5AcN3bN+r6ZL6jEo066/yNYB3tn4pQEx+A==}
    hasBin: true

  uuid@8.0.0:
    resolution: {integrity: sha512-jOXGuXZAWdsTH7eZLtyXMqUb9EcWMGZNbL9YcGBJl4MH4nrxHmZJhEHvyLFrkxo+28uLb/NYRcStH48fnD0Vzw==}
    hasBin: true

  uuid@9.0.1:
    resolution: {integrity: sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==}
    hasBin: true

  v8-compile-cache-lib@3.0.1:
    resolution: {integrity: sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==}

  validator@13.15.0:
    resolution: {integrity: sha512-36B2ryl4+oL5QxZ3AzD0t5SsMNGvTtQHpjgFO5tbNxfXbMFkY822ktCDe1MnlqV3301QQI9SLHDNJokDI+Z9pA==}
    engines: {node: '>= 0.10'}

  vary@1.1.2:
    resolution: {integrity: sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==}
    engines: {node: '>= 0.8'}

  webidl-conversions@3.0.1:
    resolution: {integrity: sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==}

  webidl-conversions@7.0.0:
    resolution: {integrity: sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==}
    engines: {node: '>=12'}

  whatwg-url@14.2.0:
    resolution: {integrity: sha512-De72GdQZzNTUBBChsXueQUnPKDkg/5A5zp7pFDuQAj5UFoENpiACU0wlCvzpAGnTkj++ihpKwKyYewn/XNUbKw==}
    engines: {node: '>=18'}

  whatwg-url@5.0.0:
    resolution: {integrity: sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==}

  which-boxed-primitive@1.1.1:
    resolution: {integrity: sha512-TbX3mj8n0odCBFVlY8AxkqcHASw3L60jIuF8jFP78az3C2YhmGvqbHBpAjTRH2/xqYunrJ9g1jSyjCjpoWzIAA==}
    engines: {node: '>= 0.4'}

  which-builtin-type@1.2.1:
    resolution: {integrity: sha512-6iBczoX+kDQ7a3+YJBnh3T+KZRxM/iYNPXicqk66/Qfm1b93iu+yOImkg0zHbj5LNOcNv1TEADiZ0xa34B4q6Q==}
    engines: {node: '>= 0.4'}

  which-collection@1.0.2:
    resolution: {integrity: sha512-K4jVyjnBdgvc86Y6BkaLZEN933SwYOuBFkdmBu9ZfkcAbdVbpITnDmjvZ/aQjRXQrv5EPkTnD1s39GiiqbngCw==}
    engines: {node: '>= 0.4'}

  which-typed-array@1.1.19:
    resolution: {integrity: sha512-rEvr90Bck4WZt9HHFC4DJMsjvu7x+r6bImz0/BrbWb7A2djJ8hnZMrWnHo9F8ssv0OMErasDhftrfROTyqSDrw==}
    engines: {node: '>= 0.4'}

  which@2.0.2:
    resolution: {integrity: sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==}
    engines: {node: '>= 8'}
    hasBin: true

  winston-transport@4.9.0:
    resolution: {integrity: sha512-8drMJ4rkgaPo1Me4zD/3WLfI/zPdA9o2IipKODunnGDcuqbHwjsbB79ylv04LCGGzU0xQ6vTznOMpQGaLhhm6A==}
    engines: {node: '>= 12.0.0'}

  winston@3.17.0:
    resolution: {integrity: sha512-DLiFIXYC5fMPxaRg832S6F5mJYvePtmO5G9v9IgUFPhXm9/GkXarH/TUrBAVzhTCzAj9anE/+GjrgXp/54nOgw==}
    engines: {node: '>= 12.0.0'}

  word-wrap@1.2.5:
    resolution: {integrity: sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==}
    engines: {node: '>=0.10.0'}

  wrap-ansi@9.0.0:
    resolution: {integrity: sha512-G8ura3S+3Z2G+mkgNRq8dqaFZAuxfsxpBB8OCTGRTCtp+l/v9nbFNmCUP1BZMts3G1142MsZfn6eeUKrr4PD1Q==}
    engines: {node: '>=18'}

  wrappy@1.0.2:
    resolution: {integrity: sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==}

  xml2js@0.6.2:
    resolution: {integrity: sha512-T4rieHaC1EXcES0Kxxj4JWgaUQHDk+qwHcYOCFHfiwKz7tOVPLq7Hjq9dM1WCMhylqMEfP7hMcOIChvotiZegA==}
    engines: {node: '>=4.0.0'}

  xmlbuilder@11.0.1:
    resolution: {integrity: sha512-fDlsI/kFEx7gLvbecc0/ohLG50fugQp8ryHzMTuW9vSa1GJ0XYWKnhsUx7oie3G98+r56aTQIUB4kht42R3JvA==}
    engines: {node: '>=4.0'}

  xtend@4.0.2:
    resolution: {integrity: sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ==}
    engines: {node: '>=0.4'}

  yaml@2.0.0-1:
    resolution: {integrity: sha512-W7h5dEhywMKenDJh2iX/LABkbFnBxasD27oyXWDS/feDsxiw0dD5ncXdYXgkvAsXIY2MpW/ZKkr9IU30DBdMNQ==}
    engines: {node: '>= 6'}

  yaml@2.7.1:
    resolution: {integrity: sha512-10ULxpnOCQXxJvBgxsn9ptjq6uviG/htZKk9veJGhlqn3w/DxQ631zFF+nlQXLwmImeS5amR2dl2U8sg6U9jsQ==}
    engines: {node: '>= 14'}
    hasBin: true

  yamljs@0.3.0:
    resolution: {integrity: sha512-C/FsVVhht4iPQYXOInoxUM/1ELSf9EsgKH34FofQOp6hwCPrW4vG4w5++TED3xRUo8gD7l0P1J1dLlDYzODsTQ==}
    hasBin: true

  yn@3.1.1:
    resolution: {integrity: sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==}
    engines: {node: '>=6'}

  yocto-queue@0.1.0:
    resolution: {integrity: sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==}
    engines: {node: '>=10'}

  z-schema@5.0.5:
    resolution: {integrity: sha512-D7eujBWkLa3p2sIpJA0d1pr7es+a7m0vFAnZLlCEKq/Ij2k0MLi9Br2UPxoxdYystm5K1yeBGzub0FlYUEWj2Q==}
    engines: {node: '>=8.0.0'}
    hasBin: true

  zod-to-json-schema@3.24.5:
    resolution: {integrity: sha512-/AuWwMP+YqiPbsJx5D6TfgRTc4kTLjsh5SOcd4bLsfUg2RcEXrFMJl1DGgdHy2aCfsIA/cr/1JM0xcB2GZji8g==}
    peerDependencies:
      zod: ^3.24.1

  zod@3.24.4:
    resolution: {integrity: sha512-OdqJE9UDRPwWsrHjLN2F8bPxvwJBK22EHLWtanu0LSYr5YqzsaaW3RMgmjwr8Rypg5k+meEJdSPXJZXE/yqOMg==}

snapshots:

  '@apidevtools/json-schema-ref-parser@9.1.2':
    dependencies:
      '@jsdevtools/ono': 7.1.3
      '@types/json-schema': 7.0.15
      call-me-maybe: 1.0.2
      js-yaml: 4.1.0

  '@apidevtools/openapi-schemas@2.1.0': {}

  '@apidevtools/swagger-methods@3.0.2': {}

  '@apidevtools/swagger-parser@10.0.3(openapi-types@12.1.3)':
    dependencies:
      '@apidevtools/json-schema-ref-parser': 9.1.2
      '@apidevtools/openapi-schemas': 2.1.0
      '@apidevtools/swagger-methods': 3.0.2
      '@jsdevtools/ono': 7.1.3
      call-me-maybe: 1.0.2
      openapi-types: 12.1.3
      z-schema: 5.0.5

  '@aws-crypto/crc32@5.2.0':
    dependencies:
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      tslib: 2.6.2

  '@aws-crypto/crc32c@5.2.0':
    dependencies:
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      tslib: 2.6.2

  '@aws-crypto/sha1-browser@5.2.0':
    dependencies:
      '@aws-crypto/supports-web-crypto': 5.2.0
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-locate-window': 3.804.0
      '@smithy/util-utf8': 2.3.0
      tslib: 2.6.2

  '@aws-crypto/sha256-browser@5.2.0':
    dependencies:
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-crypto/supports-web-crypto': 5.2.0
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-locate-window': 3.804.0
      '@smithy/util-utf8': 2.3.0
      tslib: 2.6.2

  '@aws-crypto/sha256-js@5.2.0':
    dependencies:
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      tslib: 2.6.2

  '@aws-crypto/supports-web-crypto@5.2.0':
    dependencies:
      tslib: 2.6.2

  '@aws-crypto/util@5.2.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/util-utf8': 2.3.0
      tslib: 2.6.2

  '@aws-sdk/client-s3@3.821.0':
    dependencies:
      '@aws-crypto/sha1-browser': 5.2.0
      '@aws-crypto/sha256-browser': 5.2.0
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/credential-provider-node': 3.821.0
      '@aws-sdk/middleware-bucket-endpoint': 3.821.0
      '@aws-sdk/middleware-expect-continue': 3.821.0
      '@aws-sdk/middleware-flexible-checksums': 3.821.0
      '@aws-sdk/middleware-host-header': 3.821.0
      '@aws-sdk/middleware-location-constraint': 3.821.0
      '@aws-sdk/middleware-logger': 3.821.0
      '@aws-sdk/middleware-recursion-detection': 3.821.0
      '@aws-sdk/middleware-sdk-s3': 3.821.0
      '@aws-sdk/middleware-ssec': 3.821.0
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/region-config-resolver': 3.821.0
      '@aws-sdk/signature-v4-multi-region': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@aws-sdk/util-user-agent-browser': 3.821.0
      '@aws-sdk/util-user-agent-node': 3.821.0
      '@aws-sdk/xml-builder': 3.821.0
      '@smithy/config-resolver': 4.1.4
      '@smithy/core': 3.5.1
      '@smithy/eventstream-serde-browser': 4.0.4
      '@smithy/eventstream-serde-config-resolver': 4.1.2
      '@smithy/eventstream-serde-node': 4.0.4
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/hash-blob-browser': 4.0.4
      '@smithy/hash-node': 4.0.4
      '@smithy/hash-stream-node': 4.0.4
      '@smithy/invalid-dependency': 4.0.4
      '@smithy/md5-js': 4.0.4
      '@smithy/middleware-content-length': 4.0.4
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-retry': 4.1.10
      '@smithy/middleware-serde': 4.0.8
      '@smithy/middleware-stack': 4.0.4
      '@smithy/node-config-provider': 4.1.3
      '@smithy/node-http-handler': 4.0.6
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-body-length-node': 4.0.0
      '@smithy/util-defaults-mode-browser': 4.0.17
      '@smithy/util-defaults-mode-node': 4.0.17
      '@smithy/util-endpoints': 3.0.6
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      '@smithy/util-waiter': 4.0.5
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/client-sso@3.821.0':
    dependencies:
      '@aws-crypto/sha256-browser': 5.2.0
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/middleware-host-header': 3.821.0
      '@aws-sdk/middleware-logger': 3.821.0
      '@aws-sdk/middleware-recursion-detection': 3.821.0
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/region-config-resolver': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@aws-sdk/util-user-agent-browser': 3.821.0
      '@aws-sdk/util-user-agent-node': 3.821.0
      '@smithy/config-resolver': 4.1.4
      '@smithy/core': 3.5.1
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/hash-node': 4.0.4
      '@smithy/invalid-dependency': 4.0.4
      '@smithy/middleware-content-length': 4.0.4
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-retry': 4.1.10
      '@smithy/middleware-serde': 4.0.8
      '@smithy/middleware-stack': 4.0.4
      '@smithy/node-config-provider': 4.1.3
      '@smithy/node-http-handler': 4.0.6
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-body-length-node': 4.0.0
      '@smithy/util-defaults-mode-browser': 4.0.17
      '@smithy/util-defaults-mode-node': 4.0.17
      '@smithy/util-endpoints': 3.0.6
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/core@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/core': 3.5.1
      '@smithy/node-config-provider': 4.1.3
      '@smithy/property-provider': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/signature-v4': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-middleware': 4.0.4
      fast-xml-parser: 4.4.1
      tslib: 2.6.2

  '@aws-sdk/credential-provider-env@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/credential-provider-http@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/node-http-handler': 4.0.6
      '@smithy/property-provider': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-stream': 4.2.2
      tslib: 2.6.2

  '@aws-sdk/credential-provider-ini@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/credential-provider-env': 3.821.0
      '@aws-sdk/credential-provider-http': 3.821.0
      '@aws-sdk/credential-provider-process': 3.821.0
      '@aws-sdk/credential-provider-sso': 3.821.0
      '@aws-sdk/credential-provider-web-identity': 3.821.0
      '@aws-sdk/nested-clients': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/credential-provider-imds': 4.0.6
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/credential-provider-node@3.821.0':
    dependencies:
      '@aws-sdk/credential-provider-env': 3.821.0
      '@aws-sdk/credential-provider-http': 3.821.0
      '@aws-sdk/credential-provider-ini': 3.821.0
      '@aws-sdk/credential-provider-process': 3.821.0
      '@aws-sdk/credential-provider-sso': 3.821.0
      '@aws-sdk/credential-provider-web-identity': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/credential-provider-imds': 4.0.6
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/credential-provider-process@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/credential-provider-sso@3.821.0':
    dependencies:
      '@aws-sdk/client-sso': 3.821.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/token-providers': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/credential-provider-web-identity@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/nested-clients': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/middleware-bucket-endpoint@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-arn-parser': 3.804.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      tslib: 2.6.2

  '@aws-sdk/middleware-expect-continue@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-flexible-checksums@3.821.0':
    dependencies:
      '@aws-crypto/crc32': 5.2.0
      '@aws-crypto/crc32c': 5.2.0
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/is-array-buffer': 4.0.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@aws-sdk/middleware-host-header@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-location-constraint@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-logger@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-recursion-detection@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-sdk-s3@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-arn-parser': 3.804.0
      '@smithy/core': 3.5.1
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/signature-v4': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@aws-sdk/middleware-ssec@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-user-agent@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@smithy/core': 3.5.1
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/nested-clients@3.821.0':
    dependencies:
      '@aws-crypto/sha256-browser': 5.2.0
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/middleware-host-header': 3.821.0
      '@aws-sdk/middleware-logger': 3.821.0
      '@aws-sdk/middleware-recursion-detection': 3.821.0
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/region-config-resolver': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@aws-sdk/util-user-agent-browser': 3.821.0
      '@aws-sdk/util-user-agent-node': 3.821.0
      '@smithy/config-resolver': 4.1.4
      '@smithy/core': 3.5.1
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/hash-node': 4.0.4
      '@smithy/invalid-dependency': 4.0.4
      '@smithy/middleware-content-length': 4.0.4
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-retry': 4.1.10
      '@smithy/middleware-serde': 4.0.8
      '@smithy/middleware-stack': 4.0.4
      '@smithy/node-config-provider': 4.1.3
      '@smithy/node-http-handler': 4.0.6
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-body-length-node': 4.0.0
      '@smithy/util-defaults-mode-browser': 4.0.17
      '@smithy/util-defaults-mode-node': 4.0.17
      '@smithy/util-endpoints': 3.0.6
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/region-config-resolver@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      '@smithy/util-middleware': 4.0.4
      tslib: 2.6.2

  '@aws-sdk/s3-request-presigner@3.821.0':
    dependencies:
      '@aws-sdk/signature-v4-multi-region': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-format-url': 3.821.0
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/signature-v4-multi-region@3.821.0':
    dependencies:
      '@aws-sdk/middleware-sdk-s3': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/signature-v4': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/token-providers@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/nested-clients': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/types@3.821.0':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/util-arn-parser@3.804.0':
    dependencies:
      tslib: 2.6.2

  '@aws-sdk/util-endpoints@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      '@smithy/util-endpoints': 3.0.6
      tslib: 2.6.2

  '@aws-sdk/util-format-url@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/querystring-builder': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/util-locate-window@3.804.0':
    dependencies:
      tslib: 2.6.2

  '@aws-sdk/util-user-agent-browser@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      bowser: 2.11.0
      tslib: 2.6.2

  '@aws-sdk/util-user-agent-node@3.821.0':
    dependencies:
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/xml-builder@3.821.0':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@colors/colors@1.6.0': {}

  '@cspotcode/source-map-support@0.8.1':
    dependencies:
      '@jridgewell/trace-mapping': 0.3.9

  '@dabh/diagnostics@2.0.3':
    dependencies:
      colorspace: 1.1.4
      enabled: 2.0.0
      kuler: 2.0.0

  '@eslint-community/eslint-utils@4.7.0(eslint@9.26.0)':
    dependencies:
      eslint: 9.26.0
      eslint-visitor-keys: 3.4.3

  '@eslint-community/regexpp@4.12.1': {}

  '@eslint/config-array@0.20.0':
    dependencies:
      '@eslint/object-schema': 2.1.6
      debug: 4.4.1
      minimatch: 3.1.2
    transitivePeerDependencies:
      - supports-color

  '@eslint/config-helpers@0.2.2': {}

  '@eslint/core@0.13.0':
    dependencies:
      '@types/json-schema': 7.0.15

  '@eslint/eslintrc@3.3.1':
    dependencies:
      ajv: 6.12.6
      debug: 4.4.1
      espree: 10.3.0
      globals: 14.0.0
      ignore: 5.3.2
      import-fresh: 3.3.1
      js-yaml: 4.1.0
      minimatch: 3.1.2
      strip-json-comments: 3.1.1
    transitivePeerDependencies:
      - supports-color

  '@eslint/js@9.26.0': {}

  '@eslint/object-schema@2.1.6': {}

  '@eslint/plugin-kit@0.2.8':
    dependencies:
      '@eslint/core': 0.13.0
      levn: 0.4.1

  '@humanfs/core@0.19.1': {}

  '@humanfs/node@0.16.6':
    dependencies:
      '@humanfs/core': 0.19.1
      '@humanwhocodes/retry': 0.3.1

  '@humanwhocodes/module-importer@1.0.1': {}

  '@humanwhocodes/retry@0.3.1': {}

  '@humanwhocodes/retry@0.4.3': {}

  '@jridgewell/resolve-uri@3.1.2': {}

  '@jridgewell/sourcemap-codec@1.5.0': {}

  '@jridgewell/trace-mapping@0.3.9':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.2
      '@jridgewell/sourcemap-codec': 1.5.0

  '@jsdevtools/ono@7.1.3': {}

  '@modelcontextprotocol/sdk@1.11.2':
    dependencies:
      content-type: 1.0.5
      cors: 2.8.5
      cross-spawn: 7.0.6
      eventsource: 3.0.7
      express: 5.1.0
      express-rate-limit: 7.5.0(express@5.1.0)
      pkce-challenge: 5.0.0
      raw-body: 3.0.0
      zod: 3.24.4
      zod-to-json-schema: 3.24.5(zod@3.24.4)
    transitivePeerDependencies:
      - supports-color

  '@mongodb-js/saslprep@1.2.2':
    dependencies:
      sparse-bitfield: 3.0.3

  '@payos/node@1.0.10':
    dependencies:
      axios: 1.9.0
      crypto: 1.0.1
    transitivePeerDependencies:
      - debug

  '@rtsao/scc@1.1.0': {}

  '@scarf/scarf@1.4.0': {}

  '@smithy/abort-controller@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/chunked-blob-reader-native@4.0.0':
    dependencies:
      '@smithy/util-base64': 4.0.0
      tslib: 2.6.2

  '@smithy/chunked-blob-reader@5.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/config-resolver@4.1.4':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      '@smithy/util-middleware': 4.0.4
      tslib: 2.6.2

  '@smithy/core@3.5.1':
    dependencies:
      '@smithy/middleware-serde': 4.0.8
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/credential-provider-imds@4.0.6':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/property-provider': 4.0.4
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      tslib: 2.6.2

  '@smithy/eventstream-codec@4.0.4':
    dependencies:
      '@aws-crypto/crc32': 5.2.0
      '@smithy/types': 4.3.1
      '@smithy/util-hex-encoding': 4.0.0
      tslib: 2.6.2

  '@smithy/eventstream-serde-browser@4.0.4':
    dependencies:
      '@smithy/eventstream-serde-universal': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/eventstream-serde-config-resolver@4.1.2':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/eventstream-serde-node@4.0.4':
    dependencies:
      '@smithy/eventstream-serde-universal': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/eventstream-serde-universal@4.0.4':
    dependencies:
      '@smithy/eventstream-codec': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/fetch-http-handler@5.0.4':
    dependencies:
      '@smithy/protocol-http': 5.1.2
      '@smithy/querystring-builder': 4.0.4
      '@smithy/types': 4.3.1
      '@smithy/util-base64': 4.0.0
      tslib: 2.6.2

  '@smithy/hash-blob-browser@4.0.4':
    dependencies:
      '@smithy/chunked-blob-reader': 5.0.0
      '@smithy/chunked-blob-reader-native': 4.0.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/hash-node@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-buffer-from': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/hash-stream-node@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/invalid-dependency@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/is-array-buffer@2.2.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/is-array-buffer@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/md5-js@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/middleware-content-length@4.0.4':
    dependencies:
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/middleware-endpoint@4.1.9':
    dependencies:
      '@smithy/core': 3.5.1
      '@smithy/middleware-serde': 4.0.8
      '@smithy/node-config-provider': 4.1.3
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-middleware': 4.0.4
      tslib: 2.6.2

  '@smithy/middleware-retry@4.1.10':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/service-error-classification': 4.0.5
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      tslib: 2.6.2
      uuid: 9.0.1

  '@smithy/middleware-serde@4.0.8':
    dependencies:
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/middleware-stack@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/node-config-provider@4.1.3':
    dependencies:
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/node-http-handler@4.0.6':
    dependencies:
      '@smithy/abort-controller': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/querystring-builder': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/property-provider@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/protocol-http@5.1.2':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/querystring-builder@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-uri-escape': 4.0.0
      tslib: 2.6.2

  '@smithy/querystring-parser@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/service-error-classification@4.0.5':
    dependencies:
      '@smithy/types': 4.3.1

  '@smithy/shared-ini-file-loader@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/signature-v4@5.1.2':
    dependencies:
      '@smithy/is-array-buffer': 4.0.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-hex-encoding': 4.0.0
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-uri-escape': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/smithy-client@4.4.1':
    dependencies:
      '@smithy/core': 3.5.1
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-stack': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-stream': 4.2.2
      tslib: 2.6.2

  '@smithy/types@4.3.1':
    dependencies:
      tslib: 2.6.2

  '@smithy/url-parser@4.0.4':
    dependencies:
      '@smithy/querystring-parser': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-base64@4.0.0':
    dependencies:
      '@smithy/util-buffer-from': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/util-body-length-browser@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-body-length-node@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-buffer-from@2.2.0':
    dependencies:
      '@smithy/is-array-buffer': 2.2.0
      tslib: 2.6.2

  '@smithy/util-buffer-from@4.0.0':
    dependencies:
      '@smithy/is-array-buffer': 4.0.0
      tslib: 2.6.2

  '@smithy/util-config-provider@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-defaults-mode-browser@4.0.17':
    dependencies:
      '@smithy/property-provider': 4.0.4
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      bowser: 2.11.0
      tslib: 2.6.2

  '@smithy/util-defaults-mode-node@4.0.17':
    dependencies:
      '@smithy/config-resolver': 4.1.4
      '@smithy/credential-provider-imds': 4.0.6
      '@smithy/node-config-provider': 4.1.3
      '@smithy/property-provider': 4.0.4
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-endpoints@3.0.6':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-hex-encoding@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-middleware@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-retry@4.0.5':
    dependencies:
      '@smithy/service-error-classification': 4.0.5
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-stream@4.2.2':
    dependencies:
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/node-http-handler': 4.0.6
      '@smithy/types': 4.3.1
      '@smithy/util-base64': 4.0.0
      '@smithy/util-buffer-from': 4.0.0
      '@smithy/util-hex-encoding': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/util-uri-escape@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-utf8@2.3.0':
    dependencies:
      '@smithy/util-buffer-from': 2.2.0
      tslib: 2.6.2

  '@smithy/util-utf8@4.0.0':
    dependencies:
      '@smithy/util-buffer-from': 4.0.0
      tslib: 2.6.2

  '@smithy/util-waiter@4.0.5':
    dependencies:
      '@smithy/abort-controller': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@swc/helpers@0.3.17':
    dependencies:
      tslib: 2.6.2

  '@tsconfig/node10@1.0.11': {}

  '@tsconfig/node12@1.0.11': {}

  '@tsconfig/node14@1.0.3': {}

  '@tsconfig/node16@1.0.4': {}

  '@types/aws-sdk@2.7.4':
    dependencies:
      aws-sdk: 2.1692.0

  '@types/bcryptjs@3.0.0':
    dependencies:
      bcryptjs: 3.0.2

  '@types/body-parser@1.19.5':
    dependencies:
      '@types/connect': 3.4.38
      '@types/node': 22.15.18

  '@types/compression@1.8.0':
    dependencies:
      '@types/express': 5.0.1
      '@types/node': 22.15.18

  '@types/connect@3.4.38':
    dependencies:
      '@types/node': 22.15.18

  '@types/cors@2.8.18':
    dependencies:
      '@types/node': 22.15.18

  '@types/dotenv@8.2.3':
    dependencies:
      dotenv: 16.5.0

  '@types/estree@1.0.7': {}

  '@types/express-serve-static-core@5.0.6':
    dependencies:
      '@types/node': 22.15.18
      '@types/qs': 6.9.18
      '@types/range-parser': 1.2.7
      '@types/send': 0.17.4

  '@types/express@5.0.1':
    dependencies:
      '@types/body-parser': 1.19.5
      '@types/express-serve-static-core': 5.0.6
      '@types/serve-static': 1.15.7

  '@types/hpp@0.2.6':
    dependencies:
      '@types/express': 5.0.1

  '@types/http-errors@2.0.4': {}

  '@types/json-schema@7.0.15': {}

  '@types/json5@0.0.29': {}

  '@types/jsonwebtoken@9.0.9':
    dependencies:
      '@types/ms': 2.1.0
      '@types/node': 22.15.18

  '@types/mime@1.3.5': {}

  '@types/morgan@1.9.9':
    dependencies:
      '@types/node': 22.15.18

  '@types/ms@2.1.0': {}

  '@types/multer@1.4.12':
    dependencies:
      '@types/express': 5.0.1

  '@types/node@22.15.18':
    dependencies:
      undici-types: 6.21.0

  '@types/nodemailer@6.4.17':
    dependencies:
      '@types/node': 22.15.18

  '@types/pdfkit@0.13.9':
    dependencies:
      '@types/node': 22.15.18

  '@types/qs@6.9.18': {}

  '@types/range-parser@1.2.7': {}

  '@types/send@0.17.4':
    dependencies:
      '@types/mime': 1.3.5
      '@types/node': 22.15.18

  '@types/serve-static@1.15.7':
    dependencies:
      '@types/http-errors': 2.0.4
      '@types/node': 22.15.18
      '@types/send': 0.17.4

  '@types/strip-bom@3.0.0': {}

  '@types/strip-json-comments@0.0.30': {}

  '@types/swagger-jsdoc@6.0.4': {}

  '@types/swagger-ui-express@4.1.8':
    dependencies:
      '@types/express': 5.0.1
      '@types/serve-static': 1.15.7

  '@types/triple-beam@1.3.5': {}

  '@types/validator@13.15.0': {}

  '@types/webidl-conversions@7.0.3': {}

  '@types/whatwg-url@11.0.5':
    dependencies:
      '@types/webidl-conversions': 7.0.3

  '@types/yamljs@0.2.34': {}

  accepts@2.0.0:
    dependencies:
      mime-types: 3.0.1
      negotiator: 1.0.0

  acorn-jsx@5.3.2(acorn@8.14.1):
    dependencies:
      acorn: 8.14.1

  acorn-walk@8.3.4:
    dependencies:
      acorn: 8.14.1

  acorn@8.14.1: {}

  agent-base@7.1.3: {}

  ajv@6.12.6:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-json-stable-stringify: 2.1.0
      json-schema-traverse: 0.4.1
      uri-js: 4.4.1

  ansi-escapes@7.0.0:
    dependencies:
      environment: 1.1.0

  ansi-regex@6.1.0: {}

  ansi-styles@4.3.0:
    dependencies:
      color-convert: 2.0.1

  ansi-styles@6.2.1: {}

  anymatch@3.1.3:
    dependencies:
      normalize-path: 3.0.0
      picomatch: 2.3.1

  append-field@1.0.0: {}

  arg@4.1.3: {}

  argparse@1.0.10:
    dependencies:
      sprintf-js: 1.0.3

  argparse@2.0.1: {}

  array-buffer-byte-length@1.0.2:
    dependencies:
      call-bound: 1.0.4
      is-array-buffer: 3.0.5

  array-includes@3.1.8:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-object-atoms: 1.1.1
      get-intrinsic: 1.3.0
      is-string: 1.1.1

  array.prototype.findlastindex@1.2.6:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      es-shim-unscopables: 1.1.0

  array.prototype.flat@1.3.3:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-shim-unscopables: 1.1.0

  array.prototype.flatmap@1.3.3:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-shim-unscopables: 1.1.0

  arraybuffer.prototype.slice@1.0.4:
    dependencies:
      array-buffer-byte-length: 1.0.2
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      is-array-buffer: 3.0.5

  async-function@1.0.0: {}

  async@3.2.6: {}

  asynckit@0.4.0: {}

  available-typed-arrays@1.0.7:
    dependencies:
      possible-typed-array-names: 1.1.0

  aws-sdk@2.1692.0:
    dependencies:
      buffer: 4.9.2
      events: 1.1.1
      ieee754: 1.1.13
      jmespath: 0.16.0
      querystring: 0.2.0
      sax: 1.2.1
      url: 0.10.3
      util: 0.12.5
      uuid: 8.0.0
      xml2js: 0.6.2

  axios@1.9.0:
    dependencies:
      follow-redirects: 1.15.9
      form-data: 4.0.2
      proxy-from-env: 1.1.0
    transitivePeerDependencies:
      - debug

  balanced-match@1.0.2: {}

  base64-js@0.0.8: {}

  base64-js@1.5.1: {}

  basic-auth@2.0.1:
    dependencies:
      safe-buffer: 5.1.2

  bcryptjs@3.0.2: {}

  bignumber.js@9.3.0: {}

  binary-extensions@2.3.0: {}

  body-parser@2.2.0:
    dependencies:
      bytes: 3.1.2
      content-type: 1.0.5
      debug: 4.4.1
      http-errors: 2.0.0
      iconv-lite: 0.6.3
      on-finished: 2.4.1
      qs: 6.14.0
      raw-body: 3.0.0
      type-is: 2.0.1
    transitivePeerDependencies:
      - supports-color

  bowser@2.11.0: {}

  brace-expansion@1.1.11:
    dependencies:
      balanced-match: 1.0.2
      concat-map: 0.0.1

  brace-expansion@2.0.1:
    dependencies:
      balanced-match: 1.0.2

  braces@3.0.3:
    dependencies:
      fill-range: 7.1.1

  brotli@1.3.3:
    dependencies:
      base64-js: 1.5.1

  bson@6.10.3: {}

  buffer-equal-constant-time@1.0.1: {}

  buffer-from@1.1.2: {}

  buffer@4.9.2:
    dependencies:
      base64-js: 1.5.1
      ieee754: 1.1.13
      isarray: 1.0.0

  busboy@1.6.0:
    dependencies:
      streamsearch: 1.1.0

  bytes@3.1.2: {}

  call-bind-apply-helpers@1.0.2:
    dependencies:
      es-errors: 1.3.0
      function-bind: 1.1.2

  call-bind@1.0.8:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      get-intrinsic: 1.3.0
      set-function-length: 1.2.2

  call-bound@1.0.4:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      get-intrinsic: 1.3.0

  call-me-maybe@1.0.2: {}

  callsites@3.1.0: {}

  chalk@4.1.2:
    dependencies:
      ansi-styles: 4.3.0
      supports-color: 7.2.0

  chalk@5.4.1: {}

  chokidar@3.6.0:
    dependencies:
      anymatch: 3.1.3
      braces: 3.0.3
      glob-parent: 5.1.2
      is-binary-path: 2.1.0
      is-glob: 4.0.3
      normalize-path: 3.0.0
      readdirp: 3.6.0
    optionalDependencies:
      fsevents: 2.3.3

  class-transformer@0.5.1: {}

  class-validator@0.14.2:
    dependencies:
      '@types/validator': 13.15.0
      libphonenumber-js: 1.12.8
      validator: 13.15.0

  cli-cursor@5.0.0:
    dependencies:
      restore-cursor: 5.1.0

  cli-truncate@4.0.0:
    dependencies:
      slice-ansi: 5.0.0
      string-width: 7.2.0

  clone@2.1.2: {}

  color-convert@1.9.3:
    dependencies:
      color-name: 1.1.3

  color-convert@2.0.1:
    dependencies:
      color-name: 1.1.4

  color-name@1.1.3: {}

  color-name@1.1.4: {}

  color-string@1.9.1:
    dependencies:
      color-name: 1.1.4
      simple-swizzle: 0.2.2

  color@3.2.1:
    dependencies:
      color-convert: 1.9.3
      color-string: 1.9.1

  colorette@2.0.20: {}

  colorspace@1.1.4:
    dependencies:
      color: 3.2.1
      text-hex: 1.0.0

  combined-stream@1.0.8:
    dependencies:
      delayed-stream: 1.0.0

  commander@13.1.0: {}

  commander@6.2.0: {}

  commander@9.5.0:
    optional: true

  compressible@2.0.18:
    dependencies:
      mime-db: 1.54.0

  compression@1.8.0:
    dependencies:
      bytes: 3.1.2
      compressible: 2.0.18
      debug: 2.6.9
      negotiator: 0.6.4
      on-headers: 1.0.2
      safe-buffer: 5.2.1
      vary: 1.1.2
    transitivePeerDependencies:
      - supports-color

  concat-map@0.0.1: {}

  concat-stream@1.6.2:
    dependencies:
      buffer-from: 1.1.2
      inherits: 2.0.4
      readable-stream: 2.3.8
      typedarray: 0.0.6

  content-disposition@1.0.0:
    dependencies:
      safe-buffer: 5.2.1

  content-type@1.0.5: {}

  cookie-signature@1.2.2: {}

  cookie@0.7.2: {}

  core-util-is@1.0.3: {}

  cors@2.8.5:
    dependencies:
      object-assign: 4.1.1
      vary: 1.1.2

  create-require@1.1.1: {}

  cross-spawn@7.0.6:
    dependencies:
      path-key: 3.1.1
      shebang-command: 2.0.0
      which: 2.0.2

  crypto-js@4.2.0: {}

  crypto@1.0.1: {}

  data-view-buffer@1.0.2:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-data-view: 1.0.2

  data-view-byte-length@1.0.2:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-data-view: 1.0.2

  data-view-byte-offset@1.0.1:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-data-view: 1.0.2

  date-fns@4.1.0: {}

  debug@2.6.9:
    dependencies:
      ms: 2.0.0

  debug@3.2.7:
    dependencies:
      ms: 2.1.3

  debug@4.4.1:
    dependencies:
      ms: 2.1.3

  deep-equal@2.2.3:
    dependencies:
      array-buffer-byte-length: 1.0.2
      call-bind: 1.0.8
      es-get-iterator: 1.1.3
      get-intrinsic: 1.3.0
      is-arguments: 1.2.0
      is-array-buffer: 3.0.5
      is-date-object: 1.1.0
      is-regex: 1.2.1
      is-shared-array-buffer: 1.0.4
      isarray: 2.0.5
      object-is: 1.1.6
      object-keys: 1.1.1
      object.assign: 4.1.7
      regexp.prototype.flags: 1.5.4
      side-channel: 1.1.0
      which-boxed-primitive: 1.1.1
      which-collection: 1.0.2
      which-typed-array: 1.1.19

  deep-is@0.1.4: {}

  define-data-property@1.1.4:
    dependencies:
      es-define-property: 1.0.1
      es-errors: 1.3.0
      gopd: 1.2.0

  define-properties@1.2.1:
    dependencies:
      define-data-property: 1.1.4
      has-property-descriptors: 1.0.2
      object-keys: 1.1.1

  delayed-stream@1.0.0: {}

  depd@2.0.0: {}

  dfa@1.2.0: {}

  diff@4.0.2: {}

  doctrine@2.1.0:
    dependencies:
      esutils: 2.0.3

  doctrine@3.0.0:
    dependencies:
      esutils: 2.0.3

  dotenv@16.5.0: {}

  dunder-proto@1.0.1:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-errors: 1.3.0
      gopd: 1.2.0

  dynamic-dedupe@0.3.0:
    dependencies:
      xtend: 4.0.2

  ecdsa-sig-formatter@1.0.11:
    dependencies:
      safe-buffer: 5.2.1

  ee-first@1.1.1: {}

  ejs@3.1.10:
    dependencies:
      jake: 10.9.2

  emoji-regex@10.4.0: {}

  enabled@2.0.0: {}

  encodeurl@2.0.0: {}

  envalid@8.0.0:
    dependencies:
      tslib: 2.6.2

  environment@1.1.0: {}

  es-abstract@1.23.9:
    dependencies:
      array-buffer-byte-length: 1.0.2
      arraybuffer.prototype.slice: 1.0.4
      available-typed-arrays: 1.0.7
      call-bind: 1.0.8
      call-bound: 1.0.4
      data-view-buffer: 1.0.2
      data-view-byte-length: 1.0.2
      data-view-byte-offset: 1.0.1
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      es-set-tostringtag: 2.1.0
      es-to-primitive: 1.3.0
      function.prototype.name: 1.1.8
      get-intrinsic: 1.3.0
      get-proto: 1.0.1
      get-symbol-description: 1.1.0
      globalthis: 1.0.4
      gopd: 1.2.0
      has-property-descriptors: 1.0.2
      has-proto: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      internal-slot: 1.1.0
      is-array-buffer: 3.0.5
      is-callable: 1.2.7
      is-data-view: 1.0.2
      is-regex: 1.2.1
      is-shared-array-buffer: 1.0.4
      is-string: 1.1.1
      is-typed-array: 1.1.15
      is-weakref: 1.1.1
      math-intrinsics: 1.1.0
      object-inspect: 1.13.4
      object-keys: 1.1.1
      object.assign: 4.1.7
      own-keys: 1.0.1
      regexp.prototype.flags: 1.5.4
      safe-array-concat: 1.1.3
      safe-push-apply: 1.0.0
      safe-regex-test: 1.1.0
      set-proto: 1.0.0
      string.prototype.trim: 1.2.10
      string.prototype.trimend: 1.0.9
      string.prototype.trimstart: 1.0.8
      typed-array-buffer: 1.0.3
      typed-array-byte-length: 1.0.3
      typed-array-byte-offset: 1.0.4
      typed-array-length: 1.0.7
      unbox-primitive: 1.1.0
      which-typed-array: 1.1.19

  es-define-property@1.0.1: {}

  es-errors@1.3.0: {}

  es-get-iterator@1.1.3:
    dependencies:
      call-bind: 1.0.8
      get-intrinsic: 1.3.0
      has-symbols: 1.1.0
      is-arguments: 1.2.0
      is-map: 2.0.3
      is-set: 2.0.3
      is-string: 1.1.1
      isarray: 2.0.5
      stop-iteration-iterator: 1.1.0

  es-object-atoms@1.1.1:
    dependencies:
      es-errors: 1.3.0

  es-set-tostringtag@2.1.0:
    dependencies:
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      has-tostringtag: 1.0.2
      hasown: 2.0.2

  es-shim-unscopables@1.1.0:
    dependencies:
      hasown: 2.0.2

  es-to-primitive@1.3.0:
    dependencies:
      is-callable: 1.2.7
      is-date-object: 1.1.0
      is-symbol: 1.1.1

  escape-html@1.0.3: {}

  escape-string-regexp@4.0.0: {}

  eslint-config-prettier@10.1.5(eslint@9.26.0):
    dependencies:
      eslint: 9.26.0

  eslint-import-resolver-node@0.3.9:
    dependencies:
      debug: 3.2.7
      is-core-module: 2.16.1
      resolve: 1.22.10
    transitivePeerDependencies:
      - supports-color

  eslint-module-utils@2.12.0(eslint-import-resolver-node@0.3.9)(eslint@9.26.0):
    dependencies:
      debug: 3.2.7
    optionalDependencies:
      eslint: 9.26.0
      eslint-import-resolver-node: 0.3.9
    transitivePeerDependencies:
      - supports-color

  eslint-plugin-import@2.31.0(eslint@9.26.0):
    dependencies:
      '@rtsao/scc': 1.1.0
      array-includes: 3.1.8
      array.prototype.findlastindex: 1.2.6
      array.prototype.flat: 1.3.3
      array.prototype.flatmap: 1.3.3
      debug: 3.2.7
      doctrine: 2.1.0
      eslint: 9.26.0
      eslint-import-resolver-node: 0.3.9
      eslint-module-utils: 2.12.0(eslint-import-resolver-node@0.3.9)(eslint@9.26.0)
      hasown: 2.0.2
      is-core-module: 2.16.1
      is-glob: 4.0.3
      minimatch: 3.1.2
      object.fromentries: 2.0.8
      object.groupby: 1.0.3
      object.values: 1.2.1
      semver: 6.3.1
      string.prototype.trimend: 1.0.9
      tsconfig-paths: 3.15.0
    transitivePeerDependencies:
      - eslint-import-resolver-typescript
      - eslint-import-resolver-webpack
      - supports-color

  eslint-scope@8.3.0:
    dependencies:
      esrecurse: 4.3.0
      estraverse: 5.3.0

  eslint-visitor-keys@3.4.3: {}

  eslint-visitor-keys@4.2.0: {}

  eslint@9.26.0:
    dependencies:
      '@eslint-community/eslint-utils': 4.7.0(eslint@9.26.0)
      '@eslint-community/regexpp': 4.12.1
      '@eslint/config-array': 0.20.0
      '@eslint/config-helpers': 0.2.2
      '@eslint/core': 0.13.0
      '@eslint/eslintrc': 3.3.1
      '@eslint/js': 9.26.0
      '@eslint/plugin-kit': 0.2.8
      '@humanfs/node': 0.16.6
      '@humanwhocodes/module-importer': 1.0.1
      '@humanwhocodes/retry': 0.4.3
      '@modelcontextprotocol/sdk': 1.11.2
      '@types/estree': 1.0.7
      '@types/json-schema': 7.0.15
      ajv: 6.12.6
      chalk: 4.1.2
      cross-spawn: 7.0.6
      debug: 4.4.1
      escape-string-regexp: 4.0.0
      eslint-scope: 8.3.0
      eslint-visitor-keys: 4.2.0
      espree: 10.3.0
      esquery: 1.6.0
      esutils: 2.0.3
      fast-deep-equal: 3.1.3
      file-entry-cache: 8.0.0
      find-up: 5.0.0
      glob-parent: 6.0.2
      ignore: 5.3.2
      imurmurhash: 0.1.4
      is-glob: 4.0.3
      json-stable-stringify-without-jsonify: 1.0.1
      lodash.merge: 4.6.2
      minimatch: 3.1.2
      natural-compare: 1.4.0
      optionator: 0.9.4
      zod: 3.24.4
    transitivePeerDependencies:
      - supports-color

  espree@10.3.0:
    dependencies:
      acorn: 8.14.1
      acorn-jsx: 5.3.2(acorn@8.14.1)
      eslint-visitor-keys: 4.2.0

  esquery@1.6.0:
    dependencies:
      estraverse: 5.3.0

  esrecurse@4.3.0:
    dependencies:
      estraverse: 5.3.0

  estraverse@5.3.0: {}

  esutils@2.0.3: {}

  etag@1.8.1: {}

  eventemitter3@5.0.1: {}

  events@1.1.1: {}

  eventsource-parser@3.0.1: {}

  eventsource@3.0.7:
    dependencies:
      eventsource-parser: 3.0.1

  express-rate-limit@7.5.0(express@5.1.0):
    dependencies:
      express: 5.1.0

  express@5.1.0:
    dependencies:
      accepts: 2.0.0
      body-parser: 2.2.0
      content-disposition: 1.0.0
      content-type: 1.0.5
      cookie: 0.7.2
      cookie-signature: 1.2.2
      debug: 4.4.1
      encodeurl: 2.0.0
      escape-html: 1.0.3
      etag: 1.8.1
      finalhandler: 2.1.0
      fresh: 2.0.0
      http-errors: 2.0.0
      merge-descriptors: 2.0.0
      mime-types: 3.0.1
      on-finished: 2.4.1
      once: 1.4.0
      parseurl: 1.3.3
      proxy-addr: 2.0.7
      qs: 6.14.0
      range-parser: 1.2.1
      router: 2.2.0
      send: 1.2.0
      serve-static: 2.2.0
      statuses: 2.0.1
      type-is: 2.0.1
      vary: 1.1.2
    transitivePeerDependencies:
      - supports-color

  extend@3.0.2: {}

  fast-deep-equal@3.1.3: {}

  fast-json-stable-stringify@2.1.0: {}

  fast-levenshtein@2.0.6: {}

  fast-xml-parser@4.4.1:
    dependencies:
      strnum: 1.1.2

  fecha@4.2.3: {}

  file-entry-cache@8.0.0:
    dependencies:
      flat-cache: 4.0.1

  filelist@1.0.4:
    dependencies:
      minimatch: 5.1.6

  fill-range@7.1.1:
    dependencies:
      to-regex-range: 5.0.1

  finalhandler@2.1.0:
    dependencies:
      debug: 4.4.1
      encodeurl: 2.0.0
      escape-html: 1.0.3
      on-finished: 2.4.1
      parseurl: 1.3.3
      statuses: 2.0.1
    transitivePeerDependencies:
      - supports-color

  find-up@5.0.0:
    dependencies:
      locate-path: 6.0.0
      path-exists: 4.0.0

  flat-cache@4.0.1:
    dependencies:
      flatted: 3.3.3
      keyv: 4.5.4

  flatted@3.3.3: {}

  fn.name@1.1.0: {}

  follow-redirects@1.15.9: {}

  fontkit@1.9.0:
    dependencies:
      '@swc/helpers': 0.3.17
      brotli: 1.3.3
      clone: 2.1.2
      deep-equal: 2.2.3
      dfa: 1.2.0
      restructure: 2.0.1
      tiny-inflate: 1.0.3
      unicode-properties: 1.4.1
      unicode-trie: 2.0.0

  for-each@0.3.5:
    dependencies:
      is-callable: 1.2.7

  form-data@4.0.2:
    dependencies:
      asynckit: 0.4.0
      combined-stream: 1.0.8
      es-set-tostringtag: 2.1.0
      mime-types: 2.1.35

  forwarded@0.2.0: {}

  fresh@2.0.0: {}

  fs.realpath@1.0.0: {}

  fsevents@2.3.3:
    optional: true

  function-bind@1.1.2: {}

  function.prototype.name@1.1.8:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      functions-have-names: 1.2.3
      hasown: 2.0.2
      is-callable: 1.2.7

  functions-have-names@1.2.3: {}

  gaxios@6.7.1:
    dependencies:
      extend: 3.0.2
      https-proxy-agent: 7.0.6
      is-stream: 2.0.1
      node-fetch: 2.7.0
      uuid: 9.0.1
    transitivePeerDependencies:
      - encoding
      - supports-color

  gcp-metadata@6.1.1:
    dependencies:
      gaxios: 6.7.1
      google-logging-utils: 0.0.2
      json-bigint: 1.0.0
    transitivePeerDependencies:
      - encoding
      - supports-color

  get-east-asian-width@1.3.0: {}

  get-intrinsic@1.3.0:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      function-bind: 1.1.2
      get-proto: 1.0.1
      gopd: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      math-intrinsics: 1.1.0

  get-proto@1.0.1:
    dependencies:
      dunder-proto: 1.0.1
      es-object-atoms: 1.1.1

  get-symbol-description@1.1.0:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0

  glob-parent@5.1.2:
    dependencies:
      is-glob: 4.0.3

  glob-parent@6.0.2:
    dependencies:
      is-glob: 4.0.3

  glob@7.1.6:
    dependencies:
      fs.realpath: 1.0.0
      inflight: 1.0.6
      inherits: 2.0.4
      minimatch: 3.1.2
      once: 1.4.0
      path-is-absolute: 1.0.1

  glob@7.2.3:
    dependencies:
      fs.realpath: 1.0.0
      inflight: 1.0.6
      inherits: 2.0.4
      minimatch: 3.1.2
      once: 1.4.0
      path-is-absolute: 1.0.1

  globals@14.0.0: {}

  globalthis@1.0.4:
    dependencies:
      define-properties: 1.2.1
      gopd: 1.2.0

  google-auth-library@9.15.1:
    dependencies:
      base64-js: 1.5.1
      ecdsa-sig-formatter: 1.0.11
      gaxios: 6.7.1
      gcp-metadata: 6.1.1
      gtoken: 7.1.0
      jws: 4.0.0
    transitivePeerDependencies:
      - encoding
      - supports-color

  google-logging-utils@0.0.2: {}

  gopd@1.2.0: {}

  gtoken@7.1.0:
    dependencies:
      gaxios: 6.7.1
      jws: 4.0.0
    transitivePeerDependencies:
      - encoding
      - supports-color

  has-bigints@1.1.0: {}

  has-flag@4.0.0: {}

  has-property-descriptors@1.0.2:
    dependencies:
      es-define-property: 1.0.1

  has-proto@1.2.0:
    dependencies:
      dunder-proto: 1.0.1

  has-symbols@1.1.0: {}

  has-tostringtag@1.0.2:
    dependencies:
      has-symbols: 1.1.0

  hasown@2.0.2:
    dependencies:
      function-bind: 1.1.2

  helmet@8.1.0: {}

  hpp@0.2.3:
    dependencies:
      lodash: 4.17.21
      type-is: 1.6.18

  http-errors@2.0.0:
    dependencies:
      depd: 2.0.0
      inherits: 2.0.4
      setprototypeof: 1.2.0
      statuses: 2.0.1
      toidentifier: 1.0.1

  https-proxy-agent@7.0.6:
    dependencies:
      agent-base: 7.1.3
      debug: 4.4.1
    transitivePeerDependencies:
      - supports-color

  husky@9.1.7: {}

  iconv-lite@0.6.3:
    dependencies:
      safer-buffer: 2.1.2

  ieee754@1.1.13: {}

  ignore@5.3.2: {}

  import-fresh@3.3.1:
    dependencies:
      parent-module: 1.0.1
      resolve-from: 4.0.0

  imurmurhash@0.1.4: {}

  inflight@1.0.6:
    dependencies:
      once: 1.4.0
      wrappy: 1.0.2

  inherits@2.0.3: {}

  inherits@2.0.4: {}

  internal-slot@1.1.0:
    dependencies:
      es-errors: 1.3.0
      hasown: 2.0.2
      side-channel: 1.1.0

  ipaddr.js@1.9.1: {}

  is-arguments@1.2.0:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-array-buffer@3.0.5:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      get-intrinsic: 1.3.0

  is-arrayish@0.3.2: {}

  is-async-function@2.1.1:
    dependencies:
      async-function: 1.0.0
      call-bound: 1.0.4
      get-proto: 1.0.1
      has-tostringtag: 1.0.2
      safe-regex-test: 1.1.0

  is-bigint@1.1.0:
    dependencies:
      has-bigints: 1.1.0

  is-binary-path@2.1.0:
    dependencies:
      binary-extensions: 2.3.0

  is-boolean-object@1.2.2:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-callable@1.2.7: {}

  is-core-module@2.16.1:
    dependencies:
      hasown: 2.0.2

  is-data-view@1.0.2:
    dependencies:
      call-bound: 1.0.4
      get-intrinsic: 1.3.0
      is-typed-array: 1.1.15

  is-date-object@1.1.0:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-extglob@2.1.1: {}

  is-finalizationregistry@1.1.1:
    dependencies:
      call-bound: 1.0.4

  is-fullwidth-code-point@4.0.0: {}

  is-fullwidth-code-point@5.0.0:
    dependencies:
      get-east-asian-width: 1.3.0

  is-generator-function@1.1.0:
    dependencies:
      call-bound: 1.0.4
      get-proto: 1.0.1
      has-tostringtag: 1.0.2
      safe-regex-test: 1.1.0

  is-glob@4.0.3:
    dependencies:
      is-extglob: 2.1.1

  is-map@2.0.3: {}

  is-number-object@1.1.1:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-number@7.0.0: {}

  is-promise@4.0.0: {}

  is-regex@1.2.1:
    dependencies:
      call-bound: 1.0.4
      gopd: 1.2.0
      has-tostringtag: 1.0.2
      hasown: 2.0.2

  is-set@2.0.3: {}

  is-shared-array-buffer@1.0.4:
    dependencies:
      call-bound: 1.0.4

  is-stream@2.0.1: {}

  is-string@1.1.1:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-symbol@1.1.1:
    dependencies:
      call-bound: 1.0.4
      has-symbols: 1.1.0
      safe-regex-test: 1.1.0

  is-typed-array@1.1.15:
    dependencies:
      which-typed-array: 1.1.19

  is-weakmap@2.0.2: {}

  is-weakref@1.1.1:
    dependencies:
      call-bound: 1.0.4

  is-weakset@2.0.4:
    dependencies:
      call-bound: 1.0.4
      get-intrinsic: 1.3.0

  isarray@1.0.0: {}

  isarray@2.0.5: {}

  isexe@2.0.0: {}

  jake@10.9.2:
    dependencies:
      async: 3.2.6
      chalk: 4.1.2
      filelist: 1.0.4
      minimatch: 3.1.2

  jmespath@0.16.0: {}

  js-yaml@4.1.0:
    dependencies:
      argparse: 2.0.1

  json-bigint@1.0.0:
    dependencies:
      bignumber.js: 9.3.0

  json-buffer@3.0.1: {}

  json-schema-traverse@0.4.1: {}

  json-stable-stringify-without-jsonify@1.0.1: {}

  json5@1.0.2:
    dependencies:
      minimist: 1.2.8

  jsonwebtoken@9.0.2:
    dependencies:
      jws: 3.2.2
      lodash.includes: 4.3.0
      lodash.isboolean: 3.0.3
      lodash.isinteger: 4.0.4
      lodash.isnumber: 3.0.3
      lodash.isplainobject: 4.0.6
      lodash.isstring: 4.0.1
      lodash.once: 4.1.1
      ms: 2.1.3
      semver: 7.7.2

  jwa@1.4.2:
    dependencies:
      buffer-equal-constant-time: 1.0.1
      ecdsa-sig-formatter: 1.0.11
      safe-buffer: 5.2.1

  jwa@2.0.1:
    dependencies:
      buffer-equal-constant-time: 1.0.1
      ecdsa-sig-formatter: 1.0.11
      safe-buffer: 5.2.1

  jws@3.2.2:
    dependencies:
      jwa: 1.4.2
      safe-buffer: 5.2.1

  jws@4.0.0:
    dependencies:
      jwa: 2.0.1
      safe-buffer: 5.2.1

  kareem@2.6.3: {}

  keyv@4.5.4:
    dependencies:
      json-buffer: 3.0.1

  kuler@2.0.0: {}

  levn@0.4.1:
    dependencies:
      prelude-ls: 1.2.1
      type-check: 0.4.0

  libphonenumber-js@1.12.8: {}

  lilconfig@3.1.3: {}

  linebreak@1.1.0:
    dependencies:
      base64-js: 0.0.8
      unicode-trie: 2.0.0

  lint-staged@16.0.0:
    dependencies:
      chalk: 5.4.1
      commander: 13.1.0
      debug: 4.4.1
      lilconfig: 3.1.3
      listr2: 8.3.3
      micromatch: 4.0.8
      nano-spawn: 1.0.1
      pidtree: 0.6.0
      string-argv: 0.3.2
      yaml: 2.7.1
    transitivePeerDependencies:
      - supports-color

  listr2@8.3.3:
    dependencies:
      cli-truncate: 4.0.0
      colorette: 2.0.20
      eventemitter3: 5.0.1
      log-update: 6.1.0
      rfdc: 1.4.1
      wrap-ansi: 9.0.0

  locate-path@6.0.0:
    dependencies:
      p-locate: 5.0.0

  lodash.get@4.4.2: {}

  lodash.includes@4.3.0: {}

  lodash.isboolean@3.0.3: {}

  lodash.isequal@4.5.0: {}

  lodash.isinteger@4.0.4: {}

  lodash.isnumber@3.0.3: {}

  lodash.isplainobject@4.0.6: {}

  lodash.isstring@4.0.1: {}

  lodash.merge@4.6.2: {}

  lodash.mergewith@4.6.2: {}

  lodash.once@4.1.1: {}

  lodash@4.17.21: {}

  log-update@6.1.0:
    dependencies:
      ansi-escapes: 7.0.0
      cli-cursor: 5.0.0
      slice-ansi: 7.1.0
      strip-ansi: 7.1.0
      wrap-ansi: 9.0.0

  logform@2.7.0:
    dependencies:
      '@colors/colors': 1.6.0
      '@types/triple-beam': 1.3.5
      fecha: 4.2.3
      ms: 2.1.3
      safe-stable-stringify: 2.5.0
      triple-beam: 1.4.1

  make-error@1.3.6: {}

  math-intrinsics@1.1.0: {}

  media-typer@0.3.0: {}

  media-typer@1.1.0: {}

  memory-pager@1.5.0: {}

  merge-descriptors@2.0.0: {}

  micromatch@4.0.8:
    dependencies:
      braces: 3.0.3
      picomatch: 2.3.1

  mime-db@1.52.0: {}

  mime-db@1.54.0: {}

  mime-types@2.1.35:
    dependencies:
      mime-db: 1.52.0

  mime-types@3.0.1:
    dependencies:
      mime-db: 1.54.0

  mimic-function@5.0.1: {}

  minimatch@3.1.2:
    dependencies:
      brace-expansion: 1.1.11

  minimatch@5.1.6:
    dependencies:
      brace-expansion: 2.0.1

  minimist@1.2.8: {}

  mkdirp@0.5.6:
    dependencies:
      minimist: 1.2.8

  mkdirp@1.0.4: {}

  moment@2.30.1: {}

  mongodb-connection-string-url@3.0.2:
    dependencies:
      '@types/whatwg-url': 11.0.5
      whatwg-url: 14.2.0

  mongodb@6.16.0:
    dependencies:
      '@mongodb-js/saslprep': 1.2.2
      bson: 6.10.3
      mongodb-connection-string-url: 3.0.2

  mongoose@8.14.3:
    dependencies:
      bson: 6.10.3
      kareem: 2.6.3
      mongodb: 6.16.0
      mpath: 0.9.0
      mquery: 5.0.0
      ms: 2.1.3
      sift: 17.1.3
    transitivePeerDependencies:
      - '@aws-sdk/credential-providers'
      - '@mongodb-js/zstd'
      - gcp-metadata
      - kerberos
      - mongodb-client-encryption
      - snappy
      - socks
      - supports-color

  morgan@1.10.0:
    dependencies:
      basic-auth: 2.0.1
      debug: 2.6.9
      depd: 2.0.0
      on-finished: 2.3.0
      on-headers: 1.0.2
    transitivePeerDependencies:
      - supports-color

  mpath@0.9.0: {}

  mquery@5.0.0:
    dependencies:
      debug: 4.4.1
    transitivePeerDependencies:
      - supports-color

  ms@2.0.0: {}

  ms@2.1.3: {}

  multer@2.0.0:
    dependencies:
      append-field: 1.0.0
      busboy: 1.6.0
      concat-stream: 1.6.2
      mkdirp: 0.5.6
      object-assign: 4.1.1
      type-is: 1.6.18
      xtend: 4.0.2

  nano-spawn@1.0.1: {}

  natural-compare@1.4.0: {}

  negotiator@0.6.4: {}

  negotiator@1.0.0: {}

  node-fetch@2.7.0:
    dependencies:
      whatwg-url: 5.0.0

  nodemailer@7.0.3: {}

  normalize-path@3.0.0: {}

  object-assign@4.1.1: {}

  object-inspect@1.13.4: {}

  object-is@1.1.6:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1

  object-keys@1.1.1: {}

  object.assign@4.1.7:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-object-atoms: 1.1.1
      has-symbols: 1.1.0
      object-keys: 1.1.1

  object.fromentries@2.0.8:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-object-atoms: 1.1.1

  object.groupby@1.0.3:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9

  object.values@1.2.1:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-object-atoms: 1.1.1

  on-finished@2.3.0:
    dependencies:
      ee-first: 1.1.1

  on-finished@2.4.1:
    dependencies:
      ee-first: 1.1.1

  on-headers@1.0.2: {}

  once@1.4.0:
    dependencies:
      wrappy: 1.0.2

  one-time@1.0.0:
    dependencies:
      fn.name: 1.1.0

  onetime@7.0.0:
    dependencies:
      mimic-function: 5.0.1

  openapi-types@12.1.3: {}

  optionator@0.9.4:
    dependencies:
      deep-is: 0.1.4
      fast-levenshtein: 2.0.6
      levn: 0.4.1
      prelude-ls: 1.2.1
      type-check: 0.4.0
      word-wrap: 1.2.5

  own-keys@1.0.1:
    dependencies:
      get-intrinsic: 1.3.0
      object-keys: 1.1.1
      safe-push-apply: 1.0.0

  p-limit@3.1.0:
    dependencies:
      yocto-queue: 0.1.0

  p-locate@5.0.0:
    dependencies:
      p-limit: 3.1.0

  pako@0.2.9: {}

  parent-module@1.0.1:
    dependencies:
      callsites: 3.1.0

  parseurl@1.3.3: {}

  path-exists@4.0.0: {}

  path-is-absolute@1.0.1: {}

  path-key@3.1.1: {}

  path-parse@1.0.7: {}

  path-to-regexp@8.2.0: {}

  path@0.12.7:
    dependencies:
      process: 0.11.10
      util: 0.10.4

  pdfkit@0.14.0:
    dependencies:
      crypto-js: 4.2.0
      fontkit: 1.9.0
      linebreak: 1.1.0
      png-js: 1.0.0

  picomatch@2.3.1: {}

  pidtree@0.6.0: {}

  pkce-challenge@5.0.0: {}

  png-js@1.0.0: {}

  possible-typed-array-names@1.1.0: {}

  prelude-ls@1.2.1: {}

  prettier@3.5.3: {}

  process-nextick-args@2.0.1: {}

  process@0.11.10: {}

  proxy-addr@2.0.7:
    dependencies:
      forwarded: 0.2.0
      ipaddr.js: 1.9.1

  proxy-from-env@1.1.0: {}

  punycode@1.3.2: {}

  punycode@2.3.1: {}

  qs@6.14.0:
    dependencies:
      side-channel: 1.1.0

  querystring@0.2.0: {}

  range-parser@1.2.1: {}

  raw-body@3.0.0:
    dependencies:
      bytes: 3.1.2
      http-errors: 2.0.0
      iconv-lite: 0.6.3
      unpipe: 1.0.0

  readable-stream@2.3.8:
    dependencies:
      core-util-is: 1.0.3
      inherits: 2.0.4
      isarray: 1.0.0
      process-nextick-args: 2.0.1
      safe-buffer: 5.1.2
      string_decoder: 1.1.1
      util-deprecate: 1.0.2

  readable-stream@3.6.2:
    dependencies:
      inherits: 2.0.4
      string_decoder: 1.3.0
      util-deprecate: 1.0.2

  readdirp@3.6.0:
    dependencies:
      picomatch: 2.3.1

  reflect-metadata@0.2.2: {}

  reflect.getprototypeof@1.0.10:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      get-intrinsic: 1.3.0
      get-proto: 1.0.1
      which-builtin-type: 1.2.1

  regexp.prototype.flags@1.5.4:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-errors: 1.3.0
      get-proto: 1.0.1
      gopd: 1.2.0
      set-function-name: 2.0.2

  resolve-from@4.0.0: {}

  resolve@1.22.10:
    dependencies:
      is-core-module: 2.16.1
      path-parse: 1.0.7
      supports-preserve-symlinks-flag: 1.0.0

  restore-cursor@5.1.0:
    dependencies:
      onetime: 7.0.0
      signal-exit: 4.1.0

  restructure@2.0.1: {}

  rfdc@1.4.1: {}

  rimraf@2.7.1:
    dependencies:
      glob: 7.2.3

  router@2.2.0:
    dependencies:
      debug: 4.4.1
      depd: 2.0.0
      is-promise: 4.0.0
      parseurl: 1.3.3
      path-to-regexp: 8.2.0
    transitivePeerDependencies:
      - supports-color

  safe-array-concat@1.1.3:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      get-intrinsic: 1.3.0
      has-symbols: 1.1.0
      isarray: 2.0.5

  safe-buffer@5.1.2: {}

  safe-buffer@5.2.1: {}

  safe-push-apply@1.0.0:
    dependencies:
      es-errors: 1.3.0
      isarray: 2.0.5

  safe-regex-test@1.1.0:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-regex: 1.2.1

  safe-stable-stringify@2.5.0: {}

  safer-buffer@2.1.2: {}

  sax@1.2.1: {}

  semver@6.3.1: {}

  semver@7.7.2: {}

  send@1.2.0:
    dependencies:
      debug: 4.4.1
      encodeurl: 2.0.0
      escape-html: 1.0.3
      etag: 1.8.1
      fresh: 2.0.0
      http-errors: 2.0.0
      mime-types: 3.0.1
      ms: 2.1.3
      on-finished: 2.4.1
      range-parser: 1.2.1
      statuses: 2.0.1
    transitivePeerDependencies:
      - supports-color

  serve-static@2.2.0:
    dependencies:
      encodeurl: 2.0.0
      escape-html: 1.0.3
      parseurl: 1.3.3
      send: 1.2.0
    transitivePeerDependencies:
      - supports-color

  set-function-length@1.2.2:
    dependencies:
      define-data-property: 1.1.4
      es-errors: 1.3.0
      function-bind: 1.1.2
      get-intrinsic: 1.3.0
      gopd: 1.2.0
      has-property-descriptors: 1.0.2

  set-function-name@2.0.2:
    dependencies:
      define-data-property: 1.1.4
      es-errors: 1.3.0
      functions-have-names: 1.2.3
      has-property-descriptors: 1.0.2

  set-proto@1.0.0:
    dependencies:
      dunder-proto: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1

  setprototypeof@1.2.0: {}

  shebang-command@2.0.0:
    dependencies:
      shebang-regex: 3.0.0

  shebang-regex@3.0.0: {}

  side-channel-list@1.0.0:
    dependencies:
      es-errors: 1.3.0
      object-inspect: 1.13.4

  side-channel-map@1.0.1:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      object-inspect: 1.13.4

  side-channel-weakmap@1.0.2:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      object-inspect: 1.13.4
      side-channel-map: 1.0.1

  side-channel@1.1.0:
    dependencies:
      es-errors: 1.3.0
      object-inspect: 1.13.4
      side-channel-list: 1.0.0
      side-channel-map: 1.0.1
      side-channel-weakmap: 1.0.2

  sift@17.1.3: {}

  signal-exit@4.1.0: {}

  simple-swizzle@0.2.2:
    dependencies:
      is-arrayish: 0.3.2

  slice-ansi@5.0.0:
    dependencies:
      ansi-styles: 6.2.1
      is-fullwidth-code-point: 4.0.0

  slice-ansi@7.1.0:
    dependencies:
      ansi-styles: 6.2.1
      is-fullwidth-code-point: 5.0.0

  source-map-support@0.5.21:
    dependencies:
      buffer-from: 1.1.2
      source-map: 0.6.1

  source-map@0.6.1: {}

  sparse-bitfield@3.0.3:
    dependencies:
      memory-pager: 1.5.0

  sprintf-js@1.0.3: {}

  stack-trace@0.0.10: {}

  statuses@2.0.1: {}

  stop-iteration-iterator@1.1.0:
    dependencies:
      es-errors: 1.3.0
      internal-slot: 1.1.0

  streamsearch@1.1.0: {}

  string-argv@0.3.2: {}

  string-width@7.2.0:
    dependencies:
      emoji-regex: 10.4.0
      get-east-asian-width: 1.3.0
      strip-ansi: 7.1.0

  string.prototype.trim@1.2.10:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-data-property: 1.1.4
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-object-atoms: 1.1.1
      has-property-descriptors: 1.0.2

  string.prototype.trimend@1.0.9:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-object-atoms: 1.1.1

  string.prototype.trimstart@1.0.8:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-object-atoms: 1.1.1

  string_decoder@1.1.1:
    dependencies:
      safe-buffer: 5.1.2

  string_decoder@1.3.0:
    dependencies:
      safe-buffer: 5.2.1

  strip-ansi@7.1.0:
    dependencies:
      ansi-regex: 6.1.0

  strip-bom@3.0.0: {}

  strip-json-comments@2.0.1: {}

  strip-json-comments@3.1.1: {}

  strnum@1.1.2: {}

  supports-color@7.2.0:
    dependencies:
      has-flag: 4.0.0

  supports-preserve-symlinks-flag@1.0.0: {}

  swagger-jsdoc@6.2.8(openapi-types@12.1.3):
    dependencies:
      commander: 6.2.0
      doctrine: 3.0.0
      glob: 7.1.6
      lodash.mergewith: 4.6.2
      swagger-parser: 10.0.3(openapi-types@12.1.3)
      yaml: 2.0.0-1
    transitivePeerDependencies:
      - openapi-types

  swagger-parser@10.0.3(openapi-types@12.1.3):
    dependencies:
      '@apidevtools/swagger-parser': 10.0.3(openapi-types@12.1.3)
    transitivePeerDependencies:
      - openapi-types

  swagger-ui-dist@5.21.0:
    dependencies:
      '@scarf/scarf': 1.4.0

  swagger-ui-express@5.0.1(express@5.1.0):
    dependencies:
      express: 5.1.0
      swagger-ui-dist: 5.21.0

  text-hex@1.0.0: {}

  tiny-inflate@1.0.3: {}

  to-regex-range@5.0.1:
    dependencies:
      is-number: 7.0.0

  toidentifier@1.0.1: {}

  tr46@0.0.3: {}

  tr46@5.1.1:
    dependencies:
      punycode: 2.3.1

  tree-kill@1.2.2: {}

  triple-beam@1.4.1: {}

  ts-node-dev@2.0.0(@types/node@22.15.18)(typescript@5.8.3):
    dependencies:
      chokidar: 3.6.0
      dynamic-dedupe: 0.3.0
      minimist: 1.2.8
      mkdirp: 1.0.4
      resolve: 1.22.10
      rimraf: 2.7.1
      source-map-support: 0.5.21
      tree-kill: 1.2.2
      ts-node: 10.9.2(@types/node@22.15.18)(typescript@5.8.3)
      tsconfig: 7.0.0
      typescript: 5.8.3
    transitivePeerDependencies:
      - '@swc/core'
      - '@swc/wasm'
      - '@types/node'

  ts-node@10.9.2(@types/node@22.15.18)(typescript@5.8.3):
    dependencies:
      '@cspotcode/source-map-support': 0.8.1
      '@tsconfig/node10': 1.0.11
      '@tsconfig/node12': 1.0.11
      '@tsconfig/node14': 1.0.3
      '@tsconfig/node16': 1.0.4
      '@types/node': 22.15.18
      acorn: 8.14.1
      acorn-walk: 8.3.4
      arg: 4.1.3
      create-require: 1.1.1
      diff: 4.0.2
      make-error: 1.3.6
      typescript: 5.8.3
      v8-compile-cache-lib: 3.0.1
      yn: 3.1.1

  tsconfig-paths@3.15.0:
    dependencies:
      '@types/json5': 0.0.29
      json5: 1.0.2
      minimist: 1.2.8
      strip-bom: 3.0.0

  tsconfig@7.0.0:
    dependencies:
      '@types/strip-bom': 3.0.0
      '@types/strip-json-comments': 0.0.30
      strip-bom: 3.0.0
      strip-json-comments: 2.0.1

  tslib@2.6.2: {}

  type-check@0.4.0:
    dependencies:
      prelude-ls: 1.2.1

  type-is@1.6.18:
    dependencies:
      media-typer: 0.3.0
      mime-types: 2.1.35

  type-is@2.0.1:
    dependencies:
      content-type: 1.0.5
      media-typer: 1.1.0
      mime-types: 3.0.1

  typed-array-buffer@1.0.3:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-typed-array: 1.1.15

  typed-array-byte-length@1.0.3:
    dependencies:
      call-bind: 1.0.8
      for-each: 0.3.5
      gopd: 1.2.0
      has-proto: 1.2.0
      is-typed-array: 1.1.15

  typed-array-byte-offset@1.0.4:
    dependencies:
      available-typed-arrays: 1.0.7
      call-bind: 1.0.8
      for-each: 0.3.5
      gopd: 1.2.0
      has-proto: 1.2.0
      is-typed-array: 1.1.15
      reflect.getprototypeof: 1.0.10

  typed-array-length@1.0.7:
    dependencies:
      call-bind: 1.0.8
      for-each: 0.3.5
      gopd: 1.2.0
      is-typed-array: 1.1.15
      possible-typed-array-names: 1.1.0
      reflect.getprototypeof: 1.0.10

  typedarray@0.0.6: {}

  typescript@5.8.3: {}

  unbox-primitive@1.1.0:
    dependencies:
      call-bound: 1.0.4
      has-bigints: 1.1.0
      has-symbols: 1.1.0
      which-boxed-primitive: 1.1.1

  undici-types@6.21.0: {}

  unicode-properties@1.4.1:
    dependencies:
      base64-js: 1.5.1
      unicode-trie: 2.0.0

  unicode-trie@2.0.0:
    dependencies:
      pako: 0.2.9
      tiny-inflate: 1.0.3

  unpipe@1.0.0: {}

  uri-js@4.4.1:
    dependencies:
      punycode: 2.3.1

  url@0.10.3:
    dependencies:
      punycode: 1.3.2
      querystring: 0.2.0

  util-deprecate@1.0.2: {}

  util@0.10.4:
    dependencies:
      inherits: 2.0.3

  util@0.12.5:
    dependencies:
      inherits: 2.0.4
      is-arguments: 1.2.0
      is-generator-function: 1.1.0
      is-typed-array: 1.1.15
      which-typed-array: 1.1.19

  uuid@11.1.0: {}

  uuid@8.0.0: {}

  uuid@9.0.1: {}

  v8-compile-cache-lib@3.0.1: {}

  validator@13.15.0: {}

  vary@1.1.2: {}

  webidl-conversions@3.0.1: {}

  webidl-conversions@7.0.0: {}

  whatwg-url@14.2.0:
    dependencies:
      tr46: 5.1.1
      webidl-conversions: 7.0.0

  whatwg-url@5.0.0:
    dependencies:
      tr46: 0.0.3
      webidl-conversions: 3.0.1

  which-boxed-primitive@1.1.1:
    dependencies:
      is-bigint: 1.1.0
      is-boolean-object: 1.2.2
      is-number-object: 1.1.1
      is-string: 1.1.1
      is-symbol: 1.1.1

  which-builtin-type@1.2.1:
    dependencies:
      call-bound: 1.0.4
      function.prototype.name: 1.1.8
      has-tostringtag: 1.0.2
      is-async-function: 2.1.1
      is-date-object: 1.1.0
      is-finalizationregistry: 1.1.1
      is-generator-function: 1.1.0
      is-regex: 1.2.1
      is-weakref: 1.1.1
      isarray: 2.0.5
      which-boxed-primitive: 1.1.1
      which-collection: 1.0.2
      which-typed-array: 1.1.19

  which-collection@1.0.2:
    dependencies:
      is-map: 2.0.3
      is-set: 2.0.3
      is-weakmap: 2.0.2
      is-weakset: 2.0.4

  which-typed-array@1.1.19:
    dependencies:
      available-typed-arrays: 1.0.7
      call-bind: 1.0.8
      call-bound: 1.0.4
      for-each: 0.3.5
      get-proto: 1.0.1
      gopd: 1.2.0
      has-tostringtag: 1.0.2

  which@2.0.2:
    dependencies:
      isexe: 2.0.0

  winston-transport@4.9.0:
    dependencies:
      logform: 2.7.0
      readable-stream: 3.6.2
      triple-beam: 1.4.1

  winston@3.17.0:
    dependencies:
      '@colors/colors': 1.6.0
      '@dabh/diagnostics': 2.0.3
      async: 3.2.6
      is-stream: 2.0.1
      logform: 2.7.0
      one-time: 1.0.0
      readable-stream: 3.6.2
      safe-stable-stringify: 2.5.0
      stack-trace: 0.0.10
      triple-beam: 1.4.1
      winston-transport: 4.9.0

  word-wrap@1.2.5: {}

  wrap-ansi@9.0.0:
    dependencies:
      ansi-styles: 6.2.1
      string-width: 7.2.0
      strip-ansi: 7.1.0

  wrappy@1.0.2: {}

  xml2js@0.6.2:
    dependencies:
      sax: 1.2.1
      xmlbuilder: 11.0.1

  xmlbuilder@11.0.1: {}

  xtend@4.0.2: {}

  yaml@2.0.0-1: {}

  yaml@2.7.1: {}

  yamljs@0.3.0:
    dependencies:
      argparse: 1.0.10
      glob: 7.2.3

  yn@3.1.1: {}

  yocto-queue@0.1.0: {}

  z-schema@5.0.5:
    dependencies:
      lodash.get: 4.4.2
      lodash.isequal: 4.5.0
      validator: 13.15.0
    optionalDependencies:
      commander: 9.5.0

  zod-to-json-schema@3.24.5(zod@3.24.4):
    dependencies:
      zod: 3.24.4

  zod@3.24.4: {}



================================================
FILE: README-VERCEL-OPTIMIZATION.md
================================================
# 🚀 Tối ưu Performance cho Vercel | Vercel Performance Optimization

## 📋 Tổng quan | Overview

## ⚡ Các cải tiến đã thực hiện | Implemented Optimizations

### 1. 🔧 **Cấu hình Vercel.json nâng cao**

```json
{
    "version": 2,
    "builds": [
        {
            "src": "src/server.ts",
            "use": "@vercel/node",
            "config": {
                "includeFiles": ["src/**", "swagger.yaml", "assets/**"]
            }
        }
    ],
    "functions": {
        "src/server.ts": {
            "maxDuration": 30
        }
    }
}
```

**Tính năng:**
- **Route-specific caching**: Các endpoint khác nhau có cache riêng biệt
- **Static asset optimization**: Cache lâu dài cho swagger, images
- **Security headers**: Bảo mật tự động cho tất cả API routes
- **Function timeout**: Tăng thời gian xử lý lên 30s

### 2. 🗄️ **Tối ưu MongoDB Connection**

```typescript
// Cached connection cho serverless
let cachedConnection: typeof mongoose | null = null;

private async connectToDatabase() {
    // Sử dụng connection cache
    if (cachedConnection && cachedConnection.connection.readyState === 1) {
        return cachedConnection;
    }

    const options = {
        // Connection pooling optimization
        maxPoolSize: 10,
        minPoolSize: 2,
        maxIdleTimeMS: 30000,
        // Serverless optimization
        bufferCommands: false,
        bufferMaxEntries: 0,
        // Faster timeouts
        serverSelectionTimeoutMS: 5000,
        connectTimeoutMS: 10000,
        socketTimeoutMS: 45000
    };
}
```

**Lợi ích:**
- **Connection reuse**: Tái sử dụng kết nối giữa các function calls
- **Faster cold starts**: Khởi động nhanh hơn với buffer optimization
- **Better pooling**: Quản lý connection pool hiệu quả

### 3. 💾 **In-Memory Caching System**

```typescript
// Cache middleware cho API responses
export const cacheMiddleware = (options: CacheOptions) => {
    // Tự động cache GET requests
    // TTL configurable per route
    // Condition-based caching
};

// Pre-configured cache cho các loại data
export const serviceCacheMiddleware = cacheMiddleware({
    ttl: 5 * 60 * 1000, // 5 phút
    condition: (req) => !req.headers.authorization
});

export const blogCacheMiddleware = cacheMiddleware({
    ttl: 3 * 60 * 1000, // 3 phút
});
```

**Áp dụng:**
```typescript
// Trong routes
router.get('/api/service', serviceCacheMiddleware, controller.getServices);
router.get('/api/blog', blogCacheMiddleware, controller.getBlogs);
```

### 4. 📊 **Performance Monitoring**

```typescript
// Database query optimization
const optimizedResults = DatabaseOptimizer.paginate(
    UserModel.find(filter),
    page,
    limit,
    { created_at: -1 }
);

// Performance tracking
const result = await PerformanceMonitor.monitor(
    'getUserData',
    () => userService.getData(userId)
);

// Memory management
MemoryManager.logMemoryUsage('After DB Query');
```

## 🎯 **Cách sử dụng tối ưu | How to Use Optimizations**

### **Bước 1: Cập nhật Routes với Cache**

```typescript
// TRƯỚC (Before) - No optimization
import { Router } from 'express';
import { authMiddleWare } from '../../core/middleware';

this.router.get(
    `${this.path}`,
    authMiddleWare([UserRoleEnum.ADMIN]),
    this.controller.listCases
);

// SAU (After) - With caching optimization  
import { Router } from 'express';
import { authMiddleWare } from '../../core/middleware';
import { cacheMiddleware } from '../../core/middleware/cache.middleware';

// Cache cho public data
const publicCacheMiddleware = cacheMiddleware({
    ttl: 5 * 60 * 1000, // 5 phút
    condition: (req) => !req.headers.authorization
});

// Cache cho authenticated data
const adminCacheMiddleware = cacheMiddleware({
    ttl: 2 * 60 * 1000, // 2 phút  
    condition: (req) => req.method === 'GET'
});

this.router.get(
    `${this.path}`,
    authMiddleWare([UserRoleEnum.ADMIN]),
    adminCacheMiddleware,
    this.controller.listCases
);
```

### **Bước 2: Tối ưu Database Queries**

```typescript
// TRƯỚC (Before) - Standard query
async listCases(req: Request, res: Response) {
    const { page = 1, limit = 10 } = req.query;
    const cases = await AdministrativeCase.find()
        .skip((page - 1) * limit)
        .limit(limit);
    
    const total = await AdministrativeCase.countDocuments();
    return res.json({ cases, total });
}

// SAU (After) - With optimization
async listCases(req: Request, res: Response) {
    const { page = 1, limit = 10 } = req.query;
    
    // Sử dụng DatabaseOptimizer
    const query = AdministrativeCase.find();
    const optimizedResults = await DatabaseOptimizer.paginate(
        query,
        Number(page),
        Number(limit),
        { created_at: -1 } // sort
    );
    
    // Tracking performance
    const result = await PerformanceMonitor.monitor('listCases', () => {
        return optimizedResults;
    });
    
    return res.json(result);
}
```

### **Bước 3: Optimized Service Layer**

```typescript
// service.ts - Với performance monitoring
class AdministrativeCasesService {
    
    async getCases(filters: any = {}, page: number = 1, limit: number = 10) {
        // Memory logging trước query
        MemoryManager.logMemoryUsage('Before DB Query');
        
        // Optimized query với lean() và select()
        let query = AdministrativeCase.find(filters);
        query = DatabaseOptimizer.lean(query);
        query = DatabaseOptimizer.select(query, 'title status created_at updated_at');
        
        const results = await DatabaseOptimizer.paginate(
            query, 
            page, 
            limit,
            { created_at: -1 }
        );
        
        // Memory logging sau query
        MemoryManager.logMemoryUsage('After DB Query');
        
        return results;
    }
    
    async getCaseById(id: string) {
        // Performance tracking cho single query
        return await PerformanceMonitor.monitor('getCaseById', async () => {
            let query = AdministrativeCase.findById(id);
            query = DatabaseOptimizer.lean(query);
            return await query.exec();
        });
    }
}
```

## 🚀 **Performance Best Practices**

### **1. Cache Strategy**

```typescript
// Cache levels theo độ ưu tiên
export const CacheStrategies = {
    // Public data - cache lâu nhất
    PUBLIC: { ttl: 10 * 60 * 1000, condition: (req) => !req.headers.authorization },
    
    // User-specific data - cache trung bình  
    USER: { ttl: 5 * 60 * 1000, condition: (req) => req.method === 'GET' },
    
    // Admin data - cache ngắn
    ADMIN: { ttl: 2 * 60 * 1000, condition: (req) => req.method === 'GET' },
    
    // Real-time data - không cache
    REALTIME: { ttl: 0 }
};
```

### **2. Database Query Patterns**

```typescript
// ✅ TỐT - Optimized query
const optimizedQuery = async () => {
    return await DatabaseOptimizer.paginate(
        Model.find(filter)
            .lean() // Faster object creation
            .select('field1 field2') // Only needed fields
            .populate('relation', 'name'), // Limited populate
        page,
        limit,
        { created_at: -1 }
    );
};

// ❌ TRÁNH - Non-optimized query
const slowQuery = async () => {
    const docs = await Model.find(filter); // Full objects
    const total = await Model.countDocuments(filter); // Separate count
    return { docs, total };
};
```

### **3. Memory Management**

```typescript
// Monitor memory usage trong critical operations
const performCriticalOperation = async () => {
    MemoryManager.logMemoryUsage('Start Operation');
    
    // Large data processing
    const results = await heavyDataProcessing();
    
    MemoryManager.logMemoryUsage('After Processing');
    
    // Clear memory if needed
    if (process.memoryUsage().heapUsed > 100 * 1024 * 1024) { // 100MB
        global.gc && global.gc();
        MemoryManager.logMemoryUsage('After GC');
    }
    
    return results;
};
```

## 📈 **Monitoring & Analytics**

### **Performance Metrics Dashboard**

```typescript
// Custom metrics tracking
app.get('/api/admin/performance', async (req, res) => {
    const metrics = {
        memory: process.memoryUsage(),
        uptime: process.uptime(),
        
        // Database connection status
        database: {
            status: PerformanceMonitor.getPoolStatus(),
            activeQueries: DatabaseOptimizer.getActiveQueries()
        },
        
        // Cache statistics
        cache: CacheManager.getStats(),
        
        // Recent performance logs
        recentLogs: PerformanceMonitor.getRecentLogs(10)
    };
    
    res.json(metrics);
});
```

## 🔧 **Environment Configuration**

### **Production Environment Variables**

```bash
# .env.production
NODE_ENV=production

# Database optimization
MONGODB_MAX_POOL_SIZE=10
MONGODB_MIN_POOL_SIZE=2
MONGODB_MAX_IDLE_TIME=30000

# Caching
CACHE_TTL_DEFAULT=300000  # 5 minutes
CACHE_MAX_SIZE=100        # Max cached items

# Performance
ENABLE_PERFORMANCE_MONITORING=true
ENABLE_MEMORY_LOGGING=true
GC_INTERVAL=60000         # Garbage collection interval

# Vercel specific
VERCEL_REGION=hkg1        # Hong Kong for Asia optimization
```

### **Package.json Scripts**

```json
{
    "scripts": {
        "start": "node dist/server.js",
        "build": "tsc && npm run copy-assets",
        "copy-assets": "cp -r assets dist/ && cp swagger.yaml dist/",
        "dev": "nodemon src/server.ts",
        "vercel-build": "npm run build",
        "test:performance": "node scripts/performance-test.js"
    }
}
```

## 🎯 **Deployment Checklist**

### **Pre-deployment**

- [ ] ✅ Verify `vercel.json` configuration
- [ ] ✅ Check environment variables
- [ ] ✅ Test caching middleware
- [ ] ✅ Validate database connection pooling
- [ ] ✅ Performance test critical endpoints
### Validate Password Security
- [ ] ✅ Test password security configuration
- [ ] ✅ Verify BCRYPT_SALT_ROUNDS setting
- [ ] ✅ Check password validation rules from env
- [ ] ✅ Test password hashing performance
- [ ] ✅ Validate security headers configuration


### **Post-deployment**

- [ ] 📊 Monitor `/api/admin/performance` endpoint
- [ ] 🔍 Check Vercel function logs
- [ ] ⚡ Test response times for cached vs uncached
- [ ] 💾 Verify memory usage patterns
- [ ] 🔄 Test pagination performance

## 📞 **Support & Troubleshooting**

### **Common Issues**

1. **High memory usage**: Enable garbage collection and monitor heap size
2. **Slow database queries**: Use `DatabaseOptimizer.lean()` and proper indexing
3. **Cache not working**: Check middleware order and cache conditions
4. **Connection timeouts**: Verify MongoDB connection pool settings

### **Debug Commands**

```bash
# Check memory usage
curl https://your-api.vercel.app/api/admin/performance

# Test specific endpoint performance
time curl https://your-api.vercel.app/api/your-endpoint

# View Vercel function logs
vercel logs your-function-name
```

---



================================================
FILE: render.yaml
================================================
services:
  - type: web
    name: rest-api-nodejs-express-mongodb
    env: node
    buildCommand: npm install -g pnpm && pnpm install && pnpm run build
    startCommand: pnpm start
    envVars:
      - key: NODE_ENV
        value: production



================================================
FILE: swagger.yaml
================================================
swagger: '2.0'
info:
  description: 'HuyIT Bloodline DNA Testing Service Management System API docs'
  version: '1.0.0'
  title: 'Bloodline DNA Testing Service Management System'
  termOfService: 'HuyIT'
  contact:
    email: 'huyit2003@gmail.com'
  license:
    name: 'MIT'
    url: 'https://opensource.org/licenses/MIT'
basePath: '/api'
tags:
- name: 'auth'
  description: 'Authentication APIs'
- name: 'users'
  description: 'User management APIs'
- name: 'services'
  description: 'Service management APIs'
- name: 'departments'
  description: 'Department management APIs'
- name: 'slots'
  description: 'Slot management APIs'
- name: 'kits'
  description: 'Kit management APIs'
- name: 'appointments'
  description: 'Appointment management APIs'
- name: 'appointment_logs'
  description: 'Appointment log APIs'

schemes:
- 'https'
- 'http'

# Declare security scheme
securityDefinitions:
  Bearer:
    type: 'apiKey'
    name: 'Authorization'
    in: 'header'
    description: 'Bearer token for authorization'
    x-tokenName: 'token'
    x-tokenPrefix: 'Bearer '

paths:
  /auth:
    post:
      tags:
      - 'auth'
      summary: 'Login API and get token'
      description: 'Input email and password'
      operationId: "login"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Login for user'
        required: true
        schema: 
          $ref: '#/definitions/LoginDto'
      responses:
        '200':
          description: 'Login successful'
          schema:
            $ref: '#/definitions/TokenResponse'
        '400':
          description: 'Invalid input'
    get:
      tags:
        - 'auth'
      summary: 'Get current logged-in user'
      description: 'Retrieve information about the current logged-in user'
      operationId: "getCurrentLoginUser"
      produces:
        - 'application/json'
      security:
        - Bearer: []
      responses:
        '200':
          description: 'Current logged-in user information'
          schema:
            $ref: '#/definitions/UserResponse'
        '401':
          description: 'Unauthorized - user not logged in'
        '404':
          description: 'User not found'

  /auth/google:
    post:
      tags:
      - 'auth'
      summary: 'Login API and get token By Google'
      description: 'Input google_id'
      operationId: "loginByGoogle"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Login for user via google'
        required: true
        schema: 
          $ref: '#/definitions/LoginGoogleDto'
      responses:
        '200':
          description: 'Login successful'
          schema:
            $ref: '#/definitions/TokenResponse'
        '400':
          description: 'Invalid input'
          
  /auth/verify-token:
    post:
      tags:
      - 'auth'
      summary: 'Verify Token'
      description: 'Input verifyToken'
      operationId: "verifyToken"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: ''
        required: true
        schema: 
          $ref: '#/definitions/VerifiedTokenDto'
      responses:
        '200':
          description: 'Token verified successfully'
        '400':
          description: 'Invalid input'
          
  /auth/resend-token:
    post:
      tags:
      - 'auth'
      summary: 'Resend Token'
      description: 'Resend verification token to user email'
      operationId: "resendToken"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Email to send verification token'
        required: true
        schema: 
          $ref: '#/definitions/EmailDto'
      responses:
        '200':
          description: 'Token resent successfully'
        '400':
          description: 'Invalid input'
          
  /auth/forgot-password:
    put:
      tags:
      - 'auth'
      summary: 'Forgot Password'
      description: 'Request a password reset'
      operationId: "forgotPassword"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Email to send reset password'
        required: true
        schema: 
          $ref: '#/definitions/EmailDto'
      responses:
        '200':
          description: 'Password reset email sent successfully'
        '400':
          description: 'Invalid input'
          
  /auth/logout:
    get:
      tags:
      - 'auth'
      summary: 'Logout'
      description: 'Logout current user session'
      operationId: "logout"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      responses:
        '200':
          description: 'Logout successful'
        '401':
          description: 'Unauthorized - user not logged in'

  # User routes
  /users:
    post:
      tags:
      - 'users'
      summary: 'Register new user'
      description: 'Register a new user account'
      operationId: "registerUser"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'User registration data'
        required: true
        schema: 
          $ref: '#/definitions/RegisterDto'
      responses:
        '201':
          description: 'User registered successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
          
  /users/generate:
    post:
      tags:
      - 'users'
      summary: 'Generate admin user'
      description: 'Generate default admin user'
      operationId: "generateAdminUser"
      produces:
      - 'application/json'
      responses:
        '201':
          description: 'Admin user created successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Error creating admin user'
          
  /users/google:
    post:
      tags:
      - 'users'
      summary: 'Register with Google'
      description: 'Register a new user with Google account'
      operationId: "registerWithGoogle"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Google registration data'
        required: true
        schema: 
          $ref: '#/definitions/LoginGoogleDto'
      responses:
        '201':
          description: 'User registered successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
          
  /users/create:
    post:
      tags:
      - 'users'
      summary: 'Create user (Admin only)'
      description: 'Create a new user (Admin only)'
      operationId: "createUser"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'User data'
        required: true
        schema: 
          $ref: '#/definitions/RegisterDto'
      responses:
        '201':
          description: 'User created successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/search:
    post:
      tags:
      - 'users'
      summary: 'Search users (Admin only)'
      description: 'Search for users with pagination'
      operationId: "searchUsers"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Search criteria and pagination'
        required: true
        schema: 
          $ref: '#/definitions/SearchPaginationUserDto'
      responses:
        '200':
          description: 'Search results'
          schema:
            $ref: '#/definitions/SearchPaginationResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/{id}:
    get:
      tags:
      - 'users'
      summary: 'Get user by ID'
      description: 'Get user information by ID'
      operationId: "getUserById"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'User ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'User information'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid ID'
        '404':
          description: 'User not found'
    put:
      tags:
      - 'users'
      summary: 'Update user'
      description: 'Update user information'
      operationId: "updateUser"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'User ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Updated user data'
        required: true
        schema: 
          $ref: '#/definitions/UpdateUserDto'
      responses:
        '200':
          description: 'User updated successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
    delete:
      tags:
      - 'users'
      summary: 'Delete user (Admin only)'
      description: 'Delete user by ID (soft delete)'
      operationId: "deleteUser"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'User ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'User deleted successfully'
        '400':
          description: 'Invalid ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'User not found'
          
  /users/change-password:
    put:
      tags:
      - 'users'
      summary: 'Change password'
      description: 'Change user password'
      operationId: "changePassword"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Password change data'
        required: true
        schema: 
          $ref: '#/definitions/ChangePasswordDto'
      responses:
        '200':
          description: 'Password changed successfully'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/change-status:
    put:
      tags:
      - 'users'
      summary: 'Change user status (Admin only)'
      description: 'Enable or disable a user account'
      operationId: "changeUserStatus"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Status change data'
        required: true
        schema: 
          $ref: '#/definitions/ChangeStatusDto'
      responses:
        '200':
          description: 'Status changed successfully'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/change-role:
    put:
      tags:
      - 'users'
      summary: 'Change user role (Admin only)'
      description: 'Change the role of a user'
      operationId: "changeUserRole"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Role change data'
        required: true
        schema: 
          $ref: '#/definitions/ChangeRoleDto'
      responses:
        '200':
          description: 'Role changed successfully'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /service/create:
    post:
      tags:
      - 'services'
      summary: 'Create new service (Admin, Manager only)'
      description: 'Create a new service '
      operationId: "createService"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Service information'
        required: true
        schema: 
          $ref: '#/definitions/CreateServiceDto'
      responses:
        '201':
          description: 'Service created successfully'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'

  /service/search:
    get:
      tags:
      - 'services'
      summary: 'Search and filter services (All roles)'
      description: 'Search services with pagination and filtering'
      operationId: "getServices"
      produces:
      - 'application/json'
      parameters:
      - in: 'query'
        name: 'type'
        description: 'Filter by service type (civil, administrative)'
        required: false
        type: 'string'
      - in: 'query'
        name: 'sample_method'
        description: 'Filter by sample method (self_collected, facility_collected, home_collected)'
        required: false
        type: 'string'
      - in: 'query'
        name: 'is_active'
        description: 'Filter by active status'
        required: false
        type: 'boolean'
      - in: 'query'
        name: 'min_price'
        description: 'Minimum price'
        required: false
        type: 'number'
      - in: 'query'
        name: 'max_price'
        description: 'Maximum price'
        required: false
        type: 'number'
      - in: 'query'
        name: 'pageNum'
        description: 'Page number'
        required: false
        type: 'integer'
        default: 1
      - in: 'query'
        name: 'pageSize'
        description: 'Items per page'
        required: false
        type: 'integer'
        default: 10
      - in: 'query'
        name: 'keyword'
        description: 'Search by name or description'
        required: false
        type: 'string'
      - in: 'query'
        name: 'sort_by'
        description: 'Sort field (name, price, created_at, estimated_time)'
        required: false
        type: 'string'
        default: 'created_at'
      - in: 'query'
        name: 'sort_order'
        description: 'Sort order (asc, desc)'
        required: false
        type: 'string'
        default: 'desc'
      - in: 'query'
        name: 'start_date'
        description: 'Filter by creation date (start)'
        required: false
        type: 'string'
        format: 'date'
      - in: 'query'
        name: 'end_date'
        description: 'Filter by creation date (end)'
        required: false
        type: 'string'
        format: 'date'
      responses:
        '200':
          description: 'Service list with pagination'
          schema:
            $ref: '#/definitions/ServicePaginationResponse'
        '401':
          description: 'Unauthorized'

  /service/{id}:
    get:
      tags:
      - 'services'
      summary: 'Get service by ID (All roles)'
      description: 'Retrieve service details by ID'
      operationId: "getServiceById"
      produces:
      - 'application/json'
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Service details'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'
          
    put:
      tags:
      - 'services'
      summary: 'Update service (Admin, Manager only)'
      description: 'Update service information'
      operationId: "updateService"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Updated service information'
        required: true
        schema: 
          $ref: '#/definitions/UpdateServiceDto'
      responses:
        '200':
          description: 'Service updated successfully'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

    delete:
      tags:
      - 'services'
      summary: 'Delete service (Admin, Manager only)'
      description: 'Delete service (soft delete)'
      operationId: "deleteService"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Service deleted successfully'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

  /service/{id}/child:
    get:
      tags:
      - 'services'
      summary: 'Get child services by parent service ID (All roles)'
      description: 'Retrieve all services that have the given service as their parent'
      operationId: "getChildServices"
      produces:
      - 'application/json'
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Parent service ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'List of child services'
          schema:
            type: array
            items:
              $ref: '#/definitions/ServiceResponse'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Parent service not found'

  /service/appointments:
    get:
      tags:
      - 'services'
      summary: 'Get services by appointment criteria (Admin, Manager, Staff only)'
      description: 'Filter services based on related appointments'
      operationId: "getServicesByAppointment"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'status'
        description: 'Filter by appointment status'
        required: false
        type: 'string'
      - in: 'query'
        name: 'start_appointment_date'
        description: 'Filter by appointment date (start)'
        required: false
        type: 'string'
        format: 'date'
      - in: 'query'
        name: 'end_appointment_date'
        description: 'Filter by appointment date (end)'
        required: false
        type: 'string'
        format: 'date'
      - in: 'query'
        name: 'appointment_type'
        description: 'Filter by appointment type (self, facility, home)'
        required: false
        type: 'string'
      - in: 'query'
        name: 'customer_id'
        description: 'Filter by customer ID'
        required: false
        type: 'string'
      - in: 'query'
        name: 'staff_id'
        description: 'Filter by staff ID'
        required: false
        type: 'string'
      - in: 'query'
        name: 'collection_address'
        description: 'Filter by collection address'
        required: false
        type: 'string'
      - in: 'query'
        name: 'pageNum'
        description: 'Page number'
        required: false
        type: 'integer'
        default: 1
      - in: 'query'
        name: 'pageSize'
        description: 'Items per page'
        required: false
        type: 'integer'
        default: 10
      responses:
        '200':
          description: 'Service list filtered by appointment data'
          schema:
            $ref: '#/definitions/ServicePaginationResponse'
        '401':
          description: 'Unauthorized'

  /department/create:
    post:
      tags:
      - 'departments'
      summary: 'Create new department (Admin only)'
      description: 'Create a new department with manager assignment'
      operationId: "createDepartment"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Department information'
        required: true
        schema: 
          $ref: '#/definitions/CreateDepartmentDto'
      responses:
        '201':
          description: 'Department created successfully'
          schema:
            $ref: '#/definitions/DepartmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '409':
          description: 'Department with this name already exists'

  /department/search:
    get:
      tags:
      - 'departments'
      summary: 'Search and filter departments (Admin, Manager, Laboratory Technician, Staff)'
      description: 'Search departments with pagination and filtering'
      operationId: "getDepartments"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'pageNum'
        description: 'Page number'
        required: false
        type: 'integer'
        default: 1
      - in: 'query'
        name: 'pageSize'
        description: 'Items per page'
        required: false
        type: 'integer'
        default: 10
      - in: 'query'
        name: 'keyword'
        description: 'Search by name or description'
        required: false
        type: 'string'
      - in: 'query'
        name: 'sort_by'
        description: 'Sort field (name, created_at, updated_at)'
        required: false
        type: 'string'
        default: 'created_at'
      - in: 'query'
        name: 'sort_order'
        description: 'Sort order (asc, desc)'
        required: false
        type: 'string'
        default: 'desc'
      - in: 'query'
        name: 'is_deleted'
        description: 'Filter by deletion status'
        required: false
        type: 'boolean'
        default: false
      - in: 'query'
        name: 'is_active'
        description: 'Filter by active status'
        required: false
        type: 'boolean'
      responses:
        '200':
          description: 'Department list with pagination'
          schema:
            $ref: '#/definitions/DepartmentPaginationResponse'
        '401':
          description: 'Unauthorized'

  /department/manager/{managerId}:
    get:
      tags:
      - 'departments'
      summary: 'Get departments by manager ID (Admin, Manager)'
      description: 'Retrieve departments managed by a specific manager'
      operationId: "getManagerDepartments"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'managerId'
        description: 'Manager ID'
        required: true
        type: 'string'
      - in: 'query'
        name: 'is_deleted'
        description: 'Filter by deletion status'
        required: false
        type: 'boolean'
        default: false
      responses:
        '200':
          description: 'List of departments managed by the manager'
          schema:
            type: 'object'
            properties:
              departments:
                type: 'array'
                items:
                  $ref: '#/definitions/DepartmentResponse'
              count:
                type: 'integer'
                description: 'Number of departments'
        '400':
          description: 'Invalid manager ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Manager not found'

  /department/count:
    get:
      tags:
      - 'departments'
      summary: 'Count departments (Admin, Manager)'
      description: 'Count total number of departments in the system'
      operationId: "countDepartments"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'is_deleted'
        description: 'Filter by deletion status'
        required: false
        type: 'boolean'
        default: false
      responses:
        '200':
          description: 'Count of departments'
          schema:
            type: 'object'
            properties:
              totalDepartments:
                type: 'integer'
                description: 'Total number of departments'
        '401':
          description: 'Unauthorized'

  /department/{id}:
    get:
      tags:
      - 'departments'
      summary: 'Get department by ID (Admin, Manager, Laboratory Technician, Staff)'
      description: 'Retrieve department details by ID'
      operationId: "getDepartmentById"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Department ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Department details'
          schema:
            $ref: '#/definitions/DepartmentResponse'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'
          
    put:
      tags:
      - 'departments'
      summary: 'Update department (Admin, Manager)'
      description: 'Update department information'
      operationId: "updateDepartment"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Department ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Updated department information'
        required: true
        schema: 
          $ref: '#/definitions/UpdateDepartmentDto'
      responses:
        '200':
          description: 'Department updated successfully'
          schema:
            $ref: '#/definitions/DepartmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'
        '409':
          description: 'Department with this name already exists'

    delete:
      tags:
      - 'departments'
      summary: 'Delete department (Admin only)'
      description: 'Delete department (soft delete)'
      operationId: "deleteDepartment"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Department ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Department deleted successfully'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  # Additional service endpoints (not already in your swagger.yaml)
  /service/statistics:
    get:
      tags:
      - 'services'
      summary: 'Get service statistics (Admin, Manager)'
      description: 'Count services grouped by type, status, and sample method'
      operationId: "countServicesByType"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'is_active'
        description: 'Filter by active status'
        required: false
        type: 'boolean'
      - in: 'query'
        name: 'keyword'
        description: 'Search by name or description'
        required: false
        type: 'string'
      responses:
        '200':
          description: 'Service statistics'
          schema:
            type: 'object'
            properties:
              total:
                type: 'integer'
                description: 'Total number of services'
              byType:
                type: 'object'
                description: 'Services counted by type'
                properties:
                  civil:
                    type: 'integer'
                  administrative:
                    type: 'integer'
              byStatus:
                type: 'object'
                description: 'Services counted by status'
                properties:
                  active:
                    type: 'integer'
                  inactive:
                    type: 'integer'
              bySampleMethod:
                type: 'object'
                description: 'Services counted by sample method'
                properties:
                  self_collected:
                    type: 'integer'
                  facility_collected:
                    type: 'integer'
                  home_collected:
                    type: 'integer'
        '401':
          description: 'Unauthorized'

  /service/{id}/status:
    patch:
      tags:
      - 'services'
      summary: 'Change service status (Admin, Manager)'
      description: 'Activate or deactivate a service'
      operationId: "changeServiceStatus"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Status change data'
        required: true
        schema:
          type: 'object'
          properties:
            is_active:
              type: 'boolean'
              description: 'New active status'
          required:
            - is_active
      responses:
        '200':
          description: 'Service status changed successfully'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '400':
          description: 'Invalid input or service is deleted'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

  # Staff Profile APIs
  /staff-profile/create:
    post:
      tags:
        - 'staff_profiles'
      summary: 'Create a new staff profile (Admin, Manager only)'
      description: 'Create a new staff profile with user and department association'
      operationId: 'createStaffProfile'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'body'
          name: 'body'
          description: 'Staff profile data'
          required: true
          schema:
            $ref: '#/definitions/CreateStaffProfileDto'
      responses:
        '201':
          description: 'Staff profile created successfully'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '409':
          description: 'User already has a staff profile'

  /staff-profile/search:
    get:
      tags:
        - 'staff_profiles'
      summary: 'Search staff profiles (Admin, Manager only)'
      description: 'Search for staff profiles with pagination and filtering'
      operationId: 'getStaffProfiles'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          description: 'Page number'
          required: false
          type: 'integer'
          default: 1
        - in: 'query'
          name: 'pageSize'
          description: 'Items per page'
          required: false
          type: 'integer'
          default: 10
        - in: 'query'
          name: 'department_id'
          description: 'Filter by department ID'
          required: false
          type: 'string'
        - in: 'query'
          name: 'status'
          description: 'Filter by staff status'
          required: false
          type: 'string'
        - in: 'query'
          name: 'keyword'
          description: 'Search by employee ID or job title'
          required: false
          type: 'string'
        - in: 'query'
          name: 'hire_date_from'
          description: 'Filter by hire date (start)'
          required: false
          type: 'string'
          format: 'date'
        - in: 'query'
          name: 'hire_date_to'
          description: 'Filter by hire date (end)'
          required: false
          type: 'string'
          format: 'date'
      responses:
        '200':
          description: 'Staff profile list with pagination'
          schema:
            $ref: '#/definitions/StaffProfilePaginationResponse'
        '401':
          description: 'Unauthorized'

  /staff-profile/department/{id}:
    get:
      tags:
        - 'staff_profiles'
      summary: 'Get staff profiles by department ID (Admin, Manager only)'
      description: 'Retrieve staff profiles associated with a specific department'
      operationId: 'getStaffProfilesByDepartment'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Department ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of staff profiles in the department'
          schema:
            $ref: '#/definitions/StaffProfilePaginationResponse'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  /staff-profile/{id}:
    get:
      tags:
        - 'staff_profiles'
      summary: 'Get staff profile by ID (Admin, Manager only)'
      description: 'Retrieve staff profile details by ID'
      operationId: 'getStaffProfileById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Staff profile ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'Staff profile details'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid staff profile ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'
    put:
      tags:
        - 'staff_profiles'
      summary: 'Update staff profile (Admin, Manager only)'
      description: 'Update staff profile information'
      operationId: 'updateStaffProfile'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Staff profile ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Updated staff profile data'
          required: true
          schema:
            $ref: '#/definitions/UpdateStaffProfileDto'
      responses:
        '200':
          description: 'Staff profile updated successfully'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'

  /staff-profile/{id}/status:
    put:
      tags:
        - 'staff_profiles'
      summary: 'Change staff status (Admin, Manager only)'
      description: 'Change the status of a staff profile'
      operationId: 'changeStaffStatus'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Staff profile ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Status change data'
          required: true
          schema:
            type: 'object'
            properties:
              status:
                type: 'string'
                description: 'New status'
                enum: ['active', 'on_leave', 'terminated']
      responses:
        '200':
          description: 'Staff status changed successfully'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'

  # Slot APIs
  /slot/create:
    post:
      tags:
        - slots
      summary: 'Create a new slot (Admin, Manager only)'
      description: 'Create a new slot for staff profiles'
      operationId: 'createSlot'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'body'
          name: 'body'
          description: 'Slot data'
          required: true
          schema:
            $ref: '#/definitions/CreateSlotDto'
      responses:
        '201':
          description: 'Slot created successfully'
          schema:
            $ref: '#/definitions/SlotResponse'
      '400':
        description: 'Invalid input'
      '401':
        description: 'Unauthorized'

  /slot/search:
    get:
      tags:
        - slots
      summary: 'Search slots with filters (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Search for slots with pagination and filtering'
      operationId: 'getSlots'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          type: 'integer'
          default: 1
          description: 'Page number for pagination'
        - in: 'query'
          name: 'pageSize'
          type: 'integer'
          default: 10
          description: 'Number of items per page'
        - in: 'query'
          name: 'staff_profile_ids'
          type: 'string'
          description: 'Filter by staff profile IDs (comma-separated or single value)'
        - in: 'query'
          name: 'department_id'
          type: 'string'
          description: 'Filter by department ID'
        - in: 'query'
          name: 'appointment_id'
          type: 'string'
          description: 'Filter by appointment ID'
        - in: 'query'
          name: 'status'
          type: 'string'
          enum: ['available', 'booked', 'unavailable']
          description: 'Filter by slot status'
        - in: 'query'
          name: 'date_from'
          type: 'string'
          format: 'date'
          description: 'Filter by start date (inclusive)'
        - in: 'query'
          name: 'date_to'
          type: 'string'
          format: 'date'
          description: 'Filter by end date (inclusive)'
        - in: 'query'
          name: 'sort_by'
          type: 'string'
          default: 'start_time'
          description: 'Field to sort by'
        - in: 'query'
          name: 'sort_order'
          type: 'integer'
          default: 1
          enum: [1, -1]
          description: 'Sort order (1: ascending, -1: descending)'
      responses:
        '200':
          description: 'Slot list with pagination'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '401':
          description: 'Unauthorized'

  /slot/available:
    get:
      tags:
        - slots
      summary: 'Get available slots for booking (Public)'
      description: 'Retrieve available slots for booking with optional filters'
      operationId: 'getAvailableSlots'
      produces:
        - 'application/json'
      parameters:
        - in: 'query'
          name: 'start_date'
          type: 'string'
          format: 'date'
          required: true
          description: 'Start date to search for available slots'
        - in: 'query'
          name: 'end_date'
          type: 'string'
          format: 'date'
          description: 'End date to search for available slots (defaults to 7 days from start_date if not provided)'
        - in: 'query'
          name: 'type'
          type: 'string'
          enum: ['self_collected', 'facility_collected', 'home_collected']
          description: 'Filter by sample collection method'
      responses:
        '200':
          description: 'Available slots with pagination'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid input (e.g., missing required parameters)'

  /slot/{id}:
    get:
      tags:
        - slots
      summary: 'Get slot by ID (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Retrieve slot details by ID'
      operationId: 'getSlotById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          type: 'string'
          required: true
      responses:
        '200':
          description: 'Slot details'
          schema:
            $ref: '#/definitions/SlotResponse'
        '400':
          description: 'Invalid slot ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Slot not found'
    put:
      tags:
        - slots
      summary: 'Update slot (Admin, Manager only)'
      description: 'Update slot information'
      operationId: 'updateSlot'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Slot ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Updated slot data'
          required: true
          schema:
            $ref: '#/definitions/UpdateSlotDto'
      responses:
        '200':
          description: 'Slot updated successfully'
          schema:
            $ref: '#/definitions/SlotResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Slot not found'

  /slot/{id}/status:
    patch:
      tags:
        - slots
      summary: 'Change slot status (Admin, Manager only)'
      description: 'Change the status of a slot'
      operationId: 'changeSlotStatus'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Slot ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Status change data'
          required: true
          schema:
            type: 'object'
            properties:
              status:
                type: 'string'
                description: 'New status'
                enum: ['available', 'booked', 'unavailable']
            required:
              - status
      responses:
        '200':
          description: 'Slot status changed successfully'
          schema:
            $ref: '#/definitions/SlotResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Slot not found'

  /slot/staff/{staffProfileId}:
    get:
      tags:
        - slots
      summary: 'Get slots by staff profile ID (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Retrieve slots associated with a specific staff profile'
      operationId: 'getSlotsByStaff'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'staffProfileId'
          description: 'Staff profile ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of slots for the staff profile'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid staff profile ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'

  /slot/department/{departmentId}:
    get:
      tags:
        - slots
      summary: 'Get slots by department ID (Admin, Manager only)'
      description: 'Retrieve slots associated with a specific department'
      operationId: 'getSlotsByDepartment'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'departmentId'
          description: 'Department ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of slots for the department'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  /slot/service/{serviceId}:
    get:
      tags:
        - slots
      summary: 'Get slots by service ID (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Retrieve slots associated with a specific service'
      operationId: 'getSlotsByService'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'serviceId'
          description: 'Service ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of slots for the service'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid service ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

  /department/{departmentId}/statistics:
    get:
      tags:
        - 'departments'
      summary: 'Get department performance statistics (Admin, Manager only)'
      description: 'Retrieve performance statistics for a department, including staff count, slot count, and booking rate'
      operationId: 'getDepartmentPerformance'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'departmentId'
          description: 'Department ID'
          required: true
          type: 'string'
        - in: 'query'
          name: 'date_from'
          description: 'Filter by start date'
          required: false
          type: 'string'
          format: 'date'
        - in: 'query'
          name: 'date_to'
          description: 'Filter by end date'
          required: false
          type: 'string'
          format: 'date'
      responses:
        '200':
          description: 'Department performance statistics'
          schema:
            type: 'object'
            properties:
              totalStaff:
                type: 'integer'
                description: 'Total number of active staff in the department'
              totalSlots:
                type: 'integer'
                description: 'Total number of slots'
              bookedSlots:
                type: 'integer'
                description: 'Number of booked slots'
              bookingRate:
                type: 'number'
                format: 'float'
                description: 'Booking rate percentage'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  # Kit APIs
  /kit/create:
    post:
      tags:
        - 'kits'
      summary: 'Create a new kit (Admin, Manager only)'
      description: 'Create a new kit with auto-generated code'
      operationId: 'createKit'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      responses:
        '201':
          description: 'Kit created successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '409':
          description: 'Kit code already exists'

  /kit/search:
    get:
      tags:
        - 'kits'
      summary: 'Search kits (Admin, Manager, Staff only)'
      description: 'Search for kits with pagination and filtering'
      operationId: 'searchKits'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          description: 'Page number'
          required: false
          type: 'integer'
          default: 1
        - in: 'query'
          name: 'pageSize'
          description: 'Items per page'
          required: false
          type: 'integer'
          default: 10
        - in: 'query'
          name: 'code'
          description: 'Filter by kit code'
          required: false
          type: 'string'
        - in: 'query'
          name: 'status'
          description: 'Filter by kit status'
          required: false
          type: 'string'
          enum: ['available', 'assigned', 'used', 'returned', 'damaged']
        - in: 'query'
          name: 'appointment_id'
          description: 'Filter by appointment ID'
          required: false
          type: 'string'
        - in: 'query'
          name: 'assigned_to_user_id'
          description: 'Filter by assigned user ID'
          required: false
          type: 'string'
      responses:
        '200':
          description: 'Kit list with pagination'
          schema:
            $ref: '#/definitions/KitPaginationResponse'
        '401':
          description: 'Unauthorized'

  /kit/available:
    get:
      tags:
        - 'kits'
      summary: 'Get available kits (Admin, Manager, Staff only)'
      description: 'Retrieve all available kits'
      operationId: 'getAvailableKits'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      responses:
        '200':
          description: 'List of available kits'
          schema:
            type: 'array'
            items:
              $ref: '#/definitions/KitResponse'
        '401':
          description: 'Unauthorized'

  /kit/{id}:
    get:
      tags:
        - 'kits'
      summary: 'Get kit by ID (Admin, Manager, Staff only)'
      description: 'Retrieve kit details by ID'
      operationId: 'getKitById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'Kit details'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid kit ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'
    put:
      tags:
        - 'kits'
      summary: 'Update kit (Admin, Manager only)'
      description: 'Update kit information'
      operationId: 'updateKit'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Updated kit data'
          required: true
          schema:
            $ref: '#/definitions/UpdateKitDto'
      responses:
        '200':
          description: 'Kit updated successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'
    delete:
      tags:
        - 'kits'
      summary: 'Delete kit (Admin, Manager only)'
      description: 'Mark a kit as damaged'
      operationId: 'deleteKit'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'Kit deleted successfully'
          schema:
            $ref: '#/definitions/SuccessResponse'
        '400':
          description: 'Invalid kit ID or kit is currently assigned/in use'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'

  /kit/{id}/status:
    patch:
      tags:
        - 'kits'
      summary: 'Change kit status (Admin, Manager, Staff only)'
      description: 'Change the status of a kit'
      operationId: 'changeKitStatus'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Status change data'
          required: true
          schema:
            type: 'object'
            properties:
              status:
                type: 'string'
                description: 'New status'
                enum: ['available', 'assigned', 'used', 'returned', 'damaged']
            required:
              - status
      responses:
        '200':
          description: 'Kit status changed successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'

  /kit/{id}/return:
    post:
      tags:
        - 'kits'
      summary: 'Return a kit (Admin, Manager, Staff only)'
      description: 'Return a previously assigned or used kit'
      operationId: 'returnKit'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Return notes (optional)'
          required: false
          schema:
            type: 'object'
            properties:
              notes:
                type: string
                description: 'Notes about the returned kit'
      responses:
        '200':
          description: 'Kit returned successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input or kit is not in assigned/used status'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'

  # Appointment APIs
  /appointment/create:
    post:
      tags:
        - 'appointments'
      summary: 'Create a new appointment (Customer only)'
      description: 'Create a new appointment for a service'
      operationId: 'createAppointment'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'body'
          name: 'body'
          description: 'Appointment data'
          required: true
          schema:
            $ref: '#/definitions/CreateAppointmentDto'
      responses:
        '201':
          description: 'Appointment created successfully'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'

  /appointment/search:
    get:
      tags:
        - 'appointments'
      summary: 'Search appointments'
      description: 'Search for appointments with pagination and filtering'
      operationId: 'searchAppointments'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          type: 'integer'
          default: 1
        - in: 'query'
          name: 'pageSize'
          type: 'integer'
          default: 10
        - in: 'query'
          name: 'status'
          type: 'string'
        - in: 'query'
          name: 'customer_id'
          type: 'string'
        - in: 'query'
          name: 'service_id'
          type: 'string'
        - in: 'query'
          name: 'staff_id'
          type: 'string'
        - in: 'query'
          name: 'date_from'
          type: 'string'
          format: 'date'
        - in: 'query'
          name: 'date_to'
          type: 'string'
          format: 'date'
    responses:
      '200':
        description: 'Appointment list with pagination'
        schema:
          $ref: '#/definitions/AppointmentPaginationResponse'
      '401':
        description: 'Unauthorized'

  /appointment/{id}:
    get:
      tags:
        - 'appointments'
      summary: 'Get appointment by ID'
      description: 'Retrieve appointment details by ID'
      operationId: 'getAppointmentById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          type: 'string'
          required: true
      responses:
        '200':
          description: 'Appointment details'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid appointment ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

  /appointment/{id}/assign-staff:
    put:
      tags:
        - 'appointments'
      summary: 'Assign staff to appointment (Manager only)'
      description: 'Assign staff to an existing appointment'
      operationId: 'assignStaffToAppointment'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Appointment ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Staff assignment data'
          required: true
          schema:
            $ref: '#/definitions/AssignStaffDto'
      responses:
        '200':
          description: 'Staff assigned successfully'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

  /appointment/{id}/confirm:
    put:
      tags:
        - 'appointments'
      summary: 'Confirm appointment and assign kit (Staff only)'
      description: 'Confirm an appointment, assign a kit, and update its status'
      operationId: 'confirmAppointment'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Appointment ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Confirmation data with kit assignment'
          required: true
          schema:
            $ref: '#/definitions/ConfirmAppointmentDto'
      responses:
        '200':
          description: 'Appointment confirmed successfully'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

  # Appointment Log APIs
  /appointment-logs/appointment/{appointmentId}:
    get:
      tags:
        - 'appointment_logs'
      summary: 'Get logs by appointment ID'
      description: 'Retrieve all logs for a specific appointment'
      operationId: 'getLogsByAppointment'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'appointmentId'
          description: 'Appointment ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of appointment logs'
          schema:
            type: 'array'
            items:
              $ref: '#/definitions/AppointmentLogResponse'
        '400':
          description: 'Invalid appointment ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

definitions:
  LoginDto:
    type: object
    properties:
      email:
        type: string
        format: email
        description: "User's email address"
        example: "string"
      password:
        type: string
        description: "User's password"
        minLength: 6
        example: "string"
    required:
      - email
      - password
      
  LoginGoogleDto:
    type: object
    properties:
      google_id:
        type: string
        description: "Google ID token"
        example: "string"
    required:
      - google_id
      
  VerifiedTokenDto:
    type: object
    properties:
      token:
        type: string
        description: "Verification token"
        example: "string"
    required:
      - token
      
  EmailDto:
    type: object
    properties:
      email:
        type: string
        format: email
        description: "User's email address"
        example: "string"
    required:
      - email
      
  TokenResponse:
    type: object
    properties:
      token:
        type: string
        description: "JWT authentication token"
        
  UserResponse:
    type: object
    properties:
      _id:
        type: string
        description: "User ID"
      first_name:
        type: string
        description: "User's first name"
      last_name:
        type: string
        description: "User's last name"
      email:
        type: string
        format: email
        description: "User's email address"
      google_id:
        type: string
        description: "Google ID (if applicable)"
      role:
        type: string
        enum: ["admin", "manager", "staff", "customer"]
        description: "User role"
      status:
        type: boolean
        description: "User account status"
      phone_number:
        type: string
        description: "User's phone number"
      avatar_url:
        type: string
        description: "URL to user's avatar"
      dob:
        type: string
        format: date
        description: "Date of birth"
      is_verified:
        type: boolean
        description: "Email verification status"
      created_at:
        type: string
        format: date-time
        description: "Account creation date"
      updated_at:
        type: string
        format: date-time
        description: "Account last update date"
        
  RegisterDto:
    type: object
    properties:
      google_id:
        type: string
        description: "Google ID (optional)"
      first_name:
        type: string
        description: "User's first name"
      last_name:
        type: string
        description: "User's last name"
      email:
        type: string
        format: email
        description: "User's email address"
      password:
        type: string
        minLength: 6
        description: "User's password"
      role:
        type: string
        enum: ["customer", "manager", "staff", "admin"]
        description: "User role"
      phone_number:
        type: string
        description: "User's phone number"
      avatar_url:
        type: string
        description: "URL to user's avatar"
      dob:
        type: string
        format: date
        description: "Date of birth"
      address:
        type: string
        description: "User's address"
      gender:
        type: string
        description: "User's gender"
    required:
      - first_name
      - last_name
      - email
      - password
      - phone_number
      - dob

  UpdateUserDto:
    type: object
    properties:
      first_name:
        type: string
        description: "User's first name"
      last_name:
        type: string
        description: "User's last name"
      phone_number:
        type: string
        description: "User's phone number"
      avatar_url:
        type: string
        description: "URL to user's avatar"
      dob:
        type: string
        format: date
        description: "Date of birth"
      address:
        type: string
        description: "User's address"
      gender:
        type: string
        description: "User's gender"
    required:
      - first_name
      - last_name
      
  ChangePasswordDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      old_password:
        type: string
        description: "Current password"
        minLength: 6
      new_password:
        type: string
        description: "New password"
        minLength: 6
    required:
      - user_id
      - old_password
      - new_password
      
  ChangeStatusDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      status:
        type: boolean
        description: "New status (true=active, false=inactive)"
    required:
      - user_id
      - status
      
  ChangeRoleDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      role:
        type: string
        enum: ["admin", "manager", "staff", "customer"]
        description: "New user role"
    required:
      - user_id
      - role
      
  SearchUserDto:
    type: object
    properties:
      keyword:
        type: string
        description: "Search keyword (email, first name, last name)"
        example: "string"
      role:
        type: string
        enum: ["", "all", "admin", "manager", "staff", "customer"]
        description: "Filter by role"
        example: ""
      is_verified:
        type: boolean
        description: "Filter by verification status"
        example: "true"
      status:
        type: boolean
        description: "Filter by user status"
        example: "true"
      is_deleted:
        type: boolean
        description: "Include deleted users"
        example: "false"
        
  PaginationRequestModel:
    type: object
    properties:
      pageNum:
        type: integer
        minimum: 1
        description: "Page number (starting from 1)"
        default: 1
      pageSize:
        type: integer
        minimum: 1
        description: "Number of items per page"
        default: 10
        
  SearchPaginationUserDto:
    type: object
    properties:
      pageInfo:
        $ref: '#/definitions/PaginationRequestModel'
      searchCondition:
        $ref: '#/definitions/SearchUserDto'
        
  SearchPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/UserResponse'
      pageInfo:
        type: object
        properties:
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"

  CreateServiceDto:
    type: object
    properties:
      name:
        type: string
        description: "Service name"
      description:
        type: string
        description: "Service description"
      parent_service_id:
        type: string
        description: "Parent service ID (optional)"
      price:
        type: number
        description: "Service price"
      type:
        type: string
        enum: ["civil", "administrative"]
        description: "Service type"
      sample_method:
        type: string
        enum: ["self_collected", "facility_collected", "home_collected"]
        description: "Sample collection method"
      estimated_time:
        type: number
        description: "Estimated time in hours"
    required:
      - name
      - description
      - price
      - type
      - sample_method
      - estimated_time

  UpdateServiceDto:
    type: object
    properties:
      name:
        type: string
        description: "Service name"
      description:
        type: string
        description: "Service description"
      parent_service_id:
        type: string
        description: "Parent service ID (optional)"
      price:
        type: number
        description: "Service price"
      type:
        type: string
        enum: ["civil", "administrative"]
        description: "Service type"
      sample_method:
        type: string
        enum: ["self_collected", "facility_collected", "home_collected"]
        description: "Sample collection method"
      estimated_time:
        type: number
        description: "Estimated time in hours"
    required:
      - name
      - description
      - price
      - type
      - sample_method
      - estimated_time

  ServiceResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Service ID"
      name:
        type: string
        description: "Service name"
      description:
        type: string
        description: "Service description"
      parent_service_id:
        type: string
        description: "Parent service ID (if any)"
      price:
        type: number
        description: "Service price"
      type:
        type: string
        enum: ["civil", "administrative"]
        description: "Service type"
      sample_method:
        type: string
        enum: ["self_collected", "facility_collected", "home_collected"]
        description: "Sample collection method"
      estimated_time:
        type: number
        description: "Estimated time in hours"
      is_active:
        type: boolean
        description: "Service status"
      is_deleted:
        type: boolean
        description: "Service deletion status"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  ServicePaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/ServiceResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateDepartmentDto:
    type: object
    properties:
      name:
        type: string
        description: "Department name"
        example: "Cardiology Department"
      description:
        type: string
        description: "Department description"
        example: "Department for heart-related services"
      manager_id:
        type: string
        description: "Manager ID (must be a user with MANAGER role)"
        example: "60d0fe4f5311236168a109ca"
    required:
      - name
      - description
      - manager_id

  UpdateDepartmentDto:
    type: object
    properties:
      name:
        type: string
        description: "Department name"
        example: "Cardiology Department"
      description:
        type: string
        description: "Department description"
        example: "Department for heart-related services"
      manager_id:
        type: string
        description: "Manager ID (must be a user with MANAGER role)"
        example: "60d0fe4f5311236168a109ca"
    required:
      - name
      - description
      - manager_id

  DepartmentResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Department ID"
      name:
        type: string
        description: "Department name"
      description:
        type: string
        description: "Department description"
      manager_id:
        type: object
        description: "Manager information"
        properties:
          _id:
            type: string
            description: "Manager ID"
          first_name:
            type: string
            description: "Manager's first name"
          last_name:
            type: string
            description: "Manager's last name"
          email:
            type: string
            description: "Manager's email"
      is_deleted:
        type: boolean
        description: "Deletion status"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  DepartmentPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/DepartmentResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateStaffProfileDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      department_id:
        type: string
        description: "Department ID"
      job_title:
        type: string
        description: "Job title"
      hire_date:
        type: string
        format: date
        description: "Hire date"
      salary:
        type: number
        description: "Salary"
      qualifications:
        type: array
        items:
          $ref: '#/definitions/Qualification'
    required:
      - user_id
      - department_id
      - job_title
      - hire_date
      - salary

  UpdateStaffProfileDto:
    type: object
    properties:
      department_id:
        type: string
        description: "Department ID"
      job_title:
        type: string
        description: "Job title"
      hire_date:
        type: string
        format: date
        description: "Hire date"
      salary:
        type: number
        description: "Salary"
      qualifications:
        type: array
        items:
          $ref: '#/definitions/Qualification'
    required:
      - department_id
      - job_title
      - hire_date
      - salary

  StaffProfileResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Staff profile ID"
      user_id:
        type: string
        description: "User ID"
      department_id:
        type: string
        description: "Department ID"
      job_title:
        type: string
        description: "Job title"
      hire_date:
        type: string
        format: date
        description: "Hire date"
      employee_id:
        type: string
        description: "Employee ID"
      salary:
        type: number
        description: "Salary"
      status:
        type: string
        description: "Status"
      qualifications:
        type: array
        items:
          $ref: '#/definitions/Qualification'
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  StaffProfilePaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/StaffProfileResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  Qualification:
    type: object
    properties:
      name:
        type: string
        description: "Qualification name"
      institution:
        type: string
        description: "Institution name"
      issue_date:
        type: string
        format: date
        description: "Issue date"
      expiry_date:
        type: string
        format: date
        description: "Expiry date"
      description:
        type: string
        description: "Description"

  CreateSlotDto:
    type: object
    properties:
      staff_profile_ids:
        type: array
        items:
          type: string
        description: "Array of staff profile IDs"
      service_id:
        type: string
        description: "Service ID"
      time_slots:
        type: array
        items:
          $ref: '#/definitions/TimeSlotDto'
        description: "Array of time slots"
      appointment_limit:
        type: integer
        description: "Maximum number of appointments allowed per slot"
    required:
      - staff_profile_ids
      - service_id
      - time_slots
      - appointment_limit

  TimeSlotDto:
    type: object
    properties:
      year:
        type: integer
        description: "Year"
      month:
        type: integer
        description: "Month (1-12)"
      day:
        type: integer
        description: "Day of month"
      start_time:
        $ref: '#/definitions/TimePointDto'
      end_time:
        $ref: '#/definitions/TimePointDto'
    required:
      - year
      - month
      - day
      - start_time
      - end_time

  TimePointDto:
    type: object
    properties:
      hour:
        type: integer
        minimum: 0
        maximum: 23
        description: "Hour (0-23)"
      minute:
        type: integer
        minimum: 0
        maximum: 59
        description: "Minute (0-59)"
    required:
      - hour
      - minute

  UpdateSlotDto:
    type: object
    properties:
      staff_profile_ids:
        type: array
        items:
          type: string
        description: "Array of staff profile IDs"
      service_id:
        type: string
        description: "Service ID"
      time_slots:
        type: array
        items:
          $ref: '#/definitions/TimeSlotDto'
        description: "Array of time slots"
      appointment_limit:
        type: integer
        description: "Maximum number of appointments allowed per slot"
      status:
        type: string
        enum: ["available", "booked", "unavailable"]
        description: "Slot status"
    required:
      - staff_profile_ids
      - service_id
      - time_slots
      - appointment_limit

  SlotResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Slot ID"
      staff_profile_ids:
        type: array
        items:
          type: object
          properties:
            _id:
              type: string
            employee_id:
              type: string
            job_title:
              type: string
            user_id:
              type: object
              properties:
                _id:
                  type: string
                first_name:
                  type: string
                last_name:
                  type: string
                email:
                  type: string
        description: "Array of staff profiles assigned to this slot"
      service_id:
        type: string
        description: "Service ID"
      appointment_id:
        type: object
        properties:
          _id:
            type: string
          code:
            type: string
          status:
            type: string
        description: "Associated appointment (if any)"
      time_slots:
        type: array
        items:
          $ref: '#/definitions/TimeSlotDto'
        description: "Array of time slots"
      appointment_limit:
        type: integer
        description: "Maximum number of appointments allowed per slot"
      status:
        type: string
        enum: ["available", "booked", "unavailable"]
        description: "Slot status"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  SlotPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/SlotResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateKitDto:
    type: object
    properties:
      code:
        type: string
        description: "Kit code (optional, will be auto-generated if not provided)"
        pattern: "^KIT-\\d{8}-\\d{3}$"
        example: "KIT-20230101-001"

  UpdateKitDto:
    type: object
    properties:
      notes:
        type: string
        description: "Notes about the kit"

  KitResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Kit ID"
      code:
        type: string
        description: "Kit code"
        example: "KIT-20230101-001"
      status:
        type: string
        description: "Kit status"
        enum: ["available", "assigned", "used", "returned", "damaged"]
      appointment_id:
        type: object
        description: "Associated appointment (if any)"
      assigned_to_user_id:
        type: object
        description: "User assigned to the kit (if any)"
      assigned_date:
        type: string
        format: date-time
        description: "Date when kit was assigned"
      return_date:
        type: string
        format: date-time
        description: "Date when kit was returned"
      notes:
        type: string
        description: "Notes about the kit"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  KitPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/KitResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateAppointmentDto:
    type: object
    properties:
      service_id:
        type: string
        description: "Service ID"
        example: "60d0fe4f5311236168a109ca"
      slot_id:
        type: string
        description: "Slot ID (optional)"
        example: "60d0fe4f5311236168a109cb"
      appointment_date:
        type: string
        format: date-time
        description: "Appointment date and time (optional if slot_id is provided)"
        example: "2023-10-15T14:30:00Z"
      type:
        type: string
        enum: ["self", "facility", "home"]
        description: "Type of appointment"
        example: "facility"
      collection_address:
        type: string
        description: "Address for home collection (required for home type)"
        example: "123 Main St, City, Country"
    required:
      - service_id
      - type

  AssignStaffDto:
    type: object
    properties:
      staff_id:
        type: string
        description: "Staff ID to assign to the appointment"
        example: "60d0fe4f5311236168a109cc"
    required:
      - staff_id

  ConfirmAppointmentDto:
    type: object
    properties:
      kit_id:
        type: string
        description: "Kit ID to assign to the appointment"
        example: "60d0fe4f5311236168a109cd"
    required:
      - kit_id

  AppointmentResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Appointment ID"
      user_id:
        type: object
        description: "Customer information"
      service_id:
        type: object
        description: "Service information"
      staff_id:
        type: object
        description: "Staff information (if assigned)"
      slot_id:
        type: string
        description: "Associated slot ID (if any)"
      appointment_date:
        type: string
        format: date-time
        description: "Appointment date and time"
      type:
        type: string
        enum: ["self", "facility", "home"]
        description: "Type of appointment"
      collection_address:
        type: string
        description: "Address for home collection"
      status:
        type: string
        description: "Appointment status"
        enum: ["pending", "confirmed", "sample_collected", "sample_received", "testing", "completed", "cancelled"]
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  AppointmentPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/AppointmentResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  AppointmentLogResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Log ID"
      appointment_id:
        type: string
        description: "Appointment ID"
      action:
        type: string
        description: "Action performed"
        enum: ["created", "updated", "status_changed", "staff_assigned", "feedback_added"]
      previous_state:
        type: object
        description: "Previous state of the appointment"
      new_state:
        type: object
        description: "New state of the appointment"
      performed_by:
        type: string
        description: "User ID who performed the action"
      notes:
        type: string
        description: "Additional notes"
      created_at:
        type: string
        format: date-time
        description: "Log creation date"

  SuccessResponse:
    type: object
    properties:
      success:
        type: boolean
        description: "Success status"
        example: true
      message:
        type: string
        description: "Success message"
        example: "Operation completed successfully"


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "typeRoots": [
      "./src/types",
    ],
    "target": "ES6",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "sourceMap": true,
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true
    // "baseUrl": "./src",
    // "paths": {
    //     "modules/*": ["modules/*"],
    //     "core/*": ["core/*"]
    // }
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.json",
    "src/modules/auth/swagger/auth.swagger.js",
  ],
  "exclude": [
    "node_modules"
  ]
}


================================================
FILE: vercel.json
================================================
{
    "version": 2,
    "builds": [
        {
            "src": "src/server.ts",
            "use": "@vercel/node"
        }
    ],
    "routes": [
        {
            "src": "/health",
            "dest": "/src/server.ts"
        },
        {
            "src": "/api-docs",
            "dest": "/src/server.ts"
        },
        {
            "src": "/swagger/(.*)",
            "dest": "/src/server.ts"
        },
        {
            "src": "/images/(.*)",
            "dest": "/src/server.ts"
        },
        {
            "src": "/api/(.*)",
            "dest": "/src/server.ts"
        },
        {
            "src": "/(.*)",
            "dest": "/src/server.ts"
        }
    ],
    "env": {
        "NODE_ENV": "production"
    }
}


================================================
FILE: web.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.webServer>
    <handlers>
      <add name="iisnode" path="dist/index.js" verb="*" modules="iisnode"/>
    </handlers>
    <rewrite>
      <rules>
        <rule name="NodeInspector" patternSyntax="ECMAScript" stopProcessing="true">
          <match url="^dist/index.js\/debug[\/]?" />
          <action type="Rewrite" url="http://localhost:8080/debug?port=5858" />
        </rule>
        <rule name="StaticContent">
          <action type="Rewrite" url="public{REQUEST_URI}"/>
        </rule>
        <rule name="DynamicContent">
          <conditions>
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="True"/>
          </conditions>
          <action type="Rewrite" url="dist/index.js"/>
        </rule>
      </rules>
    </rewrite>
    <iisnode 
      loggingEnabled="true"
      devErrorsEnabled="true"
      debuggingEnabled="false"
      node_env="production"
    />
    <security>
      <requestFiltering>
        <hiddenSegments>
          <add segment="node_modules"/>
        </hiddenSegments>
      </requestFiltering>
    </security>
  </system.webServer>
</configuration>


================================================
FILE: webpack.config.js
================================================
const path = require('path');
const nodeExternals = require('webpack-node-externals'); // Fix bug for express
const WebpackShellPlugin = require('webpack-shell-plugin'); // Run command after build finish
const TsconfigPathsPlugin = require('tsconfig-paths-webpack-plugin'); // Resolve module in tsconfig.json for webpack

const { NODE_ENV = 'production' } = process.env;
module.exports = {
    entry: './src/server.ts',
    watch: NODE_ENV === 'development',
    mode: NODE_ENV,
    target: 'node',
    externals: [nodeExternals()],
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'server.js',
    },
    resolve: {
        extensions: ['.ts', '.js'],
        plugins: [
            new TsconfigPathsPlugin({
                configFile: './tsconfig.json',
            }),
        ],
    },
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: ['ts-loader'],
                exclude: /node_modules/,
            },
        ],
    },
    context: path.resolve(__dirname)
};



================================================
FILE: .eslintrc
================================================
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 2021,
        "sourceType": "module",
        "project": "./tsconfig.json"
    },
    "plugins": [
        "@typescript-eslint",
        "import"
    ],
    "extends": [
        "eslint:recommended",
        "plugin:@typescript-eslint/recommended",
        "plugin:@typescript-eslint/recommended-requiring-type-checking",
        "plugin:import/errors",
        "plugin:import/warnings",
        "plugin:import/typescript",
        "prettier"
    ],
    "rules": {
        // Error prevention
        "no-console": "error",
        "no-return-await": "error",
        "no-unused-vars": "off",
        "@typescript-eslint/no-unused-vars": [
            "error",
            {
                "argsIgnorePattern": "^_",
                "varsIgnorePattern": "^_"
            }
        ],
        "@typescript-eslint/explicit-function-return-type": [
            "error",
            {
                "allowExpressions": true
            }
        ],
        "@typescript-eslint/no-explicit-any": "error",
        "@typescript-eslint/no-unsafe-assignment": "error",
        "@typescript-eslint/no-unsafe-member-access": "error",
        "@typescript-eslint/no-unsafe-call": "error",
        // Code style
        "@typescript-eslint/naming-convention": [
            "error",
            {
                "selector": "interface",
                "format": [
                    "PascalCase"
                ],
                "prefix": [
                    "I"
                ]
            },
            {
                "selector": "typeAlias",
                "format": [
                    "PascalCase"
                ]
            },
            {
                "selector": "enum",
                "format": [
                    "PascalCase"
                ]
            }
        ],
        "@typescript-eslint/explicit-member-accessibility": [
            "error",
            {
                "overrides": {
                    "constructors": "no-public"
                }
            }
        ],
        "import/order": [
            "error",
            {
                "groups": [
                    "builtin",
                    "external",
                    "internal",
                    "parent",
                    "sibling",
                    "index"
                ],
                "newlines-between": "always",
                "alphabetize": {
                    "order": "asc",
                    "caseInsensitive": true
                }
            }
        ]
    },
    "overrides": [
        {
            "files": [
                "src/**/*.ts"
            ],
            "rules": {
                // Module-specific rules
                "import/no-unresolved": "error",
                "import/no-cycle": "error",
                "import/no-self-import": "error"
            }
        }
    ],
    "settings": {
        "import/resolver": {
            "node": {
                "extensions": [
                    ".js",
                    ".ts"
                ]
            },
            "typescript": {
                "alwaysTryTypes": true
            }
        }
    }
}


================================================
FILE: .lintstagedrc
================================================
{
  "*.ts": [
    "eslint --fix",
    "prettier --write"
  ]
} 


================================================
FILE: .prettierrc
================================================
{
    "semi": true,
    "trailingComma": "all",
    "singleQuote": true,
    "printWidth": 240,
    "tabWidth": 4
}


================================================
FILE: assets/fonts/NotoSans-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/NotoSans-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/NotoSans-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/NotoSans-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/NotoSans-Italic-VariableFont_wdth,wght.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/NotoSans-VariableFont_wdth,wght.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/OFL.txt
================================================
Copyright 2022 The Noto Project Authors (https://github.com/notofonts/latin-greek-cyrillic)

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
https://openfontlicense.org


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.



================================================
FILE: assets/fonts/Noto_Sans/README.txt
================================================
Noto Sans Variable Font
=======================

This download contains Noto Sans as both variable fonts and static fonts.

Noto Sans is a variable font with these axes:
  wdth
  wght

This means all the styles are contained in these files:
  NotoSans-VariableFont_wdth,wght.ttf
  NotoSans-Italic-VariableFont_wdth,wght.ttf

If your app fully supports variable fonts, you can now pick intermediate styles
that aren’t available as static fonts. Not all apps support variable fonts, and
in those cases you can use the static font files for Noto Sans:
  static/NotoSans_ExtraCondensed-Thin.ttf
  static/NotoSans_ExtraCondensed-ExtraLight.ttf
  static/NotoSans_ExtraCondensed-Light.ttf
  static/NotoSans_ExtraCondensed-Regular.ttf
  static/NotoSans_ExtraCondensed-Medium.ttf
  static/NotoSans_ExtraCondensed-SemiBold.ttf
  static/NotoSans_ExtraCondensed-Bold.ttf
  static/NotoSans_ExtraCondensed-ExtraBold.ttf
  static/NotoSans_ExtraCondensed-Black.ttf
  static/NotoSans_Condensed-Thin.ttf
  static/NotoSans_Condensed-ExtraLight.ttf
  static/NotoSans_Condensed-Light.ttf
  static/NotoSans_Condensed-Regular.ttf
  static/NotoSans_Condensed-Medium.ttf
  static/NotoSans_Condensed-SemiBold.ttf
  static/NotoSans_Condensed-Bold.ttf
  static/NotoSans_Condensed-ExtraBold.ttf
  static/NotoSans_Condensed-Black.ttf
  static/NotoSans_SemiCondensed-Thin.ttf
  static/NotoSans_SemiCondensed-ExtraLight.ttf
  static/NotoSans_SemiCondensed-Light.ttf
  static/NotoSans_SemiCondensed-Regular.ttf
  static/NotoSans_SemiCondensed-Medium.ttf
  static/NotoSans_SemiCondensed-SemiBold.ttf
  static/NotoSans_SemiCondensed-Bold.ttf
  static/NotoSans_SemiCondensed-ExtraBold.ttf
  static/NotoSans_SemiCondensed-Black.ttf
  static/NotoSans-Thin.ttf
  static/NotoSans-ExtraLight.ttf
  static/NotoSans-Light.ttf
  static/NotoSans-Regular.ttf
  static/NotoSans-Medium.ttf
  static/NotoSans-SemiBold.ttf
  static/NotoSans-Bold.ttf
  static/NotoSans-ExtraBold.ttf
  static/NotoSans-Black.ttf
  static/NotoSans_ExtraCondensed-ThinItalic.ttf
  static/NotoSans_ExtraCondensed-ExtraLightItalic.ttf
  static/NotoSans_ExtraCondensed-LightItalic.ttf
  static/NotoSans_ExtraCondensed-Italic.ttf
  static/NotoSans_ExtraCondensed-MediumItalic.ttf
  static/NotoSans_ExtraCondensed-SemiBoldItalic.ttf
  static/NotoSans_ExtraCondensed-BoldItalic.ttf
  static/NotoSans_ExtraCondensed-ExtraBoldItalic.ttf
  static/NotoSans_ExtraCondensed-BlackItalic.ttf
  static/NotoSans_Condensed-ThinItalic.ttf
  static/NotoSans_Condensed-ExtraLightItalic.ttf
  static/NotoSans_Condensed-LightItalic.ttf
  static/NotoSans_Condensed-Italic.ttf
  static/NotoSans_Condensed-MediumItalic.ttf
  static/NotoSans_Condensed-SemiBoldItalic.ttf
  static/NotoSans_Condensed-BoldItalic.ttf
  static/NotoSans_Condensed-ExtraBoldItalic.ttf
  static/NotoSans_Condensed-BlackItalic.ttf
  static/NotoSans_SemiCondensed-ThinItalic.ttf
  static/NotoSans_SemiCondensed-ExtraLightItalic.ttf
  static/NotoSans_SemiCondensed-LightItalic.ttf
  static/NotoSans_SemiCondensed-Italic.ttf
  static/NotoSans_SemiCondensed-MediumItalic.ttf
  static/NotoSans_SemiCondensed-SemiBoldItalic.ttf
  static/NotoSans_SemiCondensed-BoldItalic.ttf
  static/NotoSans_SemiCondensed-ExtraBoldItalic.ttf
  static/NotoSans_SemiCondensed-BlackItalic.ttf
  static/NotoSans-ThinItalic.ttf
  static/NotoSans-ExtraLightItalic.ttf
  static/NotoSans-LightItalic.ttf
  static/NotoSans-Italic.ttf
  static/NotoSans-MediumItalic.ttf
  static/NotoSans-SemiBoldItalic.ttf
  static/NotoSans-BoldItalic.ttf
  static/NotoSans-ExtraBoldItalic.ttf
  static/NotoSans-BlackItalic.ttf

Get started
-----------

1. Install the font files you want to use

2. Use your app's font picker to view the font family and all the
available styles

Learn more about variable fonts
-------------------------------

  https://developers.google.com/web/fundamentals/design-and-ux/typography/variable-fonts
  https://variablefonts.typenetwork.com
  https://medium.com/variable-fonts

In desktop apps

  https://theblog.adobe.com/can-variable-fonts-illustrator-cc
  https://helpx.adobe.com/nz/photoshop/using/fonts.html#variable_fonts

Online

  https://developers.google.com/fonts/docs/getting_started
  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts/Variable_Fonts_Guide
  https://developer.microsoft.com/en-us/microsoft-edge/testdrive/demos/variable-fonts

Installing fonts

  MacOS: https://support.apple.com/en-us/HT201749
  Linux: https://www.google.com/search?q=how+to+install+a+font+on+gnu%2Blinux
  Windows: https://support.microsoft.com/en-us/help/314960/how-to-install-or-remove-a-font-in-windows

Android Apps

  https://developers.google.com/fonts/docs/android
  https://developer.android.com/guide/topics/ui/look-and-feel/downloadable-fonts

License
-------
Please read the full license text (OFL.txt) to understand the permissions,
restrictions and requirements for usage, redistribution, and modification.

You can use them in your products & projects – print or digital,
commercial or otherwise.

This isn't legal advice, please consider consulting a lawyer and see the full
license for all details.



================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: src/app.ts
================================================
import cors from 'cors';
import express from 'express';
import helmet from 'helmet';
import hpp from 'hpp';
import mongoose from 'mongoose';
import morgan from 'morgan';
import path from 'path';
import compression from 'compression';
import 'reflect-metadata'; // Import để sử dụng class-transformer decorators
import { IRoute } from './core/interfaces';
import { errorMiddleware } from './core/middleware';
import { logger } from './core/utils';

// Biến cache connection MongoDB để tái sử dụng trong serverless
// Serverless functions có thể bị khởi tạo lại nhiều lần, cache giúp tái sử dụng connection
let cachedConnection: typeof mongoose | null = null;

export default class App {
    public app: express.Application; // Instance của Express app
    public port: string | number;    // Port để chạy server
    public production: boolean;      // Flag kiểm tra môi trường production

    constructor(routes: IRoute[]) {
        // Khởi tạo Express application
        this.app = express();

        // Lấy port từ environment variables, ưu tiên PORT, sau đó WEBSITES_PORT, cuối cùng là 3000
        this.port = process.env.PORT || process.env.WEBSITES_PORT || 3000;

        // Kiểm tra có phải môi trường production không
        this.production = !!(process.env.NODE_ENV === 'production');

        // Kết nối database trước khi setup middleware
        this.connectToDatabase();

        // Setup các middleware (cors, compression, security, etc.)
        this.initializeMiddleware();

        // Đăng ký tất cả routes từ các modules
        this.initializeRoute(routes);

        // Setup middleware xử lý lỗi (phải ở cuối cùng)
        this.initializeErrorMiddleware();
    }

    public listen() {
        // Kiểm tra nếu đang chạy trên Vercel thì không cần gọi listen()
        // Vercel tự động handle việc này
        if (process.env.VERCEL) {
            logger.info('Running on Vercel - skipping listen()');
            return;
        }

        // Chỉ gọi listen() khi chạy local hoặc server thường
        this.app.listen(this.port, () => {
            logger.info(`Server is running at port ${this.port}`);
        });
    }

    // Hàm kết nối MongoDB được tối ưu cho serverless
    private async connectToDatabase() {
        // Lấy MongoDB URI từ environment variables
        const mongoDbUri = process.env.MONGODB_URI;
        if (!mongoDbUri) {
            logger.error('MongoDb URI is empty!');
            return;
        }

        // Kiểm tra xem có connection cache không và còn hoạt động không
        // readyState === 1 nghĩa là connected
        if (cachedConnection && cachedConnection.connection.readyState === 1) {
            logger.info('Using cached database connection');
            return cachedConnection; // Tái sử dụng connection cũ
        }

        try {
            // Cấu hình connection options được tối ưu cho serverless từ environment variables
            const options = {
                // Tắt auto-indexing trong production để khởi động nhanh hơn
                // Auto-indexing có thể làm chậm quá trình khởi tạo
                autoIndex: process.env.DB_AUTO_INDEX === 'true',

                // Timeout ngắn hơn phù hợp với serverless environment
                serverSelectionTimeoutMS: parseInt(process.env.DB_SERVER_SELECTION_TIMEOUT || '5000'),
                connectTimeoutMS: parseInt(process.env.DB_CONNECT_TIMEOUT || '10000'),
                socketTimeoutMS: parseInt(process.env.DB_SOCKET_TIMEOUT || '45000'),

                // Tối ưu connection pooling từ environment variables
                maxPoolSize: parseInt(process.env.DB_MAX_POOL_SIZE || '10'),
                minPoolSize: parseInt(process.env.DB_MIN_POOL_SIZE || '2'),
                maxIdleTimeMS: parseInt(process.env.DB_MAX_IDLE_TIME || '30000'),

                // Logic retry khi có lỗi từ environment variables
                retryWrites: process.env.DB_RETRY_WRITES === 'true',
                retryReads: process.env.DB_RETRY_READS === 'true'
            };

            // Tạo connection mới và lưu vào cache
            cachedConnection = await mongoose.connect(mongoDbUri, options);
            logger.info('Database connection established successfully');

            // Đăng ký event listeners để handle connection errors
            mongoose.connection.on('error', (err) => {
                logger.error('Database connection error:', err);
                cachedConnection = null; // Xóa cache khi có lỗi
            });

            mongoose.connection.on('disconnected', () => {
                logger.warn('Database disconnected');
                cachedConnection = null; // Xóa cache khi mất kết nối
            });

            return cachedConnection;
        } catch (err) {
            logger.error('Database connection failed:', err);
            cachedConnection = null; // Xóa cache khi thất bại

            // Trong serverless environment, không nên throw error nếu DB fail
            // Để app vẫn có thể khởi động và handle requests khác
            if (process.env.VERCEL) {
                logger.warn('Running in Vercel - continuing without database connection');
                return null;
            } else {
                throw err; // Ném lỗi để caller xử lý trong local environment
            }
        }
    }

    // Hàm setup các middleware được tối ưu với environment variables
    private initializeMiddleware() {
        // Compression phải được đặt đầu tiên để nén response với config từ env
        this.app.use(compression({
            // Filter function để quyết định có nén hay không
            filter: (req, res) => {
                // Không nén nếu client yêu cầu
                if (req.headers['x-no-compression']) {
                    return false;
                }
                // Sử dụng filter mặc định của compression
                return compression.filter(req, res);
            },
            level: parseInt(process.env.COMPRESSION_LEVEL || '6'),        // Mức nén từ env
            threshold: parseInt(process.env.COMPRESSION_THRESHOLD || '1024')  // Threshold từ env
        }));

        // Security middleware chỉ chạy trong production
        if (this.production) {
            // HPP (HTTP Parameter Pollution) protection
            this.app.use(hpp());

            // Helmet cho security headers
            this.app.use(helmet({
                contentSecurityPolicy: {
                    directives: {
                        defaultSrc: ["'self'"],           // Chỉ cho phép resource từ cùng origin
                        styleSrc: ["'self'", "'unsafe-inline'"], // CSS từ cùng origin + inline
                        scriptSrc: ["'self'"],            // JS chỉ từ cùng origin
                        imgSrc: ["'self'", "data:", "https:"], // Images từ nhiều nguồn
                    },
                },
                crossOriginEmbedderPolicy: false // Tắt COEP để tương thích
            }));

            // Logging tối ưu cho production - bỏ qua health check và swagger
            this.app.use(morgan('combined', {
                skip: (req) => req.url.includes('/health') || req.url.includes('/swagger')
            }));

            // CORS với origins từ environment variables
            const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['https://your-frontend-domain.com'];
            this.app.use(cors({
                origin: allowedOrigins,           // Danh sách domains được phép từ env
                credentials: true,                // Cho phép cookies
                optionsSuccessStatus: 200,        // Status cho preflight requests
                methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'], // Methods được phép
                allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'] // Headers được phép
            }));
        } else {
            // Development environment - logging đơn giản và CORS mở
            this.app.use(morgan('dev'));
            this.app.use(cors({ origin: true, credentials: true }));
        }

        // Body parsing với giới hạn kích thước
        this.app.use(express.json({
            limit: '10mb', // Giới hạn JSON payload 10MB
            verify: (req, res, buf) => {
                // Lưu raw body để verify webhooks nếu cần
                (req as any).rawBody = buf;
            }
        }));
        this.app.use(express.urlencoded({
            extended: true,  // Cho phép parse objects phức tạp
            limit: '10mb'    // Giới hạn form data 10MB
        }));

        // Middleware thêm response time header với threshold từ env
        this.app.use((req, res, next) => {
            const start = Date.now(); // Lưu thời gian bắt đầu
            const threshold = parseInt(process.env.RESPONSE_TIME_THRESHOLD || '1000');

            // Override res.end để capture khi response kết thúc
            const originalEnd = res.end;
            let finished = false;

            res.end = function (chunk?: any, encoding?: any) {
                if (!finished) {
                    finished = true;
                    const duration = Date.now() - start; // Tính thời gian xử lý

                    // Chỉ set header nếu headers chưa được gửi
                    if (!res.headersSent) {
                        res.set('X-Response-Time', `${duration}ms`); // Thêm header
                    }

                    // Log warning nếu vượt threshold từ env
                    if (duration > threshold) {
                        logger.warn(`Slow request: ${req.method} ${req.path} took ${duration}ms (threshold: ${threshold}ms)`);
                    }
                }

                // Gọi original end method
                return originalEnd.call(this, chunk, encoding);
            };

            next();
        });

        // Health check endpoint để monitoring
        this.app.get('/health', (req, res) => {
            const dbStatus = mongoose.connection.readyState === 1 ? 'connected' : 'disconnected';
            const isHealthy = dbStatus === 'connected' || process.env.VERCEL; // In Vercel, allow healthy even if DB disconnected temporarily

            res.status(isHealthy ? 200 : 503).json({
                status: isHealthy ? 'healthy' : 'unhealthy',
                timestamp: new Date().toISOString(),
                environment: process.env.NODE_ENV,
                database: dbStatus,
                vercel: !!process.env.VERCEL
            });
        });

        // Middleware kiểm tra database connection cho API requests
        this.app.use('/api', (req, res, next) => {
            // Bỏ qua check cho health endpoint
            if (req.path === '/health') {
                return next();
            }

            // Kiểm tra database connection
            if (mongoose.connection.readyState !== 1) {
                // Trong serverless, thử kết nối lại database
                if (process.env.VERCEL) {
                    logger.warn(`API request to ${req.path} - Database not connected, attempting reconnection`);
                    this.connectToDatabase().then(() => {
                        if (mongoose.connection.readyState === 1) {
                            next();
                        } else {
                            res.status(503).json({
                                success: false,
                                message: 'Database service temporarily unavailable',
                                error: 'DATABASE_CONNECTION_FAILED'
                            });
                        }
                    }).catch(() => {
                        res.status(503).json({
                            success: false,
                            message: 'Database service temporarily unavailable',
                            error: 'DATABASE_CONNECTION_FAILED'
                        });
                    });
                } else {
                    // Local environment - trả về lỗi ngay
                    res.status(503).json({
                        success: false,
                        message: 'Database service unavailable',
                        error: 'DATABASE_CONNECTION_FAILED'
                    });
                }
            } else {
                next();
            }
        });
    }

    // Middleware xử lý lỗi - phải ở cuối
    private initializeErrorMiddleware() {
        this.app.use(errorMiddleware);
    }

    // Hàm khởi tạo routes được tối ưu với static cache config từ env
    private initializeRoute(routes: IRoute[]) {
        // Đăng ký tất cả routes từ các modules
        routes.forEach((route) => {
            this.app.use('/', route.router);
        });

        // Cấu hình EJS template engine
        this.app.set('view engine', 'ejs');
        // Bật view cache trong production để render nhanh hơn
        this.app.set('view cache', this.production);

        // Đường dẫn tìm views - thứ tự ưu tiên
        this.app.set('views', [
            path.join(__dirname, 'modules/index/view'), // Thư mục view chính
            path.join(__dirname, 'modules/index'),      // Backup
            path.join(__dirname, 'modules')             // Fallback
        ]);

        // Cấu hình serve static files với caching từ environment variables
        const staticCacheMaxAge = parseInt(process.env.STATIC_CACHE_MAX_AGE || '31536000');
        const devCacheMaxAge = parseInt(process.env.DEV_CACHE_MAX_AGE || '86400');

        const staticOptions = {
            maxAge: this.production ? staticCacheMaxAge : devCacheMaxAge, // Cache time từ env
            etag: true,         // Bật ETag để kiểm tra file thay đổi
            lastModified: true, // Bật Last-Modified header
            setHeaders: (res: express.Response, path: string) => {
                // Set cache headers dựa theo loại file
                if (path.endsWith('.js') || path.endsWith('.css') || path.endsWith('.png') || path.endsWith('.jpg')) {
                    // Static assets cache với maxAge từ env
                    res.set('Cache-Control', `public, max-age=${staticCacheMaxAge}, immutable`);
                }
            }
        };

        // Route serve Swagger UI files
        this.app.use('/swagger', express.static(
            path.join(__dirname, '../node_modules/swagger-ui-dist'),
            staticOptions
        ));

        // Route serve images
        this.app.use('/images', express.static(
            path.join(__dirname, '../public/images'),
            staticOptions
        ));

        // 404 handler cho routes không tồn tại
        this.app.use((req, res) => {
            res.status(404).json({
                success: false,
                message: 'Route not found',
                path: req.path // Trả về path để debug
            });
        });
    }
}



================================================
FILE: src/server.ts
================================================
import dotenv from 'dotenv';
import App from './app';
import { validateEnv } from './core/utils';
import { DocsRoute } from './modules/docs';
import { IndexRoute } from './modules/index'
import { UserRoute } from './modules/user';
import { AuthRoute } from './modules/auth';
import { PaymentRoute } from './modules/payment';
import { ServiceRoute } from './modules/service';
import { DepartmentRoute } from './modules/department';
import { StaffProfileRoute } from './modules/staff_profile';
import { SlotRoute } from './modules/slot';
import { AppointmentRoute } from './modules/appointment';
import { AppointmentLogRoute } from './modules/appointment_log';
import { KitRoute } from './modules/kit';
import { SampleRoute } from './modules/sample';
import { ResultRoute } from './modules/result';
import { RegistrationFormRoute } from './modules/registration_form';
import { BlogRoute } from './modules/blog';
import { BlogCategoryRoute } from './modules/blog_category';
import { LogRoute } from './modules/blog/log';
import { ReviewRoute } from './modules/review';
import { AdministrativeCasesRoute } from './modules/administrative_cases';

// Load environment variables
dotenv.config();

// Validate environment variables
validateEnv();

// Initialize all routes
const routes = [
    new IndexRoute(),
    new DocsRoute(),
    new AuthRoute(),
    new UserRoute(),
    new PaymentRoute(),
    new ServiceRoute(),
    new DepartmentRoute(),
    new StaffProfileRoute(),
    new SlotRoute(),
    new AppointmentRoute(),
    new AppointmentLogRoute(),
    new KitRoute(),
    new SampleRoute(),
    new ResultRoute(),
    new RegistrationFormRoute(),
    new BlogRoute(),
    new BlogCategoryRoute(),
    new LogRoute(),
    new ReviewRoute(),
    new AdministrativeCasesRoute()
];

// Create app instance
const app = new App(routes);

// For Vercel serverless deployment, export the Express app
// The app.listen() is handled by your App class internally for Vercel detection
if (process.env.VERCEL) {
    // Export for Vercel serverless functions
    module.exports = app.app;
} else {
    // For local development, start the server
    app.listen();
}

// Default export for ES modules compatibility
export default app.app;



================================================
FILE: src/swagger.ts
================================================
import swaggerJsdoc from 'swagger-jsdoc'
import swaggerUi from 'swagger-ui-express'

const options = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Bloodline DNA Testing Service API',
            description: "API endpoints for a Bloodline DNA Testing Service documented on swagger",
            contact: {
                name: "Nguyễn Đan Huy",
                email: "huyit2003@gmail.com",
                url: "https://github.com/server-craftsman/wdp392-restApi-with-nodejs-express-mongodb"
            },
            version: '1.0.0',
        },
        servers: [
            {
                url: "http://localhost:8080/",
                description: "Local server"
            },
            {
                url: "https://restapi-dna-testing-fwdnadcqc9hsfmbf.canadacentral-01.azurewebsites.net/",
                description: "Live server"
            },
        ],
        components: {
            securitySchemes: {
                Bearer: {
                    type: "apiKey",
                    name: "Authorization",
                    in: "header",
                    description: "Bearer token for authorization",
                    scheme: "bearer",
                    bearerFormat: "JWT"
                }
            }
        },
        security: [
            {
                Bearer: []
            }
        ]
    },
    // Paths to files containing OpenAPI definitions
    apis: [
        './src/modules/*/swagger/*.js',  // Quét tất cả các file swagger trong các module
        './src/modules/*/dtos/*.ts'      // Quét các DTO để lấy thông tin schema (nếu cần)
    ],
}

const swaggerSpec = swaggerJsdoc(options)

function swaggerDocs(app: any, port: any) {
    // Swagger Page
    app.use('/docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
        swaggerOptions: {
            persistAuthorization: true,
            displayRequestDuration: true,
            docExpansion: 'none',
            filter: true,
            showExtensions: true,
            tryItOutEnabled: true,
            tagsSorter: 'alpha'
        },
        customCss: '.swagger-ui .topbar { background-color: #2C3E50; }'
    }))

    // Documentation in JSON format
    app.get('/docs.json', (req: any, res: any) => {
        res.setHeader('Content-Type', 'application/json');
        res.send(swaggerSpec);
    });
}

export default swaggerDocs


================================================
FILE: src/.eslintrc.js
================================================
module.exports = {
    extends: '../.eslintrc',
    rules: {
        // Enforce specific imports ordering for clarity
        'import/order': [
            'error',
            {
                'groups': [
                    'builtin',
                    'external',
                    'internal',
                    ['parent', 'sibling'],
                    'index'
                ],
                'pathGroups': [
                    {
                        'pattern': 'core/**',
                        'group': 'internal',
                        'position': 'before'
                    },
                    {
                        'pattern': 'modules/**',
                        'group': 'internal',
                        'position': 'after'
                    },
                    {
                        'pattern': 'types/**',
                        'group': 'internal',
                        'position': 'after'
                    }
                ],
                'pathGroupsExcludedImportTypes': ['builtin'],
                'newlines-between': 'always',
                'alphabetize': { 'order': 'asc', 'caseInsensitive': true }
            }
        ],

        // Enforce module boundaries
        'no-restricted-imports': [
            'error',
            {
                'patterns': [
                    {
                        'group': ['modules/*/internal'],
                        'message': 'Do not import from internal module folders. Use the public API.'
                    }
                ]
            }
        ],

        // Enforce return types for controllers and services
        '@typescript-eslint/explicit-function-return-type': [
            'error',
            {
                'allowExpressions': true,
                'allowTypedFunctionExpressions': true
            }
        ],

        // Enforce consistent model naming
        '@typescript-eslint/naming-convention': [
            'error',
            {
                'selector': 'interface',
                'format': ['PascalCase'],
                'prefix': ['I']
            },
            {
                'selector': 'typeAlias',
                'format': ['PascalCase']
            },
            {
                'selector': 'enum',
                'format': ['PascalCase']
            },
            {
                'selector': 'variable',
                'format': ['camelCase', 'UPPER_CASE', 'PascalCase'],
                'filter': {
                    'regex': 'Model$',
                    'match': true
                },
                'format': ['PascalCase']
            }
        ]
    },
    overrides: [
        {
            // Rules specific to controllers
            files: ['src/modules/*/controllers/*.ts'],
            rules: {
                '@typescript-eslint/explicit-function-return-type': 'error'
            }
        },
        {
            // Rules specific to services
            files: ['src/modules/*/services/*.ts'],
            rules: {
                '@typescript-eslint/explicit-function-return-type': 'error',
                'no-console': 'error'
            }
        },
        {
            // Rules specific to routes
            files: ['src/modules/*/routes/*.ts'],
            rules: {
                'import/no-cycle': 'error'
            }
        },
        {
            // Rules specific to models
            files: ['src/modules/*/models/*.ts'],
            rules: {
                '@typescript-eslint/naming-convention': [
                    'error',
                    {
                        'selector': 'variable',
                        'format': ['PascalCase'],
                        'filter': {
                            'regex': 'Schema|Model',
                            'match': true
                        }
                    }
                ]
            }
        }
    ]
}; 


================================================
FILE: src/core/constants/collection.constant.ts
================================================
export const COLLECTION_NAME = {
    SETTING: 'Setting',
    ADMINISTRATIVE_CASE: 'Administrative_Case',
    USER: 'User',
    BLOG: 'Blog',
    BLOG_LOG: 'Blog_Log',
    BLOG_CATEGORY: 'Blog_Category',
    SERVICE: 'Service',
    APPOINTMENT: 'Appointment',
    REVIEW: 'Review',
    KIT: 'Kit',
    SAMPLE: 'Sample',
    REGISTRATION_FORM: 'RegistrationForm',
    RESULT: 'Result',
    PAYMENT: 'Payment',
    TRANSACTION: 'Transaction',
    APPOINTMENT_LOG: 'AppointmentLog',
    DEPARTMENT: 'Department',
    STAFF_PROFILE: 'StaffProfile',
    SLOT: 'Slot',
    ATTENDANCE: 'Attendance',
    REFUND: 'Refund',
};



================================================
FILE: src/core/constants/common.constant.ts
================================================
export const SETTING = {
    id: '123456789',
}

export const PAGINATION = {
    pageNum: 1,
    pageSize: 10,
    totalItems: 0,
    totalPages: 0,
};



================================================
FILE: src/core/constants/date.constant.ts
================================================
export const DATE_FORMAT = {
    YYYYMMDD: 'YYYYMMDD',
};



================================================
FILE: src/core/constants/index.ts
================================================
import { COLLECTION_NAME } from './collection.constant';
import { PAGINATION, SETTING } from './common.constant';
import { DATE_FORMAT } from './date.constant';
import { API_PATH } from './path.constant';
import { PREFIX_TITLE } from './prefix.constant';

export { API_PATH, COLLECTION_NAME, DATE_FORMAT, PAGINATION, PREFIX_TITLE, SETTING };




================================================
FILE: src/core/constants/path.constant.ts
================================================
export const API_PATH = {
    // migrate
    MIGRATE: '/api/migrate',
    MIGRATE_SETTING: '/api/migrate/setting',
    MIGRATE_USERS: '/api/migrate/users',

    // setting
    SETTING: '/api/setting',
    SETTING_DEFAULT: '/api/setting/default',

    // administrative case
    ADMINISTRATIVE_CASES: '/api/administrative-cases',


    // auth
    AUTH: '/api/auth',
    AUTH_GOOGLE: '/api/auth/google',
    AUTH_VERIFY_TOKEN: '/api/auth/verify-token',
    AUTH_RESEND_TOKEN: '/api/auth/resend-token',
    AUTH_FORGOT_PASSWORD: '/api/auth/forgot-password',
    AUTH_LOGOUT: '/api/auth/logout',

    // user
    USERS: '/api/users',
    GENERATE_USERS: '/api/users/generate',
    SEARCH_USERS: '/api/users/search',
    CREATE_USERS: '/api/users/create',
    USERS_GOOGLE: '/api/users/google',
    CHANGE_PASSWORD_USERS: '/api/users/change-password',
    CHANGE_STATUS_USERS: '/api/users/change-status',
    CHANGE_ROLE_USER: '/api/users/change-role',
    REVIEW_PROFILE_ACCOUNT: '/api/users/review-profile-account',

    // DNA Testing Service API paths
    // Service
    SERVICE: '/api/service',
    SEARCH_SERVICE: '/api/service/search',
    CREATE_SERVICE: '/api/service/create',
    GET_SERVICE_BY_ID: '/api/service/:id',
    UPDATE_SERVICE: '/api/service/:id',
    DELETE_SERVICE: '/api/service/:id',


    // Appointment
    APPOINTMENT: '/api/appointment',
    SEARCH_APPOINTMENT: '/api/appointment/search',
    APPOINTMENT_FEEDBACK: '/api/appointment/feedback',
    CREATE_APPOINTMENT: '/api/appointment/create',
    GET_APPOINTMENT_BY_ID: '/api/appointment/:id',
    ASSIGN_STAFF_TO_APPOINTMENT: '/api/appointment/:id/assign-staff',
    CONFIRM_APPOINTMENT: '/api/appointment/:id/confirm',

    // Appointment Log
    APPOINTMENT_LOG: '/api/appointment-logs',
    GET_LOGS_BY_APPOINTMENT: '/api/appointment-logs/appointment/:appointmentId',

    // Kit
    KIT: '/api/kit',
    SEARCH_KIT: '/api/kit/search',
    CREATE_KIT: '/api/kit/create',
    CREATE_MULTIPLE_KITS: '/api/kit/create-multiple',
    GET_KIT_BY_ID: '/api/kit/:id',
    UPDATE_KIT: '/api/kit/:id',
    DELETE_KIT: '/api/kit/:id',
    CHANGE_KIT_STATUS: '/api/kit/:id/status',
    GET_AVAILABLE_KITS: '/api/kit/available',
    ASSIGN_KIT: '/api/kit/assign',
    RETURN_KIT: '/api/kit/:id/return',

    // Sample
    SAMPLE: '/api/sample',
    SEARCH_SAMPLE: '/api/sample/search',
    COLLECT_SAMPLE: '/api/sample/collect',
    RECEIVE_SAMPLE: '/api/sample/receive',

    // Registration Form
    REGISTRATION_FORM: '/api/registration-form',
    SEARCH_REGISTRATION_FORM: '/api/registration-form/search',

    // Result
    RESULT: '/api/result',
    SEARCH_RESULT: '/api/result/search',

    // Payment
    PAYMENT: '/api/payments',
    SEARCH_PAYMENT: '/api/payments/search',

    // Transaction
    TRANSACTION: '/api/transaction',
    SEARCH_TRANSACTION: '/api/transaction/search',


    // Department
    DEPARTMENT: '/api/department',
    SEARCH_DEPARTMENT: '/api/department/search',
    DEPARTMENT_STATISTICS: '/api/department/:departmentId/statistics',
    DEPARTMENT_CAPACITY: '/api/department/:departmentId/capacity',
    DEPARTMENT_PERFORMANCE: '/api/department/:departmentId/performance',


    // Staff Profile
    STAFF_PROFILE: '/api/staff-profile',
    SEARCH_STAFF_PROFILE: '/api/staff-profile/search',
    CREATE_STAFF_PROFILE: '/api/staff-profile/create',
    UPDATE_STAFF_PROFILE: '/api/staff-profile/:id',
    DELETE_STAFF_PROFILE: '/api/staff-profile/:id',

    // Work Schedule
    WORK_SCHEDULE: '/api/work-schedule',
    SEARCH_WORK_SCHEDULE: '/api/work-schedule/search',

    // Slot
    SLOT: '/api/slot',
    SEARCH_SLOT: '/api/slot/search',
    CREATE_SLOT: '/api/slot/create',
    UPDATE_SLOT: '/api/slot/:id',
    DELETE_SLOT: '/api/slot/:id',
    CHANGE_SLOT_STATUS: '/api/slot/:id/status',
    GET_SLOT_BY_SERVICE: '/api/slot/service/:serviceId',
    GET_SLOT_BY_STAFF: '/api/slot/staff/:id',
    GET_SLOT_BY_DEPARTMENT: '/api/slot/department/:departmentId',
    GET_SLOT_BY_ID: '/api/slot/:id',
    AVAILABLE_SLOT: '/api/slot/available',


    // Attendance
    ATTENDANCE: '/api/attendance',
    SEARCH_ATTENDANCE: '/api/attendance/search',

    // Refund
    REFUND: '/api/refund',
    SEARCH_REFUND: '/api/refund/search',
    APPROVE_REFUND: '/api/refund/approve',
    REJECT_REFUND: '/api/refund/reject',
    COMPLETE_REFUND: '/api/refund/complete',

    // Blog
    BLOG: '/api/blog',
    BLOG_SEARCH: '/api/blog/search',
    BLOG_CREATE: '/api/blog/create',
    BLOG_UPDATE: '/api/blog/:id',
    BLOG_LOGS: '/api/blog/:id/logs',
    BLOG_DELETE: '/api/blog/:id',

    // Blog Category
    BLOG_CATEGORY: '/api/blog-category',
    BLOG_CATEGORY_SEARCH: '/api/blog-category/search',
    BLOG_CATEGORY_CREATE: '/api/blog-category/create',
    BLOG_CATEGORY_UPDATE: '/api/blog-category/:id',
    BLOG_CATEGORY_DELETE: '/api/blog-category/:id',

    // Review
    REVIEW: '/api/review',
    REVIEW_SEARCH: '/api/review/search',

};



================================================
FILE: src/core/constants/prefix.constant.ts
================================================
export const PREFIX_TITLE = {
    APPOINTMENT: 'APPT',
    KIT: 'KIT',
    SAMPLE: 'SAMPLE',
    RESULT: 'RESULT',
    PAYMENT: 'PAY',
    TRANSACTION: 'TRANS',
    REFUND: 'REFUND',
};



================================================
FILE: src/core/enums/http.enum.ts
================================================
export enum HttpStatus {
    Success = 200,
    Created = 201,
    Accepted = 202,
    NoContent = 204,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
    Conflict = 409,
    InternalServerError = 500,
    NotImplemented = 501,
}



================================================
FILE: src/core/enums/index.ts
================================================
import { HttpStatus } from "./http.enum";

export { HttpStatus };



================================================
FILE: src/core/exceptions/http.exception.ts
================================================
class HttpException extends Error {
    public status: number;
    public message: string;
    public errors?: any[];

    constructor(status: number, message: string, errors: any[] = []) {
        super(message);
        this.name = 'HttpException';
        this.status = status;
        this.message = message;
        this.errors = errors;

        // This is needed to make instanceof work correctly in TypeScript
        Object.setPrototypeOf(this, HttpException.prototype);
    }
}

export default HttpException;



================================================
FILE: src/core/exceptions/index.ts
================================================
import HttpException from "./http.exception";

export { HttpException };



================================================
FILE: src/core/interfaces/error.interface.ts
================================================
interface IError {
    message: string;
    field?: string;
}

export default IError;



================================================
FILE: src/core/interfaces/index.ts
================================================
import IError from './error.interface';
import ISendMailDetail from './mail.interface';
import IRoute from './routes.interface';

export { IError, ISendMailDetail, IRoute };



================================================
FILE: src/core/interfaces/mail.interface.ts
================================================
interface ISendMailDetail {
    toMail: string;
    subject: string;
    content?: string;
    html?: string;
}

export default ISendMailDetail;



================================================
FILE: src/core/interfaces/routes.interface.ts
================================================
import { Router } from "express";

interface IRoute {
    path: string;
    router: Router;
}

export default IRoute;



================================================
FILE: src/core/middleware/auth.middleware.ts
================================================
import { NextFunction, Request, RequestHandler, Response } from 'express';
import jwt from 'jsonwebtoken';
import { DataStoredInToken } from '../../modules/auth';
import { UserRole, UserSchema } from '../../modules/user';
import { HttpStatus } from '../enums';
import { logger } from '../utils';

// List of paths that should bypass authentication
const PUBLIC_PATHS = [
    '/docs',
    '/docs/',
    '/docs.json',
    '/swagger',
    '/swagger/'
];

const authMiddleWare = (roles?: UserRole[], isClient = false): RequestHandler => {
    return (req: Request, res: Response, next: NextFunction) => {
        // kiểm tra xem đường dẫn có nằm trong danh sách các đường dẫn public không
        const path = req.path;
        // nếu có thì cho phép truy cập
        if (PUBLIC_PATHS.some(publicPath => path.startsWith(publicPath))) {
            next(); // chuyển tiếp đến middleware tiếp theo
            return;
        }

        const authHeader = req.headers['authorization'];

        if (isClient) {
            if (!authHeader) {
                req.user = { id: '', role: null, version: 0 };
                next();
                return;
            }
        } else {
            if (!authHeader) {
                res.status(HttpStatus.NotFound).json({ message: 'No token, authorization denied.' });
                return;
            }
        }

        handleCheckToken(req, res, next, authHeader, roles).catch(next);
    };
};

const handleCheckToken = async (
    req: Request,
    res: Response,
    next: NextFunction,
    authHeader: string | undefined,
    roles?: UserRole[],
) => {
    const userSchema = UserSchema;
    if (authHeader) {
        const token = authHeader.startsWith('Bearer ')
            ? authHeader.split(' ')[1]
            : authHeader;

        if (!token) {
            res.status(HttpStatus.NotFound).json({ message: 'No token, authorization denied.' });
            return;
        }

        try {
            const userToken = jwt.verify(token, process.env.JWT_TOKEN_SECRET ?? '') as DataStoredInToken;
            if (!req.user) {
                req.user = { id: '', role: null, version: 0 };
            }
            req.user.id = userToken.id;
            req.user.role = userToken.role;
            req.user.version = userToken.version;

            // check user version
            const user = await userSchema.findOne({ _id: userToken.id, is_deleted: false, is_verified: true }).lean();
            if (!user || Number(user?.token_version?.toString() || 0) !== userToken.version) {
                res.status(HttpStatus.Forbidden).json({ message: 'Access denied: invalid token!' });
                return;
            }

            // check roles if provided
            if (roles && roles.length > 0 && !roles.includes(req.user.role)) {
                res.status(HttpStatus.Forbidden).json({ message: 'Access denied: insufficient role' });
                return;
            }

            next();
        } catch (error) {
            logger.error(`[ERROR] Msg: ${token}`);
            if (error instanceof Error) {
                if (error.name === 'TokenExpiredError') {
                    res.status(HttpStatus.Forbidden).json({ message: 'Token is expired' });
                } else {
                    res.status(HttpStatus.Forbidden).json({ message: 'Token is not valid' });
                }
            } else {
                res.status(HttpStatus.InternalServerError).json({ message: 'An unknown error occurred' });
            }
        }
    }
};

export default authMiddleWare;



================================================
FILE: src/core/middleware/cache.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';
import crypto from 'crypto';
import logger from '../utils/logger';

/**
 * Interface định nghĩa cấu trúc cho cache entry
 * Mỗi cache entry chứa data và thời gian expire
 */
interface CacheEntry {
    data: any;        // Dữ liệu được cache
    timestamp: number; // Thời gian lưu cache (milliseconds)
    ttl: number;      // Time to live (thời gian sống) tính bằng milliseconds
}

/**
 * Lớp quản lý cache trong memory với configuration từ environment variables
 * Sử dụng Map để lưu trữ data tạm thời trong RAM
 */
class InMemoryCache {
    // Map lưu trữ cache entries với key là string và value là CacheEntry
    private cache = new Map<string, CacheEntry>();

    // Interval timer để dọn dẹp cache entries đã hết hạn
    private cleanupInterval: NodeJS.Timeout;

    // Cấu hình từ environment variables
    private readonly maxEntries: number;
    private readonly debugEnabled: boolean;
    private readonly statsEnabled: boolean;

    constructor() {
        // Lấy cấu hình từ environment variables
        this.maxEntries = parseInt(process.env.CACHE_MAX_ENTRIES || '1000');
        this.debugEnabled = process.env.CACHE_DEBUG_ENABLED === 'true';
        this.statsEnabled = process.env.CACHE_STATS_ENABLED === 'true';

        // Thiết lập interval tự động dọn dẹp cache với thời gian từ env
        const cleanupInterval = parseInt(process.env.CACHE_CLEANUP_INTERVAL || '300000');
        this.cleanupInterval = setInterval(() => {
            this.cleanup();
        }, cleanupInterval);

        // Log thông tin khởi tạo cache nếu debug enabled
        if (this.debugEnabled) {
            logger.debug(`Cache initialized - Max entries: ${this.maxEntries}, Cleanup interval: ${cleanupInterval}ms`);
        }
    }

    /**
     * Lưu data vào cache với key và TTL xác định
     * @param key Cache key - unique identifier cho data
     * @param data Dữ liệu cần cache (có thể là bất kỳ type nào)
     * @param ttl Time to live tính bằng milliseconds (mặc định từ env)
     */
    set(key: string, data: any, ttl: number = parseInt(process.env.CACHE_DEFAULT_TTL || '300000')): void {
        // Kiểm tra giới hạn số lượng entries
        if (this.cache.size >= this.maxEntries) {
            // Xóa entry cũ nhất nếu đã đạt giới hạn
            const oldestKey = this.cache.keys().next().value;
            if (oldestKey) {
                this.cache.delete(oldestKey);
                if (this.debugEnabled) {
                    logger.debug(`Cache evicted oldest entry: ${oldestKey} (max entries: ${this.maxEntries})`);
                }
            }
        }

        const entry: CacheEntry = {
            data,                          // Lưu data gốc
            timestamp: Date.now(),         // Thời gian hiện tại
            ttl                           // Thời gian sống
        };

        this.cache.set(key, entry);

        // Log để debug và monitoring nếu debug enabled
        if (this.debugEnabled) {
            logger.debug(`Cache SET: ${key} (TTL: ${ttl}ms, Size: ${this.cache.size}/${this.maxEntries})`);
        }
    }

    /**
     * Lấy data từ cache theo key
     * @param key Cache key cần tìm
     * @returns Data nếu tồn tại và chưa expire, null nếu không có hoặc đã hết hạn
     */
    get(key: string): any {
        const entry = this.cache.get(key);

        // Kiểm tra entry có tồn tại không
        if (!entry) {
            if (this.debugEnabled) {
                logger.debug(`Cache MISS: ${key}`);
            }
            return null;
        }

        // Kiểm tra entry đã hết hạn chưa
        const now = Date.now();
        const ageInMs = now - entry.timestamp;

        if (ageInMs > entry.ttl) {
            // Entry đã hết hạn, xóa khỏi cache
            this.cache.delete(key);
            if (this.debugEnabled) {
                logger.debug(`Cache EXPIRED: ${key} (age: ${ageInMs}ms, ttl: ${entry.ttl}ms)`);
            }
            return null;
        }

        // Entry còn hiệu lực, trả về data
        if (this.debugEnabled) {
            logger.debug(`Cache HIT: ${key} (age: ${ageInMs}ms, TTL remaining: ${entry.ttl - ageInMs}ms)`);
        }
        return entry.data;
    }

    /**
     * Xóa một cache entry theo key
     * @param key Cache key cần xóa
     */
    delete(key: string): void {
        const deleted = this.cache.delete(key);
        if (deleted && this.debugEnabled) {
            logger.debug(`Cache DELETE: ${key} (Size: ${this.cache.size}/${this.maxEntries})`);
        }
    }

    /**
     * Xóa toàn bộ cache
     * Thường dùng khi cần reset cache hoặc memory cleanup
     */
    clear(): void {
        const sizeBefore = this.cache.size;
        this.cache.clear();
        logger.info(`Cache CLEAR: Removed ${sizeBefore} entries`);
    }

    /**
     * Dọn dẹp các cache entries đã hết hạn
     * Method này được gọi tự động theo interval từ env
     */
    private cleanup(): void {
        const now = Date.now();
        let removedCount = 0;
        let totalEntries = 0;

        // Duyệt qua tất cả entries để kiểm tra expire
        for (const [key, entry] of this.cache.entries()) {
            totalEntries++;
            const ageInMs = now - entry.timestamp;

            // Nếu entry đã hết hạn thì xóa
            if (ageInMs > entry.ttl) {
                this.cache.delete(key);
                removedCount++;
            }
        }

        // Log thông tin cleanup nếu có entries bị xóa hoặc stats enabled
        if (removedCount > 0) {
            logger.info(`Cache CLEANUP: Removed ${removedCount}/${totalEntries} expired entries. Current size: ${this.cache.size}/${this.maxEntries}`);
        } else if (this.statsEnabled && totalEntries > 0) {
            logger.debug(`Cache CLEANUP: No expired entries. Current size: ${this.cache.size}/${this.maxEntries}`);
        }
    }

    /**
     * Lấy thông tin thống kê về cache với config từ env
     * @returns Object chứa thông tin size và memory usage
     */
    getStats() {
        const memoryUsage = process.memoryUsage();
        const stats = {
            size: this.cache.size,                    // Số lượng entries hiện tại
            maxEntries: this.maxEntries,              // Giới hạn entries từ env
            memoryUsage: Math.round(memoryUsage.heapUsed / 1024 / 1024 * 100) / 100, // Memory usage in MB
            hitRatio: this.calculateHitRatio(),       // Tỷ lệ cache hit
            configuredTTL: parseInt(process.env.CACHE_DEFAULT_TTL || '300000'), // TTL mặc định từ env
            cleanupInterval: parseInt(process.env.CACHE_CLEANUP_INTERVAL || '300000'), // Cleanup interval từ env
            debugEnabled: this.debugEnabled,          // Trạng thái debug từ env
            statsEnabled: this.statsEnabled           // Trạng thái stats từ env
        };

        if (this.statsEnabled) {
            logger.info(`Cache Stats: ${JSON.stringify(stats)}`);
        }

        return stats;
    }

    /**
     * Tính tỷ lệ cache hit (ước tính)
     * @returns Tỷ lệ cache hit từ 0 đến 1
     */
    private calculateHitRatio(): number {
        // Ước tính dựa trên số entries hiện tại so với max entries
        // Đây là một ước tính đơn giản, có thể cải thiện bằng cách track hits/misses
        return this.cache.size > 0 ? Math.min(this.cache.size / this.maxEntries, 1) : 0;
    }

    /**
     * Cleanup khi app shutdown
     * Dọn dẹp interval timer để tránh memory leaks
     */
    destroy(): void {
        clearInterval(this.cleanupInterval);
        this.clear();
        logger.info('Cache destroyed');
    }
}

// Singleton instance của cache
// Sử dụng pattern này để đảm bảo chỉ có 1 cache instance trong toàn app
const cache = new InMemoryCache();

/**
 * Middleware function để cache API responses với TTL từ env
 * @param ttl Time to live cho cache entry (mặc định từ env)
 * @returns Express middleware function
 */
export const cacheMiddleware = (ttl?: number) => {
    // Sử dụng TTL từ parameter hoặc từ environment variable
    const cacheTTL = ttl || parseInt(process.env.CACHE_DEFAULT_TTL || '300000');

    return (req: Request, res: Response, next: NextFunction) => {
        // Chỉ cache GET requests - những request không thay đổi data
        if (req.method !== 'GET') {
            return next();
        }

        // Tạo unique cache key từ URL và query parameters
        const key = generateCacheKey(req);

        // Thử lấy data từ cache trước
        const cachedData = cache.get(key);

        if (cachedData) {
            // Cache hit - trả về data từ cache
            logger.info(`Cache hit for ${req.originalUrl}`);

            // Thêm header để client biết response từ cache
            res.set('X-Cache', 'HIT');
            res.set('X-Cache-Key', key);
            res.set('X-Cache-TTL', cacheTTL.toString());

            return res.json(cachedData);
        }

        // Cache miss - cần gọi API và cache kết quả
        logger.info(`Cache miss for ${req.originalUrl}`);

        // Backup original res.json method
        const originalJson = res.json.bind(res);

        // Override res.json để intercept response data
        res.json = function (body: any) {
            // Cache response data nếu status code thành công (2xx)
            if (res.statusCode >= 200 && res.statusCode < 300) {
                cache.set(key, body, cacheTTL);
                logger.debug(`Cached response for ${req.originalUrl} with TTL ${cacheTTL}ms`);

                // Thêm headers để debug
                res.set('X-Cache', 'MISS');
                res.set('X-Cache-Key', key);
                res.set('X-Cache-TTL', cacheTTL.toString());
            }

            // Gọi original json method để trả response
            return originalJson(body);
        };

        // Tiếp tục với middleware/controller tiếp theo
        next();
    };
};

/**
 * Middleware để cache response có điều kiện với TTL từ env
 * Chỉ cache khi thỏa mãn các điều kiện nhất định
 * @param condition Function kiểm tra điều kiện cache
 * @param ttl Time to live cho cache (mặc định từ env)
 * @returns Express middleware function
 */
export const conditionalCache = (
    condition: (req: Request, res: Response) => boolean,
    ttl?: number
) => {
    const cacheTTL = ttl || parseInt(process.env.CACHE_DEFAULT_TTL || '300000');

    return (req: Request, res: Response, next: NextFunction) => {
        // Chỉ cache GET requests
        if (req.method !== 'GET') {
            return next();
        }

        // Kiểm tra điều kiện cache
        if (!condition(req, res)) {
            logger.debug(`Skipping cache for ${req.originalUrl} - condition not met`);
            return next();
        }

        // Áp dụng cache middleware nếu thỏa điều kiện
        return cacheMiddleware(cacheTTL)(req, res, next);
    };
};

/**
 * Middleware để invalidate (xóa) cache dựa trên patterns
 * Thường dùng cho POST/PUT/DELETE requests để xóa cache liên quan
 * @param patterns Array của regex patterns để match cache keys cần xóa
 * @returns Express middleware function
 */
export const invalidateCache = (patterns: RegExp[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        // Backup original response methods
        const originalJson = res.json.bind(res);
        const originalSend = res.send.bind(res);

        // Function để thực hiện cache invalidation
        const performInvalidation = () => {
            // Chỉ invalidate nếu response thành công
            if (res.statusCode >= 200 && res.statusCode < 300) {
                let invalidatedCount = 0;

                // Duyệt qua tất cả cache entries
                for (const key of (cache as any).cache.keys()) {
                    // Kiểm tra key có match với patterns không
                    for (const pattern of patterns) {
                        if (pattern.test(key)) {
                            cache.delete(key);
                            invalidatedCount++;
                            break; // Thoát khỏi vòng lặp patterns
                        }
                    }
                }

                if (invalidatedCount > 0) {
                    logger.info(`Invalidated ${invalidatedCount} cache entries for ${req.originalUrl}`);
                }
            }
        };

        // Override res.json để trigger invalidation
        res.json = function (body: any) {
            performInvalidation();
            return originalJson(body);
        };

        // Override res.send để trigger invalidation
        res.send = function (body: any) {
            performInvalidation();
            return originalSend(body);
        };

        // Tiếp tục với middleware/controller tiếp theo
        next();
    };
};

/**
 * Tạo unique cache key từ request
 * Key format: METHOD:PATH:QUERY_HASH
 * @param req Express Request object
 * @returns Unique cache key string
 */
function generateCacheKey(req: Request): string {
    // Lấy base path (không bao gồm query parameters)
    const basePath = req.path;

    // Convert query object thành JSON string để hash
    const queryString = JSON.stringify(req.query, Object.keys(req.query).sort());

    // Tạo hash từ query string để rút ngắn key
    const queryHash = crypto
        .createHash('md5')
        .update(queryString)
        .digest('hex')
        .substring(0, 8); // Chỉ lấy 8 ký tự đầu để ngắn gọn

    // Format: GET:/api/users:a1b2c3d4
    return `${req.method}:${basePath}:${queryHash}`;
}

/**
 * Middleware để thêm cache control headers với config từ env
 * Giúp browser và CDN cache responses
 * @param maxAge Thời gian cache ở browser (seconds) - mặc định từ env
 * @param sMaxAge Thời gian cache ở CDN (seconds) - mặc định từ env
 * @returns Express middleware function
 */
export const cacheHeaders = (maxAge?: number, sMaxAge?: number) => {
    // Lấy giá trị từ environment variables nếu không được cung cấp
    const browserMaxAge = maxAge || parseInt(process.env.CACHE_BROWSER_MAX_AGE || '300');
    const cdnMaxAge = sMaxAge || parseInt(process.env.CACHE_CDN_MAX_AGE || '600');

    return (req: Request, res: Response, next: NextFunction) => {
        // Chỉ thêm headers cho GET requests
        if (req.method === 'GET') {
            const cacheControl = [
                `public`,                                    // Có thể cache bởi browser và proxy
                `max-age=${browserMaxAge}`                   // Cache time ở browser từ env
            ];

            // Thêm s-maxage cho CDN/proxy từ env
            if (cdnMaxAge) {
                cacheControl.push(`s-maxage=${cdnMaxAge}`);
            }

            res.set('Cache-Control', cacheControl.join(', '));

            // Thêm ETag để validation
            res.set('ETag', `"${Date.now()}"`);

            // Thêm header cho monitoring
            res.set('X-Cache-Config', `browser:${browserMaxAge}s,cdn:${cdnMaxAge}s`);
        }

        next();
    };
};

/**
 * Utility function để manually clear cache
 * Có thể dùng trong admin endpoints hoặc scheduled jobs
 */
export const clearCache = () => {
    cache.clear();
};

/**
 * Utility function để get cache statistics với config từ env
 * Hữu ích cho monitoring và debugging
 * @returns Object chứa thống kê cache
 */
export const getCacheStats = () => {
    return cache.getStats();
};

/**
 * Cleanup function để gọi khi app shutdown
 * Đảm bảo cleanup proper để tránh memory leaks
 */
export const destroyCache = () => {
    cache.destroy();
};

// Export default cache middleware với TTL từ env
export default cacheMiddleware; 


================================================
FILE: src/core/middleware/error.middleware.ts
================================================
import { NextFunction, Request, Response } from "express";
import { HttpStatus } from "../enums";
import { HttpException } from "../exceptions";
import { logger } from "../utils";
import mongoose from "mongoose";

const errorMiddleware = (error: Error | HttpException, req: Request, res: Response, next: NextFunction) => {
    let status: number = HttpStatus.InternalServerError;
    let message: string = "Something went wrong!";
    let errors: any[] = [];
    let stack: string | undefined = process.env.NODE_ENV === 'production' ? undefined : error.stack;

    if (error instanceof HttpException) {
        status = error.status;
        message = error.message || "Something went wrong!";
        errors = error.errors || [];
    } else if (error instanceof mongoose.Error.ValidationError) {
        status = HttpStatus.BadRequest;
        message = "Validation error";
        errors = Object.values(error.errors).map(err => ({
            field: err.path,
            message: err.message
        }));
    } else if (error instanceof mongoose.Error.CastError) {
        status = HttpStatus.BadRequest;
        message = `Invalid ${error.path}: ${error.value}`;
    } else if (error.name === 'SyntaxError') {
        status = HttpStatus.BadRequest;
        message = "Invalid JSON syntax";
    } else {
        logger.error(`Unhandled error: ${error.message}`, error);
        message = error.message || "Internal server error";
    }

    // Log the error with more context
    logger.error(`[ERROR] - Status: ${status} - Msg: ${message}`);
    if (errors.length) {
        logger.error(`Error details: ${JSON.stringify(errors)}`);
    }

    // Include the request path and method in the log
    logger.error(`Request: ${req.method} ${req.path}`);

    res.status(status).json({
        success: false,
        message,
        errors: errors.length ? errors : undefined,
        stack: stack
    });
};

export default errorMiddleware;



================================================
FILE: src/core/middleware/index.ts
================================================
import authMiddleWare from "./auth.middleware";
import errorMiddleware from "./error.middleware";
import validationMiddleware from "./validation.middleware";
import { uploadSingleFile, uploadMultipleFiles } from "./upload.middleware";
import multer from "multer";

// Create multer instance with memory storage for direct use
const storage = multer.memoryStorage();
const uploadMiddleware = multer({
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024, // 5MB max file size
    }
});

export {
    authMiddleWare,
    errorMiddleware,
    validationMiddleware,
    uploadSingleFile,
    uploadMultipleFiles,
    uploadMiddleware
};




================================================
FILE: src/core/middleware/upload.middleware.ts
================================================
import multer from 'multer';
import path from 'path';
import { Request, Response, NextFunction } from 'express';
import { HttpException } from '../exceptions';
import { HttpStatus } from '../enums';
import { v4 as uuidv4 } from 'uuid';
import { PutObjectCommand } from '@aws-sdk/client-s3';
import { s3Client, bucketName, s3Folders } from '../utils/aws.config';
import { Readable } from 'stream';

// Memory storage instead of disk storage
const storage = multer.memoryStorage();

// File filter for images
const imageFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    // Accept only image files
    if (!file.originalname.match(/\.(jpg|jpeg|png|gif)$/i)) {
        return cb(new HttpException(HttpStatus.BadRequest, 'Only image files are allowed!'));
    }
    cb(null, true);
};

// Create upload instance with memory storage
const upload = multer({
    storage: storage,
    fileFilter: imageFilter,
    limits: {
        fileSize: 5 * 1024 * 1024, // 5MB max file size
    }
});

// Helper function to upload buffer directly to S3
const uploadBufferToS3 = async (
    buffer: Buffer,
    originalname: string,
    mimetype: string,
    sampleId?: string,
    folder: string = s3Folders.personImages
): Promise<string> => {
    try {
        // Generate a unique file name
        const fileExtension = path.extname(originalname);
        const fileName = `${uuidv4()}${fileExtension}`;

        // Create the folder path - if sampleId is provided, include it in the path
        const folderPath = sampleId ? `${folder}/${sampleId}` : folder;
        const key = `${folderPath}/${fileName}`;

        // Upload the buffer directly to S3
        const uploadParams = {
            Bucket: bucketName,
            Key: key,
            Body: buffer,
            ContentType: mimetype,
        };

        await s3Client.send(new PutObjectCommand(uploadParams));

        // Generate the URL for the uploaded file
        const region = typeof s3Client.config.region === 'string'
            ? s3Client.config.region
            : 'ap-southeast-2'; // Default region based on error message

        // Use the correct S3 URL format with dashed region
        const fileUrl = `https://${bucketName}.s3-${region}.amazonaws.com/${key}`;
        return fileUrl;
    } catch (error) {
        console.error('Error uploading buffer to S3:', error);
        throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload file to S3');
    }
};

// Middleware for single file upload directly to S3
export const uploadSingleFile = (fieldName: string, required: boolean = false) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const uploadMiddleware = upload.single(fieldName);

        uploadMiddleware(req, res, async (err: any) => {
            if (err instanceof multer.MulterError) {
                if (err.code === 'LIMIT_FILE_SIZE') {
                    return next(new HttpException(HttpStatus.BadRequest, 'File too large. Maximum size is 5MB.'));
                }
                // Handle field name mismatch error - common when form field name doesn't match expected name
                if (err.message.includes('Unexpected field')) {
                    console.warn(`Warning: Unexpected field name. Expected '${fieldName}'. Continuing without file upload.`);
                    return next(); // Continue without file upload
                }
                return next(new HttpException(HttpStatus.BadRequest, err.message));
            } else if (err) {
                return next(err);
            }

            // Check if file exists - only required if the 'required' parameter is true
            if (required && !req.file) {
                return next(new HttpException(HttpStatus.BadRequest, `Please upload a file for field '${fieldName}'`));
            }

            // If no file was uploaded and it's not required, just continue
            if (!req.file) {
                return next();
            }

            try {
                // Get sample_id from request body if available
                const sampleId = req.body?.sample_id;

                // Upload buffer directly to S3
                const fileUrl = await uploadBufferToS3(
                    req.file.buffer,
                    req.file.originalname,
                    req.file.mimetype,
                    sampleId
                );

                // Add the S3 URL to the request for later use
                req.file.path = fileUrl;
                (req.file as any).location = fileUrl; // AWS S3 compatible field

                next();
            } catch (error) {
                next(error);
            }
        });
    };
};

// Middleware for multiple file upload directly to S3
export const uploadMultipleFiles = (fieldName: string, maxCount: number = 5, required: boolean = true) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const uploadMiddleware = upload.array(fieldName, maxCount);

        uploadMiddleware(req, res, async (err: any) => {
            if (err instanceof multer.MulterError) {
                if (err.code === 'LIMIT_FILE_SIZE') {
                    return next(new HttpException(HttpStatus.BadRequest, 'File too large. Maximum size is 5MB.'));
                } else if (err.code === 'LIMIT_UNEXPECTED_FILE') {
                    return next(new HttpException(HttpStatus.BadRequest, `Too many files. Maximum is ${maxCount}.`));
                }
                // Handle field name mismatch error - common when form field name doesn't match expected name
                if (err.message.includes('Unexpected field')) {
                    console.warn(`Warning: Unexpected field name. Expected '${fieldName}'. Continuing without file upload.`);
                    return next(); // Continue without file upload
                }
                return next(new HttpException(HttpStatus.BadRequest, err.message));
            } else if (err) {
                return next(err);
            }

            // Check if files exist - only required if the 'required' parameter is true
            if (required && (!req.files || (Array.isArray(req.files) && req.files.length === 0))) {
                return next(new HttpException(HttpStatus.BadRequest, `Please upload at least one file for field '${fieldName}'`));
            }

            // If no files were uploaded and it's not required, just continue
            if (!req.files || (Array.isArray(req.files) && req.files.length === 0)) {
                return next();
            }

            try {
                // Get sample_id from request body if available
                const sampleId = req.body?.sample_id;

                // Upload all files directly to S3
                const fileUrls = await Promise.all(
                    (req.files as Express.Multer.File[]).map(async (file) => {
                        const fileUrl = await uploadBufferToS3(
                            file.buffer,
                            file.originalname,
                            file.mimetype,
                            sampleId
                        );

                        // Add the S3 URL to each file
                        file.path = fileUrl;
                        (file as any).location = fileUrl; // AWS S3 compatible field

                        return fileUrl;
                    })
                );

                // Add the S3 URLs to the request for later use
                (req as any).fileUrls = fileUrls;

                next();
            } catch (error) {
                next(error);
            }
        });
    };
}; 


================================================
FILE: src/core/middleware/validation.middleware.ts
================================================

import { plainToInstance } from "class-transformer";
import { ValidationError, validate } from "class-validator";
import { NextFunction, Request, RequestHandler, Response } from "express";
import { HttpStatus } from "../enums";
import { HttpException } from "../exceptions";
import { IError } from "../interfaces";

const validationMiddleware = (type: any, skipMissingProperties = false): RequestHandler => {
    return (req: Request, res: Response, next: NextFunction) => {
        validate(plainToInstance(type, req.body), { skipMissingProperties: skipMissingProperties }).then(
            (errors: ValidationError[]) => {
                if (errors.length > 0) {
                    let errorResults: IError[] = [];

                    const extractConstraints = (error: ValidationError) => {
                        if (error.constraints) {
                            Object.values(error.constraints || {}).forEach((message) => {
                                errorResults.push({
                                    message,
                                    field: error.property,
                                });
                            });
                        }
                        if (error.children && error.children.length > 0) {
                            error.children.forEach((childError) => {
                                extractConstraints(childError);
                            });
                        }
                    };

                    errors.forEach((error) => {
                        extractConstraints(error);
                    });

                    next(new HttpException(HttpStatus.BadRequest, "", errorResults));
                } else {
                    next();
                }
            }
        );
    };
};

export default validationMiddleware;



================================================
FILE: src/core/models/index.ts
================================================
import { SearchPaginationRequestModel, SearchPaginationResponseModel } from "./searchPagination.model";

export { SearchPaginationRequestModel, SearchPaginationResponseModel };



================================================
FILE: src/core/models/pagination.model.ts
================================================

import { IsInt, Min } from 'class-validator';
import { PAGINATION } from '../constants';

export class PaginationRequestModel {
    constructor(pageNum: number = PAGINATION.pageNum, pageSize: number = PAGINATION.pageSize) {
        this.pageNum = pageNum;
        this.pageSize = pageSize;
    }

    @IsInt()
    @Min(PAGINATION.pageNum)
    public pageNum: number;

    @IsInt()
    @Min(PAGINATION.pageSize)
    public pageSize: number;
}

export class PaginationResponseModel {
    constructor(
        pageNum: number = PAGINATION.pageNum,
        pageSize: number = PAGINATION.pageSize,
        totalItems: number = PAGINATION.totalItems,
        totalPages: number = PAGINATION.totalPages,
    ) {
        this.pageNum = pageNum;
        this.pageSize = pageSize;
        this.totalItems = totalItems;
        this.totalPages = totalPages;
    }

    public pageNum: number;
    public pageSize: number;
    public totalItems: number;
    public totalPages: number;
}



================================================
FILE: src/core/models/searchPagination.model.ts
================================================
import { Type } from 'class-transformer';
import { IsNotEmptyObject, ValidateNested } from 'class-validator';
import 'reflect-metadata';
import { PaginationRequestModel, PaginationResponseModel } from './pagination.model';

export class SearchPaginationRequestModel<T> {
    constructor(pageInfo: PaginationRequestModel, searchCondition: T) {
        this.pageInfo = pageInfo;
        this.searchCondition = searchCondition;
    }

    @IsNotEmptyObject()
    @ValidateNested()
    @Type(() => PaginationRequestModel)
    public pageInfo: PaginationRequestModel;

    @IsNotEmptyObject()
    @ValidateNested()
    @Type(() => Object) // Use Object to allow any type for searchCondition
    public searchCondition: T;
}

export class SearchPaginationResponseModel<T> {
    constructor(pageData: T[] = [], pageInfo: PaginationResponseModel = new PaginationResponseModel()) {
        this.pageData = pageData;
        this.pageInfo = pageInfo;
    }

    public pageData: T[];
    public pageInfo: PaginationResponseModel;
}



================================================
FILE: src/core/utils/aws.config.ts
================================================
import dotenv from 'dotenv';
import { S3Client } from '@aws-sdk/client-s3';

dotenv.config();

// AWS S3 configuration
export const s3Config = {
    region: process.env.AWS_REGION || 'ap-southeast-2',
    credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
    },
    bucket: process.env.AWS_S3_BUCKET_NAME || 'wdp392-generate-pdf',
};

// Initialize S3 client
export const s3Client = new S3Client({
    region: s3Config.region,
    credentials: s3Config.credentials,
});

// Define folder paths
export const s3Folders = {
    personImages: 'person-sample-images',
    resultReports: 'result-reports',
    blogImages: 'blog-images',
};

// Export bucket name
export const bucketName = s3Config.bucket;


================================================
FILE: src/core/utils/helpers.ts
================================================
import jwt from 'jsonwebtoken';
import { DataStoredInToken } from '../../modules/auth';
import moment from 'moment';
import { DATE_FORMAT } from '../constants';

export const getUserIdCurrent = (authHeader: string) => {
    if (!authHeader) {
        return '';
    }
    const token = authHeader.split(' ')[1];
    const user = jwt.verify(token, process.env.JWT_TOKEN_SECRET ?? '') as DataStoredInToken;
    return user;
};

export const isEmptyObject = (obj: any): boolean => {
    return !Object.keys(obj).length;
};

export const formatResponse = <T>(data: T, success: boolean = true, message?: string) => {
    return {
        success,
        data,
        message
    };
};

export const generateRandomNo = (PREFIX_TITLE: string, numberLimit = 6) => {
    const randomNumbers = Array.from({ length: numberLimit }, () => Math.floor(Math.random() * 10)).join('');
    const yyyymmdd = moment().format(DATE_FORMAT.YYYYMMDD); // Format current date as YYYYMMDD
    return `${PREFIX_TITLE}_${randomNumbers}${yyyymmdd}`;
};



================================================
FILE: src/core/utils/index.ts
================================================
import { formatResponse, generateRandomNo, getUserIdCurrent, isEmptyObject } from './helpers';
import logger from './logger';
import { encodePasswordUserNormal } from './password';
import { itemsQuery } from './query';
import { formatPaginationResult } from './service';
import { sendMail, createVerificationEmailTemplate, createPasswordResetEmailTemplate, createNotificationEmailTemplate } from './sendMail';
import { createToken, createTokenVerifiedUser } from './token';
import validateEnv from './validateEnv';
import { checkUserMatch, checkValidUrl } from './validation';
import { uploadFileToS3, uploadMultipleFilesToS3 } from './s3Upload';
import { s3Client, bucketName, s3Folders } from './aws.config';

export {
    checkUserMatch,
    checkValidUrl,
    createToken,
    createTokenVerifiedUser,
    createVerificationEmailTemplate,
    createPasswordResetEmailTemplate,
    createNotificationEmailTemplate,
    encodePasswordUserNormal,
    formatPaginationResult,
    formatResponse,
    generateRandomNo,
    getUserIdCurrent,
    isEmptyObject,
    itemsQuery,
    logger,
    sendMail,
    validateEnv,
    uploadFileToS3,
    uploadMultipleFilesToS3,
    s3Client,
    bucketName,
    s3Folders,
};



================================================
FILE: src/core/utils/logger.ts
================================================
import winston from "winston";

const logger: winston.Logger = winston.createLogger({
    // transports: [
    //     // - Write all logs with importance level of `error` or less to `error.log`
    //     // - Write all logs with importance level of `info` or less to `combined.log`
    //     new winston.transports.File({ filename: "./logs/error.log", level: "error" }),
    //     new winston.transports.File({ filename: "./logs/combined.log" }),
    // ],
    // format: winston.format.combine(winston.format.colorize({ all: true }), winston.format.simple()),
});

// If we're not in production then log to the `console` with the format:
if (process.env.NODE_ENV !== "production") {
    // logger.add(
    //     new winston.transports.Console({
    //         format: winston.format.combine(winston.format.colorize({ all: true }), winston.format.simple()),
    //     })
    // );
}

export default logger;



================================================
FILE: src/core/utils/password.ts
================================================
import bcryptjs from 'bcryptjs';
import logger from './logger';

/**
 * Interface định nghĩa cấu hình bảo mật password từ environment variables
 */
interface PasswordConfig {
    saltRounds: number;           // Số rounds cho bcrypt salt từ env
    minLength: number;            // Độ dài tối thiểu password từ env
    maxLength: number;            // Độ dài tối đa password từ env
    requireUppercase: boolean;    // Yêu cầu chữ hoa từ env
    requireLowercase: boolean;    // Yêu cầu chữ thường từ env  
    requireNumbers: boolean;      // Yêu cầu số từ env
    requireSpecialChars: boolean; // Yêu cầu ký tự đặc biệt từ env
}

/**
 * Lấy cấu hình password từ environment variables
 * @returns Object chứa config password security
 */
function getPasswordConfig(): PasswordConfig {
    return {
        saltRounds: parseInt(process.env.BCRYPT_SALT_ROUNDS || '12'),
        minLength: parseInt(process.env.PASSWORD_MIN_LENGTH || '8'),
        maxLength: parseInt(process.env.PASSWORD_MAX_LENGTH || '128'),
        requireUppercase: process.env.PASSWORD_REQUIRE_UPPERCASE === 'true',
        requireLowercase: process.env.PASSWORD_REQUIRE_LOWERCASE === 'true',
        requireNumbers: process.env.PASSWORD_REQUIRE_NUMBERS === 'true',
        requireSpecialChars: process.env.PASSWORD_REQUIRE_SPECIAL_CHARS === 'true'
    };
}

/**
 * Validate password theo các quy tắc từ environment variables
 * @param password Password cần validate
 * @returns Object chứa kết quả validation và thông báo lỗi
 */
export const validatePassword = (password: string): { isValid: boolean; errors: string[] } => {
    const config = getPasswordConfig();
    const errors: string[] = [];

    // Kiểm tra độ dài tối thiểu từ env
    if (password.length < config.minLength) {
        errors.push(`Password phải có ít nhất ${config.minLength} ký tự`);
    }

    // Kiểm tra độ dài tối đa từ env
    if (password.length > config.maxLength) {
        errors.push(`Password không được vượt quá ${config.maxLength} ký tự`);
    }

    // Kiểm tra yêu cầu chữ hoa nếu được bật trong env
    if (config.requireUppercase && !/[A-Z]/.test(password)) {
        errors.push('Password phải chứa ít nhất một chữ cái viết hoa');
    }

    // Kiểm tra yêu cầu chữ thường nếu được bật trong env
    if (config.requireLowercase && !/[a-z]/.test(password)) {
        errors.push('Password phải chứa ít nhất một chữ cái viết thường');
    }

    // Kiểm tra yêu cầu số nếu được bật trong env
    if (config.requireNumbers && !/\d/.test(password)) {
        errors.push('Password phải chứa ít nhất một chữ số');
    }

    // Kiểm tra yêu cầu ký tự đặc biệt nếu được bật trong env
    if (config.requireSpecialChars && !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
        errors.push('Password phải chứa ít nhất một ký tự đặc biệt');
    }

    // Kiểm tra không chứa khoảng trắng
    if (/\s/.test(password)) {
        errors.push('Password không được chứa khoảng trắng');
    }

    return {
        isValid: errors.length === 0,
        errors
    };
};

/**
 * Mã hóa password sử dụng bcryptjs với salt rounds từ environment variables
 * @param password Password cần mã hóa
 * @returns Promise trả về password đã được hash
 */
export const encodePasswordUserNormal = async (password: string): Promise<string> => {
    try {
        // Validate password trước khi hash
        const validation = validatePassword(password);
        if (!validation.isValid) {
            const errorMessage = `Password validation failed: ${validation.errors.join(', ')}`;
            logger.error(errorMessage);
            throw new Error(errorMessage);
        }

        const config = getPasswordConfig();

        // Tạo salt với số rounds từ environment variables
        const salt = await bcryptjs.genSalt(config.saltRounds);

        // Hash password với salt đã tạo
        const hashedPassword = await bcryptjs.hash(password, salt);

        // Log thông tin hash (không log password gốc vì bảo mật)
        logger.info(`Password hashed successfully with ${config.saltRounds} salt rounds`);

        return hashedPassword;
    } catch (error) {
        logger.error('Error encoding password:', error);
        throw new Error('Failed to encode password');
    }
};

/**
 * So sánh password với hash đã lưu
 * @param password Password plain text
 * @param hashedPassword Password đã được hash
 * @returns Promise trả về boolean cho biết password có đúng không
 */
export const comparePassword = async (password: string, hashedPassword: string): Promise<boolean> => {
    try {
        // Kiểm tra input validation
        if (!password || !hashedPassword) {
            logger.warn('Missing password or hash for comparison');
            return false;
        }

        // So sánh password với hash
        const isMatch = await bcryptjs.compare(password, hashedPassword);

        // Log kết quả (không log password thực tế)
        logger.debug(`Password comparison result: ${isMatch ? 'match' : 'no match'}`);

        return isMatch;
    } catch (error) {
        logger.error('Error comparing password:', error);
        return false; // Trả về false khi có lỗi để bảo mật
    }
};

/**
 * Tạo password ngẫu nhiên đáp ứng tất cả requirements từ env
 * @param length Độ dài password (mặc định từ env)
 * @returns Password ngẫu nhiên thỏa mãn tất cả điều kiện
 */
export const generateSecurePassword = (length?: number): string => {
    const config = getPasswordConfig();
    const passwordLength = length || Math.max(config.minLength, 12); // Ít nhất 12 ký tự

    // Định nghĩa các bộ ký tự
    const lowercase = 'abcdefghijklmnopqrstuvwxyz';
    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const numbers = '0123456789';
    const specialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';

    let charset = '';
    let guaranteedChars = '';

    // Thêm các bộ ký tự bắt buộc từ config
    if (config.requireLowercase) {
        charset += lowercase;
        guaranteedChars += lowercase.charAt(Math.floor(Math.random() * lowercase.length));
    }

    if (config.requireUppercase) {
        charset += uppercase;
        guaranteedChars += uppercase.charAt(Math.floor(Math.random() * uppercase.length));
    }

    if (config.requireNumbers) {
        charset += numbers;
        guaranteedChars += numbers.charAt(Math.floor(Math.random() * numbers.length));
    }

    if (config.requireSpecialChars) {
        charset += specialChars;
        guaranteedChars += specialChars.charAt(Math.floor(Math.random() * specialChars.length));
    }

    // Nếu không có yêu cầu gì, dùng tất cả
    if (!charset) {
        charset = lowercase + uppercase + numbers + specialChars;
    }

    // Tạo password với độ dài còn lại
    let password = guaranteedChars;
    for (let i = guaranteedChars.length; i < passwordLength; i++) {
        password += charset.charAt(Math.floor(Math.random() * charset.length));
    }

    // Trộn các ký tự để tránh pattern dễ đoán
    password = password.split('').sort(() => 0.5 - Math.random()).join('');

    logger.info(`Generated secure password with length ${password.length}`);
    return password;
};

/**
 * Kiểm tra password có bị compromise không (có thể mở rộng với API check)
 * @param password Password cần kiểm tra
 * @returns Promise trả về boolean, true nếu password an toàn
 */
export const checkPasswordSecurity = async (password: string): Promise<{ isSafe: boolean; warnings: string[] }> => {
    const warnings: string[] = [];

    // Kiểm tra các pattern phổ biến không an toàn
    const commonPatterns = [
        'password', '123456', 'qwerty', 'admin', 'letmein',
        'welcome', 'monkey', '1234567890', 'abc123'
    ];

    const lowerPassword = password.toLowerCase();
    for (const pattern of commonPatterns) {
        if (lowerPassword.includes(pattern)) {
            warnings.push(`Password chứa pattern không an toàn: "${pattern}"`);
        }
    }

    // Kiểm tra keyboard patterns
    const keyboardPatterns = ['qwerty', 'asdf', 'zxcv', '1234', 'abcd'];
    for (const pattern of keyboardPatterns) {
        if (lowerPassword.includes(pattern)) {
            warnings.push(`Password chứa keyboard pattern: "${pattern}"`);
        }
    }

    // Kiểm tra repeated characters
    if (/(.)\1{2,}/.test(password)) {
        warnings.push('Password chứa ký tự lặp lại liên tiếp');
    }

    // Kiểm tra sequential characters
    for (let i = 0; i < password.length - 2; i++) {
        const char1 = password.charCodeAt(i);
        const char2 = password.charCodeAt(i + 1);
        const char3 = password.charCodeAt(i + 2);

        if (char2 === char1 + 1 && char3 === char2 + 1) {
            warnings.push('Password chứa ký tự tuần tự');
            break;
        }
    }

    const isSafe = warnings.length === 0;

    if (!isSafe) {
        logger.warn(`Password security check failed: ${warnings.join(', ')}`);
    }

    return { isSafe, warnings };
};

/**
 * Lấy thông tin cấu hình password hiện tại (cho debugging/monitoring)
 * @returns Object chứa config password không sensitive
 */
export const getPasswordConfigInfo = () => {
    const config = getPasswordConfig();
    return {
        saltRounds: config.saltRounds,
        minLength: config.minLength,
        maxLength: config.maxLength,
        requirements: {
            uppercase: config.requireUppercase,
            lowercase: config.requireLowercase,
            numbers: config.requireNumbers,
            specialChars: config.requireSpecialChars
        }
    };
};

/**
 * Export function chính để tương thích với code cũ
 * Được enhance với validation và config từ env
 */
export { encodePasswordUserNormal as hashPassword };



================================================
FILE: src/core/utils/performance.ts
================================================
import mongoose from 'mongoose';
import logger from './logger';

/**
 * Lớp tiện ích tối ưu Database queries
 * Giúp cải thiện hiệu suất truy vấn MongoDB
 */
export class DatabaseOptimizer {
    /**
     * Thêm .lean() vào mongoose queries để tăng hiệu suất
     * .lean() trả về plain JavaScript objects thay vì Mongoose documents
     * Nhanh hơn vì không có getters/setters và validation
     * @param query Mongoose query object
     * @returns Query đã được tối ưu
     */
    static lean(query: any): any {
        return query.lean();
    }

    /**
     * Thêm projection để giới hạn fields trả về
     * Chỉ lấy những fields cần thiết để giảm bandwidth và memory
     * @param query Mongoose query object
     * @param fields Chuỗi các fields cần lấy (vd: 'name email created_at')
     * @returns Query với projection
     */
    static select(query: any, fields: string): any {
        return query.select(fields);
    }

    /**
     * Tối ưu pagination queries với validation và lean()
     * Tự động thêm sort, skip, limit và lean() cho hiệu suất tối đa
     * @param query Base query chưa có pagination
     * @param page Số trang (bắt đầu từ 1)
     * @param limit Số items mỗi trang
     * @param sort Tiêu chí sắp xếp (mặc định theo created_at giảm dần)
     * @returns Query đã được tối ưu với pagination
     */
    static paginate(
        query: any,
        page: number = 1,
        limit: number = 10,
        sort: any = { created_at: -1 }
    ): any {
        // Tính số documents cần skip, đảm bảo không âm
        const skip = Math.max(0, (page - 1) * limit);

        // Giới hạn limit trong khoảng 1-100 để tránh overload
        const validLimit = Math.min(Math.max(1, limit), 100);

        return query
            .sort(sort)           // Sắp xếp trước
            .skip(skip)           // Bỏ qua documents của các trang trước
            .limit(validLimit)    // Giới hạn số documents trả về
            .lean();              // Trả về plain objects để tăng tốc
    }

    /**
     * Tạo optimized count query
     * Sử dụng countDocuments() thay vì count() (deprecated)
     * @param model Mongoose model
     * @param filter Điều kiện filter (mặc định là rỗng)
     * @returns Promise trả về số lượng documents
     */
    static count(model: mongoose.Model<any>, filter: any = {}) {
        return model.countDocuments(filter);
    }

    /**
     * Xử lý batch cho datasets lớn để tránh memory overflow
     * Chia nhỏ dữ liệu thành các batch và xử lý tuần tự
     * @param model Mongoose model
     * @param filter Điều kiện filter
     * @param processor Hàm xử lý mỗi batch
     * @param batchSize Kích thước mỗi batch (mặc định 100)
     */
    static async batchProcess(
        model: mongoose.Model<any>,
        filter: any,
        processor: (batch: any[]) => Promise<void>,
        batchSize: number = 100
    ): Promise<void> {
        let skip = 0;           // Số documents đã xử lý
        let hasMore = true;     // Flag kiểm tra còn data không

        while (hasMore) {
            // Lấy một batch documents
            const batch = await model
                .find(filter)
                .skip(skip)
                .limit(batchSize)
                .lean()               // Sử dụng lean() để tăng tốc
                .exec();

            // Nếu không có data thì dừng
            if (batch.length === 0) {
                hasMore = false;
                break;
            }

            // Xử lý batch hiện tại
            await processor(batch);
            skip += batchSize;

            // Nếu batch nhỏ hơn batchSize thì đây là batch cuối
            if (batch.length < batchSize) {
                hasMore = false;
            }
        }
    }
}

/**
 * Lớp tiện ích monitoring hiệu suất
 * Giúp đo thời gian thực thi và log performance
 */
export class PerformanceMonitor {
    // Map lưu trữ thời gian bắt đầu của các timers
    private static timers = new Map<string, number>();

    /**
     * Bắt đầu đo thời gian cho một operation
     * @param label Tên của timer để identify
     */
    static start(label: string): void {
        this.timers.set(label, Date.now());
    }

    /**
     * Kết thúc đo thời gian và log kết quả
     * @param label Tên timer cần kết thúc
     * @param logLevel Mức độ log (info/warn/error)
     * @returns Thời gian thực thi tính bằng milliseconds
     */
    static end(label: string, logLevel: 'info' | 'warn' | 'error' = 'info'): number {
        const startTime = this.timers.get(label);

        // Kiểm tra timer có tồn tại không
        if (!startTime) {
            logger.warn(`Timer '${label}' was not started`);
            return 0;
        }

        // Tính thời gian thực thi
        const duration = Date.now() - startTime;

        // Xóa timer khỏi map để tiết kiệm memory
        this.timers.delete(label);

        const message = `${label} completed in ${duration}ms`;

        // Log theo mức độ tương ứng
        switch (logLevel) {
            case 'warn':
                // Chỉ warn nếu > 1 giây
                if (duration > 1000) logger.warn(message);
                break;
            case 'error':
                // Chỉ error nếu > 3 giây
                if (duration > 3000) logger.error(message);
                break;
            default:
                logger.info(message);
        }

        return duration;
    }

    /**
     * Monitor một async function và tự động đo thời gian
     * Wrapper function để tự động start/end timer
     * @param label Tên để identify operation
     * @param fn Async function cần monitor
     * @returns Kết quả của function gốc
     */
    static async monitor<T>(label: string, fn: () => Promise<T>): Promise<T> {
        this.start(label); // Bắt đầu đo thời gian
        try {
            const result = await fn(); // Thực thi function
            this.end(label);           // Kết thúc thành công
            return result;
        } catch (error) {
            this.end(label, 'error');  // Kết thúc với lỗi
            throw error;               // Re-throw error để caller xử lý
        }
    }

    /**
     * Tạo middleware tracking thời gian response
     * Middleware Express để đo thời gian xử lý request
     * @param threshold Ngưỡng cảnh báo (ms), mặc định 1000ms
     */
    static middleware(threshold: number = 1000) {
        return (req: any, res: any, next: any) => {
            const start = Date.now();
            const label = `${req.method} ${req.path}`;

            // Lắng nghe event 'finish' khi response được gửi
            res.on('finish', () => {
                const duration = Date.now() - start;

                // Thêm header response time
                res.set('X-Response-Time', `${duration}ms`);

                // Log warning nếu vượt ngưỡng
                if (duration > threshold) {
                    logger.warn(`Slow request: ${label} took ${duration}ms`);
                } else {
                    logger.info(`${label} completed in ${duration}ms`);
                }
            });

            next(); // Tiếp tục với middleware tiếp theo
        };
    }
}

/**
 * Lớp quản lý memory cho serverless environments
 * Giúp monitor và quản lý việc sử dụng bộ nhớ
 */
export class MemoryManager {
    /**
     * Ép buộc garbage collection nếu có thể
     * Chỉ hoạt động khi Node.js được start với flag --expose-gc
     */
    static forceGC(): void {
        if (global.gc) {
            global.gc(); // Gọi garbage collector
            logger.info('Forced garbage collection');
        }
    }

    /**
     * Lấy thông tin sử dụng memory hiện tại
     * Chuyển đổi từ bytes sang MB để dễ đọc
     * @returns Object chứa thông tin memory usage
     */
    static getMemoryUsage() {
        const usage = process.memoryUsage();
        return {
            // RSS: Resident Set Size - tổng memory được process sử dụng
            rss: Math.round(usage.rss / 1024 / 1024 * 100) / 100,

            // Heap Total: Tổng heap memory được allocate
            heapTotal: Math.round(usage.heapTotal / 1024 / 1024 * 100) / 100,

            // Heap Used: Heap memory đang được sử dụng
            heapUsed: Math.round(usage.heapUsed / 1024 / 1024 * 100) / 100,

            // External: Memory được sử dụng bởi C++ objects liên kết với JS objects
            external: Math.round(usage.external / 1024 / 1024 * 100) / 100,
        };
    }

    /**
     * Log thông tin memory usage với context
     * @param context Mô tả ngữ cảnh để debug (vd: 'After DB Query')
     */
    static logMemoryUsage(context: string = 'Memory Usage'): void {
        const usage = this.getMemoryUsage();
        logger.info(`${context} - RSS: ${usage.rss}MB, Heap: ${usage.heapUsed}/${usage.heapTotal}MB, External: ${usage.external}MB`);
    }

    /**
     * Kiểm tra xem memory usage có đang tiến gần giới hạn không
     * @param maxHeapMB Giới hạn heap memory tối đa (MB), mặc định 500MB
     * @returns true nếu vượt ngưỡng, false nếu còn an toàn
     */
    static checkMemoryLimits(maxHeapMB: number = 500): boolean {
        const usage = this.getMemoryUsage();
        if (usage.heapUsed > maxHeapMB) {
            logger.warn(`High memory usage detected: ${usage.heapUsed}MB (limit: ${maxHeapMB}MB)`);
            return true; // Vượt ngưỡng
        }
        return false; // Còn an toàn
    }
}

/**
 * Lớp tối ưu Connection Pool cho MongoDB
 * Monitor và log trạng thái connection pool
 */
export class ConnectionPoolOptimizer {
    /**
     * Lấy thông tin trạng thái connection pool
     * @returns Object chứa thông tin connection status
     */
    static getPoolStatus() {
        return {
            // Kiểm tra connection có đang hoạt động không (1 = connected)
            isConnected: mongoose.connection.readyState === 1,

            // Trạng thái connection: 0=disconnected, 1=connected, 2=connecting, 3=disconnecting
            readyState: mongoose.connection.readyState,

            // Host đang kết nối
            host: mongoose.connection.host,

            // Tên database
            name: mongoose.connection.name
        };
    }

    /**
     * Log thông tin pool status để monitoring
     */
    static logPoolStatus(): void {
        const status = this.getPoolStatus();
        logger.info(`DB Pool Status - Connected: ${status.isConnected}, State: ${status.readyState}, Host: ${status.host}, DB: ${status.name}`);
    }
}

/**
 * Lớp tiện ích tối ưu cho serverless environments
 * Detect và handle các đặc thù của serverless platforms
 */
export class ServerlessOptimizer {
    /**
     * Kiểm tra có đang chạy trong serverless environment không
     * @returns true nếu đang chạy trên serverless platform
     */
    static isServerless(): boolean {
        return !!(process.env.VERCEL || process.env.AWS_LAMBDA_FUNCTION_NAME || process.env.NETLIFY);
    }

    /**
     * Lấy thông tin chi tiết về serverless environment
     * @returns Object chứa thông tin platform và region
     */
    static getServerlessInfo() {
        return {
            isServerless: this.isServerless(),

            // Detect platform dựa trên environment variables
            platform: process.env.VERCEL ? 'Vercel' :
                process.env.AWS_LAMBDA_FUNCTION_NAME ? 'AWS Lambda' :
                    process.env.NETLIFY ? 'Netlify' : 'Unknown',

            // Region đang chạy
            region: process.env.VERCEL_REGION || process.env.AWS_REGION || 'unknown',

            // Có phải cold start không (function mới được khởi tạo)
            coldStart: !global.__serverless_cache_initialized
        };
    }

    /**
     * Đánh dấu cache đã được khởi tạo (warm start)
     * Giúp identify cold starts vs warm starts
     */
    static initializeCache(): void {
        global.__serverless_cache_initialized = true;
    }

    /**
     * Cleanup resources khi serverless function kết thúc
     * Đóng connections và giải phóng memory
     */
    static cleanup(): void {
        // Đóng MongoDB connection nếu đang mở
        if (mongoose.connection.readyState === 1) {
            mongoose.connection.close();
        }

        // Ép buộc garbage collection để giải phóng memory
        MemoryManager.forceGC();
    }
}

// Declare global type cho cache flag
// Biến global để track trạng thái cache initialization
declare global {
    var __serverless_cache_initialized: boolean;
} 


================================================
FILE: src/core/utils/query.ts
================================================
export const itemsQuery = (query: Record<string, any>, items: Record<string, any>): Record<string, any> => {
    for (const key in items) {
        if (items[key] || items[key] === false) {
            query = {
                ...query,
                [key]: items[key],
            };
        }
    }
    return query;
};



================================================
FILE: src/core/utils/s3Upload.ts
================================================
import { PutObjectCommand } from '@aws-sdk/client-s3';
import { s3Client, bucketName, s3Folders } from './aws.config';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import fs from 'fs';
import { HttpException } from '../exceptions';
import { HttpStatus } from '../enums';

/**
 * Upload a file to AWS S3
 * @param file The file to upload (from multer)
 * @param sampleId The sample ID to use in the folder path
 * @param folder The base folder to upload to (from s3Folders)
 * @returns The URL of the uploaded file
 */
export const uploadFileToS3 = async (
    file: Express.Multer.File,
    sampleId?: string,
    folder: string = s3Folders.personImages
): Promise<string> => {
    try {
        // If the file already has a location (uploaded directly to S3), return it
        if ((file as any).location) {
            return (file as any).location;
        }

        // Generate a unique file name
        const fileExtension = path.extname(file.originalname);
        const fileName = `${uuidv4()}${fileExtension}`;

        // Create the folder path - if sampleId is provided, include it in the path
        const folderPath = sampleId ? `${folder}/${sampleId}` : folder;
        const key = `${folderPath}/${fileName}`;

        // Check if AWS credentials are configured
        if (!s3Client.config.credentials) {
            console.error('AWS credentials not properly configured');
            throw new HttpException(
                HttpStatus.InternalServerError,
                'AWS credentials not properly configured'
            );
        }

        // Check if bucket name is configured
        if (!bucketName) {
            console.error('AWS S3 bucket name not configured');
            throw new HttpException(
                HttpStatus.InternalServerError,
                'AWS S3 bucket name not configured'
            );
        }

        // Determine if we're using buffer or file path
        let body;
        if (file.buffer) {
            // Using multer memory storage (buffer)
            body = file.buffer;
            console.log('Uploading file from buffer:', file.originalname);
        } else if (file.path) {
            // Using multer disk storage (file path)
            // Check if file exists on disk
            if (!fs.existsSync(file.path)) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `File not found on disk: ${file.path}`
                );
            }
            body = fs.createReadStream(file.path);
            console.log('Uploading file from path:', file.path);
        } else {
            throw new HttpException(
                HttpStatus.BadRequest,
                'Invalid file: neither buffer nor path is available'
            );
        }

        // Upload the file to S3
        const uploadParams = {
            Bucket: bucketName,
            Key: key,
            Body: body,
            ContentType: file.mimetype,
        };

        try {
            await s3Client.send(new PutObjectCommand(uploadParams));
        } catch (awsError) {
            console.error('AWS S3 upload error:', awsError);
            throw new HttpException(
                HttpStatus.InternalServerError,
                `AWS S3 upload error: ${(awsError as Error).message || 'Unknown error'}`
            );
        }

        // Generate the URL for the uploaded file
        const region = typeof s3Client.config.region === 'string'
            ? s3Client.config.region
            : 'ap-southeast-2'; // Default region based on error message

        // Use the correct S3 URL format with dashed region
        const fileUrl = `https://${bucketName}.s3-${region}.amazonaws.com/${key}`;

        // Delete the temporary file if it exists on disk
        if (file.path && fs.existsSync(file.path)) {
            try {
                fs.unlinkSync(file.path);
            } catch (unlinkError) {
                console.warn(`Could not delete temporary file ${file.path}:`, unlinkError);
                // Continue execution even if temp file deletion fails
            }
        }

        return fileUrl;
    } catch (error) {
        console.error('Error uploading file to S3:', error);
        if (error instanceof HttpException) {
            throw error;
        }
        throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload file to S3');
    }
};

/**
 * Upload multiple files to AWS S3
 * @param files Array of files to upload (from multer)
 * @param sampleId The sample ID to use in the folder path
 * @param folder The base folder to upload to (from s3Folders)
 * @returns Array of URLs of the uploaded files
 */
export const uploadMultipleFilesToS3 = async (
    files: Express.Multer.File[],
    sampleId?: string,
    folder: string = s3Folders.personImages
): Promise<string[]> => {
    try {
        // Validate files array
        if (!files || !Array.isArray(files) || files.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'No files provided for upload');
        }

        // Check if each file has the necessary properties
        files.forEach((file, index) => {
            if (!file || (!file.buffer && !file.path)) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Invalid file at index ${index}: missing buffer or path`
                );
            }
        });

        const uploadPromises = files.map(file => uploadFileToS3(file, sampleId, folder));
        return await Promise.all(uploadPromises);
    } catch (error) {
        console.error('Error uploading multiple files to S3:', error);
        if (error instanceof HttpException) {
            throw error;
        }
        throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload files to S3');
    }
};

// // Re-export s3Folders from aws.config.ts
export { s3Folders };

// // Define additional folders
// export const s3Folders = {
//     ...s3Folders,
//     blogImages: 'blog-images'
// }; 


================================================
FILE: src/core/utils/sendMail.ts
================================================
import nodemailer from 'nodemailer';
import { ISendMailDetail } from '../interfaces';

/**
 * Tạo HTML template cho email xác nhận đăng ký
 * @param userName Tên người dùng
 * @param verificationLink Link xác nhận
 * @returns HTML string
 */
export const createVerificationEmailTemplate = (userName: string, verificationLink: string): string => {
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Verify Your Email</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
                background-color: #f9f9f9;
            }
            .container {
                max-width: 600px;
                margin: 0 auto;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .header {
                text-align: center;
                padding: 20px 0;
                border-bottom: 1px solid #eee;
            }
            .logo {
                font-size: 24px;
                font-weight: bold;
                color: #2c3e50;
            }
            .content {
                padding: 20px 0;
            }
            .verification-button {
                display: inline-block;
                background-color: #3498db;
                color: white;
                text-decoration: none;
                padding: 12px 24px;
                border-radius: 4px;
                margin: 20px 0;
                font-weight: bold;
            }
            .verification-link {
                margin: 15px 0;
                word-break: break-all;
                color: #3498db;
            }
            .footer {
                text-align: center;
                color: #7f8c8d;
                font-size: 12px;
                margin-top: 30px;
                padding-top: 15px;
                border-top: 1px solid #eee;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <div class="logo">Bloodline DNA Testing Service</div>
            </div>
            <div class="content">
                <h2>Verify Your Email Address</h2>
                <p>Hello, <strong>${userName}</strong>!</p>
                <p>Thank you for registering with Bloodline DNA Testing Service. To complete your registration and access our services, please verify your email address by clicking the button below:</p>
                
                <div style="text-align: center;">
                    <a href="${verificationLink}" class="verification-button">Verify Email</a>
                </div>
                
                <p>If the button above doesn't work, please copy and paste the following link into your browser:</p>
                <div class="verification-link">
                    <a href="${verificationLink}">${verificationLink}</a>
                </div>
                
                <p>This verification link will expire in 24 hours.</p>
                
                <p>If you did not create an account with us, please disregard this email.</p>
            </div>
            <div class="footer">
                <p>&copy; ${new Date().getFullYear()} Bloodline DNA Testing Service. All rights reserved.</p>
                <p>This is an automated email, please do not reply.</p>
            </div>
        </div>
    </body>
    </html>
    `;
};

/**
 * Tạo HTML template cho email quên mật khẩu
 * @param userName Tên người dùng
 * @param resetLink Link đặt lại mật khẩu
 * @returns HTML string
 */
export const createPasswordResetEmailTemplate = (userName: string, resetLink: string): string => {
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Reset Your Password</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
                background-color: #f9f9f9;
            }
            .container {
                max-width: 600px;
                margin: 0 auto;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .header {
                text-align: center;
                padding: 20px 0;
                border-bottom: 1px solid #eee;
            }
            .logo {
                font-size: 24px;
                font-weight: bold;
                color: #2c3e50;
            }
            .content {
                padding: 20px 0;
            }
            .reset-button {
                display: inline-block;
                background-color: #e74c3c;
                color: white;
                text-decoration: none;
                padding: 12px 24px;
                border-radius: 4px;
                margin: 20px 0;
                font-weight: bold;
            }
            .reset-link {
                margin: 15px 0;
                word-break: break-all;
                color: #e74c3c;
            }
            .footer {
                text-align: center;
                color: #7f8c8d;
                font-size: 12px;
                margin-top: 30px;
                padding-top: 15px;
                border-top: 1px solid #eee;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <div class="logo">Bloodline DNA Testing Service</div>
            </div>
            <div class="content">
                <h2>Reset Your Password</h2>
                <p>Hello, <strong>${userName}</strong>!</p>
                <p>We received a request to reset your password. If you didn't make this request, you can safely ignore this email.</p>
                
                <div style="text-align: center;">
                    <a href="${resetLink}" class="reset-button">Reset Password</a>
                </div>
                
                <p>If the button above doesn't work, please copy and paste the following link into your browser:</p>
                <div class="reset-link">
                    <a href="${resetLink}">${resetLink}</a>
                </div>
                
                <p>This password reset link will expire in 1 hour.</p>
                
                <p>If you did not request a password reset, please contact our support team immediately.</p>
            </div>
            <div class="footer">
                <p>&copy; ${new Date().getFullYear()} Bloodline DNA Testing Service. All rights reserved.</p>
                <p>This is an automated email, please do not reply.</p>
            </div>
        </div>
    </body>
    </html>
    `;
};

/**
 * Tạo HTML template cho email thông báo
 * @param userName Tên người dùng
 * @param title Tiêu đề thông báo
 * @param message Nội dung thông báo
 * @param actionLink Link hành động (tùy chọn)
 * @param actionText Nội dung nút hành động (tùy chọn)
 * @returns HTML string
 */
export const createNotificationEmailTemplate = (
    userName: string,
    title: string,
    message: string,
    actionLink?: string,
    actionText?: string
): string => {
    const actionButton = actionLink && actionText
        ? `<div style="text-align: center;">
            <a href="${actionLink}" style="display: inline-block; background-color: #3498db; color: white; text-decoration: none; padding: 12px 24px; border-radius: 4px; margin: 20px 0; font-weight: bold;">${actionText}</a>
           </div>`
        : '';

    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${title}</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
                background-color: #f9f9f9;
            }
            .container {
                max-width: 600px;
                margin: 0 auto;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .header {
                text-align: center;
                padding: 20px 0;
                border-bottom: 1px solid #eee;
            }
            .logo {
                font-size: 24px;
                font-weight: bold;
                color: #2c3e50;
            }
            .content {
                padding: 20px 0;
            }
            .footer {
                text-align: center;
                color: #7f8c8d;
                font-size: 12px;
                margin-top: 30px;
                padding-top: 15px;
                border-top: 1px solid #eee;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <div class="logo">Bloodline DNA Testing Service</div>
            </div>
            <div class="content">
                <h2>${title}</h2>
                <p>Hello, <strong>${userName}</strong>!</p>
                <p>${message}</p>
                
                ${actionButton}
                
            </div>
            <div class="footer">
                <p>&copy; ${new Date().getFullYear()} Bloodline DNA Testing Service. All rights reserved.</p>
                <p>This is an automated email, please do not reply.</p>
            </div>
        </div>
    </body>
    </html>
    `;
};

/**
 * Gửi email với nội dung đã được định dạng
 * @param sendMailDetail Chi tiết email cần gửi
 * @returns Promise<any>
 */
export const sendMail = async (sendMailDetail: ISendMailDetail): Promise<any> => {
    const { toMail, subject, content, html } = sendMailDetail;

    const emailAdmin = process.env.EMAIL_USER;

    // Tạo transporter cho nodemailer
    const transporter = nodemailer.createTransport({
        service: 'Gmail',
        auth: {
            user: emailAdmin,
            pass: process.env.EMAIL_PASSWORD,
        },
    });

    // Cấu hình email
    const mailOptions = {
        from: `"Bloodline DNA Testing Service" <${emailAdmin}>`,
        to: toMail,
        subject,
        text: content || '',
        html: html || (content ? `<p>${content}</p>` : ''),
    };

    try {
        // Gửi email
        const info = await transporter.sendMail(mailOptions);
        return info;
    } catch (error) {
        throw error;
    }
};



================================================
FILE: src/core/utils/service.ts
================================================
import { SearchPaginationResponseModel } from '../models';
import { PaginationResponseModel } from '../models/pagination.model';

export const formatPaginationResult = <T>(
    result: SearchPaginationResponseModel<T>,
    items: any[],
    paginationInfo: PaginationResponseModel,
) => {
    result.pageInfo.pageNum = paginationInfo.pageNum;
    result.pageInfo.pageSize = paginationInfo.pageSize;
    if (paginationInfo.totalItems > 0) {
        result.pageData = items;
        result.pageInfo.totalItems = paginationInfo.totalItems;
        result.pageInfo.totalPages = Math.ceil(paginationInfo.totalItems / paginationInfo.pageSize);
    }

    return result;
};



================================================
FILE: src/core/utils/token.ts
================================================
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import { DataStoredInToken, TokenData } from '../../modules/auth';
import { IUser } from '../../modules/user';

export const createToken = (user: IUser): TokenData => {
    const dataInToken: DataStoredInToken = { id: user.id, role: user.role, version: user.token_version };
    const secret: string = process.env.JWT_TOKEN_SECRET!;
    const expiresIn: number = 28800; // 8 hours
    return {
        token: jwt.sign(dataInToken, secret, { expiresIn }),
    };
};

// create token verification
export const createTokenVerifiedUser = () => {
    return {
        verification_token: crypto.randomBytes(16).toString('hex'), // generate random bytes, convert to hex
        verification_token_expires: new Date(Date.now() + 1000 * 60 * 60 * 24), // 24 hours
    };
};



================================================
FILE: src/core/utils/validateEnv.ts
================================================
import { cleanEnv, str } from 'envalid';

// validate environment variables
const validateEnv = () => {
    cleanEnv(process.env, {
        NODE_ENV: str(),
        MONGODB_URI: str(),
    });
};

export default validateEnv;



================================================
FILE: src/core/utils/validation.ts
================================================
import { HttpStatus } from '../enums';
import { HttpException } from '../exceptions';

export const checkUserMatch = (userId: string, userInItem: string, title: string) => {
    if (userId !== userInItem) {
        throw new HttpException(HttpStatus.BadRequest, `You cannot update or delete another user's ${title}!`);
    }
};

export const checkValidUrl = (url: string) => {
    const urlPattern = /^(http:\/\/|https:\/\/)/i;
    return urlPattern.test(url);
};



================================================
FILE: src/modules/administrative_cases/administrative_cases.controller.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import AdministrativeCasesService from './administrative_cases.service';
import { UserRoleEnum } from '../user/user.enum';

export default class AdministrativeCasesController {
    private administrativeCasesService = new AdministrativeCasesService();

    public createCase = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const data = req.body;
            const applicantId = req.user.id;
            const result = await this.administrativeCasesService.createCase(data, applicantId);
            res.status(HttpStatus.Created).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    public getCaseById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const id = req.params.id;
            const result = await this.administrativeCasesService.getCaseById(id);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    public updateCase = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const id = req.params.id;
            const data = req.body;
            const result = await this.administrativeCasesService.updateCase(id, data);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    public deleteCase = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const id = req.params.id;
            const isDeleted = await this.administrativeCasesService.deleteCase(id);
            if (!isDeleted) {
                throw new HttpException(HttpStatus.NotFound, 'Administrative case not found');
            }
            res.status(HttpStatus.Success).json(formatResponse<string>('Deleted administrative case successfully!'));
        } catch (error) {
            next(error);
        }
    };

    public listCases = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const result = await this.administrativeCasesService.listCases(req.query);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };
}



================================================
FILE: src/modules/administrative_cases/administrative_cases.enum.ts
================================================
export enum AdministrativeCaseStatus {
    PENDING = 'pending',
    APPROVED = 'approved',
    DENIED = 'denied'
}


================================================
FILE: src/modules/administrative_cases/administrative_cases.interface.ts
================================================
import { Document } from 'mongoose';
import { AdministrativeCaseStatus } from './administrative_cases.enum';

export type AdministrativeCaseStatusType =
    AdministrativeCaseStatus.PENDING |
    AdministrativeCaseStatus.APPROVED |
    AdministrativeCaseStatus.DENIED;

export interface IAdministrativeCase extends Document {
    id: string;

    // Đây là một định danh duy nhất cho các trường hợp xét nghiệm DNA hành chính, 
    // thường được cơ quan chính phủ cấp để theo dõi, 
    // chẳng hạn như trong các trường hợp nhập cư . 
    // Nó giúp liên kết cuộc hẹn với một vụ việc cụ thể.
    case_number: string;

    // Đây là mã do cơ quan có thẩm quyền cung cấp để phê duyệt xét nghiệm DNA, 
    // đảm bảo rằng xét nghiệm được thực hiện hợp pháp . 
    // Nó đóng vai trò như một cơ chế xác minh.
    authorization_code: string; // số phép

    status: AdministrativeCaseStatusType;
    // cơ quan thẩm quyền
    agency_contact_email: string;
    agency_contact_name: string;
    agency_contact_phone: string;

    // người gửi - admin, manager
    applicant_name: string;
    applicant_email: string;
    applicant_id: string | undefined;

    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;

}


================================================
FILE: src/modules/administrative_cases/administrative_cases.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IAdministrativeCase } from './administrative_cases.interface';
import { AdministrativeCaseStatus } from './administrative_cases.enum';

const AdministrativeCaseSchemaEntity: Schema<IAdministrativeCase> = new Schema({
    case_number: { type: String, required: true, unique: true },
    authorization_code: { type: String, required: true, unique: true },
    status: {
        type: String,
        enum: Object.values(AdministrativeCaseStatus),
        required: true,
        default: AdministrativeCaseStatus.PENDING
    },
    agency_contact_email: { type: String, required: true },
    agency_contact_name: { type: String, required: true },
    agency_contact_phone: { type: String, required: true },
    applicant_name: { type: String, required: true },
    applicant_email: { type: String, required: true },
    applicant_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false }
});

export const AdministrativeCaseSchema = mongoose.model<IAdministrativeCase>(COLLECTION_NAME.ADMINISTRATIVE_CASE, AdministrativeCaseSchemaEntity);




================================================
FILE: src/modules/administrative_cases/administrative_cases.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import AdministrativeCasesController from './administrative_cases.controller';
import { CreateAdministrativeCaseDto } from './dtos/commonAdminCases.dto';

export default class AdministrativeCasesRouter implements IRoute {
    public path = API_PATH.ADMINISTRATIVE_CASES;
    public router = Router();
    private administrativeCasesController = new AdministrativeCasesController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/administrative-cases -> Create administrative case
        this.router.post(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            // validationMiddleware(CreateAdministrativeCaseDto),
            this.administrativeCasesController.createCase
        );

        // GET: domain:/api/administrative-cases/:id -> Get administrative case by id
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.administrativeCasesController.getCaseById
        );

        // PUT: domain:/api/administrative-cases/:id -> Update administrative case
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            // validationMiddleware(CreateAdministrativeCaseDto),
            this.administrativeCasesController.updateCase
        );

        // DELETE: domain:/api/administrative-cases/:id -> Delete administrative case
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.administrativeCasesController.deleteCase
        );

        // GET: domain:/api/administrative-cases -> Get all administrative cases
        this.router.get(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.administrativeCasesController.listCases
        );
    }
}





================================================
FILE: src/modules/administrative_cases/administrative_cases.service.ts
================================================
import { AdministrativeCaseSchema } from './administrative_cases.model';
import { IAdministrativeCase } from './administrative_cases.interface';
import { AdministrativeCaseStatus } from './administrative_cases.enum';
import UserSchema from '../user/user.model';
import { UserRoleEnum } from '../user';
import { CreateAdministrativeCaseDto } from './dtos/commonAdminCases.dto';
import { validateOrReject } from 'class-validator';

export default class AdministrativeCasesService {
    public async createCase(data: Partial<IAdministrativeCase>, userId: string): Promise<IAdministrativeCase> {
        const user = await UserSchema.findById(userId).lean();
        if (!user) {
            throw new Error('User not found');
        }
        if (user.role !== UserRoleEnum.ADMIN && user.role !== UserRoleEnum.MANAGER) {
            throw new Error('Only ADMIN or MANAGER can create administrative case');
        }

        // Always override applicant fields from user
        const caseData: any = { ...data };
        caseData.applicant_name = `${user.first_name ?? ''} ${user.last_name ?? ''}`.trim();
        caseData.applicant_email = user.email;
        caseData.applicant_id = user._id?.toString?.() ?? userId;
        caseData.status = AdministrativeCaseStatus.PENDING;

        // Validate using DTO
        const dto = Object.assign(new CreateAdministrativeCaseDto(), caseData);
        await validateOrReject(dto);

        return AdministrativeCaseSchema.create({ ...caseData });
    }

    public async getCaseById(id: string): Promise<IAdministrativeCase | null> {
        return AdministrativeCaseSchema.findById(id).populate('applicant_id', 'email first_name last_name role');
    }

    public async updateCase(id: string, data: Partial<IAdministrativeCase>): Promise<IAdministrativeCase | null> {
        if (data.is_deleted) {
            throw new Error('Cannot update deleted case');
        }
        const existingCase = await AdministrativeCaseSchema.findById(id);
        if (!existingCase) {
            throw new Error('Case not found');
        }
        if (existingCase.is_deleted) {
            throw new Error('Cannot update deleted case');
        }
        if (data.applicant_id) {
            const user = await UserSchema.findById(data.applicant_id);
            if (!user) {
                throw new Error('User not found');
            }
            if (user.role !== UserRoleEnum.ADMIN && user.role !== UserRoleEnum.MANAGER) {
                throw new Error('Only ADMIN or MANAGER can be applicant');
            }
            data.applicant_name = user.first_name + ' ' + user.last_name;
            data.applicant_email = user.email;
        }
        if (data.agency_contact_email) {
            data.agency_contact_email = data.agency_contact_email.toLowerCase();
        }
        if (data.applicant_email) {
            data.applicant_email = data.applicant_email.toLowerCase();
        }
        data.updated_at = new Date();

        // Validate using DTO (merge with existing for full object)
        const merged = { ...existingCase.toObject(), ...data };
        const dto = Object.assign(new CreateAdministrativeCaseDto(), merged);
        await validateOrReject(dto);
        return AdministrativeCaseSchema.findByIdAndUpdate(id, data, { new: true }).populate('applicant_id', 'email first_name last_name role');
    }

    public async deleteCase(id: string): Promise<IAdministrativeCase | null> {
        return AdministrativeCaseSchema.findByIdAndUpdate(
            id,
            { is_deleted: true },
            { new: true }
        );
    }

    public async listCases(query: any): Promise<IAdministrativeCase[]> {
        return AdministrativeCaseSchema.find(query).populate('applicant_id', 'email first_name last_name role');
    }
}



================================================
FILE: src/modules/administrative_cases/index.ts
================================================
import { AdministrativeCaseSchema } from './administrative_cases.model';
import { IAdministrativeCase } from './administrative_cases.interface';
import AdministrativeCasesController from './administrative_cases.controller';
import AdministrativeCasesService from './administrative_cases.service';
import AdministrativeCasesRoute from './administrative_cases.route';

export {
    AdministrativeCaseSchema,
    IAdministrativeCase,
    AdministrativeCasesController,
    AdministrativeCasesService,
    AdministrativeCasesRoute
};


================================================
FILE: src/modules/administrative_cases/dtos/commonAdminCases.dto.ts
================================================
import { IsString, IsEmail, IsOptional, Matches, IsEnum } from 'class-validator';
import { AdministrativeCaseStatus } from '../administrative_cases.enum';

export class CreateAdministrativeCaseDto {
    @IsString()
    // Format: AC-YYYYMMDD-XXXX (AC = Administrative Case, date, 4 số)
    @Matches(/^AC-\d{8}-\d{4}$/, {
        message: 'case_number must be in format AC-YYYYMMDD-XXXX (e.g., AC-20240601-0001)'
    })
    case_number!: string;

    @IsString()
    // Format: AUTH-XXXXXX (AUTH = Authorization, 6 ký tự chữ/số)
    @Matches(/^AUTH-[A-Z0-9]{6}$/, {
        message: 'authorization_code must be in format AUTH-XXXXXX (e.g., AUTH-1A2B3C)'
    })
    authorization_code!: string;

    @IsEmail()
    agency_contact_email!: string;

    @IsString()
    agency_contact_name!: string;

    @IsString()
    agency_contact_phone!: string;

    @IsString()
    applicant_name!: string;

    @IsEmail()
    applicant_email!: string;

    @IsString()
    applicant_id!: string;

    @IsOptional()
    created_at?: Date;

    @IsOptional()
    updated_at?: Date;

    @IsOptional()
    @IsEnum(AdministrativeCaseStatus)
    status?: AdministrativeCaseStatus;

    @IsOptional()
    is_deleted?: boolean;
}



================================================
FILE: src/modules/administrative_cases/swagger/swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: administrative_cases
 *   description: Quản lý các vụ việc xét nghiệm DNA hành chính
 */

/**
 * @swagger
 * /api/administrative-cases:
 *   post:
 *     tags: [administrative_cases]
 *     summary: Tạo mới vụ việc hành chính
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/AdministrativeCase'
 *     responses:
 *       201:
 *         description: Tạo thành công
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AdministrativeCase'
 *   get:
 *     tags: [administrative_cases]
 *     summary: Lấy danh sách vụ việc hành chính
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Danh sách vụ việc
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/AdministrativeCase'
 * /api/administrative-cases/{id}:
 *   get:
 *     tags: [administrative_cases]
 *     summary: Lấy chi tiết vụ việc hành chính
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Chi tiết vụ việc
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AdministrativeCase'
 *   put:
 *     tags: [administrative_cases]
 *     summary: Cập nhật vụ việc hành chính
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/AdministrativeCase'
 *     responses:
 *       200:
 *         description: Cập nhật thành công
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AdministrativeCase'
 *   delete:
 *     tags: [administrative_cases]
 *     summary: Xoá vụ việc hành chính
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Xoá thành công
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     AdministrativeCase:
 *       type: object
 *       properties:
 *         case_number:
 *           type: string
 *         authorization_code:
 *           type: string
 *         agency_contact_email:
 *           type: string
 *         agency_contact_name:
 *           type: string
 *         agency_contact_phone:
 *           type: string
 */


================================================
FILE: src/modules/appointment/appointment.constant.ts
================================================
import { AppointmentStatusEnum, TypeEnum } from './appointment.enum';

export const AppointmentStatuses = [
    '',
    AppointmentStatusEnum.PENDING,
    AppointmentStatusEnum.CONFIRMED,
    AppointmentStatusEnum.SAMPLE_COLLECTED,
    AppointmentStatusEnum.SAMPLE_RECEIVED,
    AppointmentStatusEnum.TESTING,
    AppointmentStatusEnum.COMPLETED,
    AppointmentStatusEnum.CANCELLED
];

export const CollectionTypes = [
    '',
    TypeEnum.SELF,
    TypeEnum.FACILITY,
    TypeEnum.HOME
]; 


================================================
FILE: src/modules/appointment/appointment.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IAppointment } from './appointment.interface';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';
import { AssignStaffDto } from './dtos/assign-staff.dto';
import { ConfirmAppointmentDto } from './dtos/confirm-appointment.dto';
import { SearchAppointmentDto } from './dtos/search-appointment.dto';
import AppointmentService from './appointment.service';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { UserRoleEnum } from '../user/user.enum';
import { ISample } from '../sample/sample.interface';

export default class AppointmentController {
    private appointmentService = new AppointmentService();

    /**
     * Create a new appointment
     */
    public createAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const appointmentData: CreateAppointmentDto = req.body;
            const appointment = await this.appointmentService.createAppointment(userId, appointmentData);

            // Return a success response with the created appointment
            res.status(HttpStatus.Created).json(formatResponse<IAppointment>(appointment));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get appointment by ID
     */
    public getAppointmentById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.id;
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Search appointments with filters
     */
    public searchAppointments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            const userRole = req.user.role;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Convert query parameters to SearchAppointmentDto
            const searchParams: SearchAppointmentDto = {
                pageNum: req.query.pageNum ? parseInt(req.query.pageNum as string) : 1,
                pageSize: req.query.pageSize ? parseInt(req.query.pageSize as string) : 10,
                user_id: req.query.user_id as string,
                service_id: req.query.service_id as string,
                status: req.query.status as any,
                type: req.query.type as any,
                staff_id: req.query.staff_id as string,
                start_date: req.query.start_date as string,
                end_date: req.query.end_date as string,
                search_term: req.query.search_term as string
            };

            const result = await this.appointmentService.searchAppointments(
                searchParams,
                userRole,
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointment>>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Assign staff to appointment
     * @route PUT /api/appointment/:id/assign-staff
     */
    public assignStaff = async (req: Request, res: Response, next: NextFunction) => {
        try {
            // Kiểm tra quyền truy cập
            if (req.user.role !== UserRoleEnum.MANAGER && req.user.role !== UserRoleEnum.ADMIN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only managers and admins can assign staff to appointments');
            }

            const appointmentId = req.params.id;
            const assignStaffData: AssignStaffDto = req.body;

            try {
                const appointment = await this.appointmentService.assignStaff(appointmentId, assignStaffData);
                res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment));
            } catch (error) {
                // Kiểm tra nếu lỗi liên quan đến giới hạn số lượng cuộc hẹn
                if (error instanceof HttpException &&
                    error.status === HttpStatus.BadRequest &&
                    error.message.includes('appointment limit')) {

                    // Trả về lỗi với gợi ý về nhân viên thay thế
                    res.status(error.status).json({
                        success: false,
                        message: error.message,
                        suggestion: 'Consider using another staff member who has not reached their appointment limit'
                    });
                } else {
                    // Trả về lỗi thông thường
                    next(error);
                }
            }
        } catch (error) {
            next(error);
        }
    };

    /**
     * Confirm appointment and assign kit to laboratory technician (by staff)
     */
    public confirmAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const appointmentId = req.params.id;
            const confirmData: ConfirmAppointmentDto = req.body;
            const userRole = req.user.role;

            const updatedAppointment = await this.appointmentService.confirmAppointment(
                appointmentId,
                confirmData,
                staffId,
                userRole
            );

            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(updatedAppointment as IAppointment));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get samples for an appointment
     */
    public getAppointmentSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.id;
            const samples = await this.appointmentService.getAppointmentSamples(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    };

    public getAppointmentPrice = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { appointmentId } = req.params;
            const price = await this.appointmentService.getAppointmentPrice(appointmentId);

            res.status(HttpStatus.Success).json(
                formatResponse({ price }, true, 'Appointment price retrieved successfully')
            );
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get staff roles (Department Manager only)
     */
    public getStaffRoles = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            const userRole = req.user.role;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const staffRoles = await this.appointmentService.getUserRoleStaff();

            res.status(HttpStatus.Success).json(formatResponse<string[]>(staffRoles));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get available slots for logged-in staff
     */

    public getStaffAvailableSlots = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const slots = await this.appointmentService.getStaffAvailableSlots(staffId);

            res.status(HttpStatus.Success).json(formatResponse<any[]>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get appointments assigned to staff
     */
    public getStaffAssignedAppointments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Convert query parameters to SearchAppointmentDto format
            const searchParams: SearchAppointmentDto = {
                pageNum: req.query.pageNum ? parseInt(req.query.pageNum as string) : 1,
                pageSize: req.query.pageSize ? parseInt(req.query.pageSize as string) : 10,
                user_id: req.query.user_id as string,
                service_id: req.query.service_id as string,
                status: req.query.status as any,
                type: req.query.type as any,
                staff_id: req.query.staff_id as string,
                start_date: req.query.start_date as string,
                end_date: req.query.end_date as string,
                search_term: req.query.search_term as string
            };

            const appointments = await this.appointmentService.getStaffAssignedAppointments(staffId, searchParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointment>>(appointments));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get appointments assigned to laboratory technician
     */
    public getLabTechAssignedAppointments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const labTechId = req.user.id;
            if (!labTechId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Convert query parameters to SearchAppointmentDto format
            const searchParams: SearchAppointmentDto = {
                pageNum: req.query.pageNum ? parseInt(req.query.pageNum as string) : 1,
                pageSize: req.query.pageSize ? parseInt(req.query.pageSize as string) : 10,
                user_id: req.query.user_id as string,
                service_id: req.query.service_id as string,
                status: req.query.status as any,
                type: req.query.type as any,
                staff_id: req.query.staff_id as string,
                start_date: req.query.start_date as string,
                end_date: req.query.end_date as string,
                search_term: req.query.search_term as string
            };

            const appointments = await this.appointmentService.getLabTechAssignedAppointments(labTechId, searchParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointment>>(appointments));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Assign laboratory technician to appointment
     */
    public assignLabTechnician = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const { lab_tech_id } = req.body;
            const appointment = await this.appointmentService.assignLabTechnician(id, lab_tech_id);
            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get available laboratory technicians
     */
    public getAvailableLabTechnicians = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;
            if (userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(HttpStatus.Forbidden, 'Only staff can view laboratory technicians');
            }

            const labTechs = await this.appointmentService.getAvailableLabTechnicians();
            res.status(HttpStatus.Success).json(formatResponse<any[]>(labTechs));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Unassign staff from appointment
     * @route PUT /api/appointment/:id/unassign-staff
     */
    public unassignStaff = async (req: Request, res: Response, next: NextFunction) => {
        try {
            // Kiểm tra quyền truy cập
            if (req.user.role !== UserRoleEnum.MANAGER && req.user.role !== UserRoleEnum.ADMIN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only managers and admins can unassign staff from appointments');
            }

            const appointmentId = req.params.id;
            const appointment = await this.appointmentService.unassignStaff(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment, true, 'Staff unassigned successfully'));
        } catch (error) {
            next(error);
        }
    };

}



================================================
FILE: src/modules/appointment/appointment.enum.ts
================================================
export enum AppointmentStatusEnum {
    PENDING = 'pending',
    CONFIRMED = 'confirmed',
    SAMPLE_ASSIGNED = 'sample_assigned',
    SAMPLE_COLLECTED = 'sample_collected',
    SAMPLE_RECEIVED = 'sample_received',
    TESTING = 'testing',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled'
}

export enum TypeEnum {
    SELF = 'self',
    FACILITY = 'facility',
    HOME = 'home'
}

export enum PaymentStatusEnum {
    UNPAID = 'unpaid',
    PAID = 'paid',
    REFUNDED = 'refunded',
    FAILED = 'failed'
} 


================================================
FILE: src/modules/appointment/appointment.interface.ts
================================================
import { Document } from 'mongoose';
import { AppointmentStatusEnum, TypeEnum, PaymentStatusEnum } from './appointment.enum';
import { ISample } from '../sample/sample.interface';

export type AppointmentStatus =
    AppointmentStatusEnum.PENDING |
    AppointmentStatusEnum.CONFIRMED |
    AppointmentStatusEnum.SAMPLE_COLLECTED |
    AppointmentStatusEnum.SAMPLE_RECEIVED |
    AppointmentStatusEnum.TESTING |
    AppointmentStatusEnum.COMPLETED |
    AppointmentStatusEnum.CANCELLED;

export type CollectionType =
    TypeEnum.SELF |
    TypeEnum.FACILITY |
    TypeEnum.HOME;

// Interface for sample information in appointment response
export interface ISampleInfo {
    _id: string;
    type: string;
    status: string;
    kit_id: string;
}

export interface IAppointment extends Document {
    _id: string;
    user_id: string | undefined;
    service_id: string | undefined;
    slot_id?: string | undefined;
    staff_id?: string | undefined;
    laboratory_technician_id?: string | undefined;
    agency_contact_email?: string;
    email?: string;
    appointment_date: Date;
    type: TypeEnum;
    collection_address?: string;
    status: AppointmentStatusEnum;
    payment_status: PaymentStatusEnum;
    administrative_case_id?: string | any;
    created_at: Date;
    updated_at: Date;
}


================================================
FILE: src/modules/appointment/appointment.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { AppointmentStatuses, CollectionTypes } from './appointment.constant';
import { IAppointment } from './appointment.interface';
import { AppointmentStatusEnum, TypeEnum, PaymentStatusEnum } from './appointment.enum';

const AppointmentSchemaEntity: Schema<IAppointment> = new Schema({
    user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE, required: true },
    slot_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SLOT },
    staff_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    laboratory_technician_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    agency_contact_email: { type: String }, // Thêm trường này để lưu email của agency tại thời điểm tạo appointment
    appointment_date: { type: Date, required: true }, // Thêm trường này để lưu ngày tạo appointment
    type: {
        type: String,
        enum: Object.values(TypeEnum),
        required: true
    },
    collection_address: { type: String },
    status: {
        type: String,
        enum: Object.values(AppointmentStatusEnum),
        required: true,
        default: AppointmentStatusEnum.PENDING
    },
    payment_status: {
        type: String,
        enum: Object.values(PaymentStatusEnum),
        required: true,
        default: PaymentStatusEnum.UNPAID
    },
    administrative_case_id: { type: Schema.Types.ObjectId, ref: 'administrative_cases', required: false },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const AppointmentSchema = mongoose.model<IAppointment & mongoose.Document>(
    COLLECTION_NAME.APPOINTMENT,
    AppointmentSchemaEntity
);

export default AppointmentSchema;



================================================
FILE: src/modules/appointment/appointment.repository.ts
================================================
import AppointmentSchema from './appointment.model';
import { IAppointment } from './appointment.interface';
import SampleSchema from '../sample/sample.model';
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';

export default class AppointmentRepository {
    private appointmentSchema = AppointmentSchema;

    public async create(data: Partial<IAppointment>): Promise<IAppointment> {
        return AppointmentSchema.create(data);
    }

    public async findOne(query: any): Promise<IAppointment | null> {
        return AppointmentSchema.findOne(query);
    }

    public async findById(id: string): Promise<IAppointment | null> {
        return AppointmentSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, updateData: Partial<IAppointment>, options?: any): Promise<IAppointment | null> {
        return AppointmentSchema.findByIdAndUpdate(id, updateData, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return AppointmentSchema.countDocuments(query);
    }

    public async find(query: any): Promise<IAppointment[]> {
        return AppointmentSchema.find(query);
    }

    public async findAll(query: any): Promise<IAppointment[]> {
        return AppointmentSchema.find(query);
    }

    public async findWithPopulate(query: any): Promise<IAppointment[]> {
        return AppointmentSchema.find(query)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('staff_id', 'first_name last_name email phone_number')
            .populate('slot_id')
            .populate('laboratory_technician_id', 'first_name last_name email phone_number');
    }

    public async findByIdWithPopulate(id: string): Promise<IAppointment | null> {
        return AppointmentSchema.findById(id)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('staff_id', 'first_name last_name email phone_number')
            .populate('slot_id')
            .populate('administrative_case_id', 'case_number authorization_code agency_contact_email agency_contact_name agency_contact_phone')
            .populate('payment_status')
            .populate('laboratory_technician_id', 'first_name last_name email phone_number');
    }

    public async findWithPaginationAndPopulate(
        query: any,
        sort: any,
        skip: number,
        limit: number
    ): Promise<IAppointment[]> {
        return AppointmentSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price type is_active estimated_time')
            .populate('staff_id', 'first_name last_name email phone_number')
            .populate('slot_id')
            .populate('laboratory_technician_id', 'first_name last_name email phone_number');
    }

    public async findByUserIdWithPagination(
        userId: string,
        skip: number,
        limit: number,
        sort: any = { created_at: -1 }
    ): Promise<IAppointment[]> {
        const appointments = await this.appointmentSchema.find({ user_id: userId })
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('service_id', 'name price')
            .populate('staff_id', 'first_name last_name')
            .populate('slot_id')
            .populate('laboratory_technician_id', 'first_name last_name');
        return appointments;
    }

    public async findByStaffIdWithPagination(
        staffId: string,
        skip: number,
        limit: number,
        query: any = {},
        sort: any = { created_at: -1 }
    ): Promise<IAppointment[]> {
        const appointments = await this.appointmentSchema.find({
            staff_id: staffId,
            ...query
        })
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('slot_id');
        return appointments;
    }

    public async findByLabTechIdWithPagination(
        labTechId: string,
        skip: number,
        limit: number,
        query: any = {},
        sort: any = { created_at: -1 }
    ): Promise<IAppointment[]> {
        const appointments = await this.appointmentSchema.find({
            laboratory_technician_id: labTechId,
            ...query
        })
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('slot_id')
            .populate('staff_id', 'first_name last_name');
        return appointments;
    }

    public async countAppointmentsByStaffAndSlot(staffId: string, slotId: string): Promise<number> {
        return AppointmentSchema.countDocuments({
            staff_id: staffId,
            slot_id: slotId
        });
    }
}



================================================
FILE: src/modules/appointment/appointment.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import AppointmentController from './appointment.controller';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';
import { AssignStaffDto } from './dtos/assign-staff.dto';
import { ConfirmAppointmentDto } from './dtos/confirm-appointment.dto';

export default class AppointmentRoute implements IRoute {
    public path = API_PATH.APPOINTMENT;
    public router = Router();
    private appointmentController = new AppointmentController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/appointment/search -> Search appointments with filters
        this.router.get(
            `${this.path}/search`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.searchAppointments
        );

        // POST: domain:/api/appointment/create -> Create a new appointment
        this.router.post(
            `${API_PATH.CREATE_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.CUSTOMER]), // Only customers can create appointments
            validationMiddleware(CreateAppointmentDto),
            this.appointmentController.createAppointment
        );

        // GET: domain:/api/appointment/:id -> Get appointment by ID
        this.router.get(
            `${API_PATH.GET_APPOINTMENT_BY_ID}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.getAppointmentById
        );

        // GET: domain:/api/appointment/:id/samples -> Get samples for an appointment
        this.router.get(
            `${this.path}/:id/samples`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.getAppointmentSamples
        );

        // PUT: domain:/api/appointment/:id/assign-staff -> Assign staff to appointment
        this.router.put(
            `${API_PATH.ASSIGN_STAFF_TO_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.MANAGER]), // Only managers can assign staff
            validationMiddleware(AssignStaffDto),
            this.appointmentController.assignStaff
        );

        // PUT: domain:/api/appointment/:id/confirm -> Confirm appointment and assign kit
        this.router.put(
            `${API_PATH.CONFIRM_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.STAFF]), // Only staff can confirm appointments
            validationMiddleware(ConfirmAppointmentDto),
            this.appointmentController.confirmAppointment
        );

        // GET: domain:/api/appointment/:appointmentId/price -> Get price for an appointment
        this.router.get(
            `${this.path}/:appointmentId/price`,
            authMiddleWare(),
            this.appointmentController.getAppointmentPrice
        );

        // GET: domain:/api/appointment/staff/available -> Get available staff
        this.router.get(
            `${this.path}/staff/available`,
            authMiddleWare([UserRoleEnum.MANAGER]),
            this.appointmentController.getStaffRoles
        );

        // GET: domain:/api/appointment/staff/slots -> Get available slots for logged-in staff
        this.router.get(
            `${this.path}/staff/slots`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.getStaffAvailableSlots
        );

        // GET: domain: /api/appointments/staff/assigned -> Get appointments assigned to staff
        this.router.get(
            `${this.path}/staff/assigned`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.getStaffAssignedAppointments
        );

        // GET: domain: /api/appointments/lab-tech/assigned -> Get appointments assigned to laboratory technician
        this.router.get(
            `${this.path}/lab-tech/assigned`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.getLabTechAssignedAppointments
        );

        // POST: domain: /api/appointments/:id/assign-lab-tech -> Assign laboratory technician to appointment
        this.router.post(
            `${this.path}/:id/assign-lab-tech`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.assignLabTechnician
        );

        // GET: domain: /api/appointment/lab-tech/available -> Get available laboratory technicians
        this.router.get(
            `${this.path}/lab-tech/available`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.getAvailableLabTechnicians
        );

        // PUT domain:/api/appointment/:id/assign-staff -> Assign staff to an appointment
        this.router.put(
            `${this.path}/:id/assign-staff`,
            authMiddleWare([UserRoleEnum.MANAGER, UserRoleEnum.ADMIN]),
            validationMiddleware(AssignStaffDto),
            this.appointmentController.assignStaff
        );

        // PUT domain:/api/appointment/:id/unassign-staff -> Unassign staff from an appointment
        this.router.put(
            `${this.path}/:id/unassign-staff`,
            authMiddleWare([UserRoleEnum.MANAGER, UserRoleEnum.ADMIN]),
            this.appointmentController.unassignStaff
        );
    }
} 


================================================
FILE: src/modules/appointment/appointment.service.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { SearchPaginationResponseModel } from '../../core/models';
import { IAppointment } from './appointment.interface';
import { AppointmentStatusEnum, TypeEnum, PaymentStatusEnum } from './appointment.enum';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';
import { AssignStaffDto } from './dtos/assign-staff.dto';
import { ConfirmAppointmentDto } from './dtos/confirm-appointment.dto';
import { SearchAppointmentDto } from './dtos/search-appointment.dto';
import AppointmentRepository from './appointment.repository';
import SlotSchema from '../slot/slot.model';
import { SlotStatusEnum } from '../slot/slot.enum';
import ServiceSchema from '../service/service.model';
import { SampleMethodEnum } from '../service/service.enum';
import { AppointmentLogService } from '../appointment_log';
import { AppointmentLogTypeEnum } from '../appointment_log/appointment_log.enum';
import KitService from '../kit/kit.service';
import StaffProfileSchema from '../staff_profile/staff_profile.model';
import { StaffStatusEnum } from '../staff_profile/staff_profile.enum';
import UserSchema from '../user/user.model';
import { UserRoleEnum } from '../user/user.enum';
import SampleService from '../sample/sample.service';
import { ISample } from '../sample/sample.interface';
import { sendMail, createNotificationEmailTemplate } from '../../core/utils';
import { ISendMailDetail } from '../../core/interfaces';
import { AdministrativeCaseSchema } from '../administrative_cases/administrative_cases.model';
import { AdministrativeCaseStatus } from '../administrative_cases/administrative_cases.enum';
import { ServiceTypeEnum } from '../service/service.enum';
import PaymentService from '../payment/payment.service';

export default class AppointmentService {
    private readonly appointmentRepository: AppointmentRepository;
    private readonly appointmentLogService: AppointmentLogService;
    private readonly kitService: KitService;
    private readonly staffProfileSchema: typeof StaffProfileSchema;
    private sampleService?: SampleService;

    constructor() {
        this.appointmentRepository = new AppointmentRepository();
        this.appointmentLogService = new AppointmentLogService();
        this.kitService = new KitService();
        this.staffProfileSchema = StaffProfileSchema;
    }

    private getSampleService(): SampleService {
        if (!this.sampleService) {
            this.sampleService = new SampleService();
        }
        return this.sampleService;
    }

    /**
     * Create a new appointment
     */
    public async createAppointment(userId: string, appointmentData: CreateAppointmentDto): Promise<IAppointment> {
        let appointment: IAppointment | null = null;
        let service: any = null;
        let slot: any = null;
        let staffId: any = null;
        let administrative_case_id: string | undefined;

        try {
            service = await ServiceSchema.findById(appointmentData.service_id);
            if (!service) {
                throw new HttpException(HttpStatus.NotFound, 'Service not found');
            }

            // ADMINISTRATIVE logic
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                // Validate
                if (!appointmentData.case_number || !appointmentData.authorization_code) {
                    throw new HttpException(HttpStatus.BadRequest, 'case_number and authorization_code are required for ADMINISTRATIVE service');
                }
                // Chỉ tìm administrative_case, không được tạo mới
                const adminCase = await AdministrativeCaseSchema.findOne({
                    case_number: appointmentData.case_number,
                    authorization_code: appointmentData.authorization_code
                });
                if (!adminCase) {
                    throw new HttpException(HttpStatus.NotFound, 'Administrative case not found or invalid');
                }
                administrative_case_id = (adminCase._id as any).toString();
                // Ép type = FACILITY
                appointmentData.type = TypeEnum.FACILITY;
            }

            // Nếu có slot_id, kiểm tra slot và lấy staff_id
            if (appointmentData.slot_id) {
                slot = await SlotSchema.findById(appointmentData.slot_id);
                if (!slot) {
                    throw new HttpException(HttpStatus.NotFound, 'Slot not found');
                }

                // Kiểm tra xem slot có khả dụng không
                if (slot.status !== SlotStatusEnum.AVAILABLE) {
                    throw new HttpException(HttpStatus.BadRequest, 'Slot is not available');
                }

                // Lấy staff profile từ slot
                if (slot.staff_profile_ids && slot.staff_profile_ids.length > 0) {
                    const staffProfile = await StaffProfileSchema.findById(slot.staff_profile_ids[0]);
                    if (staffProfile) {
                        // Lấy user ID từ staff profile
                        const staffUser = await UserSchema.findOne({ _id: staffProfile.user_id });
                        if (staffUser) {
                            staffId = staffUser._id;
                        }
                    }
                }

                // Nếu không có ngày appointment, sử dụng ngày từ slot entity
                if (!appointmentData.appointment_date) {
                    // set the appointment date to the slot's date
                    appointmentData.appointment_date = new Date(
                        slot?.time_slots?.[0]?.year ?? new Date().getFullYear(),
                        (slot?.time_slots?.[0]?.month ?? new Date().getMonth() + 1) - 1,
                        slot?.time_slots?.[0]?.day ?? new Date().getDate()
                    );

                    // set the appointment time to the slot's start time
                    if (slot?.time_slots?.[0]?.start_time) {
                        appointmentData.appointment_date.setHours(
                            slot.time_slots[0].start_time.hour,
                            slot.time_slots[0].start_time.minute,
                            0, 0
                        );
                    }
                }

            } else if (!appointmentData.appointment_date) {
                appointmentData.appointment_date = new Date();
            }

            // Đối với dịch vụ thu thập tại nhà, địa chỉ thu thập là bắt buộc
            if (appointmentData.type === TypeEnum.HOME && !appointmentData.collection_address) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Collection address is required for home collection'
                );
            }

            // Kiểm tra xem có agency_contact_email không
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE && !appointmentData.agency_contact_email) {
                throw new HttpException(HttpStatus.BadRequest, 'agency_contact_email is required for ADMINISTRATIVE service');
            }

            // set agency_contact_email to appointment entity bằng cách copy từ administrative_case
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE && appointmentData.agency_contact_email) {

                const adminCase = await AdministrativeCaseSchema.findOne({
                    case_number: appointmentData.case_number,
                    authorization_code: appointmentData.authorization_code
                });
                if (!adminCase) {
                    throw new HttpException(HttpStatus.NotFound, 'Administrative case not found or invalid');
                }
                administrative_case_id = (adminCase._id as any).toString();
                appointmentData.agency_contact_email = adminCase.agency_contact_email;
            }

            // Tạo appointment với staff_id nếu có
            appointment = await this.appointmentRepository.create({
                user_id: userId as any,
                service_id: appointmentData.service_id as any,
                slot_id: appointmentData.slot_id as any,
                staff_id: staffId as any, // Thêm staff_id nếu có
                appointment_date: new Date(appointmentData.appointment_date),
                type: appointmentData.type,
                collection_address: appointmentData.collection_address,
                status: AppointmentStatusEnum.PENDING,
                payment_status: service.type === ServiceTypeEnum.ADMINISTRATIVE ? PaymentStatusEnum.PAID : PaymentStatusEnum.UNPAID,
                administrative_case_id,
                agency_contact_email: service.type === ServiceTypeEnum.ADMINISTRATIVE ? appointmentData.agency_contact_email : undefined,
                created_at: new Date(),
                updated_at: new Date()
            });

            // Nếu là ADMINISTRATIVE, tạo payment PAID, amount=0, method=GOVERNMENT
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                try {
                    const paymentService = new PaymentService();
                    await paymentService.createAdministrativePayment(appointment._id.toString(), userId);
                } catch (paymentError) {
                    // Nếu lỗi khi tạo payment cho ADMINISTRATIVE, log lỗi nhưng KHÔNG throw 500
                    console.error('Failed to create administrative payment:', paymentError);
                    // Có thể thêm thông tin vào appointment để trả về cho client biết payment chưa được tạo
                    (appointment as any).paymentError = 'Failed to create administrative payment. Please contact support.';
                }
            }

            // Chỉ cập nhật status slot sau khi appointment được tạo thành công
            if (appointmentData.slot_id && slot) {
                // Atomically increment assigned_count
                const updatedSlot = await SlotSchema.findByIdAndUpdate(
                    appointmentData.slot_id,
                    { $inc: { assigned_count: 1 } }, // $inc ~ increment
                    { new: true }
                );
                if (!updatedSlot) {
                    throw new HttpException(HttpStatus.InternalServerError, 'Failed to update slot');
                }

                // If assigned_count reaches appointment_limit, set status to BOOKED
                if (updatedSlot && updatedSlot.assigned_count !== undefined && updatedSlot.assigned_count >= updatedSlot.appointment_limit) {
                    await SlotSchema.findByIdAndUpdate(
                        appointmentData.slot_id,
                        { status: SlotStatusEnum.BOOKED },
                        { new: true }
                    );
                } else if (updatedSlot.status !== SlotStatusEnum.AVAILABLE) {
                    // If not yet full, ensure status is AVAILABLE
                    await SlotSchema.findByIdAndUpdate(
                        appointmentData.slot_id,
                        { status: SlotStatusEnum.AVAILABLE },
                        { new: true }
                    );
                }
            }

            // tạo mẫu cho appointment nếu có mẫu được cung cấp
            if (appointmentData.samples && appointmentData.samples.length > 0) {
                console.log(`Sample types provided with appointment creation. These will be ignored.`);
                console.log(`Please use the /api/sample/add-to-appointment endpoint to add samples to this appointment.`);

                // Thêm thông tin hướng dẫn vào response
                (appointment as any).sampleInstructions =
                    "Please use the /api/sample/add-to-appointment endpoint to add samples to this appointment.";
            }

            // Log sự kiện tạo appointment
            try {
                await this.appointmentLogService.logAppointmentCreation(appointment);
            } catch (logError) {
                console.error('Failed to create appointment log:', logError);
            }

            // Send email notification to user
            try {
                await this.sendAppointmentCreationEmail(appointment);
            } catch (emailError) {
                console.error('Failed to send appointment creation email:', emailError);
            }

            return appointment;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            // Nếu là ADMINISTRATIVE thì không trả về 500 mà trả về 200 với appointment đã tạo (nếu có)
            if (
                service &&
                service.type === ServiceTypeEnum.ADMINISTRATIVE &&
                appointment
            ) {
                // Log the error
                console.error('Error after creating ADMINISTRATIVE appointment:', error);
                // Có thể thêm thông tin lỗi vào appointment để client biết
                (appointment as any).creationError = 'An error occurred after appointment creation. Please contact support.';
                return appointment;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating appointment');
        }
    }

    /**
     * Get appointment by ID
     */
    public async getAppointmentById(id: string): Promise<IAppointment> {
        try {
            if (!id) {
                throw new HttpException(HttpStatus.BadRequest, 'Appointment ID is required');
            }

            // Check if the id is a JSON string representation of an appointment object
            if (id.includes('_id') && id.includes('ObjectId')) {
                console.log('Received appointment object as string instead of ID:', id);

                // Try to extract the _id from the string
                try {
                    // Extract the ObjectId value using regex
                    const match = id.match(/ObjectId\('([^']+)'\)/);
                    if (match && match[1]) {
                        id = match[1];
                        console.log('Extracted ID from object string:', id);
                    } else {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            'Invalid appointment ID format: could not extract ObjectId'
                        );
                    }
                } catch (parseError) {
                    console.error('Error parsing appointment object string:', parseError);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'Invalid appointment ID format: not a valid ObjectId or appointment object'
                    );
                }
            }

            // Convert string ID to ObjectId if needed
            let objectId = id;
            if (typeof id === 'string') {
                try {
                    if (mongoose.Types.ObjectId.isValid(id)) {
                        objectId = new mongoose.Types.ObjectId(id).toString();
                    } else {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Invalid appointment ID format: ${id} is not a valid ObjectId`
                        );
                    }
                } catch (error: any) {
                    console.error(`Error converting appointment ID ${id} to ObjectId:`, error);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        `Invalid appointment ID format: ${error.message}`
                    );
                }
            }

            const appointment = await this.appointmentRepository.findByIdWithPopulate(objectId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, `Appointment not found with ID: ${id}`);
            }

            return appointment;
        } catch (error: any) {
            console.error(`Error in getAppointmentById for ID ${id}:`, error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, `Error getting appointment: ${error.message}`);
        }
    }

    /**
     * Assign staff to an appointment (by department manager)
     */
    public async assignStaff(
        appointmentId: string,
        assignStaffData: AssignStaffDto,
    ): Promise<IAppointment> {
        // Kiểm tra appointment có tồn tại và trạng thái là PENDING
        const appointment = await this.getAppointmentById(appointmentId);
        if (appointment.status !== AppointmentStatusEnum.PENDING) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Cannot assign staff to appointment with status ${appointment.status}`
            );
        }

        // Validate staff IDs
        if (!assignStaffData.staff_ids || assignStaffData.staff_ids.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'At least one staff ID is required');
        }

        // Validate all staff IDs
        for (const staffId of assignStaffData.staff_ids) {
            if (!mongoose.Types.ObjectId.isValid(staffId)) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid staff ID: ${staffId}`);
            }
        }

        // Lấy thông tin user cho tất cả staff
        const staffUsers = await UserSchema.find({
            _id: { $in: assignStaffData.staff_ids },
            role: UserRoleEnum.STAFF
        });

        if (staffUsers.length !== assignStaffData.staff_ids.length) {
            throw new HttpException(HttpStatus.NotFound, 'One or more staff users not found');
        }

        // Kiểm tra staff profile liên kết với user
        const staffProfiles = await StaffProfileSchema.find({
            user_id: { $in: assignStaffData.staff_ids }
        });

        if (staffProfiles.length !== assignStaffData.staff_ids.length) {
            throw new HttpException(
                HttpStatus.NotFound,
                'One or more staff profiles not found'
            );
        }

        // Kiểm tra tất cả staff có active không
        for (const profile of staffProfiles) {
            if (profile.status !== StaffStatusEnum.ACTIVE) {
                const staffUser = staffUsers.find(u => u._id.toString() === profile.user_id?.toString());
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Staff ${staffUser?.first_name} ${staffUser?.last_name} is not active`
                );
            }
        }

        // Kiểm tra slot nếu có
        if (appointment.slot_id) {
            const slot = await SlotSchema.findById(appointment.slot_id);
            if (slot) {
                // Kiểm tra xem tất cả staff có trong danh sách staff của slot không
                const slotStaffProfileIds = slot.staff_profile_ids?.map(id => id.toString()) || [];
                const assignedStaffProfileIds = staffProfiles.map(profile => profile._id.toString());

                const missingStaff = assignedStaffProfileIds.filter(id => !slotStaffProfileIds.includes(id));
                if (missingStaff.length > 0) {
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'One or more staff are not assigned to this slot'
                    );
                }

                // Kiểm tra giới hạn số lượng appointment cho tất cả staff trong slot này
                for (const staffUser of staffUsers) {
                    const appointmentsInSlot = await this.appointmentRepository.countAppointmentsByStaffAndSlot(
                        staffUser._id.toString(),
                        slot._id.toString()
                    );

                    if (appointmentsInSlot >= slot.appointment_limit) {
                        // Tìm staff khác trong slot chưa đạt giới hạn
                        const alternativeStaff = await this.findAvailableStaffInSlot(slot);

                        if (alternativeStaff) {
                            // Gợi ý staff thay thế
                            throw new HttpException(
                                HttpStatus.BadRequest,
                                `Staff ${staffUser.first_name} ${staffUser.last_name} has reached appointment limit for this slot. Consider assigning to ${alternativeStaff.first_name} ${alternativeStaff.last_name} (ID: ${alternativeStaff._id})`
                            );
                        } else {
                            throw new HttpException(
                                HttpStatus.BadRequest,
                                `Staff ${staffUser.first_name} ${staffUser.last_name} has reached appointment limit for this slot and no alternative staff is available`
                            );
                        }
                    }
                }

                // Cập nhật thông tin slot nếu cần
                try {
                    // Kiểm tra xem slot có đang theo dõi số lượng appointment đã gán không
                    if (!slot.assigned_count) {
                        // Nếu không có trường assigned_count, thêm vào và đặt giá trị là 1
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                $set: { assigned_count: 1 },
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    } else {
                        // Nếu đã có trường assigned_count, tăng giá trị lên 1
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                $inc: { assigned_count: 1 }, // $inc ~ increment
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    }

                    // Nếu số lượng đã gán bằng với giới hạn, đánh dấu slot là BOOKED
                    const updatedSlot = await SlotSchema.findById(slot._id);
                    if (updatedSlot && updatedSlot?.assigned_count && updatedSlot?.assigned_count >= updatedSlot?.appointment_limit) {
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                status: SlotStatusEnum.BOOKED,
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    } else if (updatedSlot && updatedSlot?.status !== SlotStatusEnum.AVAILABLE) {
                        // Nếu chưa đạt giới hạn nhưng slot không ở trạng thái AVAILABLE, đặt lại trạng thái
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                status: SlotStatusEnum.AVAILABLE,
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    }
                } catch (error) {
                    console.error('Failed to update slot assigned count:', error);
                    // Không fail quá trình gán staff nếu cập nhật slot thất bại
                }
            }
        }

        // Cập nhật appointment với array của user IDs
        const oldStatus = appointment.status;
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                staff_id: assignStaffData.staff_ids as any,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign staff to appointment');
        }

        // Log sự kiện gán nhân viên
        try {
            await this.appointmentLogService.logStatusChange(
                updatedAppointment,
                oldStatus as unknown as AppointmentLogTypeEnum
            );
        } catch (logError) {
            console.error('Failed to create appointment log for staff assignment:', logError);
        }

        return updatedAppointment;
    }

    /**
     * Find available staff in a slot that hasn't reached appointment limit
     */
    private async findAvailableStaffInSlot(slot: any): Promise<any> {
        // Lấy danh sách staff profile từ slot
        const staffProfileIds = slot.staff_profile_ids;
        if (!staffProfileIds || staffProfileIds.length === 0) {
            return null;
        }

        // Lấy thông tin staff profile
        const staffProfiles = await StaffProfileSchema.find({
            _id: { $in: staffProfileIds },
            status: StaffStatusEnum.ACTIVE
        });

        // Lấy user_id từ staff profile
        const staffUserIds = staffProfiles.map(profile => profile.user_id);

        // Lấy thông tin user
        const staffUsers = await UserSchema.find({
            _id: { $in: staffUserIds },
            role: UserRoleEnum.STAFF
        });

        // Kiểm tra số lượng appointment của mỗi staff trong slot này
        for (const staffUser of staffUsers) {
            const appointmentsCount = await this.appointmentRepository.countAppointmentsByStaffAndSlot(
                staffUser._id.toString(),
                slot._id.toString()
            );

            if (appointmentsCount < slot.appointment_limit) {
                return staffUser; // Trả về staff đầu tiên chưa đạt giới hạn
            }
        }

        return null; // Không tìm thấy staff nào có thể nhận thêm appointment
    }

    /**
     * Confirm appointment by selecting a slot (by staff)
     */
    public async confirmAppointment(
        appointmentId: string,
        confirmData: ConfirmAppointmentDto,
        staffId: string,
        userRole: UserRoleEnum
    ): Promise<IAppointment | undefined> {
        const appointment = await this.getAppointmentById(appointmentId);

        // Only staff can confirm appointments
        if (userRole !== UserRoleEnum.STAFF) {
            throw new HttpException(HttpStatus.Forbidden, 'Only staff can confirm appointments');
        }

        // Check if staff is assigned to the appointment
        if (!appointment.staff_id) {
            throw new HttpException(
                HttpStatus.BadRequest,
                'No staff assigned to this appointment yet. Department manager must assign staff first.'
            );
        }

        // Check if the appointment is in PENDING status
        if (appointment.status !== AppointmentStatusEnum.PENDING) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Cannot confirm appointment with status ${appointment.status}`
            );
        }

        // Check if the assigned staff matches the confirming staff
        const staffProfile = await StaffProfileSchema.findOne({ user_id: staffId });
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        const appointmentStaff = await UserSchema.findById(appointment.staff_id);
        if (!appointmentStaff) {
            throw new HttpException(HttpStatus.NotFound, 'Assigned staff not found');
        }

        if (appointmentStaff._id.toString() !== staffId) {
            throw new HttpException(
                HttpStatus.Forbidden,
                'You are not assigned to this appointment'
            );
        }

        // Validate slot
        const slot = await SlotSchema.findById(confirmData.slot_id);
        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        if (slot.status !== SlotStatusEnum.AVAILABLE) {
            throw new HttpException(HttpStatus.BadRequest, 'Slot is not available');
        }

        // Update appointment with new slot and status
        const oldStatus = appointment.status;
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                slot_id: confirmData.slot_id as any,
                status: AppointmentStatusEnum.CONFIRMED,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to confirm appointment');
        }

        // // Update slot status to BOOKED
        // await SlotSchema.findByIdAndUpdate(
        //     confirmData.slot_id,
        //     { status: SlotStatusEnum.BOOKED },
        //     { new: true }
        // );

        // Cập nhật thông tin slot nếu cần
        try {
            // Kiểm tra xem slot có đang theo dõi số lượng appointment đã gán không
            if (!slot.assigned_count) {
                // Nếu không có trường assigned_count, thêm vào và đặt giá trị là 1
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        $set: { assigned_count: 1 },
                        updated_at: new Date()
                    },
                    { new: true }
                );
            } else {
                // Nếu đã có trường assigned_count, tăng giá trị lên 1
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        $inc: { assigned_count: 1 }, // $inc ~ increment
                        updated_at: new Date()
                    },
                    { new: true }
                );
            }

            // Nếu số lượng đã gán bằng với giới hạn, đánh dấu slot là BOOKED
            const updatedSlot = await SlotSchema.findById(slot._id);
            if (updatedSlot && updatedSlot?.assigned_count && updatedSlot?.assigned_count >= updatedSlot?.appointment_limit) {
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        status: SlotStatusEnum.BOOKED,
                        updated_at: new Date()
                    },
                    { new: true }
                );
            } else if (updatedSlot && updatedSlot?.status !== SlotStatusEnum.AVAILABLE) {
                // Nếu chưa đạt giới hạn nhưng slot không ở trạng thái AVAILABLE, đặt lại trạng thái
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        status: SlotStatusEnum.AVAILABLE,
                        updated_at: new Date()
                    },
                    { new: true }
                );
            }

            // Log the confirmation
            try {
                await this.appointmentLogService.logStatusChange(
                    updatedAppointment,
                    oldStatus as unknown as AppointmentLogTypeEnum
                );
            } catch (logError) {
                console.error('Failed to create appointment log for confirmation:', logError);
            }

            // Send confirmation email to user
            try {
                await this.sendAppointmentConfirmationEmail(updatedAppointment);
            } catch (emailError) {
                console.error('Failed to send appointment confirmation email:', emailError);
            }

            return updatedAppointment;
        }
        catch (error) {
            console.error('Failed to update slot assigned count:', error);
            // Không fail quá trình xác nhận nếu cập nhật slot thất bại
        }
    }

    /**
     * Search appointments with filters
     */
    public async searchAppointments(
        searchParams: SearchAppointmentDto,
        userRole: UserRoleEnum,
        userId?: string
    ): Promise<SearchPaginationResponseModel<IAppointment>> {
        try {
            // Process pagination parameters
            const pageNum = searchParams.pageNum || 1;
            const pageSize = searchParams.pageSize || 10;
            const skip = (pageNum - 1) * pageSize;

            // Build the query based on filters
            const query: any = {};

            // If user is a customer, they can only see their own appointments
            if (userRole === UserRoleEnum.CUSTOMER && userId) {
                query.user_id = new mongoose.Types.ObjectId(userId);
            }
            // If user is a staff, they can only see appointments assigned to them
            else if (userRole === UserRoleEnum.STAFF && userId) {
                query.staff_id = new mongoose.Types.ObjectId(userId);
            }
            // If user is a laboratory technician, they can only see appointments assigned to them
            else if (userRole === UserRoleEnum.LABORATORY_TECHNICIAN && userId) {
                query.laboratory_technician_id = new mongoose.Types.ObjectId(userId);
            }
            // For other roles, apply filters if provided
            else {
                if (searchParams.user_id) {
                    query.user_id = new mongoose.Types.ObjectId(searchParams.user_id);
                }

                if (searchParams.staff_id) {
                    query.staff_id = new mongoose.Types.ObjectId(searchParams.staff_id);
                }
            }

            // Apply common filters
            if (searchParams.service_id) {
                query.service_id = new mongoose.Types.ObjectId(searchParams.service_id);
            }

            if (searchParams.status) {
                query.status = searchParams.status;
            }

            if (searchParams.type) {
                query.type = searchParams.type;
            }

            // Date range filter
            if (searchParams.start_date || searchParams.end_date) {
                query.appointment_date = {};

                if (searchParams.start_date) {
                    query.appointment_date.$gte = new Date(searchParams.start_date);
                }

                if (searchParams.end_date) {
                    query.appointment_date.$lte = new Date(searchParams.end_date);
                }
            }

            // Handle search term differently based on type
            if (searchParams.search_term) {
                const searchRegex = new RegExp(searchParams.search_term, 'i');

                // If there's a search term, we'll search in collection_address if type is HOME
                if (searchParams.type === TypeEnum.HOME) {
                    query.collection_address = { $regex: searchRegex };
                } else {
                    // For non-HOME types, we need to search in user names
                    // This requires a different approach using aggregation or lookup
                    // For now, we'll handle this by fetching all results and filtering
                    // This is not ideal for large datasets but works for the current use case
                }
            }

            let appointments: IAppointment[] = [];
            let totalCount: number = 0;

            // If we have a search term for non-HOME types, we need to handle it differently
            if (searchParams.search_term && searchParams.type !== TypeEnum.HOME) {
                // Fetch all appointments matching the base query (without pagination)
                const allAppointments = await this.appointmentRepository.findWithPopulate(query);

                // Filter by search term
                const searchRegex = new RegExp(searchParams.search_term, 'i');
                const filteredAppointments = allAppointments.filter(appointment => {
                    const user = appointment.user_id as any;
                    if (user && (user.first_name || user.last_name)) {
                        const fullName = `${user.first_name || ''} ${user.last_name || ''}`;
                        return searchRegex.test(fullName);
                    }
                    return false;
                });

                // Calculate total count from filtered results
                totalCount = filteredAppointments.length;

                // Apply pagination to filtered results
                const startIndex = skip;
                const endIndex = startIndex + pageSize;
                appointments = filteredAppointments.slice(startIndex, endIndex);
            } else {
                // For HOME type searches or no search term, use normal pagination
                // Count total documents matching the query
                totalCount = await this.appointmentRepository.countDocuments(query);

                // Sort by appointment date (newest first)
                const sort = { appointment_date: -1 };

                // Fetch appointments with pagination
                appointments = await this.appointmentRepository.findWithPaginationAndPopulate(
                    query,
                    sort,
                    skip,
                    pageSize
                );
            }

            return {
                pageData: appointments,
                pageInfo: {
                    totalItems: totalCount,
                    pageNum,
                    pageSize,
                    totalPages: Math.ceil(totalCount / pageSize)
                }
            };
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching appointments');
        }
    }

    /**
     * Process query parameters
     */
    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }

    /**
     * Update appointment status
     */
    public async updateAppointmentStatus(appointmentId: string, status: AppointmentStatusEnum): Promise<IAppointment> {
        // Validate appointmentId
        if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
        }

        // Find the appointment
        const appointment = await this.getAppointmentById(appointmentId);

        // Update appointment status
        const oldStatus = appointment.status;
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                status: status,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update appointment status');
        }

        // Log the status change
        try {
            await this.appointmentLogService.logStatusChange(
                updatedAppointment,
                oldStatus as unknown as AppointmentLogTypeEnum
            );
        } catch (logError) {
            console.error('Failed to create appointment log for status change:', logError);
        }

        // Send status update email to user
        try {
            await this.sendAppointmentStatusUpdateEmail(updatedAppointment, oldStatus);
        } catch (emailError) {
            console.error('Failed to send appointment status update email:', emailError);
        }

        return updatedAppointment;
    }

    /**
     * Get samples for an appointment
     */
    public async getAppointmentSamples(appointmentId: string): Promise<ISample[]> {
        // Validate appointment exists
        await this.getAppointmentById(appointmentId);

        // Get samples for the appointment
        const samples = await this.getSampleService().getSamplesByAppointmentId(appointmentId);
        return samples;
    }

    /**
     * Get price for an appointment
     * @param appointmentId The ID of the appointment
     * @returns The price of the service associated with the appointment
     */
    public async getAppointmentPrice(appointmentId: string): Promise<number> {
        try {
            if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            const appointment = await this.appointmentRepository.findById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                throw new HttpException(HttpStatus.NotFound, 'Service not found for this appointment');
            }

            return service.price;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting appointment price');
        }
    }

    /**
     * Get staff roles for department manager
     */
    public async getUserRoleStaff(): Promise<any[]> {
        try {
            // Get all staff users
            const staffUsers = await UserSchema.find({ role: UserRoleEnum.STAFF })
                .select('_id first_name last_name email phone_number');

            // Get staff profiles
            const staffProfiles = await StaffProfileSchema.find({
                user_id: { $in: staffUsers.map(user => user._id) }
            }).select('user_id status department');

            // Combine user and profile information, only include staff with profiles
            const staffWithRoles = staffUsers
                .map(user => {
                    const profile = staffProfiles.find(p => p.user_id?.toString() === user._id.toString());
                    if (!profile) return null;

                    return {
                        ...user.toObject(),
                        staff_profile: {
                            status: profile.status,
                            department: profile.department_id
                        }
                    };
                })
                .filter(staff => staff !== null);

            return staffWithRoles;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff roles');
        }
    }

    /**
     * Get available slots for logged-in staff
     */
    public async getStaffAvailableSlots(staffId: string): Promise<any[]> {
        try {
            // Get staff profile
            const staffProfile = await StaffProfileSchema.findOne({ user_id: staffId });
            if (!staffProfile) {
                throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
            }

            // Get all slots assigned to this staff
            const slots = await SlotSchema.find({
                staff_profile_ids: { $in: [staffProfile._id] },
                status: SlotStatusEnum.AVAILABLE
            })

            return slots;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff available slots');
        }
    }

    /**
     * Get appointments assigned to a staff member
     */
    public async getStaffAssignedAppointments(
        staffId: string,
        searchParams: SearchAppointmentDto
    ): Promise<SearchPaginationResponseModel<IAppointment>> {
        try {
            // staff_id will be automatically set by role-based filtering in searchAppointments
            return this.searchAppointments(searchParams, UserRoleEnum.STAFF, staffId);
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff assigned appointments');
        }
    }

    /**
     * Get appointments assigned to a laboratory technician in appointment collection
     */
    /**
     * Get appointments assigned to a laboratory technician
     */
    public async getLabTechAssignedAppointments(
        labTechId: string,
        searchParams: SearchAppointmentDto
    ): Promise<SearchPaginationResponseModel<IAppointment>> {
        try {
            // laboratory_technician_id will be automatically set by role-based filtering in searchAppointments
            return this.searchAppointments(searchParams, UserRoleEnum.LABORATORY_TECHNICIAN, labTechId);
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting laboratory technician assigned appointments');
        }
    }

    /**
     * Assign laboratory technician to an appointment
     */
    public async assignLabTechnician(
        appointmentId: string,
        labTechId: string
    ): Promise<IAppointment> {
        try {
            // Validate appointment exists
            const appointment = await this.getAppointmentById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            // Validate lab technician exists and has correct role
            const labTech = await UserSchema.findOne({
                _id: labTechId,
                role: UserRoleEnum.LABORATORY_TECHNICIAN
            });
            if (!labTech) {
                throw new HttpException(HttpStatus.NotFound, 'Laboratory technician not found');
            }

            // Update appointment with lab technician
            const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
                appointmentId,
                {
                    laboratory_technician_id: labTechId,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedAppointment) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign laboratory technician');
            }

            // Log the assignment
            try {
                await this.appointmentLogService.logAppointmentCreation(updatedAppointment);
            } catch (logError) {
                console.error('Failed to create appointment log for lab tech assignment:', logError);
            }

            return updatedAppointment;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error assigning laboratory technician');
        }
    }

    /**
     * Get available laboratory technicians
     */
    public async getAvailableLabTechnicians(): Promise<any[]> {
        try {
            // Get all laboratory technician users
            const labTechUsers = await UserSchema.find({ role: UserRoleEnum.LABORATORY_TECHNICIAN })
                .select('_id first_name last_name email phone_number');

            // Get staff profiles for these users
            const labTechProfiles = await StaffProfileSchema.find({
                user_id: { $in: labTechUsers.map(user => user._id) },
                status: StaffStatusEnum.ACTIVE
            }).select('user_id status department');

            // Only include users who have a staff profile
            const availableLabTechs = labTechUsers
                .map(user => {
                    const profile = labTechProfiles.find(p => p.user_id?.toString() === user._id.toString());
                    if (!profile) return null;

                    return {
                        ...user.toObject(),
                        staff_profile: {
                            status: profile.status,
                            department: profile.department_id
                        }
                    };
                })
                .filter(tech => tech !== null);

            return availableLabTechs;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting available laboratory technicians');
        }
    }

    /**
     * Unassign staff from an appointment
     * This method is used when you need to change the assigned staff
     * or when an appointment is cancelled
     */
    public async unassignStaff(appointmentId: string): Promise<IAppointment> {
        // Kiểm tra appointment có tồn tại
        const appointment = await this.getAppointmentById(appointmentId);

        // Nếu không có staff_id hoặc slot_id, không cần xử lý
        if (!appointment.staff_id || !appointment.slot_id) {
            return appointment;
        }

        // Cập nhật slot để giảm assigned_count
        try {
            const slot = await SlotSchema.findById(appointment.slot_id);
            if (slot) {
                // Giảm assigned_count nếu có
                if (slot.assigned_count && slot.assigned_count > 0) {
                    await SlotSchema.findByIdAndUpdate(
                        slot._id,
                        {
                            $inc: { assigned_count: -1 },
                            updated_at: new Date()
                        },
                        { new: true }
                    );
                }

                // Nếu slot đang ở trạng thái BOOKED và assigned_count < appointment_limit
                // thì đặt lại trạng thái là AVAILABLE
                const updatedSlot = await SlotSchema.findById(slot._id);
                const assignedCount = updatedSlot?.assigned_count || 0;
                const appointmentLimit = updatedSlot?.appointment_limit || 1;
                if (updatedSlot &&
                    updatedSlot.status === SlotStatusEnum.BOOKED &&
                    assignedCount < appointmentLimit) {
                    await SlotSchema.findByIdAndUpdate(
                        slot._id,
                        {
                            status: SlotStatusEnum.AVAILABLE,
                            updated_at: new Date()
                        },
                        { new: true }
                    );
                }
            }
        } catch (error) {
            console.error('Failed to update slot assigned count during unassign:', error);
            // Không fail quá trình unassign nếu cập nhật slot thất bại
        }

        // Xóa staff_id khỏi appointment bằng cách sử dụng mongoose update operators
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                // Sử dụng type assertion để tránh lỗi TypeScript
                staff_id: undefined as unknown as string,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to unassign staff from appointment');
        }

        return updatedAppointment;
    }

    /**
     * Send email notification for appointment creation
     */
    private async sendAppointmentCreationEmail(appointment: IAppointment): Promise<void> {
        try {
            // Get user details
            const user = await UserSchema.findById(appointment.user_id);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;
            const appointmentDate = appointment.appointment_date
                ? new Date(appointment.appointment_date).toLocaleString()
                : 'To be confirmed';

            const title = 'Appointment Created Successfully';
            const message = `
                Your appointment for ${service.name} has been created successfully.
                <br><br>
                <strong>Appointment Details:</strong>
                <br>
                Service: ${service.name}
                <br>
                Date: ${appointmentDate}
                <br>
                Type: ${appointment.type}
                <br>
                Status: ${appointment.status}
                <br><br>
                We will notify you once your appointment is confirmed by our staff.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Appointment Created - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Appointment creation email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending appointment creation email:', error);
        }
    }

    /**
     * Send email notification for appointment confirmation
     */
    private async sendAppointmentConfirmationEmail(appointment: IAppointment): Promise<void> {
        try {
            // Get user details
            const user = await UserSchema.findById(appointment.user_id);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            // Get slot details if available
            let slotDetails = 'Not specified';
            if (appointment.slot_id) {
                const slot = await SlotSchema.findById(appointment.slot_id);
                if (slot && slot.time_slots && slot.time_slots.length > 0) {
                    const timeSlot = slot.time_slots[0];
                    const date = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
                    const formattedDate = date.toLocaleDateString();
                    const startTime = `${timeSlot.start_time.hour}:${timeSlot.start_time.minute.toString().padStart(2, '0')}`;
                    const endTime = `${timeSlot.end_time.hour}:${timeSlot.end_time.minute.toString().padStart(2, '0')}`;
                    slotDetails = `${formattedDate} from ${startTime} to ${endTime}`;
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Appointment Confirmed';
            const message = `
                Your appointment for ${service.name} has been confirmed.
                <br><br>
                <strong>Appointment Details:</strong>
                <br>
                Service: ${service.name}
                <br>
                Scheduled Time: ${slotDetails}
                <br>
                Type: ${appointment.type}
                <br>
                Status: ${appointment.status}
                <br><br>
                ${appointment.type === TypeEnum.HOME ?
                    `Our staff will visit your location at the scheduled time.` :
                    `Please arrive at our facility at the scheduled time.`}
                <br><br>
                If you need to reschedule or cancel your appointment, please contact us as soon as possible.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Appointment Confirmed - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Appointment confirmation email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending appointment confirmation email:', error);
        }
    }

    /**
     * Send email notification for appointment status update
     */
    private async sendAppointmentStatusUpdateEmail(appointment: IAppointment, oldStatus: AppointmentStatusEnum): Promise<void> {
        try {
            // Get user details
            const user = await UserSchema.findById(appointment.user_id);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;
            const appointmentDate = appointment.appointment_date
                ? new Date(appointment.appointment_date).toLocaleString()
                : 'To be confirmed';

            let title = 'Appointment Status Updated';
            let message = `
                Your appointment for ${service.name} has been updated from ${oldStatus} to ${appointment.status}.
                <br><br>
                <strong>Appointment Details:</strong>
                <br>
                Service: ${service.name}
                <br>
                Date: ${appointmentDate}
                <br>
                Type: ${appointment.type}
                <br>
                Status: ${appointment.status}
                <br><br>
            `;

            // Add specific messages based on the new status
            switch (appointment.status) {
                case AppointmentStatusEnum.COMPLETED:
                    message += 'Your appointment has been completed. Thank you for using our services.';
                    title = 'Appointment Completed';
                    break;
                case AppointmentStatusEnum.CANCELLED:
                    message += 'Your appointment has been cancelled. If you did not request this cancellation, please contact us.';
                    title = 'Appointment Cancelled';
                    break;
                case AppointmentStatusEnum.PENDING:
                    message += 'Your appointment is now in progress.';
                    title = 'Appointment In Progress';
                    break;
                case AppointmentStatusEnum.SAMPLE_COLLECTED:
                    message += 'Your samples have been collected. They will be processed by our laboratory.';
                    title = 'Samples Collected';
                    break;
                case AppointmentStatusEnum.CONFIRMED:
                    message += 'Your appointment has been confirmed. Please prepare for the appointment.';
                    title = 'Appointment Confirmed';
                    break;
                case AppointmentStatusEnum.SAMPLE_RECEIVED:
                    message += 'Your samples have been received by our laboratory. They will be processed soon.';
                    title = 'Samples Received';
                    break;
                case AppointmentStatusEnum.TESTING:
                    message += 'Your samples are now being tested by our laboratory.';
                    title = 'Samples Testing';
                    break;
                default:
                    message += 'If you have any questions about your appointment, please contact us.';
            }

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: `${title} - Bloodline DNA Testing Service`,
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Appointment status update email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending appointment status update email:', error);
        }
    }
}



================================================
FILE: src/modules/appointment/index.ts
================================================
import AppointmentSchema from './appointment.model';
import { IAppointment, AppointmentStatus, CollectionType } from './appointment.interface';
import { AppointmentStatusEnum, TypeEnum } from './appointment.enum';
import { AppointmentStatuses, CollectionTypes } from './appointment.constant';
import { CollectionMethodEnum } from '../sample/sample.enum';
import AppointmentRoute from './appointment.route';
import AppointmentController from './appointment.controller';
import AppointmentService from './appointment.service';
import AppointmentRepository from './appointment.repository';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';

export {
    AppointmentSchema,
    IAppointment,
    AppointmentStatus,
    CollectionType,
    AppointmentStatusEnum,
    TypeEnum,
    CollectionMethodEnum,
    AppointmentStatuses,
    CollectionTypes,
    AppointmentRoute,
    AppointmentController,
    AppointmentService,
    AppointmentRepository,
    CreateAppointmentDto
}; 


================================================
FILE: src/modules/appointment/dtos/assign-staff.dto.ts
================================================
import { IsMongoId, IsArray } from 'class-validator';

export class AssignStaffDto {
    @IsArray()
    @IsMongoId({ each: true })
    staff_ids: string[] = [];
} 


================================================
FILE: src/modules/appointment/dtos/confirm-appointment.dto.ts
================================================
import { IsNotEmpty, IsString } from 'class-validator';

export class ConfirmAppointmentDto {
    @IsNotEmpty({ message: 'Slot ID is required' })
    @IsString({ message: 'Slot ID must be a string' })
    slot_id: string = '';

} 


================================================
FILE: src/modules/appointment/dtos/createAppointment.dto.ts
================================================
import { IsArray, IsDate, IsEnum, IsMongoId, IsOptional, IsString, ValidateNested } from 'class-validator';
import { TypeEnum } from '../appointment.enum';
import { Transform, Type } from 'class-transformer';
import { SampleTypeEnum } from '../../sample/sample.enum';

export class SampleSelectionDto {
    @IsEnum(SampleTypeEnum)
    type: SampleTypeEnum = SampleTypeEnum.SALIVA;
}

export class CreateAppointmentDto {
    @IsMongoId()
    service_id: string = '';

    @IsMongoId()
    @IsOptional()
    slot_id?: string;

    @IsOptional()
    @Type(() => Date)
    appointment_date?: Date;

    @IsEnum(TypeEnum)
    @IsOptional()
    type?: TypeEnum;

    @IsString()
    @IsOptional()
    collection_address?: string;

    /**
     * @deprecated Use /api/sample/add-to-appointment endpoint instead
     */
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SampleSelectionDto)
    @IsOptional()
    samples?: SampleSelectionDto[] = [];

    @IsOptional()
    administrative_case_id?: string;

    @IsString()
    @IsOptional()
    agency_contact_email?: string;

    @IsString()
    @IsOptional()
    case_number?: string;

    @IsString()
    @IsOptional()
    authorization_code?: string;
}



================================================
FILE: src/modules/appointment/dtos/search-appointment.dto.ts
================================================
import { IsDateString, IsEnum, IsMongoId, IsNumber, IsOptional, IsString } from 'class-validator';
import { AppointmentStatusEnum, TypeEnum } from '../appointment.enum';

export class SearchAppointmentDto {
    @IsOptional()
    @IsNumber()
    pageNum?: number = 1;

    @IsOptional()
    @IsNumber()
    pageSize?: number = 10;

    @IsOptional()
    @IsMongoId()
    user_id?: string;

    @IsOptional()
    @IsMongoId()
    service_id?: string;

    @IsOptional()
    @IsEnum(AppointmentStatusEnum)
    status?: AppointmentStatusEnum;

    @IsOptional()
    @IsEnum(TypeEnum)
    type?: TypeEnum;

    @IsOptional()
    @IsMongoId()
    staff_id?: string;

    @IsOptional()
    @IsDateString()
    start_date?: string;

    @IsOptional()
    @IsDateString()
    end_date?: string;

    @IsOptional()
    @IsString()
    search_term?: string;
} 


================================================
FILE: src/modules/appointment/swagger/appointment.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Appointment:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Appointment ID
 *         user_id:
 *           type: string
 *           description: ID of the user who made the appointment
 *         service_id:
 *           type: string
 *           description: ID of the service
 *         slot_id:
 *           type: string
 *           description: ID of the selected time slot
 *         staff_id:
 *           type: string
 *           description: ID of the assigned staff member
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the assigned laboratory technician
 *         appointment_date:
 *           type: string
 *           format: date-time
 *           description: Date and time of the appointment
 *         type:
 *           type: string
 *           enum: [FACILITY, HOME]
 *           description: Type of appointment
 *         collection_address:
 *           type: string
 *           description: Address for home collection
 *         status:
 *           type: string
 *           enum: [PENDING, CONFIRMED, IN_PROGRESS, COMPLETED, CANCELLED]
 *           description: Current status of the appointment
 *         payment_status:
 *           type: string
 *           enum: [UNPAID, PAID, REFUNDED]
 *           description: Payment status of the appointment
 *         administrative_case_id:
 *           type: string
 *           description: ID of the administrative case associated with the appointment
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 *     CreateAppointmentDto:
 *       type: object
 *       required:
 *         - service_id
 *         - type
 *       properties:
 *         service_id:
 *           type: string
 *         slot_id:
 *           type: string
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *         collection_address:
 *           type: string
 *         case_number:
 *           type: string
 *         authorization_code:
 *           type: string
 *     AppointmentResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *         message:
 *           type: string
 *         data:
 *           $ref: '#/components/schemas/Appointment'
 *     AppointmentListResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *         message:
 *           type: string
 *         data:
 *           type: object
 *           properties:
 *             pageData:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Appointment'
 *             pageInfo:
 *               type: object
 *               properties:
 *                 totalItems:
 *                   type: integer
 *                 totalPages:
 *                   type: integer
 *                 pageNum:
 *                   type: integer
 *                 pageSize:
 *                   type: integer
 *     AssignLabTechRequest:
 *       type: object
 *       required:
 *         - lab_tech_id
 *       properties:
 *         lab_tech_id:
 *           type: string
 *           description: ID of the laboratory technician to assign
 *     SlotWithAppointmentLimit:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Slot ID
 *         staff_profile_ids:
 *           type: array
 *           description: List of staff profile IDs assigned to this slot
 *           items:
 *             type: string
 *         appointment_limit:
 *           type: integer
 *           description: Maximum number of appointments a staff member can handle in this slot
 *           example: 3
 *         assigned_count:
 *           type: integer
 *           description: Current number of appointments assigned to this slot
 *           example: 1
 *         time_slots:
 *           type: array
 *           description: Time slots details
 *           items:
 *             type: object
 *             properties:
 *               year:
 *                 type: integer
 *               month:
 *                 type: integer
 *               day:
 *                 type: integer
 *               start_time:
 *                 type: object
 *                 properties:
 *                   hour:
 *                     type: integer
 *                   minute:
 *                     type: integer
 *               end_time:
 *                 type: object
 *                 properties:
 *                   hour:
 *                     type: integer
 *                   minute:
 *                     type: integer
 *         status:
 *           type: string
 *           enum: [AVAILABLE, BOOKED, UNAVAILABLE]
 *           description: Current status of the slot
 */



================================================
FILE: src/modules/appointment/swagger/appointment.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: appointments
 *   description: Appointment management APIs
 */

/**
 * @swagger
 * /api/appointment/create:
 *   post:
 *     tags:
 *       - appointments
 *     summary: Create a new appointment (Customer only)
 *     description: Book a new appointment for a DNA testing service
 *     operationId: createAppointment
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateAppointmentDto'
 *     responses:
 *       201:
 *         description: Appointment created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid input data or missing required fields
 *       401:
 *         description: Unauthorized - Customer authentication required
 *       404:
 *         description: Service or slot not found
 *       409:
 *         description: Slot already booked or unavailable
 */

/**
 * @swagger
 * /api/appointment/search:
 *   get:
 *     tags: [appointments]
 *     summary: Search appointments
 *     description: Search and filter appointments with pagination
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: user_id
 *         schema:
 *           type: string
 *         description: Filter by user ID (MongoDB ObjectId)
 *       - in: query
 *         name: staff_id
 *         schema:
 *           type: string
 *         description: Filter by staff ID (MongoDB ObjectId)
 *       - in: query
 *         name: service_id
 *         schema:
 *           type: string
 *         description: Filter by service ID (MongoDB ObjectId)
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, sample_received, testing, completed, cancelled]
 *         description: Filter by appointment status
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [self, facility, home]
 *         description: Filter by appointment type
 *       - in: query
 *         name: start_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter appointments from this date (YYYY-MM-DD)
 *       - in: query
 *         name: end_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter appointments until this date (YYYY-MM-DD)
 *       - in: query
 *         name: search_term
 *         schema:
 *           type: string
 *         description: Search term for customer name or address
 *     responses:
 *       200:
 *         description: Successful operation
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       401:
 *         description: Unauthorized - User not authenticated
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/{id}:
 *   get:
 *     tags:
 *       - appointments
 *     summary: Get appointment by ID (All authenticated users)
 *     description: Retrieve detailed information about a specific appointment
 *     operationId: getAppointmentById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Appointment details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid appointment ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - User cannot access this appointment
 *       404:
 *         description: Appointment not found
 */

/**
 * @swagger
 * /api/appointment/{id}/assign-staff:
 *   put:
 *     tags:
 *       - appointments
 *     summary: Assign staff to appointment (Manager only)
 *     description: Assign a staff member to an existing appointment. The system checks if the staff is assigned to the slot and if they haven't reached their appointment limit for that slot.
 *     operationId: assignStaffToAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - staff_id
 *             properties:
 *               staff_id:
 *                 type: string
 *                 description: ID of the staff member to assign
 *                 example: "60d0fe4f5311236168a109ca"
 *     responses:
 *       200:
 *         description: Staff assigned successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid input data, appointment ID format, or staff has reached appointment limit for this slot
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Staff has reached appointment limit for this slot. Consider assigning to John Doe (ID: 60d0fe4f5311236168a109cb)"
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       404:
 *         description: Appointment or staff not found
 *       422:
 *         description: Invalid operation - Appointment status must be 'pending'
 */

/**
 * @swagger
 * /api/appointment/{id}/confirm:
 *   put:
 *     tags:
 *       - appointments
 *     summary: Confirm appointment (Staff only)
 *     description: Confirm an appointment, assign a testing kit to a laboratory technician, and update appointment status to 'confirmed'
 *     operationId: confirmAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - slot_id
 *             properties:
 *               slot_id:
 *                 type: string
 *                 description: ID of the time slot for the appointment
 *                 example: "60d0fe4f5311236168a109cd"
 *     responses:
 *       200:
 *         description: Appointment confirmed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid input data, appointment ID format, or laboratory technician role
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required or staff not assigned to this appointment
 *       404:
 *         description: Appointment, kit, or laboratory technician not found
 *       409:
 *         description: Kit already assigned to another appointment
 *       422:
 *         description: Invalid operation - Appointment status must be 'pending' with assigned staff
 */

/**
 * @swagger
 * /api/appointment/{id}/samples:
 *   get:
 *     tags:
 *       - appointments
 *     summary: Get samples for an appointment
 *     description: Retrieve all samples associated with a specific appointment
 *     operationId: getAppointmentSamples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Samples retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Invalid appointment ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       404:
 *         description: Appointment not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/{appointmentId}/price:
 *   get:
 *     tags:
 *       - appointments
 *     summary: Get price for an appointment
 *     description: Retrieves the price for an appointment based on its associated service
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: appointmentId
 *         in: path
 *         required: true
 *         description: ID of the appointment
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Appointment price retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     price:
 *                       type: number
 *                       example: 100000
 *                 message:
 *                   type: string
 *                   example: "Appointment price retrieved successfully"
 *       '400':
 *         description: Bad request
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '401':
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '404':
 *         description: Appointment not found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '500':
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/appointment/staff/assigned:
 *   get:
 *     tags: [appointments]
 *     summary: Get appointments assigned to staff member (Staff only)
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of assigned appointments
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentListResponse'
 *       401:
 *         description: Unauthorized
 *
 * /api/appointment/lab-tech/assigned:
 *   get:
 *     tags: [appointments]
 *     summary: Get appointments assigned to laboratory technician (Lab technician only)
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of assigned appointments
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentListResponse'
 *       401:
 *         description: Unauthorized
 *
 * /api/appointment/{id}/assign-lab-tech:
 *   post:
 *     tags: [appointments]
 *     summary: Assign a laboratory technician to an appointment (Staff only)
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/AssignLabTechRequest'
 *     responses:
 *       200:
 *         description: Laboratory technician assigned successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid request
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Appointment or laboratory technician not found
 */

/**
 * @swagger
 * /api/appointment/staff/available:
 *   get:
 *     tags: [appointments]
 *     summary: Get available staff (Manager only)
 *     description: Retrieve list of staff members with their roles and departments
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Staff roles retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Staff user ID
 *                       first_name:
 *                         type: string
 *                         description: Staff first name
 *                       last_name:
 *                         type: string
 *                         description: Staff last name
 *                       email:
 *                         type: string
 *                         description: Staff email
 *                       phone_number:
 *                         type: string
 *                         description: Staff phone number
 *                       staff_profile:
 *                         type: object
 *                         properties:
 *                           status:
 *                             type: string
 *                             enum: [ACTIVE, INACTIVE]
 *                             description: Staff profile status
 *                           department:
 *                             type: string
 *                             description: Department ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       500:
 *         description: Internal server error
 *
 * /api/appointment/staff/slots:
 *   get:
 *     tags: [appointments]
 *     summary: Get available slots for logged-in staff (Staff only)
 *     description: Retrieve all available time slots assigned to the logged-in staff member
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Available slots retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Slot ID
 *                       date:
 *                         type: string
 *                         format: date
 *                         description: Date of the slot
 *                       time_slots:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             start_time:
 *                               type: object
 *                               properties:
 *                                 hour:
 *                                   type: integer
 *                                 minute:
 *                                   type: integer
 *                             end_time:
 *                               type: object
 *                               properties:
 *                                 hour:
 *                                   type: integer
 *                                 minute:
 *                                   type: integer
 *                       status:
 *                         type: string
 *                         enum: [AVAILABLE, BOOKED]
 *                         description: Slot status
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required
 *       404:
 *         description: Staff profile not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/lab-tech/available:
 *   get:
 *     tags: [appointments]
 *     summary: Get available laboratory technicians (Staff only)
 *     description: Retrieve list of available laboratory technicians that can be assigned to appointments
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Available laboratory technicians retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Laboratory technician user ID
 *                       first_name:
 *                         type: string
 *                         description: Laboratory technician first name
 *                       last_name:
 *                         type: string
 *                         description: Laboratory technician last name
 *                       email:
 *                         type: string
 *                         description: Laboratory technician email
 *                       phone_number:
 *                         type: string
 *                         description: Laboratory technician phone number
 *                       staff_profile:
 *                         type: object
 *                         properties:
 *                           status:
 *                             type: string
 *                             enum: [ACTIVE, INACTIVE]
 *                             description: Staff profile status
 *                           department:
 *                             type: string
 *                             description: Department ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/staff/available-for-slot/{slotId}:
 *   get:
 *     tags: [appointments]
 *     summary: Get available staff for a specific slot (Manager only)
 *     description: Retrieve list of staff members assigned to a slot who haven't reached their appointment limit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: slotId
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Available staff for slot retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Staff user ID
 *                       first_name:
 *                         type: string
 *                         description: Staff first name
 *                       last_name:
 *                         type: string
 *                         description: Staff last name
 *                       email:
 *                         type: string
 *                         description: Staff email
 *                       appointment_count:
 *                         type: integer
 *                         description: Current number of appointments assigned to this staff in this slot
 *                         example: 2
 *                       appointment_limit:
 *                         type: integer
 *                         description: Maximum number of appointments this staff can handle in this slot
 *                         example: 3
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       404:
 *         description: Slot not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/{id}/unassign-staff:
 *   put:
 *     tags:
 *       - appointments
 *     summary: Unassign staff from appointment (Manager/Admin only)
 *     description: Remove the assigned staff from an appointment and update the slot's assigned_count
 *     operationId: unassignStaffFromAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Staff unassigned successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/AppointmentResponse'
 *                 message:
 *                   type: string
 *                   example: "Staff unassigned successfully"
 *       400:
 *         description: Invalid appointment ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager/Admin access required
 *       404:
 *         description: Appointment not found
 */


================================================
FILE: src/modules/appointment_log/appointment_log.constant.ts
================================================
import { AppointmentLogTypeEnum } from './appointment_log.enum';

export const AppointmentLogTypes = [
    '',
    AppointmentLogTypeEnum.PENDING,
    AppointmentLogTypeEnum.CONFIRMED,
    AppointmentLogTypeEnum.SAMPLE_COLLECTED,
    AppointmentLogTypeEnum.TESTING,
    AppointmentLogTypeEnum.COMPLETED,
    AppointmentLogTypeEnum.CANCELLED
];



================================================
FILE: src/modules/appointment_log/appointment_log.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IAppointmentLog } from './appointment_log.interface';
import AppointmentLogService from './appointment_log.service';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class AppointmentLogController {
    private appointmentLogService = new AppointmentLogService();

    /**
     * Get logs for a specific appointment
     */
    public getLogsByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            if (!appointmentId) {
                throw new HttpException(HttpStatus.BadRequest, 'Appointment ID is required');
            }

            const logs = await this.appointmentLogService.getLogsByAppointmentId(appointmentId, req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointmentLog>>(logs));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/appointment_log/appointment_log.enum.ts
================================================
export enum AppointmentLogTypeEnum {
    PENDING = 'pending',
    CONFIRMED = 'confirmed',
    SAMPLE_ASSIGNED = 'sample_assigned',
    SAMPLE_COLLECTED = 'sample_collected',
    SAMPLE_RECEIVED = 'sample_received',
    TESTING = 'testing',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled',
    SAMPLE_CREATED = 'sample_created'
}




================================================
FILE: src/modules/appointment_log/appointment_log.interface.ts
================================================
import { Schema } from 'mongoose';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import { CollectionType } from '../appointment/appointment.interface';

export interface IAppointmentLog extends Document {
    _id: string;
    customer_id: string | undefined;
    staff_id: string | undefined;
    laboratory_technician_id: string | undefined;
    appointment_id: string | undefined;
    old_status: AppointmentLogTypeEnum;
    new_status: AppointmentLogTypeEnum;
    type: CollectionType;
    notes?: string;
    created_at: Date;
    updated_at: Date;
}



================================================
FILE: src/modules/appointment_log/appointment_log.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import { IAppointmentLog } from './appointment_log.interface';
import { CollectionTypes } from '../appointment';
import { COLLECTION_NAME } from '../../core/constants';

const AppointmentLogSchema = new Schema({
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    staff_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    laboratory_technician_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    old_status: { type: String, enum: AppointmentLogTypeEnum },
    new_status: { type: String, enum: AppointmentLogTypeEnum },
    type: { type: String, enum: CollectionTypes },
    notes: { type: String },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const AppointmentLog = mongoose.model<IAppointmentLog>(COLLECTION_NAME.APPOINTMENT_LOG, AppointmentLogSchema);

export default AppointmentLog;  



================================================
FILE: src/modules/appointment_log/appointment_log.repository.ts
================================================
import AppointmentLogSchema from './appointment_log.model';
import { IAppointmentLog } from './appointment_log.interface';

export default class AppointmentLogRepository {
    public async create(data: Partial<IAppointmentLog>): Promise<IAppointmentLog> {
        return AppointmentLogSchema.create(data);
    }

    public async findOne(query: any): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findOne(query);
    }

    public async findById(id: string): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IAppointmentLog>, options: any = {}): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findByIdAndUpdate(id, update, options) as Promise<IAppointmentLog | null>;
    }

    public async countDocuments(query: any): Promise<number> {
        return AppointmentLogSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IAppointmentLog[]> {
        return AppointmentLogSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IAppointmentLog[]> {
        return AppointmentLogSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IAppointmentLog[]> {
        return AppointmentLogSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('customer_id', '_id first_name last_name')
            .populate('staff_id', '_id first_name last_name')
            .populate('laboratory_technician_id', '_id first_name last_name')
            .populate('appointment_id');
    }

    public async findByIdWithPopulate(id: string): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findById(id)
            .populate('customer_id', '_id first_name last_name')
            .populate('staff_id', '_id first_name last_name')
            .populate('laboratory_technician_id', '_id first_name last_name')
            .populate('appointment_id');
    }
} 


================================================
FILE: src/modules/appointment_log/appointment_log.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import AppointmentLogController from './appointment_log.controller';

export default class AppointmentLogRoute implements IRoute {
    public path = API_PATH.APPOINTMENT_LOG;
    public router = Router();
    private appointmentLogController = new AppointmentLogController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/appointment-logs/appointment/:appointmentId -> Get logs for a specific appointment
        this.router.get(
            `${API_PATH.GET_LOGS_BY_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.CUSTOMER]),
            this.appointmentLogController.getLogsByAppointmentId
        );
    }
} 


================================================
FILE: src/modules/appointment_log/appointment_log.service.ts
================================================
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IAppointmentLog } from './appointment_log.interface';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import AppointmentLogRepository from './appointment_log.repository';
import { IAppointment } from '../appointment/appointment.interface';
import { SearchPaginationResponseModel } from '../../core/models';
import mongoose from 'mongoose';
import { ISample } from '../sample/sample.interface';

export default class AppointmentLogService {
    private appointmentLogRepository = new AppointmentLogRepository();

    /**
     * Tạo log cho sự kiện tạo appointment
     * @param appointmentData Thông tin appointment
     * @param oldStatus Trạng thái cũ (null cho sự kiện tạo mới)
     * @param newStatus Trạng thái mới
     */
    public async createAppointmentLog(
        appointmentData: IAppointment,
        oldStatus: AppointmentLogTypeEnum | undefined,
        newStatus: AppointmentLogTypeEnum
    ): Promise<IAppointmentLog> {
        try {
            const appointmentLog = await this.appointmentLogRepository.create({
                appointment_id: appointmentData._id as any,
                customer_id: appointmentData.user_id,
                staff_id: appointmentData.staff_id,
                old_status: oldStatus,
                new_status: newStatus,
                type: appointmentData.type,
                created_at: new Date(),
                updated_at: new Date()
            });

            return appointmentLog;
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating appointment log');
        }
    }

    /**
     * Log sự kiện tạo appointment
     * @param appointmentData Thông tin appointment mới được tạo
     */
    public async logAppointmentCreation(appointmentData: IAppointment): Promise<IAppointmentLog> {
        return this.createAppointmentLog(
            appointmentData,
            undefined, // Không có trạng thái cũ cho sự kiện tạo mới
            appointmentData.status as unknown as AppointmentLogTypeEnum
        );
    }

    /**
     * Log sự kiện thay đổi trạng thái appointment
     * @param appointmentData Thông tin appointment đã được cập nhật
     * @param oldStatus Trạng thái cũ
     */
    public async logStatusChange(
        appointmentData: IAppointment,
        oldStatus: AppointmentLogTypeEnum
    ): Promise<IAppointmentLog> {
        return this.createAppointmentLog(
            appointmentData,
            oldStatus,
            appointmentData.status as unknown as AppointmentLogTypeEnum
        );
    }

    /**
     * Lấy logs cho một appointment cụ thể
     * @param appointmentId ID của appointment
     * @param queryParams Tham số truy vấn cho phân trang
     */
    public async getLogsByAppointmentId(
        appointmentId: string,
        queryParams: any = {}
    ): Promise<SearchPaginationResponseModel<IAppointmentLog>> {
        if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
        }

        // Xử lý tham số truy vấn
        const { pageNum = 1, pageSize = 10 } = this.processQueryParams(queryParams);
        const skip = (pageNum - 1) * pageSize; // Bỏ qua bao nhiêu logs

        // Xây dựng truy vấn
        const query = { appointment_id: appointmentId };

        // Đếm tổng số logs
        const totalItems = await this.appointmentLogRepository.countDocuments(query);
        const totalPages = Math.ceil(totalItems / pageSize);

        // Lấy logs với phân trang và sắp xếp theo ngày tạo (mới nhất trước)
        const logs = await this.appointmentLogRepository.findWithPopulate(
            query,
            { created_at: -1 }, // Sắp xếp theo ngày tạo (mới nhất trước)
            skip,
            pageSize
        );

        return {
            pageData: logs,
            pageInfo: {
                pageNum,
                pageSize,
                totalItems,
                totalPages
            }
        };
    }

    /**
     * Process query parameters
     */
    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }

    /**
     * Log sample creation for an appointment
     * @param appointmentData The appointment data
     * @param samples The created samples
     */
    public async logSampleCreation(
        appointmentData: IAppointment,
        samples: ISample[]
    ): Promise<IAppointmentLog> {
        try {
            const sampleTypes = samples.map(sample => sample.type).join(', ');
            const notes = `Created ${samples.length} sample(s): ${sampleTypes}`;

            const appointmentLog = await this.appointmentLogRepository.create({
                appointment_id: appointmentData._id as any,
                customer_id: appointmentData.user_id,
                staff_id: appointmentData.staff_id,
                old_status: appointmentData.status as unknown as AppointmentLogTypeEnum,
                new_status: AppointmentLogTypeEnum.SAMPLE_CREATED,
                type: appointmentData.type,
                notes: notes,
                created_at: new Date(),
                updated_at: new Date()
            });

            return appointmentLog;
        } catch (error) {
            console.error('Error creating sample creation log:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating sample creation log');
        }
    }
} 


================================================
FILE: src/modules/appointment_log/index.ts
================================================
import AppointmentLogSchema from './appointment_log.model';
import { IAppointmentLog } from './appointment_log.interface';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import { AppointmentLogTypes } from './appointment_log.constant';
import AppointmentLogService from './appointment_log.service';
import AppointmentLogRepository from './appointment_log.repository';
import { CreateAppointmentLogDto } from './dtos/createAppointmentLog.dto';
import AppointmentLogController from './appointment_log.controller';
import AppointmentLogRoute from './appointment_log.route';

export {
    AppointmentLogSchema,
    IAppointmentLog,
    AppointmentLogTypeEnum,
    AppointmentLogTypes,
    AppointmentLogService,
    AppointmentLogRepository,
    CreateAppointmentLogDto,
    AppointmentLogController,
    AppointmentLogRoute
}; 


================================================
FILE: src/modules/appointment_log/dtos/createAppointmentLog.dto.ts
================================================
import { IsEnum, IsMongoId, IsOptional } from 'class-validator';
import { AppointmentLogTypeEnum } from '../appointment_log.enum';
import { TypeEnum } from '../../appointment/appointment.enum';

export class CreateAppointmentLogDto {
    @IsMongoId()
    appointment_id: string = '';

    @IsMongoId()
    customer_id: string = '';

    @IsMongoId()
    @IsOptional()
    staff_id?: string;

    @IsMongoId()
    @IsOptional()
    laboratory_technician_id?: string;

    @IsEnum(AppointmentLogTypeEnum)
    @IsOptional()
    old_status?: AppointmentLogTypeEnum;

    @IsEnum(AppointmentLogTypeEnum)
    new_status: AppointmentLogTypeEnum = AppointmentLogTypeEnum.PENDING;

    @IsEnum(TypeEnum)
    type: TypeEnum = TypeEnum.SELF;
} 


================================================
FILE: src/modules/appointment_log/swagger/appointment_log.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateAppointmentLogDto:
 *       type: object
 *       required:
 *         - appointment_id
 *         - customer_id
 *         - new_status
 *         - type
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment being logged
 *           example: "60d0fe4f5311236168a109ce"
 *         customer_id:
 *           type: string
 *           description: ID of the customer associated with the appointment
 *           example: "60d0fe4f5311236168a109cf"
 *         staff_id:
 *           type: string
 *           description: ID of the staff member handling the appointment (optional)
 *           example: "60d0fe4f5311236168a109cc"
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the laboratory technician processing the sample (optional)
 *           example: "60d0fe4f5311236168a109cd"
 *         old_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Previous status of the appointment (optional)
 *           example: "pending"
 *         new_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: New status of the appointment
 *           example: "confirmed"
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Type of sample collection
 *           example: "facility"
 *
 *     AppointmentLogResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Unique log identifier
 *           example: "60d0fe4f5311236168a109d0"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment information
 *           properties:
 *             _id:
 *               type: string
 *               description: Appointment ID
 *               example: "60d0fe4f5311236168a109ce"
 *             service_id:
 *               type: string
 *               description: Service ID
 *               example: "60d0fe4f5311236168a109ca"
 *             status:
 *               type: string
 *               description: Current appointment status
 *               example: "confirmed"
 *         customer_id:
 *           type: object
 *           description: Customer information
 *           properties:
 *             _id:
 *               type: string
 *               description: Customer ID
 *               example: "60d0fe4f5311236168a109cf"
 *             first_name:
 *               type: string
 *               description: Customer's first name
 *               example: "John"
 *             last_name:
 *               type: string
 *               description: Customer's last name
 *               example: "Doe"
 *             email:
 *               type: string
 *               description: Customer's email
 *               example: "john.doe@example.com"
 *         staff_id:
 *           type: object
 *           description: Staff information (if assigned)
 *           properties:
 *             _id:
 *               type: string
 *               description: Staff ID
 *               example: "60d0fe4f5311236168a109cc"
 *             first_name:
 *               type: string
 *               description: Staff's first name
 *               example: "Jane"
 *             last_name:
 *               type: string
 *               description: Staff's last name
 *               example: "Smith"
 *         laboratory_technician_id:
 *           type: object
 *           description: Laboratory technician information (if assigned)
 *           properties:
 *             _id:
 *               type: string
 *               description: Laboratory technician ID
 *               example: "60d0fe4f5311236168a109cd"
 *             first_name:
 *               type: string
 *               description: Technician's first name
 *               example: "Mark"
 *             last_name:
 *               type: string
 *               description: Technician's last name
 *               example: "Johnson"
 *         old_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Previous status of the appointment
 *           example: "pending"
 *         new_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: New status of the appointment
 *           example: "confirmed"
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Type of sample collection
 *           example: "facility"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Log creation date
 *           example: "2023-10-01T12:30:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Log last update date
 *           example: "2023-10-01T12:30:00Z"
 *
 *     AppointmentLogPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/AppointmentLogResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 15
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 2
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     SearchAppointmentLogParams:
 *       type: object
 *       properties:
 *         pageNum:
 *           type: integer
 *           description: Page number for pagination
 *           default: 1
 *           example: 1
 *         pageSize:
 *           type: integer
 *           description: Number of items per page
 *           default: 10
 *           example: 10
 *         old_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Filter by previous status
 *           example: "pending"
 *         new_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Filter by new status
 *           example: "confirmed"
 *         customer_id:
 *           type: string
 *           description: Filter logs by customer ID
 *           example: "60d0fe4f5311236168a109cf"
 *         staff_id:
 *           type: string
 *           description: Filter logs by staff ID
 *           example: "60d0fe4f5311236168a109cc"
 *         date_from:
 *           type: string
 *           format: date
 *           description: Filter logs from this date
 *           example: "2023-10-01"
 *         date_to:
 *           type: string
 *           format: date
 *           description: Filter logs until this date
 *           example: "2023-10-31"
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Filter by appointment type
 *           example: "facility"
 */



================================================
FILE: src/modules/appointment_log/swagger/appointment_log.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: appointment_logs
 *   description: Appointment log management APIs
 */

/**
 * @swagger
 * /api/appointment-logs/appointment/{appointmentId}:
 *   get:
 *     tags:
 *       - appointment_logs
 *     summary: Get logs by appointment ID (Admin, Manager, Customer)
 *     description: Retrieve the history of status changes and actions for a specific appointment
 *     operationId: getLogsByAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID to retrieve logs for
 *         example: "60d0fe4f5311236168a109ce"
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *         example: 1
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of logs per page
 *         example: 10
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           enum: [created_at]
 *         description: Field to sort results by
 *         example: "created_at"
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *         description: Sort order (ascending or descending)
 *         example: "desc"
 *     responses:
 *       200:
 *         description: List of appointment logs with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentLogPaginationResponse'
 *       400:
 *         description: Invalid appointment ID format or query parameters
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - User does not have permission to view these logs
 *       404:
 *         description: Appointment not found
 */


================================================
FILE: src/modules/auth/auth.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { API_PATH } from '../../core/constants';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import { IUser } from '../user';
import { TokenData } from './auth.interface';
import AuthService from './auth.service';
import LoginDto from './dtos/login.dto';
import LoginGoogleDto from './dtos/loginGoogle.dto';

export default class AuthController {
    private authService = new AuthService();

    public login = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: LoginDto | LoginGoogleDto = req.body;
            const isGoogle = req.route.path === API_PATH.AUTH_GOOGLE ? true : false;
            const tokenData: TokenData = await this.authService.login(model, isGoogle);
            res.status(HttpStatus.Success).json(formatResponse<TokenData>(tokenData));
        } catch (error) {
            next(error);
        }
    };

    public verifiedToken = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.verifiedTokenUser(req.body.token);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public resendToken = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.resendTokenUser(req.body.email);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public getCurrentLoginUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const user: IUser = await this.authService.getCurrentLoginUser(req.user.id);
            res.status(HttpStatus.Success).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public forgotPassword = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.forgotPassword(req.body.email);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public logout = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.logout(req.user.id);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };
}



================================================
FILE: src/modules/auth/auth.interface.ts
================================================
import { UserRole } from '../user';

export interface DataStoredInToken {
    id: string;
    role: UserRole | string;
    version: number;
}

export interface TokenData {
    token: string;
}

export const UserInfoInTokenDefault = {
    id: '',
    role: '',
    version: 0
};



================================================
FILE: src/modules/auth/auth.repository.ts
================================================
import { IUser, UserSchema } from '../user';

export default class AuthRepository {
    public async findUserByEmail(email: string): Promise<IUser | null> {
        return UserSchema.findOne({ email }).exec();
    }

    public async findUserById(userId: string): Promise<IUser | null> {
        return UserSchema.findById(userId).lean();
    }

    public async findUserByVerificationToken(token: string): Promise<IUser | null> {
        return UserSchema.findOne({ verification_token: token });
    }

    public async updateUser(user: IUser): Promise<IUser> {
        return user.save();
    }

    public async updateUserById(userId: string, update: Partial<IUser>): Promise<IUser | null> {
        return UserSchema.findByIdAndUpdate(userId, update, { new: true });
    }
}



================================================
FILE: src/modules/auth/auth.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import AuthController from './auth.controller';
import EmailDto from './dtos/emai.dto';
import LoginDto from './dtos/login.dto';
import LoginGoogleDto from './dtos/loginGoogle.dto';
import VerifiedTokenDto from './dtos/verifiedToken.dto';

export default class AuthRoute implements IRoute {
    public path = API_PATH.AUTH;
    public router = Router();
    public authController = new AuthController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST domain:/api/auth -> Login normal
        this.router.post(this.path, validationMiddleware(LoginDto), this.authController.login);

        // POST domain:/api/auth/google -> Login via google
        this.router.post(API_PATH.AUTH_GOOGLE, validationMiddleware(LoginGoogleDto), this.authController.login);

        // POST domain:/api/auth/verify-token -> Verify token
        this.router.post(
            API_PATH.AUTH_VERIFY_TOKEN,
            this.authController.verifiedToken,
        );

        // POST domain:/api/auth/resend-token -> Resend token via email
        this.router.post(API_PATH.AUTH_RESEND_TOKEN, validationMiddleware(EmailDto), this.authController.resendToken);

        // GET domain:/api/auth -> Require Login
        this.router.get(this.path, authMiddleWare(), this.authController.getCurrentLoginUser);

        // PUT domain:/api/auth/forgot-password -> Forgot password
        this.router.put(
            API_PATH.AUTH_FORGOT_PASSWORD,
            validationMiddleware(EmailDto),
            this.authController.forgotPassword,
        );

        // GET domain:/api/auth/logout -> Logout user
        this.router.get(API_PATH.AUTH_LOGOUT, authMiddleWare(), this.authController.logout);
    }
}



================================================
FILE: src/modules/auth/auth.service.ts
================================================
import bcryptjs from 'bcryptjs';
import crypto from 'crypto';
import { OAuth2Client } from 'google-auth-library';
import moment from 'moment';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { createToken, createTokenVerifiedUser, encodePasswordUserNormal, isEmptyObject } from '../../core/utils';
import { sendMail } from '../../core/utils/sendMail';
import { IUser, UserSchema } from '../user';
import { TokenData } from './auth.interface';
import LoginDto from './dtos/login.dto';
import LoginGoogleDto from './dtos/loginGoogle.dto';
import AuthRepository from './auth.repository';
import { AdministrativeCaseSchema } from '../administrative_cases';


export default class AuthService {
    public userSchema = UserSchema;
    private authRepository = new AuthRepository();

    public async login(model: LoginDto | LoginGoogleDto, isGoogle = false): Promise<TokenData> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model user is empty');
        }

        let emailCheck = model.email;
        let userLogin = model;

        // login by google
        if (isGoogle) {
            if (model.google_id) {
                try {
                    const client = new OAuth2Client();
                    // check google_id is valid
                    const ticket = await client.verifyIdToken({
                        idToken: model.google_id,
                    });
                    console.log(ticket);
                    // get user info from ticket
                    const payload = ticket.getPayload();
                    // If payload already exists, assign email and emailCheck
                    if (payload) {
                        userLogin.email = payload.email!;
                        emailCheck = payload.email!;
                    }
                } catch (error) {
                    throw new HttpException(HttpStatus.BadRequest, 'Account google is incorrect, please try again!');
                }
            } else {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Field google_id via IdToken is empty, please send google_id!',
                );
            }
        }

        const user = await this.authRepository.findUserByEmail(emailCheck);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Your email: ${emailCheck} is not exists.`);
        }

        if (!user.is_verified) {
            throw new HttpException(HttpStatus.BadRequest, 'User is not verified! Please check your email in 24h!');
        }

        if (user.google_id && model.password) {
            throw new HttpException(HttpStatus.BadRequest, 'You must login by google!');
        }

        // login normal
        if (!isGoogle && model.password) {
            const isMatchPassword = await bcryptjs.compare(model.password, user.password!);
            if (!isMatchPassword) {
                throw new HttpException(HttpStatus.BadRequest, `Your password is incorrect!`);
            }
        }

        if (!user.status) {
            throw new HttpException(
                HttpStatus.Forbidden,
                `Your account has been locked. Please contact admin via mail to activate!`,
            );
        }

        if (user.is_deleted) {
            throw new HttpException(
                HttpStatus.Forbidden,
                `Your account has been deleted. Please contact admin via mail to help!`,
            );
        }

        if (!user.token_version) {
            user.token_version = 0;
        }

        return createToken(user);
    }

    public async verifiedTokenUser(verifiedToken: string): Promise<boolean> {
        const user = await this.authRepository.findUserByVerificationToken(verifiedToken);

        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Token is not valid.`);
        }
        // use moment to parse verification_token_expires with format 'ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'
        const tokenExpires = moment(
            user?.verification_token_expires?.toString(),
            'ddd MMM DD YYYY HH:mm:ss [GMT]ZZ',
        ).toDate();
        // if current time is after token expires => throw error
        if (moment(new Date()).isAfter(moment(tokenExpires))) {
            throw new HttpException(HttpStatus.BadRequest, `Token is expired!`);
        }

        user.is_verified = true;
        user.verification_token = undefined;
        user.verification_token_expires = undefined;
        user.updated_at = new Date();

        const updateUserId = await this.authRepository.updateUser(user);
        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async resendTokenUser(email: string): Promise<boolean> {
        const user = await this.authRepository.findUserByEmail(email);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `User with mail: ${email} is not exists.`);
        }

        if (user.is_verified) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `User with mail: ${email} has already verified their email.`,
            );
        }

        // create token verification
        const tokenData = createTokenVerifiedUser();
        user.is_verified = false;
        user.verification_token = tokenData.verification_token;
        user.verification_token_expires = tokenData.verification_token_expires;
        user.updated_at = new Date();
        const domain = process.env.DOMAIN_FE;

        // send mail with token
        const sendMailResult = await sendMail({
            toMail: user.email,
            subject: 'Verify your email address',
            content: `Hello, ${user.first_name} ${user.last_name}.\nPlease click the following link to verify your email address:\n${domain}/verify-email/${tokenData.verification_token}`,
        });
        if (!sendMailResult) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${user.email}`);
        }

        const updateUser = await this.authRepository.updateUser(user);
        if (!updateUser) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async getCurrentLoginUser(userId: string): Promise<IUser> {
        // Lấy user kèm staff_profile (nếu có)
        const user = await this.userSchema
            .findById(userId)
            .populate('staff_profile')
            .lean({ virtuals: true });

        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `User is not exists.`);
        }

        // Lấy các administrative cases mà user là applicant_id
        // Nếu đã có administrative_cases (không phải mảng rỗng), không ghi đè
        let administrative_cases = user.administrative_cases;
        if (!Array.isArray(administrative_cases) || administrative_cases.length === 0) {
            administrative_cases = await AdministrativeCaseSchema.find({ applicant_id: userId });
        }
        user.administrative_cases = administrative_cases;

        // Xóa password nếu có
        if ('password' in user) {
            delete user.password;
        }

        return user as IUser;
    }

    public async forgotPassword(email: string): Promise<boolean> {
        const user = await this.userSchema.findOne({ email, is_deleted: false, is_verified: true });
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `User with mail: ${email} is not exists.`);
        }

        if (user.google_id) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Your account is logged in by google. Please contact google for reset password!`,
            );
        }

        // handle encode password
        const generateRandomPassword = this.generateRandomPassword(10);

        // send mail with new password
        const sendMailResult = await sendMail({
            toMail: user.email,
            subject: 'Generate new password for user',
            html: `Hello, ${user.first_name} ${user.last_name}.<br>This is a new password for ${user.email} is:<br><strong>${generateRandomPassword}</strong>`,
        });
        if (!sendMailResult) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${user.email}`);
        }

        const newPassword = await encodePasswordUserNormal(generateRandomPassword);
        user.password = newPassword;
        user.updated_at = new Date();
        const updateUser = await this.authRepository.updateUser(user);
        if (!updateUser) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async logout(userId: string): Promise<boolean> {
        const user = await this.authRepository.updateUserById(userId, { token_version: 1 });
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot logout!`);
        }
        return true;
    }

    private generateRandomPassword(length: number) {
        return crypto
            .randomBytes(length) // generate random bytes
            .toString('base64') // convert to base64
            .slice(0, length) // slice the length of the string, 0 is the start index, length is the end index
            .replace(/[^a-zA-Z0-9]/g, ''); // replace all non-alphanumeric characters with an empty string
    }
}



================================================
FILE: src/modules/auth/index.ts
================================================
import { DataStoredInToken, TokenData, UserInfoInTokenDefault } from './auth.interface';
import AuthRoute from './auth.route';

export { AuthRoute, DataStoredInToken, TokenData, UserInfoInTokenDefault };



================================================
FILE: src/modules/auth/dtos/emai.dto.ts
================================================
import { IsEmail, IsNotEmpty } from 'class-validator';

export default class EmailDto {
    constructor(email: string) {
        this.email = email;
    }

    @IsNotEmpty()
    @IsEmail()
    public email: string;
}



================================================
FILE: src/modules/auth/dtos/login.dto.ts
================================================
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export default class LoginDto {
    constructor(google_id: string, email: string, password: string) {
        this.google_id = google_id || '';
        this.email = email;
        this.password = password;
    }

    public google_id: string;

    @IsNotEmpty()
    @IsEmail()
    public email: string;

    @IsNotEmpty()
    @MinLength(6)
    public password: string;
}



================================================
FILE: src/modules/auth/dtos/loginGoogle.dto.ts
================================================
import { IsNotEmpty } from 'class-validator';

export default class LoginGoogleDto {
    constructor(google_id: string, email: string, password: string) {
        this.google_id = google_id;
        this.email = email;
        this.password = password;
    }

    @IsNotEmpty()
    public google_id: string;

    public email: string;

    public password: string;
}



================================================
FILE: src/modules/auth/dtos/verifiedToken.dto.ts
================================================
import { IsNotEmpty } from 'class-validator';

export default class VerifiedTokenDto {
    constructor(verifiedToken: string) {
        this.verifiedToken = verifiedToken;
    }

    @IsNotEmpty()
    public verifiedToken: string;
}



================================================
FILE: src/modules/auth/swagger/auth.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     LoginDto:
 *       type: object
 *       required:
 *         - email
 *         - password
 *       properties:
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *           example: "thichtamphuc@gmail.com"
 *         password:
 *           type: string
 *           description: User's password (minimum 6 characters)
 *           minLength: 6
 *           example: "123456"
 *     LoginGoogleDto:
 *       type: object
 *       properties:
 *         google_id:
 *           type: string
 *           description: Google ID token
 *
 *     VerifiedTokenDto:
 *       type: object
 *       required:
 *         - verifiedToken
 *       properties:
 *         verifiedToken:
 *           type: string
 *           description: Verification token sent to user's email
 *           example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 *
 *     EmailDto:
 *       type: object
 *       required:
 *         - email
 *       properties:
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *
 *     TokenResponse:
 *       type: object
 *       properties:
 *         token:
 *           type: string
 *           description: JWT authentication token
 *           example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 *         user:
 *           $ref: '#/components/schemas/UserResponse'
 *
 *     AuthErrorResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Error message
 *           example: "Invalid email or password"
 *         status:
 *           type: integer
 *           description: HTTP status code
 *           example: 401
 *
 *     ForgotPasswordResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Password reset email sent successfully"
 *         success:
 *           type: boolean
 *           description: Operation success status
 *           example: true
 *
 *     VerificationResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Email verified successfully"
 *         success:
 *           type: boolean
 *           description: Operation success status
 *           example: true
 *         user:
 *           $ref: '#/components/schemas/UserResponse'
 *
 *     LogoutResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Logged out successfully"
 *         success:
 *           type: boolean
 *           description: Operation success status
 *           example: true
 */



================================================
FILE: src/modules/auth/swagger/auth.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: auth
 *   description: Authentication APIs
 */

/**
 * @swagger
 * /api/auth:
 *   post:
 *     tags:
 *       - auth
 *     summary: Login with email and password
 *     description: Authenticate a user with email and password credentials
 *     operationId: login
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/LoginDto'
 *     responses:
 *       200:
 *         description: Login successful, returns authentication token and user information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/TokenResponse'
 *       400:
 *         description: Invalid input - email format invalid or password too short
 *       401:
 *         description: Authentication failed - wrong email or password
 *       404:
 *         description: User not found
 *       422:
 *         description: User account is inactive or email not verified
 *   
 *   get:
 *     tags:
 *       - auth
 *     summary: Get current logged-in user
 *     description: Retrieve information about the currently authenticated user
 *     operationId: getCurrentLoginUser
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Current user information retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       401:
 *         description: Unauthorized - valid authentication token required
 *       404:
 *         description: User not found or deleted
 */

/**
 * @swagger
 * /api/auth/google:
 *   post:
 *     tags:
 *       - auth
 *     summary: Login with Google
 *     description: Authenticate a user with Google credentials (create account if not exists)
 *     operationId: loginWithGoogle
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               google_id:
 *                 type: string
 *                 description: Google ID token
 *     responses:
 *       200:
 *         description: Login successful, returns authentication token and user information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/TokenResponse'
 *       201:
 *         description: New user created with Google credentials
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/TokenResponse'
 *       400:
 *         description: Invalid input - missing required fields
 *       422:
 *         description: User account is inactive
 */

/**
 * @swagger
 * /api/auth/verify-token:
 *   post:
 *     tags:
 *       - auth
 *     summary: Verify email with token
 *     description: Verify user's email address using the verification token sent via email
 *     operationId: verifyToken
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/VerifiedTokenDto'
 *     responses:
 *       200:
 *         description: Email verified successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/VerificationResponse'
 *       400:
 *         description: Invalid input - token missing or malformed
 *       404:
 *         description: User not found
 *       410:
 *         description: Token expired or invalid
 */

/**
 * @swagger
 * /api/auth/resend-token:
 *   post:
 *     tags:
 *       - auth
 *     summary: Resend verification token
 *     description: Resend the email verification token to the user's email address
 *     operationId: resendToken
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/EmailDto'
 *     responses:
 *       200:
 *         description: Verification token resent successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Verification token has been sent to your email"
 *                 success:
 *                   type: boolean
 *                   example: true
 *       400:
 *         description: Invalid input - email format invalid
 *       404:
 *         description: User not found with provided email
 *       409:
 *         description: Email already verified
 */

/**
 * @swagger
 * /api/auth/forgot-password:
 *   put:
 *     tags:
 *       - auth
 *     summary: Request password reset
 *     description: Send a password reset link to the user's email address
 *     operationId: forgotPassword
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/EmailDto'
 *     responses:
 *       200:
 *         description: Password reset email sent successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ForgotPasswordResponse'
 *       400:
 *         description: Invalid input - email format invalid
 *       404:
 *         description: User not found with provided email
 */

/**
 * @swagger
 * /api/auth/logout:
 *   get:
 *     tags:
 *       - auth
 *     summary: Logout current user
 *     description: Invalidate the current user's authentication token
 *     operationId: logout
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Logout successful
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/LogoutResponse'
 *       401:
 *         description: Unauthorized - valid authentication token required
 */



================================================
FILE: src/modules/blog/blog.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { IBlog } from './blog.interface';
import BlogService from './blog.service';
import { BlogResponseDto, BlogSearchDto, CreateBlogDto, UpdateBlogDto } from './dtos/blog.dto';
import { ILog } from './log/log.interface';
import { LogService } from './log';
import { plainToInstance } from 'class-transformer';
import { validateOrReject } from 'class-validator';
import { formatResponse } from '../../core/utils';
import { HttpException } from '../../core/exceptions';
import { SearchPaginationResponseModel } from '../../core/models';

// Define a type for the files object from multer's fields middleware
interface MulterFiles {
    [fieldname: string]: Express.Multer.File[];
}

class BlogController {
    private blogService = new BlogService();
    private logService = new LogService();

    public createBlog = async (req: Request, res: Response, next: NextFunction) => {
        try {
            console.log('Starting blog creation process...');
            const blogData = plainToInstance(CreateBlogDto, req.body);

            try {
                await validateOrReject(blogData);
            } catch (errors) {
                console.error('Validation errors:', errors);
                const validationErrors = errors as Array<{ property: string, constraints: Record<string, string> }>;
                const formattedErrors = validationErrors.map(error =>
                    Object.values(error.constraints || {}).join(', ')
                ).join('; ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${formattedErrors}`);
            }

            if (req.user && req.user.id) {
                blogData.user_id = req.user.id;
            } else {
                throw new HttpException(HttpStatus.Unauthorized, 'User authentication required');
            }

            // Handle boolean conversion for is_published if it's a string
            if (req.body.is_published !== undefined) {
                if (req.body.is_published === 'true') {
                    blogData.is_published = true;
                } else if (req.body.is_published === 'false') {
                    blogData.is_published = false;
                }
            }

            // Handle date conversion for published_at if it's a string
            if (req.body.published_at) {
                try {
                    const date = new Date(req.body.published_at);
                    // Check if the date is valid
                    if (isNaN(date.getTime())) {
                        console.error('Invalid date format for published_at:', req.body.published_at);
                        // Set to current date instead of invalid date
                        blogData.published_at = new Date();
                    } else {
                        blogData.published_at = date;
                    }
                } catch (error) {
                    console.error('Error converting published_at to Date:', error);
                    // Set to current date if conversion fails
                    blogData.published_at = new Date();
                }
            } else {
                // If no published_at provided, set to current date
                blogData.published_at = new Date();
            }

            // Add uploaded files to the DTO
            const files: Express.Multer.File[] = [];

            console.log('Checking for uploaded files...');
            if (req.files && typeof req.files === 'object') {
                console.log('Files found in request:', Object.keys(req.files));
                const multerFiles = req.files as MulterFiles;

                // Handle files from both 'images' and 'image_files' fields
                if (multerFiles['images'] && Array.isArray(multerFiles['images'])) {
                    console.log(`Found ${multerFiles['images'].length} files in 'images' field`);

                    // Validate each file to ensure it has the necessary properties
                    multerFiles['images'].forEach((file, index) => {
                        console.log(`Checking file ${index}:`, {
                            hasBuffer: !!file.buffer,
                            hasOriginalName: !!file.originalname,
                            hasMimetype: !!file.mimetype,
                            size: file.size
                        });

                        if (!file.buffer || !file.originalname || !file.mimetype) {
                            console.error('Invalid file object:', file);
                        } else {
                            files.push(file);
                        }
                    });
                }

                if (files.length > 0) {
                    console.log(`Adding ${files.length} valid files to blogData`);
                    blogData.files = files;
                } else {
                    console.log('No valid files found to upload');
                }
            } else {
                console.log('No files found in request');
            }

            // Check if required fields are present
            if (!blogData.service_id) {
                throw new HttpException(HttpStatus.BadRequest, 'service_id is required');
            }

            if (!blogData.blog_category_id) {
                throw new HttpException(HttpStatus.BadRequest, 'blog_category_id is required');
            }

            // save log in blog_logs collection
            console.log('Sending data to blog service for creation...');
            const blog: IBlog = await this.blogService.createBlog(blogData);
            console.log('Blog created successfully with ID:', blog._id);
            res.status(HttpStatus.Created).json(formatResponse<IBlog>(blog));
        } catch (error) {
            console.error('Controller error:', error);
            next(error);
        }
    };

    public updateBlog = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const blogData = plainToInstance(UpdateBlogDto, req.body);

            try {
                await validateOrReject(blogData);
            } catch (errors) {
                console.error('Validation errors:', errors);
                const validationErrors = errors as Array<{ property: string, constraints: Record<string, string> }>;
                const formattedErrors = validationErrors.map(error =>
                    Object.values(error.constraints || {}).join(', ')
                ).join('; ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${formattedErrors}`);
            }

            // Handle boolean conversion for is_published if it's a string
            if (req.body.is_published !== undefined) {
                if (req.body.is_published === 'true') {
                    blogData.is_published = true;
                } else if (req.body.is_published === 'false') {
                    blogData.is_published = false;
                }
            }

            // Handle date conversion for published_at if it's a string
            if (req.body.published_at) {
                try {
                    const date = new Date(req.body.published_at);
                    // Check if the date is valid
                    if (isNaN(date.getTime())) {
                        console.error('Invalid date format for published_at:', req.body.published_at);
                        // Set to current date instead of invalid date
                        blogData.published_at = new Date();
                    } else {
                        blogData.published_at = date;
                    }
                } catch (error) {
                    console.error('Error converting published_at to Date:', error);
                    // Set to current date if conversion fails
                    blogData.published_at = new Date();
                }
            }

            // Process uploaded files
            // Note: If new files are uploaded, they will REPLACE existing images, not add to them
            const files: Express.Multer.File[] = [];

            if (req.files && typeof req.files === 'object') {
                console.log('Update blog: Processing uploaded files');
                const multerFiles = req.files as MulterFiles;

                // Handle files from 'images' field
                if (multerFiles['images'] && Array.isArray(multerFiles['images'])) {
                    console.log(`Update blog: Found ${multerFiles['images'].length} image files`);
                    // Validate each file to ensure it has the necessary properties
                    multerFiles['images'].forEach((file, index) => {
                        console.log(`Checking file ${index}:`, {
                            hasBuffer: !!file.buffer,
                            hasOriginalName: !!file.originalname,
                            hasMimetype: !!file.mimetype,
                            size: file.size
                        });

                        if (!file.buffer || !file.originalname || !file.mimetype) {
                            console.error('Invalid file object:', file);
                        } else {
                            files.push(file);
                        }
                    });
                }

                if (files.length > 0) {
                    console.log(`Update blog: Adding ${files.length} valid files to update request`);
                    blogData.files = files;
                } else {
                    console.log('Update blog: No valid files found to upload');
                }
            }

            // Extract user_id from JWT token for author tracking
            const authorId = req.user?.id || '';
            if (!authorId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User authentication required');
            }

            console.log('Update blog: Sending update request to service');
            const blog: IBlog = await this.blogService.updateBlog(blogId, blogData, authorId);
            console.log('Update blog: Blog updated successfully');
            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            console.error('Controller error during update:', error);
            next(error);
        }
    };

    public uploadBlogImages = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const files: Express.Multer.File[] = [];

            // Check if files were uploaded from either field
            if (req.files && typeof req.files === 'object') {
                const multerFiles = req.files as MulterFiles;

                if (multerFiles['images'] && Array.isArray(multerFiles['images'])) {
                    // Validate each file to ensure it has the necessary properties
                    multerFiles['images'].forEach(file => {
                        if (!file.buffer || !file.originalname || !file.mimetype) {
                            console.error('Invalid file object:', file);
                        } else {
                            files.push(file);
                        }
                    });
                }
            }

            if (files.length === 0) {
                return res.status(HttpStatus.BadRequest).json({
                    status: HttpStatus.BadRequest,
                    message: 'No files uploaded'
                });
            }

            // This method is used for standalone image uploads separate from blog creation/update
            // It follows the same process: uploads to S3 and automatically generates metadata
            const blog = await this.blogService.uploadBlogImages(blogId, files);

            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            console.error('Controller error during image upload:', error);
            next(error);
        }
    };

    public deleteBlogImage = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const imageUrl = req.body.image_url;

            if (!imageUrl) {
                throw new HttpException(HttpStatus.BadRequest, 'Image URL is required');
            }

            const isDeleted = await this.blogService.deleteBlogImage(blogId, imageUrl);
            if (isDeleted) {
                res.status(HttpStatus.Success).json(formatResponse<string>('Deleted blog image successfully!'));
            } else {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
        } catch (error) {
            next(error);
        }
    };

    public deleteBlog = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const isDeleted = await this.blogService.deleteBlog(blogId);
            if (isDeleted) {
                res.status(HttpStatus.Success).json(formatResponse<string>('Deleted blog successfully!'));
            } else {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
        } catch (error) {
            next(error);
        }
    };

    public getBlogById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const blog: IBlog = await this.blogService.getBlogById(blogId);
            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            next(error);
        }
    };

    public getBlogBySlug = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slug = req.params.slug;
            const blog: IBlog = await this.blogService.getBlogBySlug(slug);
            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            next(error);
        }
    };

    public getBlogs = async (req: Request, res: Response, next: NextFunction) => {
        try {
            console.log('Controller: Fetching all blogs');
            const blogs: IBlog[] = await this.blogService.getBlogs();
            console.log(`Controller: Successfully fetched ${blogs.length} blogs`);
            res.status(HttpStatus.Success).json(formatResponse<IBlog[]>(blogs));
        } catch (error) {
            console.error('Controller error fetching blogs:', error);
            next(error);
        }
    };

    public searchBlogs = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
            // Check if there are any blogs in the database first
            try {
                const totalBlogsCount = await this.blogService.getTotalBlogsCount();
                console.log(`Controller: Total blogs in database: ${totalBlogsCount}`);

                if (totalBlogsCount === 0) {
                    console.log('Controller: No blogs found in database');
                    // If no blogs exist, return empty pagination result with correct structure
                    const emptyResult = new SearchPaginationResponseModel<IBlog>();
                    emptyResult.pageInfo.pageNum = 1;
                    emptyResult.pageInfo.pageSize = 10;
                    emptyResult.pageInfo.totalItems = 0;
                    emptyResult.pageInfo.totalPages = 0;
                    res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IBlog>>(emptyResult));
                    return;
                }
            } catch (error) {
                console.error('Controller: Error checking total blogs count:', error);
                // Continue with search even if this check fails
            }

            // Default search condition and pagination if not provided
            const searchCondition = req.body.searchCondition || {};
            console.log('Controller: Raw search condition:', JSON.stringify(searchCondition));

            // Initialize with empty object if searchCondition is null or undefined
            const searchData = plainToInstance(BlogSearchDto, searchCondition);

            try {
                // Skip validation if empty search condition (will return all blogs with pagination)
                if (Object.keys(searchCondition).length > 0) {
                    await validateOrReject(searchData);
                }
                console.log('Controller: Search data validation passed');
            } catch (validationErrors) {
                console.error('Controller: Search data validation failed:', validationErrors);
                // Extract specific validation error messages for better debugging
                const errorDetails = Array.isArray(validationErrors)
                    ? validationErrors.map(err => Object.values(err.constraints || {}).join(', ')).join('; ')
                    : 'Validation failed';

                throw new HttpException(HttpStatus.BadRequest, `Invalid search parameters: ${errorDetails}`);
            }

            // Ensure pageInfo has valid values
            const pageInfo = req.body.pageInfo || { pageNum: 1, pageSize: 10 };
            const pageNum = parseInt(pageInfo.pageNum) || 1;
            const pageSize = parseInt(pageInfo.pageSize) || 10;

            console.log(`Controller: Searching blogs with pageNum=${pageNum}, pageSize=${pageSize}`);
            console.log('Controller: Search conditions:', JSON.stringify(searchData));

            const searchResult = await this.blogService.searchBlogs(searchData, pageNum, pageSize);

            console.log(`Controller: Search completed, found ${searchResult.pageData.length} blogs`);
            console.log(`Controller: Total items: ${searchResult.pageInfo.totalItems}, Total pages: ${searchResult.pageInfo.totalPages}`);
            console.log('Controller: Search result structure:', JSON.stringify({
                hasPageData: !!searchResult.pageData,
                pageDataLength: searchResult.pageData?.length || 0,
                hasPageInfo: !!searchResult.pageInfo,
                pageInfoProps: searchResult.pageInfo ? Object.keys(searchResult.pageInfo) : []
            }));

            // Format the response exactly as the frontend expects it
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IBlog>>(searchResult));
        } catch (error) {
            console.error('Controller error during blog search:', error);
            next(error);
        }
    };

    public getBlogLogs = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const logs: ILog[] = await this.logService.getLogsByBlogId(blogId);
            res.status(HttpStatus.Success).json(formatResponse<ILog[]>(logs));
        } catch (error) {
            next(error);
        }
    };
}

export default BlogController;



================================================
FILE: src/modules/blog/blog.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IBlogImage {
    name: string;
    image_url: string;
    created_at: Date;
}

export interface IBlog extends Document {
    _id: string;
    title: string;
    content: string;
    slug: string;
    user_id: string | undefined;
    service_id: string | undefined;
    blog_category_id: string | undefined;
    is_published: boolean;
    published_at?: Date;
    images?: IBlogImage[];
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
} 


================================================
FILE: src/modules/blog/blog.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IBlog } from './blog.interface';

const BlogImageSchema = new Schema({
    name: { type: String, required: true },
    image_url: { type: String, required: true },
    created_at: { type: Date, default: Date.now }
});

const BlogSchemaEntity: Schema<IBlog> = new Schema({
    title: { type: String, required: true },
    content: { type: String, required: true },
    slug: { type: String, required: true, unique: true },
    user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE, required: true },
    blog_category_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG_CATEGORY, required: true },
    is_published: { type: Boolean, default: true },
    published_at: { type: Date, default: Date.now },
    images: [BlogImageSchema],
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false }
});

const BlogSchema = mongoose.model<IBlog & mongoose.Document>(
    COLLECTION_NAME.BLOG,
    BlogSchemaEntity
);

export default BlogSchema; 


================================================
FILE: src/modules/blog/blog.repository.ts
================================================
import { IBlog } from "./blog.interface";
import BlogSchemaEntity from "./blog.model";
import mongoose from "mongoose";
import { BlogSearchDto } from "./dtos/blog.dto";

export default class BlogRepository {
    public async createBlog(model: IBlog): Promise<IBlog> {
        try {
            return await BlogSchemaEntity.create(model);
        } catch (error) {
            console.error('Repository error creating blog:', error);
            throw error;
        }
    }

    public async updateBlog(id: string, model: Partial<IBlog>): Promise<IBlog | null> {
        try {
            console.log(`Repository: Updating blog ${id} with data:`, JSON.stringify(model));
            const blog = await BlogSchemaEntity.findByIdAndUpdate(
                id,
                { ...model, updated_at: new Date() },
                { new: true }
            );
            console.log(`Repository: Blog ${id} update result:`, blog ? 'Success' : 'Not found');
            return blog;
        } catch (error) {
            console.error(`Repository error updating blog ${id}:`, error);
            throw error;
        }
    }

    public async deleteBlog(id: string): Promise<IBlog | null> {
        return BlogSchemaEntity.findByIdAndUpdate(
            id,
            { is_deleted: true, updated_at: new Date() },
            { new: true }
        );
    }

    public async getBlogById(id: string): Promise<IBlog | null> {
        return BlogSchemaEntity.findById(id).where({ is_deleted: false });
    }

    public async getBlogBySlug(slug: string): Promise<IBlog | null> {
        return BlogSchemaEntity.findOne({ slug, is_deleted: false });
    }

    public async checkSlugExists(slug: string, excludeId?: string): Promise<boolean> {
        const query: any = { slug, is_deleted: false };

        // If excludeId is provided, exclude that blog from the check
        // This is useful when updating a blog to check if the slug exists for any blog other than the current one
        if (excludeId) {
            query._id = { $ne: excludeId };
        }

        const count = await BlogSchemaEntity.countDocuments(query);
        return count > 0;
    }

    public async getBlogs(): Promise<IBlog[]> {
        try {
            console.log('Repository: Fetching all non-deleted blogs');
            const blogs = await BlogSchemaEntity.find({ is_deleted: false })
                .sort({ created_at: -1 });
            console.log(`Repository: Found ${blogs.length} blogs`);
            return blogs;
        } catch (error) {
            console.error('Repository error fetching blogs:', error);
            throw error;
        }
    }

    /**
     * Get the total count of non-deleted blogs in the database
     */
    public async getTotalBlogsCount(): Promise<number> {
        try {
            console.log('Repository: Counting all non-deleted blogs');
            const count = await BlogSchemaEntity.countDocuments({ is_deleted: false });
            console.log(`Repository: Total non-deleted blogs: ${count}`);
            return count;
        } catch (error) {
            console.error('Repository error counting all blogs:', error);
            throw error;
        }
    }

    public async searchBlogs(searchParams: BlogSearchDto): Promise<IBlog[]> {
        const query: any = { is_deleted: false };

        if (searchParams.title) {
            query.title = { $regex: searchParams.title, $options: 'i' };
        }

        if (searchParams.blog_category_id) {
            query.blog_category_id = searchParams.blog_category_id;
        }

        if (searchParams.user_id) {
            query.user_id = searchParams.user_id;
        }

        if (searchParams.service_id) {
            query.service_id = searchParams.service_id;
        }

        if (searchParams.is_published !== undefined) {
            query.is_published = searchParams.is_published;
        }

        return BlogSchemaEntity.find(query);
    }

    public async countBlogs(searchParams: BlogSearchDto): Promise<number> {
        try {
            console.log('Repository: Counting blogs with search params:', JSON.stringify(searchParams));
            const query: any = { is_deleted: false };

            if (searchParams.title) {
                query.title = { $regex: searchParams.title, $options: 'i' };
            }

            // Build $or conditions for ID fields to handle potential schema inconsistencies
            const orConditions = [];

            if (searchParams.blog_category_id) {
                orConditions.push(
                    { blog_category_id: searchParams.blog_category_id },
                    { blog_category_id: searchParams.blog_category_id.toString() }
                );
            }

            if (searchParams.user_id) {
                orConditions.push(
                    { user_id: searchParams.user_id },
                    { user_id: searchParams.user_id.toString() }
                );
            }

            if (searchParams.service_id) {
                orConditions.push(
                    { service_id: searchParams.service_id },
                    { service_id: searchParams.service_id.toString() }
                );
            }

            // Add $or conditions to query if any exist
            if (orConditions.length > 0) {
                query.$or = orConditions;
            }

            if (searchParams.is_published !== undefined) {
                query.is_published = searchParams.is_published;
            }

            console.log('Repository: Final count query:', JSON.stringify(query));

            // First try with the specific query
            let count = await BlogSchemaEntity.countDocuments(query);
            console.log(`Repository: Found ${count} matching blogs with specific query`);

            // If no results and we have filters, try a fallback count of all non-deleted blogs
            if (count === 0 && Object.keys(query).length > 1) {
                const fallbackCount = await BlogSchemaEntity.countDocuments({ is_deleted: false });
                console.log(`Repository: Fallback count of all non-deleted blogs: ${fallbackCount}`);

                if (fallbackCount > 0) {
                    console.log('Repository: Using fallback count instead');
                    count = fallbackCount;
                }
            }

            return count;
        } catch (error) {
            console.error('Repository error counting blogs:', error);
            throw error;
        }
    }

    public async getBlogsWithPagination(query: any, skip: number, limit: number): Promise<IBlog[]> {
        try {
            console.log(`Repository: Getting paginated blogs with skip=${skip}, limit=${limit}`);
            console.log('Repository: Query:', JSON.stringify(query));

            // Ensure skip and limit are valid numbers
            const validSkip = Math.max(0, skip || 0);
            const validLimit = Math.max(1, Math.min(100, limit || 10));

            // Add explicit sorting to ensure consistent results
            const blogs = await BlogSchemaEntity.find(query)
                .skip(validSkip)
                .limit(validLimit)
                .sort({ created_at: -1 })
                .lean()  // Convert to plain JavaScript objects for better performance
                .exec(); // Explicitly execute the query

            // Ensure we always return an array
            const safeBlogs = Array.isArray(blogs) ? blogs : [];

            console.log(`Repository: Retrieved ${safeBlogs.length} blogs`);

            // Log a sample of the first blog for debugging (if available)
            if (safeBlogs.length > 0) {
                const sampleBlog = { ...safeBlogs[0] };
                if (sampleBlog.content && sampleBlog.content.length > 100) {
                    sampleBlog.content = sampleBlog.content.substring(0, 100) + '...';
                }
                console.log('Repository: Sample blog:', JSON.stringify(sampleBlog));
            } else {
                console.log('Repository: No blogs found with query:', JSON.stringify(query));

                // Debug: Try a simple query to check if any blogs exist
                const totalBlogsCount = await BlogSchemaEntity.countDocuments({ is_deleted: false });
                console.log(`Repository: Total non-deleted blogs in database: ${totalBlogsCount}`);

                if (totalBlogsCount > 0) {
                    // Get a sample blog to check schema
                    const sampleBlog = await BlogSchemaEntity.findOne({ is_deleted: false }).lean();
                    if (sampleBlog) {
                        console.log('Repository: Sample blog from database:', JSON.stringify({
                            id: sampleBlog._id,
                            title: sampleBlog.title,
                            fields: Object.keys(sampleBlog)
                        }));
                    }
                }
            }

            return safeBlogs;
        } catch (error) {
            console.error('Repository error getting paginated blogs:', error);
            // Return empty array instead of throwing to prevent complete failure
            // The service layer can handle this appropriately
            return [];
        }
    }
}



================================================
FILE: src/modules/blog/blog.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import multer from 'multer';
import { UserRoleEnum } from '../user/user.enum';
import BlogController from './blog.controller';
import { CreateBlogDto, UpdateBlogDto } from './dtos/blog.dto';

export default class BlogRoute implements IRoute {
    public path = API_PATH.BLOG;
    public router = Router();
    public blogController = new BlogController();

    // Configure multer for memory storage
    private storage = multer.memoryStorage();
    private upload = multer({
        storage: this.storage,
        limits: {
            fileSize: 5 * 1024 * 1024 // 5MB max file size
        },
        fileFilter: (req, file, cb) => {
            // Accept only image files
            if (!file.originalname.match(/\.(jpg|jpeg|png|gif)$/i)) {
                return cb(null, false);
            }
            cb(null, true);
        }
    });

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {

        // POST: domain:/api/blog/create -> Create blog with image upload
        // Uses multer middleware to handle multipart/form-data form with image uploads
        this.router.post(
            `${this.path}/create`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.upload.fields([
                { name: 'images', maxCount: 10 }
            ]),
            validationMiddleware(CreateBlogDto, true),
            this.blogController.createBlog
        );

        // GET: domain:/api/blog/:id -> Get blog by id
        this.router.get(
            `${this.path}/:id`,
            this.blogController.getBlogById
        );

        // GET: domain:/api/blog/slug/:slug -> Get blog by slug
        this.router.get(
            `${this.path}/slug/:slug`,
            this.blogController.getBlogBySlug
        );

        // GET: domain:/api/blog -> Get all blogs
        this.router.get(
            `${this.path}`,
            this.blogController.getBlogs
        );

        // POST: domain:/api/blog/search -> Search blogs
        this.router.post(
            `${this.path}/search`,
            this.blogController.searchBlogs
        );

        // GET: domain:/api/blog/:id/logs -> Get blog logs
        this.router.get(
            `${this.path}/:id/logs`,
            this.blogController.getBlogLogs
        );

        // DELETE: domain:/api/blog/:id/image -> Delete image from blog
        this.router.delete(
            `${this.path}/:id/image`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.blogController.deleteBlogImage
        );

        // PUT: domain:/api/blog/:id -> Update blog with image upload
        // Uses multer middleware to handle multipart/form-data form with image uploads
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.upload.fields([
                { name: 'images', maxCount: 10 }
            ]),
            validationMiddleware(UpdateBlogDto, true),
            this.blogController.updateBlog
        );

        // DELETE: domain:/api/blog/:id -> Delete blog
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.blogController.deleteBlog
        );
    }
}



================================================
FILE: src/modules/blog/blog.service.ts
================================================
import { UserRoleEnum, UserSchema } from "../user";
import mongoose, { Schema } from "mongoose";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { isEmptyObject } from "../../core/utils";
import { IBlog, IBlogImage } from "./blog.interface";
import BlogRepository from "./blog.repository";
import { BlogSearchDto, CreateBlogDto, UpdateBlogDto } from "./dtos/blog.dto";
import { ILog } from "./log/log.interface";
import LogService from "./log/log.service";
import { uploadMultipleFilesToS3, s3Folders } from "../../core/utils/s3Upload";

export default class BlogService {
    private blogRepository = new BlogRepository();
    private logService = new LogService();

    public async createBlog(createBlogDto: CreateBlogDto): Promise<IBlog> {
        try {
            console.log('Blog service: Starting blog creation...');
            // Generate a unique slug based on the title if not provided
            if (!createBlogDto.slug) {
                createBlogDto.slug = await this.generateSlug(createBlogDto.title);
            } else {
                // If slug is provided, ensure it's unique
                createBlogDto.slug = await this.generateSlug(createBlogDto.slug);
            }

            // Set default values for is_published and published_at if not provided
            if (createBlogDto.is_published === undefined) {
                createBlogDto.is_published = true;
            }

            // Ensure published_at is a valid date
            if (!createBlogDto.published_at || isNaN(createBlogDto.published_at.getTime())) {
                createBlogDto.published_at = new Date();
            }

            // Handle file uploads if files are provided
            if (createBlogDto.files && createBlogDto.files.length > 0) {
                console.log(`Blog service: Processing ${createBlogDto.files.length} files for upload`);
                try {
                    // Create blog first to get the ID
                    console.log('Blog service: Creating blog in database...');
                    const blog = await this.blogRepository.createBlog(createBlogDto as unknown as IBlog);
                    console.log(`Blog service: Blog created with ID: ${blog._id}`);

                    try {
                        // Upload images to S3 - this will store files in the blog-images/[blog_id] folder
                        const blogFolder = s3Folders.blogImages;
                        console.log(`Blog service: Uploading files to S3 folder: ${blogFolder}/${blog._id}`);
                        const imageUrls = await uploadMultipleFilesToS3(createBlogDto.files, blog._id, blogFolder);
                        console.log(`Blog service: ${imageUrls.length} files uploaded successfully`);

                        // Create image objects with auto-generated metadata:
                        // - name: original filename from the uploaded file
                        // - image_url: AWS S3 URL returned from the upload function
                        // - created_at: current timestamp
                        const blogImages: IBlogImage[] = imageUrls.map((url, index) => ({
                            name: createBlogDto.files![index].originalname,
                            image_url: url,
                            created_at: new Date()
                        }));
                        console.log('Blog service: Created image metadata objects:', blogImages);

                        // Update blog with images
                        console.log(`Blog service: Updating blog ${blog._id} with ${blogImages.length} images`);
                        const updatedBlog = await this.blogRepository.updateBlog(blog._id, {
                            images: blogImages,
                            updated_at: new Date()
                        });
                        console.log('Blog service: Blog updated with images successfully');

                        return updatedBlog || blog;
                    } catch (uploadError) {
                        console.error('Error uploading images to S3:', uploadError);

                        // Even if image upload fails, return the blog without images
                        return blog;
                    }
                } catch (dbError) {
                    console.error('Error creating blog in database:', dbError);
                    throw dbError;
                }
            } else {
                // Create blog without images
                console.log('Blog service: No files to upload, creating blog without images');
                const blog = await this.blogRepository.createBlog(createBlogDto as unknown as IBlog);
                return blog;
            }
        } catch (error) {
            console.error('Blog creation error:', error);
            if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            } else if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating blog');
        }
    }

    public async updateBlog(id: string, updateBlogDto: UpdateBlogDto, authorId: string): Promise<IBlog> {
        try {
            const existingBlog = await this.blogRepository.getBlogById(id);
            if (!existingBlog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            // If slug is being updated, ensure it's unique
            if (updateBlogDto.slug && updateBlogDto.slug !== existingBlog.slug) {
                updateBlogDto.slug = await this.generateSlug(updateBlogDto.slug, id);
            }
            // If title is being updated but slug isn't, update the slug based on the new title
            else if (updateBlogDto.title && !updateBlogDto.slug && updateBlogDto.title !== existingBlog.title) {
                updateBlogDto.slug = await this.generateSlug(updateBlogDto.title, id);
            }

            // Ensure published_at is a valid date if provided
            if (updateBlogDto.published_at !== undefined) {
                if (!updateBlogDto.published_at || isNaN(updateBlogDto.published_at.getTime())) {
                    updateBlogDto.published_at = new Date();
                }
            }

            // Handle file uploads if files are provided
            if (updateBlogDto.files && updateBlogDto.files.length > 0) {
                console.log(`Blog update: Processing ${updateBlogDto.files.length} new image files`);
                try {
                    // Upload images to S3 - this will store files in the blog-images/[blog_id] folder
                    const blogFolder = s3Folders.blogImages;
                    const imageUrls = await uploadMultipleFilesToS3(updateBlogDto.files, id, blogFolder);

                    // Create image objects with auto-generated metadata:
                    // - name: original filename from the uploaded file
                    // - image_url: AWS S3 URL returned from the upload function
                    // - created_at: current timestamp
                    const blogImages: IBlogImage[] = imageUrls.map((url, index) => ({
                        name: updateBlogDto.files![index].originalname,
                        image_url: url,
                        created_at: new Date()
                    }));

                    // Replace existing images with new ones instead of adding to them
                    // This fixes the bug where images accumulate on each update
                    updateBlogDto.images = blogImages;
                    console.log(`Blog update: Replacing existing images with ${blogImages.length} new images`);
                } catch (uploadError) {
                    console.error('Error uploading images to S3 during update:', uploadError);
                    // Continue with the update without changing images
                }
            } else if (updateBlogDto.images === undefined) {
                // If no new files are uploaded and images field is not explicitly set,
                // preserve the existing images
                updateBlogDto.images = existingBlog.images || [];
                console.log('Blog update: No new images provided, keeping existing images');
            }

            // Create log entry for the update
            await this.createBlogLog(existingBlog, updateBlogDto, authorId);

            const updatedBlog = await this.blogRepository.updateBlog(id, updateBlogDto as Partial<IBlog>);
            if (!updatedBlog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return updatedBlog;
        } catch (error) {
            console.error(`Blog update error for ID ${id}:`, error);
            if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            } else if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating blog');
        }
    }

    /**
     * Uploads images to an existing blog
     * Note: This method is primarily used internally by the createBlog and updateBlog methods
     * It's not exposed as a separate API endpoint as image uploads are integrated directly into
     * the blog creation and update processes
     * 
     * @param blogId The ID of the blog to upload images to
     * @param files The files to upload
     * @returns The updated blog with the new images
     */
    public async uploadBlogImages(blogId: string, files: Express.Multer.File[]): Promise<IBlog> {
        try {
            console.log(`uploadBlogImages: Processing ${files.length} files for blog ${blogId}`);

            // Check if blog exists
            const blog = await this.blogRepository.getBlogById(blogId);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            // Create a folder specific to this blog
            const blogFolder = s3Folders.blogImages;

            try {
                // Log file details for debugging
                files.forEach((file, index) => {
                    console.log(`File ${index} details:`, {
                        originalname: file.originalname,
                        mimetype: file.mimetype,
                        size: file.size,
                        hasBuffer: !!file.buffer,
                        hasPath: !!file.path
                    });
                });

                // Upload images to S3
                console.log(`Uploading files to S3 folder: ${blogFolder}/${blogId}`);
                const imageUrls = await uploadMultipleFilesToS3(files, blogId, blogFolder);
                console.log(`Successfully uploaded ${imageUrls.length} files to S3`);

                // Create image objects
                const blogImages: IBlogImage[] = imageUrls.map((url, index) => ({
                    name: files[index].originalname,
                    image_url: url,
                    created_at: new Date()
                }));
                console.log('Created image metadata objects:', blogImages);

                // Replace existing images with new ones (not adding to them)
                console.log(`Replacing ${blog.images?.length || 0} existing images with ${blogImages.length} new images`);

                // Update blog with new images
                const updatedBlog = await this.blogRepository.updateBlog(blogId, {
                    images: blogImages, // Replace existing images
                    updated_at: new Date()
                });

                if (!updatedBlog) {
                    throw new HttpException(HttpStatus.NotFound, 'Blog not found');
                }

                console.log('Blog successfully updated with new images');
                return updatedBlog;
            } catch (uploadError) {
                console.error('Error uploading images to S3:', uploadError);
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload files to S3');
            }
        } catch (error) {
            console.error(`Error in uploadBlogImages for blog ID ${blogId}:`, error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error uploading blog images');
        }
    }

    public async deleteBlogImage(blogId: string, imageUrl: string): Promise<boolean> {
        try {
            // Check if blog exists
            const blog = await this.blogRepository.getBlogById(blogId);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            // Check if blog has images
            if (!blog.images || blog.images.length === 0) {
                throw new HttpException(HttpStatus.NotFound, 'Blog has no images');
            }

            // Filter out the image to delete
            const updatedImages = blog.images.filter(image => image.image_url !== imageUrl);

            // Check if image was found
            if (updatedImages.length === blog.images.length) {
                throw new HttpException(HttpStatus.NotFound, 'Image not found');
            }

            // Update blog with filtered images
            const updatedBlog = await this.blogRepository.updateBlog(blogId, {
                images: updatedImages,
                updated_at: new Date()
            });

            if (!updatedBlog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            return true;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting blog image');
        }
    }

    public async deleteBlog(id: string): Promise<boolean> {
        try {
            const blog = await this.blogRepository.deleteBlog(id);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return true;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting blog');
        }
    }

    public async getBlogById(id: string): Promise<IBlog> {
        try {
            const blog = await this.blogRepository.getBlogById(id);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return blog;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog');
        }
    }

    public async getBlogBySlug(slug: string): Promise<IBlog> {
        try {
            const blog = await this.blogRepository.getBlogBySlug(slug);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return blog;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog by slug');
        }
    }

    public async getBlogs(): Promise<IBlog[]> {
        try {
            console.log('Blog service: Fetching all blogs');
            const blogs = await this.blogRepository.getBlogs();
            console.log(`Blog service: Successfully fetched ${blogs.length} blogs`);
            return blogs;
        } catch (error) {
            console.error('Error fetching blogs:', error);
            if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            } else if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blogs');
        }
    }

    /**
     * Get the total count of non-deleted blogs in the database
     * This is useful for quickly checking if there are any blogs before performing a search
     */
    public async getTotalBlogsCount(): Promise<number> {
        try {
            console.log('Blog service: Getting total blogs count');
            const count = await this.blogRepository.getTotalBlogsCount();
            console.log(`Blog service: Total blogs count: ${count}`);
            return count;
        } catch (error) {
            console.error('Error getting total blogs count:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting total blogs count');
        }
    }

    public async searchBlogs(searchParams: BlogSearchDto, pageNum: number, pageSize: number): Promise<SearchPaginationResponseModel<IBlog>> {
        try {
            const query: any = { is_deleted: false };

            if (searchParams.title) {
                query.title = { $regex: searchParams.title, $options: 'i' };
            }

            // Simply use the ID strings directly without ObjectId conversion
            if (searchParams.blog_category_id) {
                // Try both formats (string and ObjectId) to handle potential schema inconsistencies
                query.$or = [
                    { blog_category_id: searchParams.blog_category_id },
                    { blog_category_id: searchParams.blog_category_id.toString() }
                ];
            }

            if (searchParams.user_id) {
                if (!query.$or) query.$or = [];
                query.$or.push(
                    { user_id: searchParams.user_id },
                    { user_id: searchParams.user_id.toString() }
                );
            }

            if (searchParams.service_id) {
                if (!query.$or) query.$or = [];
                query.$or.push(
                    { service_id: searchParams.service_id },
                    { service_id: searchParams.service_id.toString() }
                );
            }

            if (searchParams.is_published !== undefined) {
                query.is_published = searchParams.is_published;
            }

            // Count total items matching the query
            const totalItems = await this.blogRepository.countBlogs(searchParams);
            // Ensure pagination values are valid numbers
            const validPageNum = Math.max(1, pageNum || 1);
            const validPageSize = Math.max(1, Math.min(100, pageSize || 10)); // Limit max page size to 100

            // Calculate pagination values
            const totalPages = Math.ceil(totalItems / validPageSize);
            const skip = (validPageNum - 1) * validPageSize;

            // Get paginated results
            const blogs = await this.blogRepository.getBlogsWithPagination(query, skip, validPageSize);
            // If no blogs found with the query, try a fallback query to get any blogs
            if (blogs.length === 0 && Object.keys(query).length > 1) {
                console.log('Blog service: No blogs found with specific query, trying fallback query');
                const fallbackQuery = { is_deleted: false };
                const fallbackBlogs = await this.blogRepository.getBlogsWithPagination(
                    fallbackQuery, 0, validPageSize
                );

                if (fallbackBlogs.length > 0) {
                    // Use the fallback blogs but keep original pagination info
                    return new SearchPaginationResponseModel<IBlog>(
                        fallbackBlogs,
                        {
                            pageNum: validPageNum,
                            pageSize: validPageSize,
                            totalItems,
                            totalPages
                        }
                    );
                }
            }

            // Ensure blogs is always an array
            const safeBlogs = Array.isArray(blogs) ? blogs : [];

            // Create and return the search pagination response with proper structure
            const response = new SearchPaginationResponseModel<IBlog>(
                safeBlogs,
                {
                    pageNum: validPageNum,
                    pageSize: validPageSize,
                    totalItems,
                    totalPages
                }
            );
            return response;
        } catch (error) {
            console.error('Error searching blogs:', error);
            if (error instanceof HttpException) {
                throw error;
            } else if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching blogs');
        }
    }

    /**
     * Generates a unique slug based on the provided text
     * @param text The text to generate a slug from
     * @param excludeId Optional blog ID to exclude from uniqueness check
     * @returns A unique slug
     */
    public async generateSlug(text: string, excludeId?: string): Promise<string> {
        // Convert to lowercase, replace spaces and special chars with hyphens
        let slug = text
            .toLowerCase()
            .trim()
            .replace(/[àáạảãâầấậẩẫăằắặẳẵ]/g, 'a')
            .replace(/[èéẹẻẽêềếệểễ]/g, 'e')
            .replace(/[ìíịỉĩ]/g, 'i')
            .replace(/[òóọỏõôồốộổỗơờớợởỡ]/g, 'o')
            .replace(/[ùúụủũưừứựửữ]/g, 'u')
            .replace(/[ỳýỵỷỹ]/g, 'y')
            .replace(/đ/g, 'd');

        // Then handle spaces and special characters
        slug = slug
            .replace(/[^\w\s-]/g, '') // Xóa các ký tự không phải là từ ngoại trừ khoảng trắng và dấu gạch nối
            .replace(/[\s_]+/g, '-') // Thay thế khoảng trắng và dấu gạch dưới bằng dấu gạch nối
            .replace(/-+/g, '-') // Xóa các dấu gạch nối liên tiếp
            .replace(/^-+|-+$/g, ''); // Xóa các dấu gạch nối ở đầu và cuối chuỗi


        // Check if the slug already exists
        let isSlugExists = await this.blogRepository.checkSlugExists(slug, excludeId);
        let counter = 1;

        // If slug exists, append a number until we find a unique slug
        const originalSlug = slug;
        while (isSlugExists) {
            slug = `${originalSlug}-${counter}`;
            isSlugExists = await this.blogRepository.checkSlugExists(slug, excludeId);
            counter++;
        }

        return slug;
    }

    private async createBlogLog(oldBlog: IBlog, updateData: UpdateBlogDto, authorId: string): Promise<ILog> {
        const logData: any = {
            blog_id: oldBlog._id,
            author_id: authorId
        };

        // Only log fields that are being updated
        if (updateData.title !== undefined) {
            logData.old_title = oldBlog.title;
            logData.new_title = updateData.title;
        }

        if (updateData.content !== undefined) {
            logData.old_content = oldBlog.content;
            logData.new_content = updateData.content;
        }

        if (updateData.slug !== undefined) {
            logData.old_slug = oldBlog.slug;
            logData.new_slug = updateData.slug;
        }

        if (updateData.blog_category_id !== undefined) {
            logData.old_blog_category_id = oldBlog.blog_category_id;
            logData.new_blog_category_id = updateData.blog_category_id;
        }

        if (updateData.service_id !== undefined) {
            logData.old_service_id = oldBlog.service_id;
            logData.new_service_id = updateData.service_id;
        }

        if (updateData.user_id !== undefined) {
            logData.old_user_id = oldBlog.user_id;
            logData.new_user_id = updateData.user_id;
        }

        if (updateData.is_published !== undefined) {
            logData.old_is_published = oldBlog.is_published;
            logData.new_is_published = updateData.is_published;
        }

        if (updateData.published_at !== undefined) {
            logData.old_published_at = oldBlog.published_at;
            logData.new_published_at = updateData.published_at;
        }

        if (updateData.images !== undefined) {
            logData.old_images = oldBlog.images;
            logData.new_images = updateData.images;
        }

        return this.logService.createLog(logData);
    }
}



================================================
FILE: src/modules/blog/index.ts
================================================
import BlogSchema from './blog.model';
import { IBlog, IBlogImage } from './blog.interface';
import BlogController from './blog.controller';
import BlogService from './blog.service';
import BlogRepository from './blog.repository';
import { BlogResponseDto, BlogSearchDto, CreateBlogDto, UpdateBlogDto, BlogImageDto } from './dtos/blog.dto';
import { LogSchema, ILog, LogService, LogRepository } from './log';
import BlogRoute from './blog.route';

export {
    BlogSchema,
    IBlog,
    IBlogImage,
    BlogController,
    BlogService,
    BlogRepository,
    BlogResponseDto,
    BlogSearchDto,
    CreateBlogDto,
    UpdateBlogDto,
    BlogImageDto,
    LogSchema,
    ILog,
    LogService,
    LogRepository,
    BlogRoute
}; 


================================================
FILE: src/modules/blog/dtos/blog.dto.ts
================================================
import { IsArray, IsBoolean, IsDate, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

export class BlogImageDto {
    @IsString()
    @IsNotEmpty()
    name!: string;

    @IsString()
    @IsNotEmpty()
    image_url!: string;

    @IsOptional()
    @IsDate()
    created_at?: Date;
}

export class UploadBlogImagesDto {
    @IsMongoId()
    @IsNotEmpty()
    blog_id!: string;
}

export class CreateBlogDto {
    @IsString()
    @IsNotEmpty()
    title!: string;

    @IsString()
    @IsNotEmpty()
    content!: string;

    @IsString()
    @IsOptional()
    slug?: string;

    // @IsMongoId()
    @IsOptional()
    user_id: string = '';

    // @IsMongoId()
    @IsNotEmpty()
    service_id: string = '';

    // @IsMongoId()
    @IsNotEmpty()
    blog_category_id: string = '';

    @Type(() => Boolean)
    @IsOptional()
    is_published?: boolean;

    @IsOptional()
    @Type(() => Date)
    published_at?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    images?: BlogImageDto[];

    // This field is not validated by class-validator as it will be handled by multer
    files?: Express.Multer.File[];
}

export class UpdateBlogDto {
    @IsString()
    @IsOptional()
    title?: string;

    @IsString()
    @IsOptional()
    content?: string;

    @IsString()
    @IsOptional()
    slug?: string;

    @IsOptional()
    user_id: string = '';

    @IsOptional()
    service_id: string = '';

    @IsOptional()
    blog_category_id: string = '';

    @Type(() => Boolean)
    @IsOptional()
    is_published?: boolean;

    @IsOptional()
    @Type(() => Date)
    published_at?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    images?: BlogImageDto[];

    // This field is not validated by class-validator as it will be handled by multer
    files?: Express.Multer.File[];
}

export class BlogResponseDto {
    id!: string;
    title!: string;
    content!: string;
    slug!: string;
    user_id!: string;
    service_id!: string;
    blog_category_id!: string;
    is_published!: boolean;
    published_at?: Date;
    images!: BlogImageDto[];
    created_at!: Date;
    updated_at!: Date;
}

export class BlogSearchDto {
    @IsString()
    @IsOptional()
    title?: string;

    @IsString()
    @IsOptional()
    blog_category_id?: string;

    @IsString()
    @IsOptional()
    user_id?: string;

    @IsString()
    @IsOptional()
    service_id?: string;

    @IsBoolean()
    @IsOptional()
    @Type(() => Boolean)
    is_published?: boolean;
} 


================================================
FILE: src/modules/blog/log/index.ts
================================================
import LogSchema from './log.model';
import { ILog } from './log.interface';
import LogService from './log.service';
import LogRepository from './log.repository';
import LogController from './log.controller';
import LogRoute from './log.route';


export {
    LogSchema,
    ILog,
    LogService,
    LogRepository,
    LogController,
    LogRoute
};



================================================
FILE: src/modules/blog/log/log.controller.ts
================================================
import { NextFunction, Request, Response, Router } from 'express';
import { HttpStatus } from '../../../core/enums';
import { SearchPaginationResponseModel } from '../../../core/models';
import { ILog } from './log.interface';
import LogService from './log.service';
import { LogSearchDto } from './dtos/log.dto';
import { plainToInstance } from 'class-transformer';
import { validateOrReject } from 'class-validator';
import { formatResponse } from '../../../core/utils';

class LogController {
    private logService = new LogService();

    public getLogById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const logId = req.params.id;
            const log: ILog = await this.logService.getLogById(logId);
            res.status(HttpStatus.Success).json(formatResponse<ILog>(log));
        } catch (error) {
            next(error);
        }
    };

    public getLogsByBlogId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.blogId;
            const logs: ILog[] = await this.logService.getLogsByBlogId(blogId);
            res.status(HttpStatus.Success).json(formatResponse<ILog[]>(logs));
        } catch (error) {
            next(error);
        }
    };

    public searchLogs = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const searchData = plainToInstance(LogSearchDto, req.body.searchCondition || {});
            await validateOrReject(searchData);

            const pageInfo = req.body.pageInfo || { pageNum: 1, pageSize: 10 };
            const { pageNum, pageSize } = pageInfo;

            const searchResult = await this.logService.searchLogs(searchData, pageNum, pageSize);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ILog>>(searchResult));
        } catch (error) {
            next(error);
        }
    };
}

export default LogController;



================================================
FILE: src/modules/blog/log/log.interface.ts
================================================
import { Document, Schema } from "mongoose";
import { IBlogImage } from "../blog.interface";

export interface ILog extends Document {
    _id: string;
    blog_id: string;
    author_id: string;
    old_title: string;
    new_title: string;
    old_content: string;
    new_content: string;
    old_slug: string;
    new_slug: string;
    old_blog_category_id: string;
    new_blog_category_id: string;
    old_service_id: string;
    new_service_id: string;
    old_user_id: string;
    new_user_id: string;
    old_is_published: boolean;
    new_is_published: boolean;
    old_published_at: Date;
    new_published_at: Date;
    old_images: IBlogImage[];
    new_images: IBlogImage[];
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
}



================================================
FILE: src/modules/blog/log/log.model.ts
================================================
import mongoose, { Schema } from "mongoose";
import { ILog } from "./log.interface";
import { COLLECTION_NAME } from "../../../core/constants";

const BlogImageSchema = new Schema({
    name: { type: String },
    image_url: { type: String },
    created_at: { type: Date, default: Date.now }
});

const LogSchemaEntity = new Schema({
    blog_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG },
    author_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    old_title: { type: String },
    new_title: { type: String },
    old_content: { type: String },
    new_content: { type: String },
    old_slug: { type: String },
    new_slug: { type: String },
    old_blog_category_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG_CATEGORY },
    new_blog_category_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG_CATEGORY },
    old_service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE },
    new_service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE },
    old_user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    new_user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    old_is_published: { type: Boolean },
    new_is_published: { type: Boolean },
    old_published_at: { type: Date },
    new_published_at: { type: Date },
    old_images: [BlogImageSchema],
    new_images: [BlogImageSchema],
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false }
});

const LogSchema = mongoose.model<ILog & mongoose.Document>(
    COLLECTION_NAME.BLOG_LOG,
    LogSchemaEntity
);

export default LogSchema;



================================================
FILE: src/modules/blog/log/log.repository.ts
================================================
import { ILog } from "./log.interface";
import LogSchema from "./log.model";

export default class LogRepository {
    public async createLog(model: ILog): Promise<ILog> {
        return LogSchema.create(model);
    }

    public async getLogById(id: string): Promise<ILog | null> {
        return LogSchema.findById(id);
    }

    public async getLogsByBlogId(blogId: string): Promise<ILog[]> {
        return LogSchema.find({ blog_id: blogId }).sort({ created_at: -1 });
    }

    public async countLogs(query: any): Promise<number> {
        return LogSchema.countDocuments(query);
    }

    public async getLogsWithPagination(query: any, skip: number, limit: number): Promise<ILog[]> {
        return LogSchema.find(query)
            .skip(skip)
            .limit(limit)
            .sort({ created_at: -1 });
    }
}



================================================
FILE: src/modules/blog/log/log.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../../core/constants';
import { IRoute } from '../../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../../core/middleware';
import { UserRoleEnum } from '../../user/user.enum';
import LogController from './log.controller';

export default class LogRoute implements IRoute {
    public path = API_PATH.BLOG_LOGS;
    public router = Router();
    public logController = new LogController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/blog-logs/:id -> Get log by id
        this.router.get(
            `${this.path}/:id`,
            this.logController.getLogById
        );

        // GET: domain:/api/blog-logs/blog/:blogId -> Get logs by blog id
        this.router.get(
            `${this.path}/blog/:blogId`,
            this.logController.getLogsByBlogId
        );

        // POST: domain:/api/blog-logs/search -> Search logs
        this.router.post(
            `${this.path}/search`,
            this.logController.searchLogs
        );
    }
}



================================================
FILE: src/modules/blog/log/log.service.ts
================================================
import { HttpStatus } from "../../../core/enums";
import { HttpException } from "../../../core/exceptions";
import { SearchPaginationResponseModel } from "../../../core/models";
import { ILog } from "./log.interface";
import LogRepository from "./log.repository";
import { CreateLogDto, LogSearchDto } from "./dtos/log.dto";

export default class LogService {
    private logRepository = new LogRepository();

    public async createLog(createLogDto: CreateLogDto): Promise<ILog> {
        try {
            const log = await this.logRepository.createLog(createLogDto as unknown as ILog);
            return log;
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating blog log');
        }
    }

    public async getLogsByBlogId(blogId: string): Promise<ILog[]> {
        try {
            return await this.logRepository.getLogsByBlogId(blogId);
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog logs');
        }
    }

    public async getLogById(id: string): Promise<ILog> {
        try {
            const log = await this.logRepository.getLogById(id);
            if (!log) {
                throw new HttpException(HttpStatus.NotFound, 'Blog log not found');
            }
            return log;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog log');
        }
    }

    public async searchLogs(searchParams: LogSearchDto, pageNum: number, pageSize: number): Promise<SearchPaginationResponseModel<ILog>> {
        try {
            const query: any = {};

            if (searchParams.blog_id) {
                query.blog_id = searchParams.blog_id;
            }

            if (searchParams.author_id) {
                query.author_id = searchParams.author_id;
            }

            if (searchParams.created_at_from || searchParams.created_at_to) {
                query.created_at = {};

                if (searchParams.created_at_from) {
                    query.created_at.$gte = searchParams.created_at_from;
                }

                if (searchParams.created_at_to) {
                    query.created_at.$lte = searchParams.created_at_to;
                }
            }

            const totalItems = await this.logRepository.countLogs(query);
            const totalPages = Math.ceil(totalItems / pageSize);
            const skip = (pageNum - 1) * pageSize;

            const logs = await this.logRepository.getLogsWithPagination(query, skip, pageSize);

            return new SearchPaginationResponseModel<ILog>(
                logs,
                {
                    pageNum,
                    pageSize,
                    totalItems,
                    totalPages
                }
            );
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching blog logs');
        }
    }
}



================================================
FILE: src/modules/blog/log/dtos/log.dto.ts
================================================
import { IsArray, IsBoolean, IsDate, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { BlogImageDto } from '../../dtos/blog.dto';

export class CreateLogDto {
    @IsMongoId()
    @IsNotEmpty()
    blog_id!: string;

    @IsMongoId()
    @IsNotEmpty()
    author_id!: string;

    @IsString()
    @IsOptional()
    old_title?: string;

    @IsString()
    @IsOptional()
    new_title?: string;

    @IsString()
    @IsOptional()
    old_content?: string;

    @IsString()
    @IsOptional()
    new_content?: string;

    @IsString()
    @IsOptional()
    old_slug?: string;

    @IsString()
    @IsOptional()
    new_slug?: string;

    @IsMongoId()
    @IsOptional()
    old_blog_category_id?: string;

    @IsMongoId()
    @IsOptional()
    new_blog_category_id?: string;

    @IsMongoId()
    @IsOptional()
    old_service_id?: string;

    @IsMongoId()
    @IsOptional()
    new_service_id?: string;

    @IsMongoId()
    @IsOptional()
    old_user_id?: string;

    @IsMongoId()
    @IsOptional()
    new_user_id?: string;

    @IsBoolean()
    @IsOptional()
    old_is_published?: boolean;

    @IsBoolean()
    @IsOptional()
    new_is_published?: boolean;

    @IsDate()
    @IsOptional()
    old_published_at?: Date;

    @IsDate()
    @IsOptional()
    new_published_at?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    old_images?: BlogImageDto[];

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    new_images?: BlogImageDto[];
}

export class LogResponseDto {
    id!: string;
    blog_id!: string;
    author_id!: string;
    old_title?: string;
    new_title?: string;
    old_content?: string;
    new_content?: string;
    old_slug?: string;
    new_slug?: string;
    old_blog_category_id?: string;
    new_blog_category_id?: string;
    old_service_id?: string;
    new_service_id?: string;
    old_user_id?: string;
    new_user_id?: string;
    old_is_published?: boolean;
    new_is_published?: boolean;
    old_published_at?: Date;
    new_published_at?: Date;
    old_images?: BlogImageDto[];
    new_images?: BlogImageDto[];
    created_at!: Date;
    updated_at!: Date;
}

export class LogSearchDto {
    @IsMongoId()
    @IsOptional()
    blog_id?: string;

    @IsMongoId()
    @IsOptional()
    author_id?: string;

    @IsDate()
    @IsOptional()
    created_at_from?: Date;

    @IsDate()
    @IsOptional()
    created_at_to?: Date;
} 


================================================
FILE: src/modules/blog/log/swagger/log.swagger.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     LogResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the log
 *         blog_id:
 *           type: string
 *           description: ID of the blog
 *         author_id:
 *           type: string
 *           description: ID of the author who made the changes
 *         old_title:
 *           type: string
 *           description: Previous title of the blog
 *         new_title:
 *           type: string
 *           description: New title of the blog
 *         old_content:
 *           type: string
 *           description: Previous content of the blog
 *         new_content:
 *           type: string
 *           description: New content of the blog
 *         old_blog_category_id:
 *           type: string
 *           description: Previous blog category ID
 *         new_blog_category_id:
 *           type: string
 *           description: New blog category ID
 *         old_service_id:
 *           type: string
 *           description: Previous service ID
 *         new_service_id:
 *           type: string
 *           description: New service ID
 *         old_user_id:
 *           type: string
 *           description: Previous user ID
 *         new_user_id:
 *           type: string
 *           description: New user ID
 *         old_is_published:
 *           type: boolean
 *           description: Previous published status
 *         new_is_published:
 *           type: boolean
 *           description: New published status
 *         old_published_at:
 *           type: string
 *           format: date-time
 *           description: Previous published date
 *         new_published_at:
 *           type: string
 *           format: date-time
 *           description: New published date
 *         old_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Previous images
 *         new_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: New images
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was last updated
 *
 *     LogSearch:
 *       type: object
 *       properties:
 *         blog_id:
 *           type: string
 *           description: ID of the blog to filter by
 *         author_id:
 *           type: string
 *           description: ID of the author to filter by
 *         created_at_from:
 *           type: string
 *           format: date-time
 *           description: Filter logs created after this date
 *         created_at_to:
 *           type: string
 *           format: date-time
 *           description: Filter logs created before this date
 */

/**
 * @swagger
 * tags:
 *   name: BlogLogs
 *   description: Blog log management API
 */

/**
 * @swagger
 * /api/blog-logs/{id}:
 *   get:
 *     summary: Get a blog log by ID
 *     tags: [BlogLogs]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the log
 *     responses:
 *       200:
 *         description: Blog log details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/LogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog log fetched successfully
 *       404:
 *         description: Blog log not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-logs/blog/{blogId}:
 *   get:
 *     summary: Get logs for a specific blog
 *     tags: [BlogLogs]
 *     parameters:
 *       - in: path
 *         name: blogId
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: List of blog logs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/LogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog logs fetched successfully
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-logs/search:
 *   post:
 *     summary: Search blog logs with pagination
 *     tags: [BlogLogs]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               searchCondition:
 *                 $ref: '#/components/schemas/LogSearch'
 *               pageInfo:
 *                 type: object
 *                 properties:
 *                   pageNum:
 *                     type: number
 *                     example: 1
 *                   pageSize:
 *                     type: number
 *                     example: 10
 *     responses:
 *       200:
 *         description: Search results
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/LogResponse'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         pageNum:
 *                           type: number
 *                           example: 1
 *                         pageSize:
 *                           type: number
 *                           example: 10
 *                         totalItems:
 *                           type: number
 *                           example: 50
 *                         totalPages:
 *                           type: number
 *                           example: 5
 *                 message:
 *                   type: string
 *                   example: Blog logs searched successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */ 


================================================
FILE: src/modules/blog/swagger/blog.swagger.js
================================================
/**
 * @swagger
 * components:
 *   securitySchemes:
 *     Bearer:
 *       type: http
 *       scheme: bearer
 *       bearerFormat: JWT
 *   schemas:
 *     BlogImage:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the image (automatically generated from the uploaded file name)
 *         image_url:
 *           type: string
 *           description: URL of the image (automatically generated from AWS S3 upload)
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the image was created (automatically generated)
 *       required:
 *         - name
 *         - image_url
 *
 *     CreateBlog:
 *       type: object
 *       properties:
 *         title:
 *           type: string
 *           description: Title of the blog
 *         content:
 *           type: string
 *           description: Content of the blog
 *         slug:
 *           type: string
 *           description: URL slug for the blog (optional, will be generated from title if not provided)
 *         user_id:
 *           type: string
 *           description: ID of the user who created the blog (automatically extracted from JWT token)
 *         service_id:
 *           type: string
 *           description: ID of the service associated with the blog
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category
 *         is_published:
 *           type: boolean
 *           description: Whether the blog is published (optional, defaults to true)
 *         published_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was published (optional, defaults to current date)
 *         images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Images associated with the blog
 *       required:
 *         - title
 *         - content
 *         - service_id
 *         - blog_category_id
 *
 *     UpdateBlog:
 *       type: object
 *       properties:
 *         title:
 *           type: string
 *           description: Title of the blog
 *         content:
 *           type: string
 *           description: Content of the blog
 *         slug:
 *           type: string
 *           description: URL slug for the blog
 *         user_id:
 *           type: string
 *           description: ID of the user who created the blog (automatically extracted from JWT token)
 *         service_id:
 *           type: string
 *           description: ID of the service associated with the blog
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category
 *         is_published:
 *           type: boolean
 *           description: Whether the blog is published (optional)
 *         published_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was published (optional)
 *         images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Images associated with the blog
 *     BlogResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the blog
 *         title:
 *           type: string
 *           description: Title of the blog
 *         content:
 *           type: string
 *           description: Content of the blog
 *         slug:
 *           type: string
 *           description: URL slug for the blog
 *         user_id:
 *           type: string
 *           description: ID of the user who created the blog
 *         service_id:
 *           type: string
 *           description: ID of the service associated with the blog
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category
 *         is_published:
 *           type: boolean
 *           description: Whether the blog is published
 *         published_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was published
 *         images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Images associated with the blog
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was last updated
 *
 *     BlogSearch:
 *       type: object
 *       properties:
 *         title:
 *           type: string
 *           description: Title to search for (partial match)
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category to filter by
 *         user_id:
 *           type: string
 *           description: ID of the user to filter by
 *         service_id:
 *           type: string
 *           description: ID of the service to filter by
 *         is_published:
 *           type: boolean
 *           description: Filter by published status
 *
 *     DeleteImageRequest:
 *       type: object
 *       properties:
 *         image_url:
 *           type: string
 *           description: URL of the image to delete
 *       required:
 *         - image_url
 *
 *     LogResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the log entry
 *         blog_id:
 *           type: string
 *           description: ID of the blog this log belongs to
 *         author_id:
 *           type: string
 *           description: ID of the user who made the changes
 *         old_title:
 *           type: string
 *           description: Previous title of the blog
 *         new_title:
 *           type: string
 *           description: New title of the blog
 *         old_content:
 *           type: string
 *           description: Previous content of the blog
 *         new_content:
 *           type: string
 *           description: New content of the blog
 *         old_slug:
 *           type: string
 *           description: Previous slug of the blog
 *         new_slug:
 *           type: string
 *           description: New slug of the blog
 *         old_blog_category_id:
 *           type: string
 *           description: Previous blog category ID
 *         new_blog_category_id:
 *           type: string
 *           description: New blog category ID
 *         old_service_id:
 *           type: string
 *           description: Previous service ID
 *         new_service_id:
 *           type: string
 *           description: New service ID
 *         old_user_id:
 *           type: string
 *           description: Previous user ID
 *         new_user_id:
 *           type: string
 *           description: New user ID
 *         old_is_published:
 *           type: boolean
 *           description: Previous published status
 *         new_is_published:
 *           type: boolean
 *           description: New published status
 *         old_published_at:
 *           type: string
 *           format: date-time
 *           description: Previous published date
 *         new_published_at:
 *           type: string
 *           format: date-time
 *           description: New published date
 *         old_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Previous images of the blog
 *         new_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: New images of the blog
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was last updated
 *
 *     LogSearch:
 *       type: object
 *       properties:
 *         blog_id:
 *           type: string
 *           description: ID of the blog to filter logs by
 *         author_id:
 *           type: string
 *           description: ID of the author to filter logs by
 *         created_at_from:
 *           type: string
 *           format: date-time
 *           description: Start date for filtering logs
 *         created_at_to:
 *           type: string
 *           format: date-time
 *           description: End date for filtering logs
 */

/**
 * @swagger
 * tags:
 *   name: Blogs
 *   description: Blog management API
 */

/**
 * @swagger
 * /api/blog:
 *   get:
 *     summary: Get all blogs
 *     tags: [Blogs]
 *     responses:
 *       200:
 *         description: List of blogs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blogs fetched successfully
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/create:
 *   post:
 *     summary: Create a new blog with optional image uploads
 *     description: Creates a new blog with the provided data. Images are uploaded to AWS S3, and their metadata (name, URL, creation date) are automatically generated and stored in the database. The original file name is used for the image name, the S3 URL is stored as image_url, and the current date is used for created_at. The user_id is automatically extracted from the JWT token.
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 description: Title of the blog
 *               content:
 *                 type: string
 *                 description: Content of the blog
 *               slug:
 *                 type: string
 *                 description: URL slug for the blog (optional)
 *               service_id:
 *                 type: string
 *                 description: ID of the service associated with the blog
 *               blog_category_id:
 *                 type: string
 *                 description: ID of the blog category
 *               is_published:
 *                 type: boolean
 *                 description: Whether the blog is published (optional, defaults to true)
 *               published_at:
 *                 type: string
 *                 format: date-time
 *                 description: Date when the blog was published (optional, defaults to current date)
 *               images:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *                 description: Images to upload (up to 10). These will be automatically uploaded to AWS S3.
 *             required:
 *               - title
 *               - content
 *               - service_id
 *               - blog_category_id
 *     responses:
 *       201:
 *         description: Blog created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 201
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog created successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/slug/{slug}:
 *   get:
 *     summary: Get a blog by slug
 *     tags: [Blogs]
 *     parameters:
 *       - in: path
 *         name: slug
 *         schema:
 *           type: string
 *         required: true
 *         description: Slug of the blog
 *     responses:
 *       200:
 *         description: Blog details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog fetched successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/{id}:
 *   get:
 *     summary: Get a blog by ID
 *     tags: [Blogs]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: Blog details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog fetched successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 *
 *   put:
 *     summary: Update a blog with optional image uploads
 *     description: Updates a blog with the provided data. If images are uploaded, they are stored in AWS S3, and their metadata (name, URL, creation date) are automatically generated and stored in the database. The original file name is used for the image name, the S3 URL is stored as image_url, and the current date is used for created_at. Any uploaded images will REPLACE the blog's existing images, not add to them. The user_id for tracking changes is automatically extracted from the JWT token.
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 description: Title of the blog
 *               content:
 *                 type: string
 *                 description: Content of the blog
 *               slug:
 *                 type: string
 *                 description: URL slug for the blog
 *               service_id:
 *                 type: string
 *                 description: ID of the service associated with the blog
 *               blog_category_id:
 *                 type: string
 *                 description: ID of the blog category
 *               is_published:
 *                 type: boolean
 *                 description: Whether the blog is published (optional)
 *               published_at:
 *                 type: string
 *                 format: date-time
 *                 description: Date when the blog was published (optional)
 *               images:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *                 description: New images to upload (up to 10). These will be automatically uploaded to AWS S3 and will REPLACE any existing images.
 *     responses:
 *       200:
 *         description: Blog updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog updated successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 *
 *   delete:
 *     summary: Delete a blog
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: Blog deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog deleted successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/{id}/image:
 *   delete:
 *     summary: Delete an image from a blog
 *     description: Deletes an image from a blog by its URL. Note that this only removes the image reference from the database, not from AWS S3.
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/DeleteImageRequest'
 *     responses:
 *       200:
 *         description: Image deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog image deleted successfully
 *       400:
 *         description: Image URL is required
 *       404:
 *         description: Blog not found or image not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/search:
 *   post:
 *     summary: Search blogs with pagination
 *     tags: [Blogs]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               searchCondition:
 *                 $ref: '#/components/schemas/BlogSearch'
 *               pageInfo:
 *                 type: object
 *                 properties:
 *                   pageNum:
 *                     type: number
 *                     example: 1
 *                   pageSize:
 *                     type: number
 *                     example: 10
 *     responses:
 *       200:
 *         description: Search results
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/BlogResponse'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         pageNum:
 *                           type: number
 *                           example: 1
 *                         pageSize:
 *                           type: number
 *                           example: 10
 *                         totalItems:
 *                           type: number
 *                           example: 50
 *                         totalPages:
 *                           type: number
 *                           example: 5
 *                 message:
 *                   type: string
 *                   example: Blogs searched successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/{id}/logs:
 *   get:
 *     summary: Get logs for a blog
 *     tags: [Blogs]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: Blog logs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/LogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog logs fetched successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 */ 


================================================
FILE: src/modules/blog_category/blog_category.controller.ts
================================================
import { NextFunction, Request, Response, Router } from 'express';
import { HttpStatus } from '../../core/enums';
import { IBlogCategory } from './blog_category.interface';
import BlogCategoryService from './blog_category.service';
import { BlogCategoryResponseDto, BlogCategorySearchDto, CreateBlogCategoryDto, UpdateBlogCategoryDto } from './dtos/blog_category.dto';
import { plainToInstance } from 'class-transformer';
import { validateOrReject } from 'class-validator';
import { formatResponse } from '../../core/utils';
import { SearchPaginationResponseModel } from '../../core/models';

class BlogCategoryController {
    private blogCategoryService = new BlogCategoryService();

    public createBlogCategory = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryData = plainToInstance(CreateBlogCategoryDto, req.body);
            await validateOrReject(categoryData);

            const blogCategory: IBlogCategory = await this.blogCategoryService.createBlogCategory(categoryData);
            res.status(HttpStatus.Created).json(formatResponse<IBlogCategory>(blogCategory));
        } catch (error) {
            next(error);
        }
    };

    public updateBlogCategory = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryId = req.params.id;
            const categoryData = plainToInstance(UpdateBlogCategoryDto, req.body);
            await validateOrReject(categoryData);

            const blogCategory: IBlogCategory = await this.blogCategoryService.updateBlogCategory(categoryId, categoryData);
            res.status(HttpStatus.Success).json(formatResponse<IBlogCategory>(blogCategory));
        } catch (error) {
            next(error);
        }
    };

    public deleteBlogCategory = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryId = req.params.id;
            const blogCategory: IBlogCategory = await this.blogCategoryService.deleteBlogCategory(categoryId);
            res.status(HttpStatus.Success).json(formatResponse<string>('Blog category deleted successfully'));
        } catch (error) {
            next(error);
        }
    };

    public getBlogCategoryById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryId = req.params.id;
            const blogCategory: IBlogCategory = await this.blogCategoryService.getBlogCategoryById(categoryId);
            res.status(HttpStatus.Success).json(formatResponse<IBlogCategory>(blogCategory));
        } catch (error) {
            next(error);
        }
    };

    public getBlogCategories = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogCategories: IBlogCategory[] = await this.blogCategoryService.getBlogCategories();
            res.status(HttpStatus.Success).json(formatResponse<IBlogCategory[]>(blogCategories));
        } catch (error) {
            next(error);
        }
    };

    public searchBlogCategories = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const searchData = plainToInstance(BlogCategorySearchDto, req.body.searchCondition || {});
            await validateOrReject(searchData);

            const pageInfo = req.body.pageInfo || { pageNum: 1, pageSize: 10 };
            const { pageNum, pageSize } = pageInfo;

            const searchResult = await this.blogCategoryService.searchBlogCategories(searchData, pageNum, pageSize);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IBlogCategory>>(searchResult));
        } catch (error) {
            next(error);
        }
    };

    public mapBlogCategoryToResponseDto(blogCategory: IBlogCategory): BlogCategoryResponseDto {
        return {
            id: blogCategory._id,
            name: blogCategory.name,
            created_at: blogCategory.created_at,
            updated_at: blogCategory.updated_at
        };
    }
}

export default BlogCategoryController;



================================================
FILE: src/modules/blog_category/blog_category.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IBlogCategory extends Document {
    _id: string;
    name: string;
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
}


================================================
FILE: src/modules/blog_category/blog_category.model.ts
================================================
import mongoose, { Schema } from "mongoose";
import { IBlogCategory } from "./blog_category.interface";
import { COLLECTION_NAME } from "../../core/constants/collection.constant";

const BlogCategorySchema: Schema<IBlogCategory> = new Schema({
    name: {
        type: String,
        required: true,
        unique: true,
    },
    created_at: {
        type: Date,
        default: Date.now,
    },
    updated_at: {
        type: Date,
        default: Date.now,
    },
    is_deleted: {
        type: Boolean,
        default: false,
    },
})

export const BlogCategoryModel = mongoose.model<IBlogCategory>(
    COLLECTION_NAME.BLOG_CATEGORY,
    BlogCategorySchema
);



================================================
FILE: src/modules/blog_category/blog_category.repository.ts
================================================
import { IBlogCategory } from "./blog_category.interface";
import { BlogCategoryModel } from "./blog_category.model";

export default class BlogCategoryRepository {
    public async createBlogCategory(model: IBlogCategory): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.create(model);
        if (!blogCategory) {
            throw new Error('Blog category not created');
        }
        return blogCategory;
    }

    public async updateBlogCategory(id: string, model: IBlogCategory): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.findByIdAndUpdate(id, model, { new: true });
        if (!blogCategory) {
            throw new Error('Blog category not found');
        }
        return blogCategory;
    }

    public async deleteBlogCategory(id: string): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.findByIdAndUpdate(
            id,
            { is_deleted: true },
            { new: true }
        );
        if (!blogCategory) {
            throw new Error('Blog category not found');
        }
        return blogCategory;
    }

    public async getBlogCategoryById(id: string): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.findById(id);
        if (!blogCategory) {
            throw new Error('Blog category not found');
        }
        return blogCategory;
    }

    public async getBlogCategories(): Promise<IBlogCategory[]> {
        return BlogCategoryModel.find();
    }

    public async getBlogCategoriesWithPagination(query: any): Promise<IBlogCategory[]> {
        return BlogCategoryModel.find(query);
    }
}


================================================
FILE: src/modules/blog_category/blog_category.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import BlogCategoryController from './blog_category.controller';
import { CreateBlogCategoryDto, UpdateBlogCategoryDto } from './dtos/blog_category.dto';

export default class BlogCategoryRoute implements IRoute {
    public path = API_PATH.BLOG_CATEGORY;
    public router = Router();
    public blogCategoryController = new BlogCategoryController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        this.router.post(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(CreateBlogCategoryDto),
            this.blogCategoryController.createBlogCategory
        );

        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(UpdateBlogCategoryDto),
            this.blogCategoryController.updateBlogCategory
        );

        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.blogCategoryController.deleteBlogCategory
        );

        this.router.get(
            `${this.path}/:id`,
            this.blogCategoryController.getBlogCategoryById
        );

        this.router.get(
            `${this.path}`,
            this.blogCategoryController.getBlogCategories
        );

        this.router.post(
            `${this.path}/search`,
            this.blogCategoryController.searchBlogCategories
        );
    }
}



================================================
FILE: src/modules/blog_category/blog_category.service.ts
================================================
import mongoose, { Schema } from "mongoose";
import { IBlogCategory } from "./blog_category.interface";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { isEmptyObject } from "../../core/utils";
import { UserRoleEnum, UserSchema } from "../user";
import BlogCategoryRepository from "./blog_category.repository";
import { BlogCategorySearchDto, CreateBlogCategoryDto, UpdateBlogCategoryDto } from "./dtos/blog_category.dto";

export default class BlogCategoryService {
    private blogCategoryRepository = new BlogCategoryRepository();

    public async createBlogCategory(createBlogCategoryDto: CreateBlogCategoryDto): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.createBlogCategory(createBlogCategoryDto as unknown as IBlogCategory);
            return blogCategory;
        } catch (error: any) {
            if (error.code === 11000) { // Duplicate key error
                throw new HttpException(HttpStatus.Conflict, 'Blog category with this name already exists');
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating blog category');
        }
    }

    public async updateBlogCategory(id: string, updateBlogCategoryDto: UpdateBlogCategoryDto): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.updateBlogCategory(id, updateBlogCategoryDto as unknown as IBlogCategory);
            if (!blogCategory) {
                throw new HttpException(HttpStatus.NotFound, 'Blog category not found');
            }
            return blogCategory;
        } catch (error: any) {
            if (error instanceof HttpException) {
                throw error;
            }
            if (error.code === 11000) { // Duplicate key error
                throw new HttpException(HttpStatus.Conflict, 'Blog category with this name already exists');
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating blog category');
        }
    }

    public async deleteBlogCategory(id: string): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.deleteBlogCategory(id);
            if (!blogCategory) {
                throw new HttpException(HttpStatus.NotFound, 'Blog category not found');
            }
            return blogCategory;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting blog category');
        }
    }

    public async getBlogCategoryById(id: string): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.getBlogCategoryById(id);
            if (!blogCategory) {
                throw new HttpException(HttpStatus.NotFound, 'Blog category not found');
            }
            return blogCategory;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog category');
        }
    }

    public async getBlogCategories(): Promise<IBlogCategory[]> {
        try {
            return await this.blogCategoryRepository.getBlogCategories();
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog categories');
        }
    }

    public async searchBlogCategories(searchParams: BlogCategorySearchDto, pageNum: number, pageSize: number): Promise<SearchPaginationResponseModel<IBlogCategory>> {
        try {
            const query: any = {};

            if (searchParams.name) {
                query.name = { $regex: searchParams.name, $options: 'i' };
            }

            const totalItems = await this.blogCategoryRepository.getBlogCategoriesWithPagination(query).then(categories => categories.length);
            const totalPages = Math.ceil(totalItems / pageSize);
            const skip = (pageNum - 1) * pageSize;

            const blogCategories = await this.blogCategoryRepository.getBlogCategoriesWithPagination(query)
                .then(categories => categories.slice(skip, skip + pageSize));

            return new SearchPaginationResponseModel<IBlogCategory>(
                blogCategories,
                {
                    pageNum,
                    pageSize,
                    totalItems,
                    totalPages
                }
            );
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching blog categories');
        }
    }
}




================================================
FILE: src/modules/blog_category/index.ts
================================================
import { BlogCategoryModel } from './blog_category.model';
import { IBlogCategory } from './blog_category.interface';
import BlogCategoryController from './blog_category.controller';
import BlogCategoryService from './blog_category.service';
import BlogCategoryRepository from './blog_category.repository';
import { BlogCategoryResponseDto, BlogCategorySearchDto, CreateBlogCategoryDto, UpdateBlogCategoryDto } from './dtos/blog_category.dto';
import BlogCategoryRoute from './blog_category.route';

export {
    BlogCategoryModel,
    IBlogCategory,
    BlogCategoryController,
    BlogCategoryService,
    BlogCategoryRepository,
    BlogCategoryResponseDto,
    BlogCategorySearchDto,
    CreateBlogCategoryDto,
    UpdateBlogCategoryDto,
    BlogCategoryRoute
};



================================================
FILE: src/modules/blog_category/dtos/blog_category.dto.ts
================================================
import { IsBoolean, IsDate, IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateBlogCategoryDto {
    @IsString()
    @IsNotEmpty()
    name!: string;
}

export class UpdateBlogCategoryDto {
    @IsString()
    @IsOptional()
    name?: string;
}

export class BlogCategoryResponseDto {
    id!: string;
    name!: string;
    created_at!: Date;
    updated_at!: Date;
}

export class BlogCategorySearchDto {
    @IsString()
    @IsOptional()
    name?: string;
} 


================================================
FILE: src/modules/blog_category/swagger/blog_category.swagger.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateBlogCategory:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the blog category
 *       required:
 *         - name
 *
 *     UpdateBlogCategory:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the blog category
 *
 *     BlogCategoryResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the blog category
 *         name:
 *           type: string
 *           description: Name of the blog category
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog category was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog category was last updated
 *
 *     BlogCategorySearch:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name to search for (partial match)
 */

/**
 * @swagger
 * tags:
 *   name: blog_categories
 *   description: Blog category management API
 */

/**
 * @swagger
 * /api/blog-category:
 *   post:
 *     summary: Create a new blog category
 *     tags: [blog_categories]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateBlogCategory'
 *     responses:
 *       201:
 *         description: Blog category created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 201
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category created successfully
 *       400:
 *         description: Invalid input
 *       409:
 *         description: Blog category with this name already exists
 *       500:
 *         description: Server error
 *
 *   get:
 *     summary: Get all blog categories
 *     tags: [blog_categories]
 *     responses:
 *       200:
 *         description: List of blog categories
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog categories fetched successfully
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-category/{id}:
 *   get:
 *     summary: Get a blog category by ID
 *     tags: [blog_categories]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog category
 *     responses:
 *       200:
 *         description: Blog category details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category fetched successfully
 *       404:
 *         description: Blog category not found
 *       500:
 *         description: Server error
 *
 *   put:
 *     summary: Update a blog category
 *     tags: [blog_categories]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog category
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateBlogCategory'
 *     responses:
 *       200:
 *         description: Blog category updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category updated successfully
 *       404:
 *         description: Blog category not found
 *       409:
 *         description: Blog category with this name already exists
 *       500:
 *         description: Server error
 *
 *   delete:
 *     summary: Delete a blog category
 *     tags: [blog_categories]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog category
 *     responses:
 *       200:
 *         description: Blog category deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category deleted successfully
 *       404:
 *         description: Blog category not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-category/search:
 *   post:
 *     summary: Search blog categories with pagination
 *     tags: [blog_categories]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               searchCondition:
 *                 $ref: '#/components/schemas/BlogCategorySearch'
 *               pageInfo:
 *                 type: object
 *                 properties:
 *                   pageNum:
 *                     type: number
 *                     example: 1
 *                   pageSize:
 *                     type: number
 *                     example: 10
 *     responses:
 *       200:
 *         description: Search results
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/BlogCategoryResponse'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         pageNum:
 *                           type: number
 *                           example: 1
 *                         pageSize:
 *                           type: number
 *                           example: 10
 *                         totalItems:
 *                           type: number
 *                           example: 50
 *                         totalPages:
 *                           type: number
 *                           example: 5
 *                 message:
 *                   type: string
 *                   example: Blog categories searched successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */ 


================================================
FILE: src/modules/department/department.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import DepartmentService from './department.service';
import CreateDepartmentDto from './dtos/createDepartment.dto';
import UpdateDepartmentDto from './dtos/updateDepartment.dto';
import { IDepartment } from './department.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class DepartmentController {
    private departmentService = new DepartmentService();

    /**
     * Tạo phòng ban mới
     */
    public createDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: CreateDepartmentDto = req.body;
            const department = await this.departmentService.createDepartment(model);
            res.status(HttpStatus.Created).json(formatResponse<IDepartment>(department));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Lấy danh sách phòng ban
     */
    public getDepartments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const departments = await this.departmentService.getDepartments(req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IDepartment>>(departments));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Lấy thông tin phòng ban theo ID
     */
    public getDepartmentById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const department = await this.departmentService.getDepartmentById(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<IDepartment>(department));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Cập nhật thông tin phòng ban
     */
    public updateDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: UpdateDepartmentDto = req.body;
            const department = await this.departmentService.updateDepartment(req.params.id, model);
            res.status(HttpStatus.Success).json(formatResponse<IDepartment>(department));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Xóa phòng ban
     */
    public deleteDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.departmentService.deleteDepartment(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<string>('Delete department successfully'));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Lấy danh sách phòng ban của một manager
     */
    public getManagerDepartments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const managerId = req.params.managerId;
            const result = await this.departmentService.getManagerDepartments(managerId, req.query);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Đếm tổng số phòng ban trong hệ thống
     */
    public countDepartments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const count = await this.departmentService.countDepartments(req.query);
            res.status(HttpStatus.Success).json(formatResponse({
                totalDepartments: count
            }));
        } catch (error) {
            next(error);
        }
    }
}


================================================
FILE: src/modules/department/department.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IDepartment extends Document {
    _id: string;
    name: string;
    description: string;
    manager_id: string | undefined;
    is_deleted: boolean;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/department/department.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IDepartment } from './department.interface';

const DepartmentSchemaEntity: Schema<IDepartment> = new Schema({
    name: { type: String, required: true },
    description: { type: String, required: true },
    manager_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    is_deleted: { type: Boolean, default: false },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const DepartmentSchema = mongoose.model<IDepartment & mongoose.Document>(
    COLLECTION_NAME.DEPARTMENT,
    DepartmentSchemaEntity
);

export default DepartmentSchema; 


================================================
FILE: src/modules/department/department.repository.ts
================================================
import DepartmentSchema from './department.model';
import { IDepartment } from './department.interface';
import { Schema } from 'mongoose';

export default class DepartmentRepository {
    public async createDepartment(data: Partial<IDepartment>): Promise<IDepartment> {
        return DepartmentSchema.create(data);
    }

    public async findOne(query: any): Promise<IDepartment | null> {
        return DepartmentSchema.findOne(query);
    }

    public async findById(id: string): Promise<IDepartment | null> {
        return DepartmentSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IDepartment>, options: any = {}): Promise<IDepartment | null> {
        return DepartmentSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return DepartmentSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IDepartment[]> {
        return DepartmentSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IDepartment[]> {
        return DepartmentSchema.find(query);
    }

    public async findByIdWithPopulate(id: string): Promise<IDepartment | null> {
        return DepartmentSchema.findById(id).populate('manager_id', 'first_name last_name email');
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IDepartment[]> {
        return DepartmentSchema.find(query).sort(sort).skip(skip).limit(limit).populate('manager_id', 'first_name last_name email');
    }
}



================================================
FILE: src/modules/department/department.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import DepartmentController from './department.controller';
import CreateDepartmentDto from './dtos/createDepartment.dto';
import UpdateDepartmentDto from './dtos/updateDepartment.dto';
import { UserRoleEnum } from '../user/user.enum';

export default class DepartmentRoute implements IRoute {
    public path = API_PATH.DEPARTMENT;
    public router = Router();
    private departmentController = new DepartmentController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/department/create -> Create department
        this.router.post(
            `${this.path}/create`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(CreateDepartmentDto),
            this.departmentController.createDepartment
        );

        // GET: domain:/api/department/search -> Get all departments with pagination
        this.router.get(
            API_PATH.SEARCH_DEPARTMENT,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.departmentController.getDepartments
        );

        // GET: domain:/api/department/manager/:managerId -> Get departments by manager ID
        this.router.get(
            `${this.path}/manager/:managerId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.departmentController.getManagerDepartments
        );

        // GET: domain:/api/department/count -> Count all departments
        this.router.get(
            `${this.path}/count`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.departmentController.countDepartments
        );

        // GET: domain:/api/department/:id -> Get department by ID
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.departmentController.getDepartmentById
        );

        // PUT: domain:/api/department/:id -> Update department
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateDepartmentDto),
            this.departmentController.updateDepartment
        );

        // DELETE: domain:/api/department/:id -> Delete department
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.departmentController.deleteDepartment
        );
    }
}


================================================
FILE: src/modules/department/department.service.ts
================================================
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { IDepartment } from "./department.interface";
import CreateDepartmentDto from "./dtos/createDepartment.dto";
import UpdateDepartmentDto from "./dtos/updateDepartment.dto";
import { isEmptyObject } from "../../core/utils";
import { UserRoleEnum, UserSchema } from "../user";
import mongoose, { Schema } from "mongoose";
import DepartmentRepository from './department.repository';

export default class DepartmentService {
    private userSchema = UserSchema;
    private departmentRepository = new DepartmentRepository();

    /**
     * Tạo phòng ban mới
     */
    public async createDepartment(model: CreateDepartmentDto): Promise<IDepartment> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Dữ liệu đầu vào không được trống');
        }

        // Kiểm tra tên phòng ban đã tồn tại chưa
        const existingDepartment = await this.departmentRepository.findOne({ name: model.name });
        if (existingDepartment) {
            throw new HttpException(HttpStatus.Conflict, `The department with name "${model.name}" already exists`);
        }

        // Kiểm tra manager_id có tồn tại và có phải là Manager không
        if (!mongoose.Types.ObjectId.isValid(model.manager_id) || !(await this.userSchema.findById(model.manager_id))) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        const manager = await this.userSchema.findById(model.manager_id);
        if (!manager || manager.role !== UserRoleEnum.MANAGER) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager must have the role of Manager');
        }

        if (!mongoose.Types.ObjectId.isValid(model.manager_id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        // Tạo phòng ban mới
        const department = await this.departmentRepository.createDepartment({
            ...model,
            manager_id: model.manager_id as any,
            created_at: new Date(),
            updated_at: new Date()
        }) as IDepartment;

        return department;
    }

    /**
     * Lấy danh sách phòng ban với bộ lọc và phân trang
     */
    public async getDepartments(queryParams: any = {}): Promise<SearchPaginationResponseModel<IDepartment>> {
        try {
            const {
                pageNum,
                pageSize,
                sort_by,
                sort_order,
                keyword,
                is_deleted
            } = this.processQueryParams(queryParams);

            const skip = (pageNum - 1) * pageSize;

            // Xây dựng truy vấn
            const query: any = {};

            // 1. Xử lý trạng thái is_deleted
            if (is_deleted !== undefined) {
                query.is_deleted = is_deleted;
            } else {
                // Mặc định chỉ hiển thị các phòng ban chưa bị xóa logic
                query.is_deleted = false;
                query.is_active = true;
            }

            // 2. Tìm kiếm theo từ khóa nếu có
            if (keyword) {
                query.$or = [
                    { name: { $regex: keyword, $options: 'i' } },
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            // Đếm tổng số phòng ban
            const totalItems = await this.departmentRepository.countDocuments(query);

            const sortOptions: any = {};
            sortOptions[sort_by] = sort_order === 'asc' ? 1 : -1; // Sắp xếp theo trường và thứ tự

            // Lấy dữ liệu với phân trang và populate
            const departments = await this.departmentRepository.findWithPopulate(query, sortOptions, skip, pageSize);

            // Tính tổng số trang
            const totalPages = Math.ceil(totalItems / pageSize);

            // Kết quả trả về
            return {
                pageData: departments,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: pageNum,
                    pageSize: pageSize
                }
            };
        } catch (error) {
            console.error('Error in getDepartments:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error when getting the list of departments');
        }
    }

    /**
     * Lấy thông tin phòng ban theo ID
     */
    public async getDepartmentById(id: string): Promise<IDepartment> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The department ID is invalid');
        }

        const department = await this.departmentRepository.findByIdWithPopulate(id);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'The department is not found');
        }

        return department;
    }

    /**
     * Cập nhật thông tin phòng ban
     */
    public async updateDepartment(id: string, model: UpdateDepartmentDto): Promise<IDepartment> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Dữ liệu cập nhật không được trống');
        }

        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The department ID is invalid');
        }

        // Kiểm tra phòng ban tồn tại
        const department = await this.departmentRepository.findById(id);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'The department is not found');
        }

        // Kiểm tra tên phòng ban đã tồn tại chưa (nếu tên thay đổi)
        if (model.name !== department.name) {
            const existingDepartment = await this.departmentRepository.findOne({ name: model.name, _id: { $ne: id } });
            if (existingDepartment) {
                throw new HttpException(HttpStatus.Conflict, `The department with name "${model.name}" already exists`);
            }
        }

        // Kiểm tra manager_id có tồn tại
        if (model.manager_id && !mongoose.Types.ObjectId.isValid(model.manager_id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        if (model.manager_id) {
            const manager = await this.userSchema.findById(model.manager_id);
            if (!manager || manager.role !== UserRoleEnum.MANAGER) {
                throw new HttpException(HttpStatus.BadRequest, 'The manager must have the role of Manager');
            }
        }

        // Cập nhật phòng ban
        const updatedDepartment = await this.departmentRepository.findByIdAndUpdate(
            id,
            {
                ...model,
                manager_id: model.manager_id ? (model.manager_id as any) : department.manager_id,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedDepartment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Cannot update the department');
        }

        return updatedDepartment;
    }

    /**
     * Xóa phòng ban bằng cách cập nhật cột is_deleted thành true
     */
    public async deleteDepartment(id: string): Promise<IDepartment> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The department ID is invalid');
        }

        // Kiểm tra phòng ban tồn tại
        const department = await this.departmentRepository.findById(id);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'The department is not found');
        }

        // Cập nhật cột is_deleted thành true
        const deletedDepartment = await this.departmentRepository.findByIdAndUpdate(
            id,
            { is_deleted: true, updated_at: new Date() },
            { new: true }
        );

        if (!deletedDepartment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Cannot delete the department');
        }

        return deletedDepartment;
    }

    /**
     * Xử lý tham số truy vấn
     */
    private processQueryParams(params: any): {
        pageNum: number;
        pageSize: number;
        is_deleted?: boolean;
        sort_by: string;
        sort_order: string;
        keyword?: string;
    } {
        const processedParams: Record<string, any> = {}; // Khởi tạo một đối tượng để lưu trữ các tham số đã xử lý

        // Xử lý tham số
        Object.keys(params).forEach(key => {
            const trimmedKey = key.trim(); // Loại bỏ khoảng trắng ở đầu và cuối
            const normalizedKey = trimmedKey.replace(/-/g, '_'); // Thay thế dấu '-' bằng dấu '_'
            processedParams[normalizedKey] = params[key]; // Lưu trữ giá trị vào processedParams
        });

        // Xác thực trường sắp xếp hợp lệ
        const allowedSortFields = ['name', 'created_at', 'updated_at'];
        const sortBy = processedParams.sort_by?.toLowerCase();

        // Xử lý các tham số boolean
        const processBoolean = (value: any): boolean | undefined => {
            if (value === undefined || value === '') return undefined; // Nếu giá trị không xác định hoặc rỗng, trả về undefined
            if (typeof value === 'boolean') return value; // Nếu giá trị là boolean, trả về giá trị đó
            if (value === 'true') return true; // Nếu giá trị là 'true', trả về true
            if (value === 'false') return false; // Nếu giá trị là 'false', trả về false
            return undefined; // Nếu không phải là boolean, trả về undefined
        };

        return {
            pageNum: processedParams.pageNum ? parseInt(processedParams.pageNum) : 1,
            pageSize: processedParams.pageSize ? parseInt(processedParams.pageSize) : 10,
            sort_by: allowedSortFields.includes(sortBy) ? sortBy : 'created_at',
            sort_order: processedParams.sort_order === 'asc' ? 'asc' : 'desc',
            keyword: processedParams.keyword,
            is_deleted: processBoolean(processedParams.is_deleted)
        };
    }

    /**
     * Lấy danh sách phòng ban của một manager
     */
    public async getManagerDepartments(managerId: string, queryParams: any = {}): Promise<{
        departments: IDepartment[];
        count: number;
    }> {
        // Kiểm tra managerId có hợp lệ không
        if (!mongoose.Types.ObjectId.isValid(managerId)) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        // Kiểm tra manager có tồn tại không
        const manager = await this.userSchema.findById(managerId);
        if (!manager) {
            throw new HttpException(HttpStatus.NotFound, 'Manager not found');
        }

        // Xử lý các tham số truy vấn
        const { is_deleted } = this.processQueryParams(queryParams);

        // Xây dựng truy vấn
        // Đảm bảo đang tìm kiếm theo manager_id trong database
        const query: any = { manager_id: managerId };

        // Xử lý trạng thái is_deleted
        if (is_deleted !== undefined) {
            query.is_deleted = is_deleted;
        } else {
            // Mặc định chỉ hiển thị các phòng ban chưa bị xóa logic
            query.is_deleted = false;
        }

        // Lấy danh sách phòng ban và đếm số lượng
        const departments = await this.departmentRepository.findWithPopulate(query, {}, 0, 1000);

        return {
            departments,
            count: departments.length
        };
    }

    /**
     * Đếm tổng số phòng ban trong hệ thống 
     */
    public async countDepartments(queryParams: any = {}): Promise<number> {
        // Xử lý các tham số truy vấn
        const { is_deleted } = this.processQueryParams(queryParams);

        // Xây dựng truy vấn
        const query: any = {};

        // Xử lý trạng thái is_deleted
        if (is_deleted !== undefined) {
            query.is_deleted = is_deleted;
        } else {
            // Mặc định chỉ đếm các phòng ban chưa bị xóa logic
            query.is_deleted = false;
        }

        // Đếm số lượng phòng ban
        return await this.departmentRepository.countDocuments(query);
    }
}


================================================
FILE: src/modules/department/index.ts
================================================
import DepartmentSchema from './department.model';
import { IDepartment } from './department.interface';
import DepartmentController from './department.controller';
import DepartmentService from './department.service';
import DepartmentRoute from './department.route';

export {
    DepartmentSchema,
    IDepartment,
    DepartmentController,
    DepartmentService,
    DepartmentRoute
}; 


================================================
FILE: src/modules/department/dtos/createDepartment.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString } from "class-validator";
import { IDepartment } from "../department.interface";

export default class CreateDepartmentDto {
    constructor(
        name: string,
        description: string,
        manager_id: string
    ) {
        this.name = name;
        this.description = description;
        this.manager_id = manager_id;
    }

    @IsString()
    @IsNotEmpty()
    public name: string;

    @IsString()
    @IsNotEmpty()
    public description: string;

    @IsString()
    @IsNotEmpty()
    public manager_id: string;
}





================================================
FILE: src/modules/department/dtos/updateDepartment.dto.ts
================================================
import { IsNotEmpty, IsString } from "class-validator";

export default class UpdateDepartmentDto {
    constructor(
        name: string,
        description: string,
        manager_id: string
    ) {
        this.name = name;
        this.description = description;
        this.manager_id = manager_id;
    }

    @IsString()
    @IsNotEmpty()
    public name: string;

    @IsString()
    @IsNotEmpty()
    public description: string;

    @IsString()
    @IsNotEmpty()
    public manager_id: string;
}




================================================
FILE: src/modules/department/swagger/department.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateDepartmentDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - manager_id
 *       properties:
 *         name:
 *           type: string
 *           description: Department name
 *           example: "Cardiology Department"
 *         description:
 *           type: string
 *           description: Department description
 *           example: "Department for heart-related services and diagnostics"
 *         manager_id:
 *           type: string
 *           description: Manager ID (must be a user with MANAGER role)
 *           example: "60d0fe4f5311236168a109ca"
 *
 *     UpdateDepartmentDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - manager_id
 *       properties:
 *         name:
 *           type: string
 *           description: Department name
 *           example: "Cardiology Department"
 *         description:
 *           type: string
 *           description: Department description
 *           example: "Department for heart-related services and diagnostics"
 *         manager_id:
 *           type: string
 *           description: Manager ID (must be a user with MANAGER role)
 *           example: "60d0fe4f5311236168a109ca"
 *
 *     DepartmentResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Department ID
 *           example: "60d0fe4f5311236168a109cb"
 *         name:
 *           type: string
 *           description: Department name
 *           example: "Cardiology Department"
 *         description:
 *           type: string
 *           description: Department description
 *           example: "Department for heart-related services and diagnostics"
 *         manager_id:
 *           type: object
 *           description: Manager information
 *           properties:
 *             _id:
 *               type: string
 *               description: Manager ID
 *               example: "60d0fe4f5311236168a109ca"
 *             first_name:
 *               type: string
 *               description: Manager's first name
 *               example: "John"
 *             last_name:
 *               type: string
 *               description: Manager's last name
 *               example: "Smith"
 *             email:
 *               type: string
 *               description: Manager's email
 *               example: "john.smith@example.com"
 *         is_deleted:
 *           type: boolean
 *           description: Deletion status
 *           example: false
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-06-15T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-06-20T14:20:00.000Z"
 *
 *     DepartmentPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/DepartmentResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     DepartmentCountResponse:
 *       type: object
 *       properties:
 *         totalDepartments:
 *           type: integer
 *           description: Total number of departments
 *           example: 8
 *
 *     ManagerDepartmentsResponse:
 *       type: object
 *       properties:
 *         departments:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/DepartmentResponse'
 *         count:
 *           type: integer
 *           description: Number of departments managed by the manager
 *           example: 2
 *
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Error message
 *           example: "Department not found"
 *         status:
 *           type: integer
 *           description: HTTP status code
 *           example: 404
 */



================================================
FILE: src/modules/department/swagger/department.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: departments
 *   description: Department management APIs
 */

/**
 * @swagger
 * /api/department/create:
 *   post:
 *     tags:
 *       - departments
 *     summary: Create new department (Admin only)
 *     description: Create a new department with manager assignment
 *     operationId: createDepartment
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateDepartmentDto'
 *     responses:
 *       201:
 *         description: Department created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentResponse'
 *       400:
 *         description: Invalid input data or invalid manager ID
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: Manager not found or not a valid manager
 *       409:
 *         description: Department with this name already exists
 */

/**
 * @swagger
 * /api/department/search:
 *   get:
 *     tags:
 *       - departments
 *     summary: Search and filter departments (Admin, Manager, Laboratory Technician, Staff)
 *     description: Search departments with pagination and filtering options
 *     operationId: getDepartments
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *         example: 1
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *         example: 10
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by department name or description
 *         example: "cardiology"
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           default: created_at
 *           enum: [name, created_at, updated_at]
 *         description: Field to sort results by
 *         example: "name"
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           default: desc
 *           enum: [asc, desc]
 *         description: Sort order (ascending or descending)
 *         example: "asc"
 *       - in: query
 *         name: is_deleted
 *         schema:
 *           type: boolean
 *           default: false
 *         description: Filter by deletion status
 *         example: false
 *     responses:
 *       200:
 *         description: List of departments with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentPaginationResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 */

/**
 * @swagger
 * /api/department/manager/{managerId}:
 *   get:
 *     tags:
 *       - departments
 *     summary: Get departments by manager ID (Admin, Manager)
 *     description: Retrieve all departments managed by a specific manager
 *     operationId: getManagerDepartments
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: managerId
 *         required: true
 *         schema:
 *           type: string
 *         description: Manager ID
 *         example: "60d0fe4f5311236168a109ca"
 *       - in: query
 *         name: is_deleted
 *         schema:
 *           type: boolean
 *           default: false
 *         description: Include deleted departments
 *         example: false
 *     responses:
 *       200:
 *         description: List of departments managed by the specified manager
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ManagerDepartmentsResponse'
 *       400:
 *         description: Invalid manager ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Manager not found
 */

/**
 * @swagger
 * /api/department/count:
 *   get:
 *     tags:
 *       - departments
 *     summary: Count departments (Admin, Manager)
 *     description: Get the total number of departments in the system
 *     operationId: countDepartments
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: is_deleted
 *         schema:
 *           type: boolean
 *           default: false
 *         description: Include deleted departments in count
 *         example: false
 *     responses:
 *       200:
 *         description: Total count of departments
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentCountResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 */

/**
 * @swagger
 * /api/department/{id}:
 *   get:
 *     tags:
 *       - departments
 *     summary: Get department by ID (Admin, Manager, Laboratory Technician, Staff)
 *     description: Retrieve detailed information about a specific department
 *     operationId: getDepartmentById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     responses:
 *       200:
 *         description: Department details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentResponse'
 *       400:
 *         description: Invalid department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Department not found
 *
 *   put:
 *     tags:
 *       - departments
 *     summary: Update department (Admin, Manager)
 *     description: Update department information including name, description, and manager
 *     operationId: updateDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateDepartmentDto'
 *     responses:
 *       200:
 *         description: Department updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentResponse'
 *       400:
 *         description: Invalid input data or department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Department or manager not found
 *       409:
 *         description: Department with this name already exists
 *
 *   delete:
 *     tags:
 *       - departments
 *     summary: Delete department (Admin only)
 *     description: Soft delete a department (marks as deleted but keeps in database)
 *     operationId: deleteDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     responses:
 *       200:
 *         description: Department deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Department deleted successfully"
 *       400:
 *         description: Invalid department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin access required
 *       404:
 *         description: Department not found
 */

/**
 * @swagger
 * /api/department/{departmentId}/statistics:
 *   get:
 *     tags:
 *       - departments
 *     summary: Get department statistics (Admin, Manager)
 *     description: Retrieve statistical information about a department
 *     operationId: getDepartmentStatistics
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: departmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     responses:
 *       200:
 *         description: Department statistics retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 staffCount:
 *                   type: integer
 *                   description: Number of staff in the department
 *                   example: 15
 *                 activeAppointments:
 *                   type: integer
 *                   description: Number of active appointments
 *                   example: 28
 *                 completedAppointments:
 *                   type: integer
 *                   description: Number of completed appointments
 *                   example: 142
 *                 serviceTypes:
 *                   type: integer
 *                   description: Number of different service types offered
 *                   example: 8
 *       400:
 *         description: Invalid department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Department not found
 */


================================================
FILE: src/modules/docs/docs.route.ts
================================================
import { Router } from 'express';
import { IRoute } from '../../core/interfaces';
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';
import path from 'path';
import fs from 'fs';

export default class DocsRoute implements IRoute {
    public path = '/api-docs';
    public router = Router();

    constructor() {
        this.initializeRoutes();
    }

    /**
     * Count the number of endpoints in the project by analyzing route files
     * @returns The total number of endpoints
     */
    private countEndpoints(): number {
        let totalEndpoints = 0;
        const moduleDir = path.join(__dirname, '..');

        try {
            // Get all module directories
            const modules = fs.readdirSync(moduleDir).filter(file =>
                fs.statSync(path.join(moduleDir, file)).isDirectory()
            );

            // For each module, check if it has a route file
            modules.forEach(moduleName => {
                const routeFilePath = path.join(moduleDir, moduleName, `${moduleName}.route.ts`);

                if (fs.existsSync(routeFilePath)) {
                    // Read the route file content
                    const routeContent = fs.readFileSync(routeFilePath, 'utf8');

                    // Count occurrences of router.get, router.post, router.put, router.delete, etc.
                    const getEndpoints = (routeContent.match(/router\.get\(/g) || []).length;
                    const postEndpoints = (routeContent.match(/router\.post\(/g) || []).length;
                    const putEndpoints = (routeContent.match(/router\.put\(/g) || []).length;
                    const deleteEndpoints = (routeContent.match(/router\.delete\(/g) || []).length;
                    const patchEndpoints = (routeContent.match(/router\.patch\(/g) || []).length;

                    const moduleEndpoints = getEndpoints + postEndpoints + putEndpoints + deleteEndpoints + patchEndpoints;
                    totalEndpoints += moduleEndpoints;
                }
            });

            console.log(`Total endpoints: ${totalEndpoints}`);
            return totalEndpoints;
        } catch (error) {
            console.error('Error counting endpoints:', error);
            return 0;
        }
    }

    private initializeRoutes() {
        // Count endpoints
        const endpointCount = this.countEndpoints();

        // Swagger options
        const options = {
            definition: {
                openapi: '3.0.0',
                info: {
                    title: 'Bloodline DNA Testing Service API',
                    description: `API endpoints for a Bloodline DNA Testing Service documented on swagger. This API has ${endpointCount} endpoints in total.`,
                    contact: {
                        name: "Nguyễn Đan Huy",
                        email: "huyit2003@gmail.com",
                        url: "https://github.com/server-craftsman/wdp392-restApi-with-nodejs-express-mongodb"
                    },
                    version: '1.0.0',
                },
                servers: [
                    {
                        url: "https://restapi-dnatesting.vercel.app/",
                        description: "Live server"
                    },
                    {
                        url: "http://localhost:6969/",
                        description: "Local server"
                    },
                ],
                components: {
                    securitySchemes: {
                        Bearer: {
                            type: "apiKey",
                            name: "Authorization",
                            in: "header",
                            description: "Bearer token for authorization",
                            scheme: "bearer",
                            bearerFormat: "JWT"
                        }
                    }
                }
            },
            apis: [
                './src/modules/*/swagger/*.js',
                './src/modules/*/dtos/*.ts'
            ],
        };

        const swaggerSpec = swaggerJsdoc(options);

        // Add endpoint count to swagger UI
        this.router.use(this.path, (req, res, next) => {
            // Add endpoint count to res.locals for access in the view
            res.locals.endpointCount = endpointCount;
            next();
        });

        // Serve swagger UI
        this.router.use(this.path, swaggerUi.serve);
        this.router.get(this.path, swaggerUi.setup(swaggerSpec, {
            swaggerOptions: {
                persistAuthorization: true,
                displayRequestDuration: true,
                docExpansion: 'list',
                filter: true,
                showExtensions: true,
                tryItOutEnabled: true,
                tagsSorter: 'alpha',
                defaultModelsExpandDepth: 1,
                operationsSorter: 'alpha'
            },
            customCss: `
                .swagger-ui .topbar { background-color: rgb(0, 0, 0); }
                .swagger-ui .opblock-tag { font-size: 16px; margin: 10px 0 5px 0; }
                .swagger-ui .opblock .opblock-summary-description { font-size: 13px; }
                .swagger-ui .opblock-tag:hover { background-color: rgba(0, 0, 0, 0.1); }
                .endpoint-count { 
                    background-color: #49cc90; 
                    color: white; 
                    padding: 5px 10px; 
                    border-radius: 4px; 
                    margin: 10px 0; 
                    display: inline-block; 
                    font-weight: bold;
                }
            `,
            customSiteTitle: `API Documentation (${endpointCount} endpoints)`,
            customfavIcon: "/favicon.ico"
        }));

        // Serve swagger spec as JSON
        this.router.get(`${this.path}.json`, (req, res) => {
            res.setHeader('Content-Type', 'application/json');
            res.send(swaggerSpec);
        });
    }
} 


================================================
FILE: src/modules/docs/index.ts
================================================
import DocsRoute from './docs.route';

export {
    DocsRoute
}; 


================================================
FILE: src/modules/index/index.controller.ts
================================================
import { NextFunction, Request, Response } from "express";
import { HttpStatus } from "../../core/enums";
import { formatResponse } from "../../core/utils";
import { version } from "../../../package.json";
import path from 'path';
import fs from 'fs';

export default class IndexController {
    /**
     * API root endpoint
     * Returns information about the API in various formats based on Accept header
     */
    public index = (req: Request, res: Response, next: NextFunction) => {
        try {
            const apiInfo = {
                name: "Bloodline DNA Testing Service API",
                version: version,
                status: "running",
                documentation: "/api-docs",
                timestamp: new Date().toISOString()
            };

            // Get the Accept header
            const acceptHeader = req.header('Accept');

            // Respond based on the requested format
            if (acceptHeader && acceptHeader.includes('text/html')) {
                // HTML response
                const htmlResponse = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>${apiInfo.name}</title>
                    <style>
                        body {
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                            line-height: 1.6;
                            color: #333;
                            max-width: 800px;
                            margin: 0 auto;
                            padding: 20px;
                        }
                        header {
                            border-bottom: 1px solid #eee;
                            padding-bottom: 20px;
                            margin-bottom: 20px;
                        }
                        h1 {
                            color: #2c3e50;
                        }
                        .status {
                            display: inline-block;
                            background-color: #27ae60;
                            color: white;
                            padding: 5px 10px;
                            border-radius: 4px;
                            font-weight: bold;
                        }
                        .api-details {
                            background-color: #f9f9f9;
                            border-left: 4px solid #2c3e50;
                            padding: 15px;
                            margin: 20px 0;
                        }
                        .api-details p {
                            margin: 10px 0;
                        }
                        .docs-button {
                            display: inline-block;
                            background-color: #3498db;
                            color: white;
                            padding: 10px 20px;
                            text-decoration: none;
                            border-radius: 4px;
                            font-weight: bold;
                            margin-top: 20px;
                        }
                        .docs-button:hover {
                            background-color: #2980b9;
                        }
                        footer {
                            margin-top: 40px;
                            text-align: center;
                            color: #7f8c8d;
                            font-size: 0.9em;
                        }
                    </style>
                </head>
                <body>
                    <header>
                        <h1>${apiInfo.name}</h1>
                        <div class="status">Status: ${apiInfo.status}</div>
                    </header>
                    
                    <main>
                        <div class="api-details">
                            <p><strong>Version:</strong> ${apiInfo.version}</p>
                            <p><strong>Last Updated:</strong> ${apiInfo.timestamp}</p>
                        </div>
                                                
                        <a href="${apiInfo.documentation}" class="docs-button">View API Documentation</a>
                    </main>
                    
                    <footer>
                        &copy; ${new Date().getFullYear()} Bloodline DNA Testing Service
                    </footer>
                </body>
                </html>
                `;
                res.header('Content-Type', 'text/html').send(htmlResponse);
            } else if (acceptHeader && acceptHeader.includes('application/xml')) {
                // XML response
                const xmlResponse = `<?xml version="1.0" encoding="UTF-8"?>
                <api>
                    <name>${apiInfo.name}</name>
                    <version>${apiInfo.version}</version>
                    <status>${apiInfo.status}</status>
                    <documentation>${apiInfo.documentation}</documentation>
                    <timestamp>${apiInfo.timestamp}</timestamp>
                </api>`;
                res.header('Content-Type', 'application/xml').send(xmlResponse);
            } else {
                // Default JSON response
                res.status(HttpStatus.Success).json(formatResponse(apiInfo));
            }
        } catch (error) {
            next(error);
        }
    };

    /**
     * Serve a welcome page
     * Returns a static HTML welcome page
     */
    public welcomePage = (req: Request, res: Response, next: NextFunction) => {
        try {
            res.sendFile(path.join(__dirname, '../../../public/welcome.html'));
        } catch (error) {
            next(error);
        }
    };

    /**
     * API documentation redirect
     * Redirects to the Swagger documentation
     */
    public apiDocs = (req: Request, res: Response, next: NextFunction) => {
        try {
            res.redirect('/api-docs');
        } catch (error) {
            next(error);
        }
    };
}


================================================
FILE: src/modules/index/index.route.ts
================================================
import { Router } from 'express';
import { IRoute } from '../../core/interfaces';
import IndexController from './index.controller';

export default class IndexRoute implements IRoute {
    public path = '/';
    public router = Router();

    public indexController = new IndexController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        this.router.get(this.path, this.indexController.index);
        this.router.get('/api', this.indexController.apiDocs);
        this.router.get('/welcome', this.indexController.welcomePage);
    }
}



================================================
FILE: src/modules/index/index.ts
================================================
import IndexController from "./index.controller";
import IndexRoute from "./index.route";

export { IndexController, IndexRoute };



================================================
FILE: src/modules/index/view/index.ejs
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloodline DNA Testing Service Management System</title>
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #2ec4b6;
            --dark: #212529;
            --light: #f8f9fa;
            --gray: #6c757d;
            --border: #e9ecef;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }
        
        .container {
            background-color: white;
            padding: 3rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 600px;
            width: 100%;
            animation: fadeIn 0.8s ease-out;
            border-top: 5px solid var(--primary);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            color: var(--primary);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            font-weight: 600;
        }
        
        .info-block {
            background-color: var(--light);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 0.75rem 0;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }
        
        .info-item:last-child {
            border-bottom: none;
        }
        
        .label {
            font-weight: 600;
            color: var(--gray);
        }
        
        .value {
            color: var(--dark);
            font-weight: 500;
        }
        
        .links {
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        
        .btn {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background-color: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 30px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(67, 97, 238, 0.15);
        }
        
        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(67, 97, 238, 0.2);
        }
        
        .btn-secondary {
            background-color: white;
            color: var(--primary);
            border: 2px solid var(--primary);
        }
        
        .btn-secondary:hover {
            background-color: var(--light);
            color: var(--primary-dark);
            border-color: var(--primary-dark);
        }
        .info-item:last-child {
            border-bottom: none;
        }        
    </style>
</head>
<body>
    <div class="container">
        <h1><%= message %></h1>
        
        <div class="info-block">
            <div class="info-item">
                <span class="label">API Version</span>
                <span class="value"><%= api_version %></span>
            </div>
            <div class="info-item">
                <span class="label">Server Time</span>
                <span class="value"><%= server_time %></span>
            </div>
            <div class="info-item">
                <span class="label">Author</span>
                <span class="value"><%= author %></span>
            </div>
        </div>
        
        <div class="links">
            <a href="<%= links.documentation %>" class="btn">Documentation</a>
            <a href="<%= links.services %>" class="btn btn-secondary">Services</a>
        </div>
    </div>
</body>
</html>


================================================
FILE: src/modules/kit/index.ts
================================================
import KitSchema from './kit.model';
import { IKit, KitStatus } from './kit.interface';
import { KitStatusEnum } from './kit.enum';
import { KitStatuses } from './kit.constant';
import KitRepository from './kit.repository';
import KitService from './kit.service';
import KitController from './kit.controller';
import KitRoute from './kit.route';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { SearchKitDto } from './dtos/searchKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';

export {
    KitSchema,
    IKit,
    KitStatus,
    KitStatusEnum,
    KitStatuses,
    KitRepository,
    KitService,
    KitController,
    KitRoute,
    CreateKitDto,
    UpdateKitDto,
    SearchKitDto,
    ReturnKitDto
}; 


================================================
FILE: src/modules/kit/kit.constant.ts
================================================
import { KitStatusEnum } from './kit.enum';

export const KitStatuses = [
    KitStatusEnum.AVAILABLE,
    KitStatusEnum.ASSIGNED,
    KitStatusEnum.USED,
    KitStatusEnum.RETURNED,
    KitStatusEnum.DAMAGED
]; 


================================================
FILE: src/modules/kit/kit.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IKit } from './kit.interface';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { SearchKitDto } from './dtos/searchKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';
import KitService from './kit.service';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class KitController {
    private kitService = new KitService();

    /**
     * Create a new kit with auto-generated code
     */
    public createKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitData: CreateKitDto = req.body;
            const kit = await this.kitService.createKit(kitData);
            res.status(HttpStatus.Created).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get kit by ID
     */
    public getKitById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const kit = await this.kitService.getKitById(kitId);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Search kits
     */
    public searchKits = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const searchParams: SearchKitDto = req.query as any;
            const searchResult = await this.kitService.searchKits(searchParams);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IKit>>(searchResult));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Update kit
     */
    public updateKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const kitData: UpdateKitDto = req.body;
            const updatedKit = await this.kitService.updateKit(kitId, kitData);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(updatedKit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Delete kit
     */
    public deleteKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            await this.kitService.deleteKit(kitId);

            res.status(HttpStatus.Success).json(formatResponse<string>('Kit deleted successfully'));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Change kit status
     */
    public changeKitStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const { status } = req.body;
            const updatedKit = await this.kitService.changeKitStatus(kitId, status);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(updatedKit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get available kits
     */
    public getAvailableKits = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kits = await this.kitService.getAvailableKits();

            res.status(HttpStatus.Success).json(formatResponse<IKit[]>(kits));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Return a kit
     */
    public returnKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const { notes } = req.body;

            const kit = await this.kitService.returnKit(kitId, notes);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Assign a kit to a laboratory technician
     */
    public assignKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const { appointment_id, laboratory_technician_id } = req.body;

            const kit = await this.kitService.assignKit(
                kitId,
                appointment_id,
                laboratory_technician_id
            );

            res.status(HttpStatus.Success).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/kit/kit.enum.ts
================================================
export enum KitStatusEnum {
    AVAILABLE = 'available',
    ASSIGNED = 'assigned',
    USED = 'used',
    RETURNED = 'returned',
    DAMAGED = 'damaged' // đã hư hỏng
} 


================================================
FILE: src/modules/kit/kit.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { KitStatusEnum } from './kit.enum';

export type KitStatus =
    KitStatusEnum.AVAILABLE |
    KitStatusEnum.ASSIGNED |
    KitStatusEnum.USED |
    KitStatusEnum.RETURNED |
    KitStatusEnum.DAMAGED;

export interface IKit extends Document {
    _id: string;
    code: string;
    status: KitStatus;
    appointment_id?: string | undefined;
    assigned_date?: Date;
    assigned_to_user_id?: string | undefined;
    return_date?: Date;
    notes?: string;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/kit/kit.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { KitStatuses } from './kit.constant';
import { IKit } from './kit.interface';

// Define schema with clear types
const KitSchemaEntity = new Schema({
    code: { type: String, required: true, unique: true },
    status: {
        type: String,
        enum: KitStatuses,
        required: true
    },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: false },
    assigned_date: { type: Date },
    assigned_to_user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: false },
    return_date: { type: Date },
    notes: { type: String },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

// Create and export the model with explicit typing
const KitSchema = mongoose.model<IKit>(COLLECTION_NAME.KIT, KitSchemaEntity);
export default KitSchema; 


================================================
FILE: src/modules/kit/kit.repository.ts
================================================
import KitSchema from './kit.model';
import { IKit } from './kit.interface';

export default class KitRepository {
    public async create(data: Partial<IKit>): Promise<IKit> {
        return await KitSchema.create(data);
    }

    public async findOne(query: any): Promise<IKit | null> {
        return KitSchema.findOne(query);
    }

    public async findById(id: string): Promise<IKit | null> {
        return KitSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IKit>, options: any = {}): Promise<IKit | null> {
        return KitSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return KitSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IKit[]> {
        return KitSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IKit[]> {
        return KitSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IKit[]> {
        return KitSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('appointment_id')
            .populate('assigned_to_user_id', '_id first_name last_name');
    }

    public async findByIdWithPopulate(id: string): Promise<IKit | null> {
        return KitSchema.findById(id)
            .populate('appointment_id')
            .populate('assigned_to_user_id', '_id first_name last_name');
    }

    public async findWithDetailedPopulate(query: any): Promise<IKit[]> {
        return KitSchema.find(query)
            .populate({
                path: 'appointment_id',
                populate: {
                    path: 'service_id',
                    select: '_id name description price'
                }
            })
            .populate({
                path: 'assigned_to_user_id',
                select: '_id first_name last_name email role'
            });
    }
} 


================================================
FILE: src/modules/kit/kit.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import KitController from './kit.controller';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';
import { AssignKitDto } from './dtos/assignKit.dto';

export default class KitRoute implements IRoute {
    public path = API_PATH.KIT;
    public router = Router();
    private kitController = new KitController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/kit/search -> Search kits
        this.router.get(
            `${API_PATH.SEARCH_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.searchKits
        );

        // GET: domain:/api/kit/available -> Get available kits
        this.router.get(
            `${API_PATH.GET_AVAILABLE_KITS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.getAvailableKits
        );

        // GET: domain:/api/kit/:id -> Get kit by ID
        this.router.get(
            `${API_PATH.GET_KIT_BY_ID}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.getKitById
        );

        // POST: domain:/api/kit/create -> Create a kit
        this.router.post(
            `${API_PATH.CREATE_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.kitController.createKit
        );

        // PUT: domain:/api/kit/:id -> Update a kit
        this.router.put(
            `${API_PATH.UPDATE_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateKitDto),
            this.kitController.updateKit
        );

        // POST: domain:/api/kit/:id/assign -> Assign a kit to a laboratory technician
        this.router.post(
            `${API_PATH.ASSIGN_KIT}`,
            authMiddleWare([UserRoleEnum.STAFF]),
            validationMiddleware(AssignKitDto),
            this.kitController.assignKit
        );

        // PATCH: domain:/api/kit/:id/status -> Change kit status
        this.router.patch(
            `${API_PATH.CHANGE_KIT_STATUS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.changeKitStatus
        );

        // DELETE: domain:/api/kit/:id -> Delete a kit
        this.router.delete(
            `${API_PATH.DELETE_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.kitController.deleteKit
        );

        // POST: domain:/api/kit/:id/return -> Return a kit
        this.router.post(
            `${API_PATH.RETURN_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.returnKit
        );
    }
} 


================================================
FILE: src/modules/kit/kit.service.ts
================================================
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IKit } from './kit.interface';
import { KitStatusEnum } from './kit.enum';
import KitRepository from './kit.repository';
import mongoose from 'mongoose';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { SearchKitDto } from './dtos/searchKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { PaginationResponseModel } from '../../core/models/pagination.model';
import { format, isValid, parse } from "date-fns";

export default class KitService {
    private kitRepository = new KitRepository();

    // Hàm tự động sinh mã kit
    private async generateKitCode(): Promise<string> {
        const today = new Date();
        const dateStr = format(today, "yyyyMMdd"); // e.g., 20250528

        // Tìm số lượng kit đã tạo trong ngày để xác định số thứ tự
        const kitsToday = await this.kitRepository.countDocuments({
            code: { $regex: `^KIT-${dateStr}-` }
        });

        const sequence = (kitsToday + 1).toString().padStart(3, "0"); // e.g., 001, 002, ...
        if (parseInt(sequence) > 999) {
            throw new HttpException(HttpStatus.Conflict, "Maximum kits for today reached (999)");
        }

        return `KIT-${dateStr}-${sequence}`; // e.g., KIT-20250528-001
    }

    // Hàm validate mã kit nếu người dùng nhập thủ công
    private validateKitCode(code: string): void {
        // Kiểm tra định dạng tổng quát
        const codeRegex = /^KIT-\d{8}-\d{3}$/;
        if (!codeRegex.test(code)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid code format');
        }

        // Kiểm tra phần ngày
        const dateStr = code.split("-")[1]; // e.g., 20250528
        const parsedDate = parse(dateStr, "yyyyMMdd", new Date());
        if (!isValid(parsedDate)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid date');
        }

        // Kiểm tra số thứ tự
        const sequence = parseInt(code.split("-")[2], 10); // e.g., 001 -> 1
        if (sequence < 1 || sequence > 999) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid sequence');
        }
    }

    /**
     * Create a new kit with auto-generated code
     */
    public async createKit(kitData?: CreateKitDto): Promise<IKit> {
        let code: string;

        try {
            // Handle code generation or validation
            if (!kitData || !kitData.code) {
                code = await this.generateKitCode();
            } else {
                code = kitData.code;
                this.validateKitCode(code);
            }

            // Check if kit already exists
            const existingKit = await this.kitRepository.findOne({ code });
            if (existingKit) {
                throw new HttpException(HttpStatus.Conflict, 'Kit code already exists');
            }

            // Create kit object
            const kitObject = {
                code,
                status: KitStatusEnum.AVAILABLE,
                created_at: new Date(),
                updated_at: new Date()
            };

            // Create kit in database
            const kit = await this.kitRepository.create(kitObject);
            return kit;
        } catch (error) {
            // Handle errors
            if (error instanceof HttpException) {
                throw error;
            }

            console.error('Error creating kit:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating kit');
        }
    }

    /**
     * Find an available kit by ID
     */
    public async findAvailableKitById(kitId: string): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status !== KitStatusEnum.AVAILABLE) {
            throw new HttpException(HttpStatus.BadRequest, 'Kit is not available');
        }

        return kit;
    }

    /**
     * Get kit by ID
     */
    public async getKitById(kitId: string): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findByIdWithPopulate(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        return kit;
    }

    /**
     * Search kits with pagination
     */
    public async searchKits(searchParams: SearchKitDto): Promise<SearchPaginationResponseModel<IKit>> {
        try {
            const { pageNum = 1, pageSize = 10, ...filters } = searchParams;

            const query: any = {};

            if (filters.code) {
                query.code = { $regex: filters.code, $options: 'i' }; // $regex: dùng để tìm kiếm theo mã kit
            }

            if (filters.status) {
                query.status = filters.status;
            }

            if (filters.appointment_id) {
                query.appointment_id = filters.appointment_id;
            }

            if (filters.assigned_to_user_id) {
                query.assigned_to_user_id = filters.assigned_to_user_id;
            }

            const skip = (pageNum - 1) * pageSize; // skip: bỏ qua bao nhiêu dòng
            const limit = pageSize; // limit: lấy bao nhiêu dòng

            const [kits, totalCount] = await Promise.all([ // Promise.all: chạy song song các promise
                this.kitRepository.findWithPopulate(query, { created_at: -1 }, skip, limit), // findWithPopulate: lấy dữ liệu và populate dữ liệu
                this.kitRepository.countDocuments(query) // countDocuments: đếm số dòng
            ]);

            const paginationInfo = new PaginationResponseModel(
                pageNum,
                pageSize,
                totalCount,
                Math.ceil(totalCount / pageSize) // Math.ceil: làm tròn lên
            );

            return new SearchPaginationResponseModel<IKit>(kits, paginationInfo); // trả về dữ liệu và phân trang
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching kits');
        }
    }

    /**
     * Update a kit
     */
    public async updateKit(kitId: string, kitData: UpdateKitDto): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status !== KitStatusEnum.AVAILABLE) {
            throw new HttpException(HttpStatus.BadRequest, 'Kit is not available');
        }

        if (kitData.notes) {
            kit.notes = kitData.notes;
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                ...kitData,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update kit');
        }

        return updatedKit;
    }

    /**
     * Delete a kit
     */
    public async deleteKit(kitId: string): Promise<void> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status === KitStatusEnum.ASSIGNED || kit.status === KitStatusEnum.USED) {
            throw new HttpException(
                HttpStatus.BadRequest,
                'Cannot delete kit that is currently assigned or in use'
            );
        }

        await this.kitRepository.findByIdAndUpdate(kitId, { status: KitStatusEnum.DAMAGED });
    }

    /**
     * Change kit status
     */
    public async changeKitStatus(kitId: string, status: KitStatusEnum): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        if (!Object.values(KitStatusEnum).includes(status)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid status');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                status,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update kit status');
        }

        return updatedKit;
    }

    /**
     * Get all available kits
     */
    public async getAvailableKits(): Promise<IKit[]> {
        return this.kitRepository.find({ status: KitStatusEnum.AVAILABLE });
    }

    /**
     * Assign a kit to an appointment and laboratory technician
     * @param kitId - The ID of the kit to assign
     * @param appointmentId - The ID of the appointment
     * @param technicianId - The ID of the laboratory technician
     */
    public async assignKit(kitId: string, appointmentId: string, technicianId: string): Promise<IKit> {
        const kit = await this.findAvailableKitById(kitId);

        // Validate userId is a valid ObjectId
        if (!mongoose.Types.ObjectId.isValid(technicianId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid laboratory technician ID');
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                status: KitStatusEnum.ASSIGNED,
                appointment_id: appointmentId as any,
                assigned_to_user_id: technicianId as any,
                assigned_date: new Date(),
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign kit');
        }

        return updatedKit;
    }

    /**
     * Return a kit
     */
    public async returnKit(kitId: string, notes?: string): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status !== KitStatusEnum.ASSIGNED && kit.status !== KitStatusEnum.USED) {
            throw new HttpException(
                HttpStatus.BadRequest,
                'Only assigned or used kits can be returned'
            );
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                status: KitStatusEnum.RETURNED,
                return_date: new Date(),
                notes,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to return kit');
        }

        return updatedKit;
    }

    /**
     * Process query parameters
     */
    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }
} 


================================================
FILE: src/modules/kit/dtos/assignKit.dto.ts
================================================
import { IsMongoId, IsNotEmpty } from 'class-validator';

export class AssignKitDto {
    @IsNotEmpty({ message: 'Appointment ID is required' })
    @IsMongoId({ message: 'Invalid appointment ID format' })
    appointment_id: string = '';

    @IsNotEmpty({ message: 'Laboratory technician ID is required' })
    @IsMongoId({ message: 'Invalid laboratory technician ID format' })
    laboratory_technician_id: string = '';
} 


================================================
FILE: src/modules/kit/dtos/createKit.dto.ts
================================================
import { IsOptional, IsString, Matches } from 'class-validator';

export class CreateKitDto {
    constructor(
        code?: string
    ) {
        this.code = code;
    }

    @IsOptional()
    @IsString({ message: 'Kit code must be a string' })
    // @Matches(/^KIT-\d{8}-\d{3}$/, {
    //     message: 'Kit code must follow the format KIT-YYYYMMDD-###',
    //     each: false
    // })
    code?: string;
}


================================================
FILE: src/modules/kit/dtos/returnKit.dto.ts
================================================
import { IsMongoId, IsOptional, IsString } from 'class-validator';

export class ReturnKitDto {
    @IsMongoId()
    kit_id: string = '';

    @IsString()
    @IsOptional()
    notes?: string;
} 


================================================
FILE: src/modules/kit/dtos/searchKit.dto.ts
================================================
import { IsString, IsOptional, IsEnum, IsMongoId, IsNumber } from 'class-validator';
import { KitStatusEnum } from '../kit.enum';

export class SearchKitDto {
    @IsString()
    @IsOptional()
    code?: string;

    @IsEnum(KitStatusEnum)
    @IsOptional()
    status?: KitStatusEnum;

    @IsMongoId()
    @IsOptional()
    appointment_id?: string;

    @IsMongoId()
    @IsOptional()
    assigned_to_user_id?: string;

    @IsNumber()
    @IsOptional()
    pageNum?: number;

    @IsNumber()
    @IsOptional()
    pageSize?: number;
}



================================================
FILE: src/modules/kit/dtos/updateKit.dto.ts
================================================
import { IsString, IsOptional } from 'class-validator';

export class UpdateKitDto {
    @IsString()
    @IsOptional()
    notes?: string;
} 


================================================
FILE: src/modules/kit/swagger/kit.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateKitDto:
 *       type: object
 *       properties:
 *         code:
 *           type: string
 *           description: Kit code (optional, will be auto-generated if not provided)
 *           pattern: "^KIT-\\d{8}-\\d{3}$"
 *           example: "KIT-20230615-001"
 *
 *     AssignKitDto:
 *       type: object
 *       required:
 *         - appointment_id
 *         - laboratory_technician_id
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment to assign the kit to
 *           example: "60d5ec9af682fbd12a0f4d4d"
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the laboratory technician to assign the kit to
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *
 *     UpdateKitDto:
 *       type: object
 *       properties:
 *         notes:
 *           type: string
 *           description: Notes about the kit
 *           example: "Kit has been sterilized and verified for proper functionality"
 *
 *     ReturnKitDto:
 *       type: object
 *       required:
 *         - kit_id
 *       properties:
 *         kit_id:
 *           type: string
 *           description: ID of the kit being returned
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         notes:
 *           type: string
 *           description: Notes about the returned kit condition
 *           example: "Kit returned in good condition, all components present"
 *
 *     ChangeKitStatusDto:
 *       type: object
 *       required:
 *         - status
 *       properties:
 *         status:
 *           type: string
 *           enum: [available, assigned, used, returned, damaged]
 *           description: New status for the kit
 *           example: "available"
 *
 *     KitResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Kit ID
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         code:
 *           type: string
 *           description: Kit unique identifier code
 *           example: "KIT-20230615-001"
 *         status:
 *           type: string
 *           description: Current kit status
 *           enum: [available, assigned, used, returned, damaged]
 *           example: "available"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment (if any)
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4d4d"
 *             appointment_code:
 *               type: string
 *               example: "APP-20230615-001"
 *         assigned_to_user_id:
 *           type: object
 *           description: Laboratory technician assigned to the kit (if any)
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4a1a"
 *             first_name:
 *               type: string
 *               example: "Alex"
 *             last_name:
 *               type: string
 *               example: "Johnson"
 *             email:
 *               type: string
 *               example: "alex.johnson@example.com"
 *             role:
 *               type: string
 *               example: "laboratory_technician"
 *         assigned_date:
 *           type: string
 *           format: date-time
 *           description: Date when kit was assigned
 *           example: "2023-06-15T09:30:00.000Z"
 *         return_date:
 *           type: string
 *           format: date-time
 *           description: Date when kit was returned
 *           example: "2023-06-20T14:20:00.000Z"
 *         notes:
 *           type: string
 *           description: Notes about the kit
 *           example: "Kit has been sterilized and verified for proper functionality"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-06-20T14:20:00.000Z"
 *
 *     KitPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/KitResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     SearchKitDto:
 *       type: object
 *       properties:
 *         code:
 *           type: string
 *           description: Filter by kit code
 *           example: "KIT-20230615"
 *         status:
 *           type: string
 *           enum: [available, assigned, used, returned, damaged]
 *           description: Filter by kit status
 *           example: "available"
 *         appointment_id:
 *           type: string
 *           description: Filter by appointment ID
 *           example: "60d5ec9af682fbd12a0f4d4d"
 *         assigned_to_user_id:
 *           type: string
 *           description: Filter by assigned laboratory technician ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         pageNum:
 *           type: integer
 *           description: Page number for pagination
 *           default: 1
 *           example: 1
 *         pageSize:
 *           type: integer
 *           description: Number of items per page
 *           default: 10
 *           example: 10
 *
 *     SuccessResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *           description: Success status
 *           example: true
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Operation completed successfully"
 *
 *     KitDetailedResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Kit ID
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         code:
 *           type: string
 *           description: Kit unique identifier code
 *           example: "KIT-20230615-001"
 *         status:
 *           type: string
 *           description: Current kit status
 *           enum: [available, assigned, used, returned, damaged]
 *           example: "available"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment (if any)
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4d4d"
 *             appointment_code:
 *               type: string
 *               example: "APP-20230615-001"
 *             service_id:
 *               type: object
 *               properties:
 *                 _id:
 *                   type: string
 *                   example: "60d5ec9af682fbd12a0f4d4e"
 *                 name:
 *                   type: string
 *                   example: "DNA Paternity Test"
 *                 description:
 *                   type: string
 *                   example: "Standard paternity test with 99.99% accuracy"
 *                 price:
 *                   type: number
 *                   example: 1500
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-06-01T09:30:00.000Z"
 */



================================================
FILE: src/modules/kit/swagger/kit.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: kits
 *   description: Kit management APIs
 */

/**
 * @swagger
 * /api/kit/create:
 *   post:
 *     tags:
 *       - kits
 *     summary: Create a new kit (Admin, Manager only)
 *     description: Create a new kit with auto-generated code or specified code
 *     operationId: createKit
 *     security:
 *       - Bearer: []
 *     responses:
 *       201:
 *         description: Kit created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid input or malformed kit code
 *       401:
 *         description: Unauthorized - Admin or Manager access required
 *       409:
 *         description: Kit code already exists
 */

/**
 * @swagger
 * /api/kit/search:
 *   get:
 *     tags:
 *       - kits
 *     summary: Search kits (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Search for kits with pagination and filtering options
 *     operationId: searchKits
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *         example: 1
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *         example: 10
 *       - in: query
 *         name: code
 *         schema:
 *           type: string
 *         description: Filter by kit code (full or partial)
 *         example: "KIT-20230615"
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, assigned, used, returned, damaged]
 *         description: Filter by kit status
 *         example: "available"
 *       - in: query
 *         name: appointment_id
 *         schema:
 *           type: string
 *         description: Filter by appointment ID
 *         example: "60d5ec9af682fbd12a0f4d4d"
 *       - in: query
 *         name: assigned_to_user_id
 *         schema:
 *           type: string
 *         description: Filter by assigned laboratory technician ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     responses:
 *       200:
 *         description: List of kits with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitPaginationResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 */

/**
 * @swagger
 * /api/kit/available:
 *   get:
 *     tags:
 *       - kits
 *     summary: Get available kits (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Retrieve all kits with 'available' status
 *     operationId: getAvailableKits
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: List of available kits
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/KitResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 */

/**
 * @swagger
 * /api/kit/{id}:
 *   get:
 *     tags:
 *       - kits
 *     summary: Get kit by ID (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Retrieve detailed information about a specific kit
 *     operationId: getKitById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     responses:
 *       200:
 *         description: Kit details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid kit ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Kit not found
 *   
 *   put:
 *     tags:
 *       - kits
 *     summary: Update kit (Admin, Manager only)
 *     description: Update kit information (currently only notes can be updated)
 *     operationId: updateKit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateKitDto'
 *     responses:
 *       200:
 *         description: Kit updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid input data or kit ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Kit not found
 *         
 *   delete:
 *     tags:
 *       - kits
 *     summary: Delete kit (Admin, Manager only)
 *     description: Mark a kit as damaged or delete it from the system
 *     operationId: deleteKit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     responses:
 *       200:
 *         description: Kit deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SuccessResponse'
 *       400:
 *         description: Invalid kit ID format or kit is currently assigned/in use
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Kit not found
 */

/**
 * @swagger
 * /api/kit/{id}/status:
 *   patch:
 *     tags:
 *       - kits
 *     summary: Change kit status (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Change the status of a kit (available, assigned, used, returned, damaged)
 *     operationId: changeKitStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangeKitStatusDto'
 *     responses:
 *       200:
 *         description: Kit status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid input data or kit ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Kit not found
 *       422:
 *         description: Invalid status transition (e.g., cannot change from used to available directly)
 */

/**
 * @swagger
 * /api/kit/{id}/return:
 *   post:
 *     tags:
 *       - kits
 *     summary: Return a kit (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Mark a kit as returned and update its status
 *     operationId: returnKit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               notes:
 *                 type: string
 *                 description: Notes about the returned kit
 *                 example: "Kit returned in good condition"
 *     responses:
 *       200:
 *         description: Kit returned successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid kit ID format or kit is not in a returnable state
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Kit not found
 */


================================================
FILE: src/modules/payment/index.ts
================================================
import PaymentSchema from './payment.model';
import { IPayment, PaymentMethod, PaymentStatus } from './payment.interface';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';
import { PaymentMethods, PaymentStatuses } from './payment.constant';
import PaymentRoute from './payment.route';
export {
    PaymentSchema,
    IPayment,
    PaymentMethod,
    PaymentStatus,
    PaymentMethodEnum,
    PaymentStatusEnum,
    PaymentMethods,
    PaymentStatuses,
    PaymentRoute
}; 


================================================
FILE: src/modules/payment/payment.constant.ts
================================================
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';

export const PaymentMethods = [
    '',
    PaymentMethodEnum.CASH,
    PaymentMethodEnum.PAY_OS
];

export const PaymentStatuses = [
    '',
    PaymentStatusEnum.PENDING,
    PaymentStatusEnum.COMPLETED,
    PaymentStatusEnum.FAILED,
    PaymentStatusEnum.REFUNDED
]; 


================================================
FILE: src/modules/payment/payment.controller.ts
================================================
import { NextFunction, Request, Response, Router } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import PaymentService from './payment.service';
import { CreatePayosPaymentDto } from './dtos/createPayosPayment.dto';
import { CreateSamplePaymentDto } from './dtos/createSamplePayment.dto';
import { CreateAppointmentPaymentDto } from './dtos/createAppointmentPayment.dto';

export default class PaymentController {
    private paymentService = new PaymentService();

    // Xử lý webhook từ PayOS khi có thay đổi trạng thái thanh toán
    public handlePayosWebhook = async (req: Request, res: Response, next: NextFunction) => {
        try {
            console.log('PayOS Webhook received:', {
                headers: req.headers,
                body: req.body,
                method: req.method,
                url: req.url
            });

            // Validate webhook data
            if (!req.body) {
                console.error('PayOS Webhook: Empty request body');
                return res.status(HttpStatus.BadRequest).json(
                    formatResponse(false, false, 'Empty webhook data')
                );
            }

            const webhookData = req.body;

            // Process webhook
            const result = await this.paymentService.processPayosWebhook(webhookData);

            // PayOS expects a 200 response for successful webhook processing
            const statusCode = result.success ? HttpStatus.Success : HttpStatus.BadRequest;

            res.status(statusCode).json(
                formatResponse(result, result.success, result.message)
            );

        } catch (error: any) {
            console.error('PayOS Webhook handler error:', error);

            // Always return 200 to PayOS to prevent retries for server errors
            // but log the actual error for debugging
            res.status(HttpStatus.Success).json(
                formatResponse(false, false, 'Webhook processing failed')
            );
        }
    };

    // Tạo chữ ký webhook test cho development
    public generateTestWebhookSignature = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (process.env.NODE_ENV === 'production') {
                return res.status(HttpStatus.Forbidden).json(
                    formatResponse(false, false, 'Test endpoint not available in production')
                );
            }

            const testData = req.body;
            if (!testData) {
                return res.status(HttpStatus.BadRequest).json(
                    formatResponse(false, false, 'No test data provided')
                );
            }

            // Import the signature generation function
            const { generatePayosSignature } = await import('./payment.util');
            const signature = generatePayosSignature(testData);

            res.status(HttpStatus.Success).json(
                formatResponse({
                    signature,
                    data: testData,
                    signedData: { ...testData, signature }
                }, true, 'Test signature generated successfully')
            );

        } catch (error) {
            next(error);
        }
    };

    // Xử lý return URL từ PayOS sau khi thanh toán
    public handlePayosReturn = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
            const { orderCode } = req.query;
            if (!orderCode) {
                res.status(HttpStatus.BadRequest).json({ message: 'Missing orderCode' });
                return;
            }

            // Find the payment by orderCode
            const payment = await this.paymentService.findPaymentByOrderCode(Number(orderCode));
            if (!payment) {
                res.status(HttpStatus.NotFound).json({ message: 'Payment not found' });
                return;
            }

            // Now you have payos_web_id
            const idWebPayOs = payment.payos_web_id;

            const result = await this.paymentService.verifyPaymentStatus(orderCode.toString());

            // Redirect to frontend with /payos path
            const frontendUrl = process.env.DOMAIN_FE || '/';
            const params = new URLSearchParams([
                ['code', '00'],
                ['id', idWebPayOs || ''],
                ['orderCode', orderCode.toString()],
                ['status', result.payment_status || payment.status || '']
            ]);
            // Add /payos after the domain
            res.redirect(`${frontendUrl.replace(/\/$/, '')}/payos?${params.toString()}`);
            return;
        } catch (error) {
            next(error);
        }
    };

    // Xử lý cancel URL từ PayOS khi hủy thanh toán
    public handlePayosCancel = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
            const { orderCode } = req.query;
            console.log('PayOS cancel handler called with:', { orderCode });

            if (orderCode) {
                // Cancel the payment if it exists
                await this.paymentService.cancelPayment(orderCode.toString());
            }

            // Redirect to frontend with cancel status
            const frontendUrl = process.env.DOMAIN_FE || '/';
            const params = new URLSearchParams([
                ['code', '99'],
                ['orderCode', orderCode?.toString() || ''],
                ['status', 'cancelled']
            ]);
            res.redirect(`${frontendUrl.replace(/\/$/, '')}/payos?${params.toString()}`);
            return;
        } catch (error) {
            console.error('Error in handlePayosCancel:', error);
            const frontendUrl = process.env.DOMAIN_FE || '/';
            const params = new URLSearchParams([
                ['code', '99'],
                ['status', 'error']
            ]);
            res.redirect(`${frontendUrl.replace(/\/$/, '')}/payos?${params.toString()}`);
        }
    };

    // Tạo thanh toán cho lịch hẹn xét nghiệm DNA
    public createAppointmentPayment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                res.status(HttpStatus.Unauthorized).json(
                    formatResponse(false, true, 'User not authenticated')
                );
                return;
            }

            const paymentData: CreateAppointmentPaymentDto = req.body;

            // If sample_ids is not provided, it will be handled in the service
            // by automatically fetching all samples for the appointment

            const result = await this.paymentService.createAppointmentPayment(userId, paymentData);

            res.status(HttpStatus.Success).json(
                formatResponse(result, true, 'Appointment payment created successfully')
            );
        } catch (error) {
            next(error);
        }
    };

    // Xác minh trạng thái thanh toán với PayOS
    public verifyPayment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { paymentNo } = req.params;
            const result = await this.paymentService.verifyPaymentStatus(paymentNo);

            res.status(HttpStatus.Success).json(
                formatResponse(result, true, 'Payment verification completed')
            );
        } catch (error) {
            next(error);
        }
    };

    // Hủy thanh toán đang ở trạng thái pending
    public cancelPayment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { paymentNo } = req.params;
            const result = await this.paymentService.cancelPayment(paymentNo);

            res.status(HttpStatus.Success).json(
                formatResponse(result, true, result.message)
            );
        } catch (error) {
            next(error);
        }
    };

    // Xử lý callback thành công từ PayOS
    public handlePaymentSuccess = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { orderCode, amount, status } = req.query;
            console.log('Payment success handler called with:', { orderCode, amount, status });

            if (!orderCode) {
                console.error('Missing orderCode in payment success callback');
                return res.redirect(process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed');
            }

            // Verify the payment status
            const result = await this.paymentService.verifyPaymentStatus(orderCode.toString());

            if (result.payment_status === 'completed') {
                console.log(`Payment ${orderCode} verified as completed`);

                // Get frontend success URL from environment or use default
                const successUrl = process.env.FRONTEND_PAYMENT_SUCCESS_URL || '/payments/success';

                // Add payment info to URL if needed
                const redirectUrl = `${successUrl}?orderCode=${orderCode}&status=success`;

                // Redirect to frontend success page
                return res.redirect(redirectUrl);
            } else {
                console.log(`Payment ${orderCode} verification failed or payment not completed`);

                // If payment verification failed, check if we should retry
                if (result.payment_status === 'pending') {
                    // Payment is still pending, we can show a processing page
                    const pendingUrl = process.env.FRONTEND_PAYMENT_PENDING_URL || '/payments/pending';
                    return res.redirect(`${pendingUrl}?orderCode=${orderCode}`);
                } else {
                    // Payment failed or was cancelled
                    const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
                    return res.redirect(`${failedUrl}?orderCode=${orderCode}&status=${result.payment_status}`);
                }
            }
        } catch (error) {
            console.error('Error in handlePaymentSuccess:', error);
            const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
            return res.redirect(`${failedUrl}?error=internal`);
        }
    };

    // Xử lý callback thất bại từ PayOS
    public handlePaymentFailure = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { orderCode } = req.query;
            console.log('Payment failure handler called with:', { orderCode });

            if (orderCode) {
                // Cancel the payment if it exists
                await this.paymentService.cancelPayment(orderCode.toString());
            }

            // Redirect to frontend failed page
            const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
            return res.redirect(`${failedUrl}?orderCode=${orderCode || 'unknown'}&status=cancelled`);
        } catch (error) {
            console.error('Error in handlePaymentFailure:', error);
            const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
            return res.redirect(`${failedUrl}?error=internal`);
        }
    };

    // Lấy danh sách mẫu xét nghiệm của thanh toán
    public getPaymentSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { paymentId } = req.params;
            const samples = await this.paymentService.getPaymentSamples(paymentId);

            res.status(HttpStatus.Success).json(
                formatResponse(samples, true, 'Samples retrieved successfully')
            );
        } catch (error) {
            next(error);
        }
    };
}



================================================
FILE: src/modules/payment/payment.enum.ts
================================================
export enum PaymentMethodEnum {
    CASH = 'cash',
    PAY_OS = 'pay_os',
    GOVERNMENT = 'government'
}

export enum PaymentStatusEnum {
    PENDING = 'pending',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled',
    FAILED = 'failed',
    REFUNDED = 'refunded'
} 


================================================
FILE: src/modules/payment/payment.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';

export type PaymentMethod =
    PaymentMethodEnum.CASH |
    PaymentMethodEnum.PAY_OS;

export type PaymentStatus =
    PaymentStatusEnum.PENDING |
    PaymentStatusEnum.COMPLETED |
    PaymentStatusEnum.FAILED |
    PaymentStatusEnum.CANCELLED |
    PaymentStatusEnum.REFUNDED;

export interface IPayment extends Document {
    _id: string;
    appointment_id: string | undefined;
    sample_ids?: string[] | undefined;
    amount: number;
    payment_no?: string;
    payment_method: PaymentMethod;
    status: PaymentStatus;
    balance_origin: number;
    payos_payment_id?: string;
    payos_payment_url?: string;
    payos_payment_status?: string;
    payos_order_code?: number;
    payos_web_id?: string;
    payos_payment_status_message?: string;
    payos_payment_status_code?: string;
    payos_payment_status_detail?: string;
    payos_payment_status_time?: Date;
    payos_webhook_received_at?: Date;

    payer_name?: string;
    payer_email?: string;
    payer_phone?: string;

    // // demo payOs
    // order_code?: string;
    // order_id?: string;
    // // end demo payOs

    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/payment/payment.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IPayment } from './payment.interface';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';

const PaymentSchemaEntity: Schema<IPayment> = new Schema({
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    sample_ids: [{ type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SAMPLE }],
    amount: { type: Number, required: true },
    payment_no: { type: String },
    payment_method: {
        type: String,
        enum: Object.values(PaymentMethodEnum),
        required: true
    },
    status: {
        type: String,
        enum: Object.values(PaymentStatusEnum),
        default: PaymentStatusEnum.PENDING
    },
    balance_origin: { type: Number, default: 0 },
    payos_payment_id: { type: String },
    payos_order_code: { type: Number },
    payos_web_id: { type: String },
    payos_payment_url: { type: String },
    payos_payment_status: { type: String },
    payos_payment_status_message: { type: String },
    payos_payment_status_code: { type: String },
    payos_payment_status_detail: { type: String },
    payos_payment_status_time: { type: Date },
    payer_name: { type: String },
    payer_email: { type: String },
    payer_phone: { type: String },

    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const PaymentSchema = mongoose.model<IPayment & mongoose.Document>(
    COLLECTION_NAME.PAYMENT,
    PaymentSchemaEntity
);

export default PaymentSchema; 


================================================
FILE: src/modules/payment/payment.route.ts
================================================
import { Router } from 'express';
import { IRoute } from '../../core/interfaces';
import PaymentController from './payment.controller';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { CreatePayosPaymentDto } from './dtos/createPayosPayment.dto';
import { CreateSamplePaymentDto } from './dtos/createSamplePayment.dto';
import { API_PATH } from '../../core/constants';
import { UserRoleEnum } from '../user/user.enum';
import { CreateAppointmentPaymentDto } from './dtos/createAppointmentPayment.dto';

export default class PaymentRoute implements IRoute {
    public path = API_PATH.PAYMENT;
    public router = Router();
    private paymentController = new PaymentController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {

        // POST: domain:/api/payments/webhook -> Handle PayOS webhook
        this.router.post(
            `${this.path}/webhook/payos`,
            this.paymentController.handlePayosWebhook as any
        );

        // GET: domain:/api/payments/payos-return -> Handle PayOS return
        this.router.get(
            `${this.path}/payos-return`,
            this.paymentController.handlePayosReturn.bind(this.paymentController)
        );

        // GET: domain:/api/payments/payos-cancel -> Handle PayOS cancel
        this.router.get(
            `${this.path}/payos-cancel`,
            this.paymentController.handlePayosCancel.bind(this.paymentController)
        );

        // POST: domain:/api/payments/appointment -> Create a payment for an appointment with selected payment method
        this.router.post(
            `${this.path}/appointment`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(CreateAppointmentPaymentDto),
            this.paymentController.createAppointmentPayment
        );

        // GET: domain:/api/payments/verify/:paymentNo -> Verify payment status
        this.router.get(
            `${this.path}/:paymentNo/verify`,
            authMiddleWare(),
            this.paymentController.verifyPayment
        );

        // POST: domain:/api/payments/cancel/:paymentNo -> Cancel payment
        this.router.post(
            `${this.path}/:paymentNo/cancel`,
            authMiddleWare(),
            this.paymentController.cancelPayment
        );

        // GET: domain:/api/payments/success -> Handle successful payment redirect
        this.router.get(
            `${this.path}/success`,
            this.paymentController.handlePaymentSuccess
        );

        // GET: domain:/api/payments/failed -> Handle failed payment redirect
        this.router.get(
            `${this.path}/failed`,
            this.paymentController.handlePaymentFailure
        );

        // GET: domain:/api/payments/:paymentId/samples -> Get samples for a payment
        this.router.get(
            `${this.path}/:paymentId/samples`,
            authMiddleWare(),
            this.paymentController.getPaymentSamples
        );

        // POST: domain:/api/payments/test-webhook-signature -> Generate test webhook signature (dev only)
        this.router.post(
            `${this.path}/test-webhook-signature`,
            this.paymentController.generateTestWebhookSignature as any
        );
    }
}



================================================
FILE: src/modules/payment/payment.service.ts
================================================
import { v4 as uuidv4 } from 'uuid';
import moment from 'moment';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { createPayosPayment, verifyPayosWebhook } from './payment.util';
import PaymentSchema from './payment.model';
import AppointmentSchema from '../appointment/appointment.model';
import { AppointmentStatusEnum, PaymentStatusEnum as AppointmentPaymentStatusEnum } from '../appointment/appointment.enum';
import { TransactionSchema } from '../transaction';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';
import { CreatePayosPaymentDto } from './dtos/createPayosPayment.dto';
import { CreateWebhookDto } from './dtos/createWebhook.dto';
import { SampleService } from '../sample';
import { CreateAppointmentPaymentDto } from './dtos/createAppointmentPayment.dto';
import ServiceSchema from '../service/service.model';
import UserService from '../user/user.service';
import { sendMail, createNotificationEmailTemplate } from '../../core/utils';
import { ISendMailDetail } from '../../core/interfaces';
import { TransactionStatusEnum } from '../transaction/transaction.enum';

export default class PaymentService {
    private paymentSchema = PaymentSchema;
    private appointmentSchema = AppointmentSchema;
    private transactionSchema = TransactionSchema;
    private sampleService = new SampleService();
    private userService = new UserService();

    /**
     * Process PayOS Webhook - Fixed version with better error handling
     */
    public async processPayosWebhook(data: CreateWebhookDto): Promise<{ success: boolean; message: string }> {
        try {
            console.log('PayOS Webhook received:', JSON.stringify(data, null, 2));

            // Validate required webhook data
            if (!data.payment_no || !data.status) {
                console.error('PayOS Webhook: Missing required data (payment_no or status)');
                return { success: false, message: 'Invalid webhook data - missing required fields' };
            }

            // Verify webhook signature
            const receivedSignature = data.signature || '';
            if (!receivedSignature) {
                console.error('PayOS Webhook: Missing signature');
                return { success: false, message: 'Missing webhook signature' };
            }

            const isValidSignature = verifyPayosWebhook(data, receivedSignature);
            if (!isValidSignature) {
                console.error('PayOS Webhook: Invalid signature received');
                return { success: false, message: 'Invalid webhook signature' };
            }

            console.log('PayOS Webhook: Signature verified successfully');

            const { payment_no, amount, status } = data;
            console.log(`Processing PayOS webhook for payment ${payment_no} with status ${status}`);

            // Find the payment by payment_no or payos_order_code
            const payment = await this.paymentSchema.findOne({
                $or: [
                    { payment_no: payment_no },
                    { payos_order_code: parseInt(payment_no) || 0 }
                ]
            });

            if (!payment) {
                console.error(`PayOS Webhook: Payment not found: ${payment_no}`);
                return { success: false, message: 'Payment not found' };
            }

            // Verify amount if provided
            if (amount && payment.amount !== Number(amount)) {
                console.error(`PayOS Webhook: Amount mismatch. Expected: ${payment.amount}, Received: ${amount}`);
                return { success: false, message: 'Amount mismatch' };
            }

            // Update payment with webhook received timestamp
            payment.payos_webhook_received_at = new Date();
            payment.updated_at = new Date();

            // Process based on status
            if (status === TransactionStatusEnum.SUCCESS || status === 'PAID') {
                console.log(`Payment ${payment_no} successful, recording webhook data`);

                // Update payment webhook data
                payment.payos_payment_status = TransactionStatusEnum.SUCCESS;
                payment.payos_payment_status_time = new Date();

                // NEW: Mark payment as completed if not already and update appointment status to PAID
                let appointment: any = undefined;
                if (payment.status !== PaymentStatusEnum.COMPLETED) {
                    payment.status = PaymentStatusEnum.COMPLETED;
                    appointment = await this.appointmentSchema.findByIdAndUpdate(
                        payment.appointment_id,
                        { payment_status: AppointmentPaymentStatusEnum.PAID },
                        { new: true }
                    );
                }

                await payment.save();

                // Send success email notification (only once)
                try {
                    if (!appointment) {
                        // Fetch appointment if we didn't update it above
                        appointment = await this.appointmentSchema.findById(payment.appointment_id);
                    }
                    if (appointment) {
                        await this.sendPaymentSuccessEmail(payment, appointment);
                    }
                } catch (emailErr) {
                    console.error('Failed to send payment success email:', emailErr);
                }

                // Create/update transactions for tracking (without changing payment status)
                if (payment.sample_ids && payment.sample_ids.length > 0) {
                    const transactionPromises = payment.sample_ids.map(async (sampleId) => {
                        return await this.transactionSchema.findOneAndUpdate(
                            {
                                payment_id: payment._id,
                                sample_id: sampleId
                            },
                            {
                                payment_id: payment._id,
                                receipt_number: `${payment_no}-${sampleId.toString().substring(0, 6)}`,
                                transaction_date: new Date(),
                                sample_id: sampleId,
                                payos_transaction_id: payment.payos_payment_id,
                                payos_payment_status: TransactionStatusEnum.SUCCESS,
                                payos_payment_status_time: new Date(),
                                payos_webhook_received_at: new Date(),
                                updated_at: new Date(),
                            },
                            {
                                upsert: true,
                                new: true,
                                setDefaultsOnInsert: true
                            }
                        );
                    });

                    try {
                        const transactions = await Promise.all(transactionPromises);
                        console.log(`Created/updated ${transactions.length} transactions for payment ${payment_no}`);
                    } catch (transactionError) {
                        console.error(`Error creating transactions for payment ${payment_no}:`, transactionError);
                    }
                }

                console.log(`Payment webhook ${payment_no} processed successfully - webhook data recorded`);
                return { success: true, message: 'Payment webhook processed successfully' };

            } else if (status === TransactionStatusEnum.FAILED || status === 'CANCELLED') {
                console.log(`Payment ${payment_no} failed/cancelled with status ${status}`);

                // Update payment webhook data (but not status as requested)
                payment.payos_payment_status = status;
                payment.payos_payment_status_time = new Date();
                await payment.save();

                // Update any existing transactions webhook data
                if (payment.sample_ids && payment.sample_ids.length > 0) {
                    await this.transactionSchema.updateMany(
                        { payment_id: payment._id },
                        {
                            payos_payment_status: status,
                            payos_payment_status_time: new Date(),
                            payos_webhook_received_at: new Date(),
                            updated_at: new Date(),
                        }
                    );
                }

                console.log(`Payment webhook ${payment_no} processed - failure status recorded`);
                return { success: true, message: 'Payment webhook processed - failure recorded' };

            } else {
                console.log(`Payment ${payment_no} webhook received with unknown status: ${status}`);

                // Still update webhook received time
                payment.payos_payment_status = status;
                payment.payos_payment_status_time = new Date();
                await payment.save();

                return { success: true, message: `Webhook processed - status: ${status}` };
            }

        } catch (error) {
            console.error('PayOS Webhook processing error:', error);
            return { success: false, message: 'Internal webhook processing error' };
        }
    }

    /**
     * Create payment for appointment with selected payment method
     * @param userId ID of the user making the payment
     * @param paymentData Payment data including method and appointment ID
     * @returns Payment details including checkout URL if PAY_OS is selected
     */
    public async createAppointmentPayment(userId: string, paymentData: CreateAppointmentPaymentDto): Promise<{
        payment_no: string;
        payment_method: string;
        status: string;
        amount: number;
        checkout_url?: string;
    }> {
        try {
            // Validate appointment
            const appointment = await this.appointmentSchema.findById(paymentData.appointment_id);
            if (!appointment) {
                throw new HttpException(HttpStatus.BadRequest, 'Appointment not found');
            }

            // Check if user has permission
            if (appointment.user_id && appointment.user_id.toString() !== userId) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to pay for this appointment');
            }

            // Check if payment already exists
            const existingPayment = await this.paymentSchema.findOne({
                appointment_id: paymentData.appointment_id,
                status: { $in: [PaymentStatusEnum.COMPLETED, PaymentStatusEnum.PENDING] }
            });

            if (existingPayment) {
                throw new HttpException(HttpStatus.BadRequest, 'Payment already exists for this appointment');
            }

            // Get service price from appointment
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                throw new HttpException(HttpStatus.BadRequest, 'Service not found for this appointment');
            }

            const amount = service.price;
            if (amount <= 0) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid payment amount');
            }

            const paymentNo = `PAY-${uuidv4().substring(0, 8)}-${moment().format('HHmmss')}`;

            // Tự động lấy tất cả các mẫu dữ liệu liên quan đến cuộc hẹn
            const samples = await this.sampleService.getSamplesByAppointmentId(paymentData.appointment_id);
            if (!samples || samples.length === 0) {
                console.log(`No samples found for appointment ${paymentData.appointment_id}`);
            } else {
                console.log(`Found ${samples.length} samples for appointment ${paymentData.appointment_id}`);
            }

            // Lưu danh sách ID mẫu
            const sampleIds = samples.map(sample => sample._id.toString());

            const payment = await this.paymentSchema.create({
                appointment_id: paymentData.appointment_id,
                sample_ids: sampleIds,
                amount: amount,
                payment_no: paymentNo,
                payment_method: paymentData.payment_method,
                status: PaymentStatusEnum.PENDING,
                balance_origin: 0,
                created_at: new Date(),
                updated_at: new Date(),
            });

            // Update appointment payment status
            await this.appointmentSchema.findByIdAndUpdate(
                paymentData.appointment_id,
                { payment_status: AppointmentPaymentStatusEnum.UNPAID },
                { new: true }
            );

            // Send payment initiated email
            try {
                await this.sendPaymentInitiatedEmail(payment, appointment, userId);
            } catch (emailError) {
                console.error('Failed to send payment initiated email:', emailError);
            }

            // Immediately verify payment for CASH (and mark as completed, update appointment, create transaction)
            if (paymentData.payment_method === PaymentMethodEnum.CASH) {
                await this.verifyPaymentStatus(paymentNo);
            }

            // Return result based on payment method
            const result = {
                payment_no: paymentNo,
                payment_method: paymentData.payment_method,
                status: PaymentStatusEnum.PENDING,
                amount: amount,
            };

            // If PAY_OS, generate checkout URL
            if (paymentData.payment_method === PaymentMethodEnum.PAY_OS) {
                // Get user information for payment
                const user = await this.userService.getUserById(userId);

                const description = `Thanh toán ${paymentNo}`;
                const { checkoutUrl, orderCode } = await createPayosPayment(
                    amount,
                    paymentNo,
                    description,
                    `${user.first_name || ''} ${user.last_name || ''}`.trim(),
                    user.email || '',
                    user.phone_number || ''
                );

                const payosWebId = checkoutUrl.split('/web/')[1];

                await this.paymentSchema.findByIdAndUpdate(
                    payment._id,
                    {
                        payos_payment_url: checkoutUrl,
                        payment_no: paymentNo,
                        payos_order_code: orderCode,
                        payos_web_id: payosWebId
                    },
                    { new: true }
                );

                return {
                    ...result,
                    checkout_url: checkoutUrl
                };
            }

            // For CASH payment, no checkout URL is needed
            return result;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating appointment payment');
        }
    }

    /**
     * Verify payment status - Fixed version with proper PayOS API integration
     */
    public async verifyPaymentStatus(paymentIdentifier: string): Promise<{
        payment_status: string;
        appointment_id: string;
        paymentNo: string;
        payos_status?: string;
        last_verified_at?: Date;
    }> {
        try {
            console.log(`Verifying payment status for: ${paymentIdentifier}`);

            // Try to find payment by payment_no first
            let payment = await this.paymentSchema.findOne({ payment_no: paymentIdentifier });

            // If not found, try by payos_order_code (number)
            if (!payment && /^\d+$/.test(paymentIdentifier)) {
                payment = await this.paymentSchema.findOne({ payos_order_code: parseInt(paymentIdentifier, 10) });
            }

            if (!payment) {
                throw new HttpException(HttpStatus.NotFound, 'Payment not found');
            }

            console.log(`Found payment: ${payment._id}, current status: ${payment.status}, method: ${payment.payment_method}`);

            // For cash payments, just return current status without changing anything
            if (payment.payment_method === PaymentMethodEnum.CASH) {
                console.log(`Cash payment - returning current status: ${payment.status}`);
                return {
                    paymentNo: payment.payment_no || paymentIdentifier,
                    payment_status: payment.status,
                    appointment_id: payment.appointment_id || '',
                    last_verified_at: new Date()
                };
            }

            // For PayOS payments, check with PayOS API if we have order code
            if (payment.payment_method === PaymentMethodEnum.PAY_OS && payment.payos_order_code) {
                try {
                    console.log(`Checking PayOS status for order code: ${payment.payos_order_code}`);

                    // Get PayOS client instance
                    const PayOS = require('@payos/node');
                    const payosClient = new PayOS(
                        process.env.PAYOS_CLIENT_ID,
                        process.env.PAYOS_API_KEY,
                        process.env.PAYOS_CHECKSUM_KEY
                    );

                    // Query PayOS for payment information
                    const payosResponse = await payosClient.getPaymentLinkInformation(payment.payos_order_code);
                    console.log(`PayOS API response:`, JSON.stringify(payosResponse, null, 2));

                    // Update payment with latest PayOS status (without changing main status)
                    const updateData: any = {
                        payos_payment_status: payosResponse.status,
                        payos_payment_status_time: new Date(),
                        updated_at: new Date()
                    };

                    // Add additional PayOS data if available
                    if (payosResponse.transactions && payosResponse.transactions.length > 0) {
                        const transaction = payosResponse.transactions[0];
                        updateData.payos_payment_status_message = transaction.description;
                        updateData.payos_payment_status_code = transaction.counterAccountNumber;
                    }

                    await this.paymentSchema.findByIdAndUpdate(payment._id, updateData);

                    console.log(`PayOS verification complete - PayOS status: ${payosResponse.status}, Local status: ${payment.status}`);

                    // If PayOS confirms payment (PAID/SUCCESS) and local status not completed, update both payment and appointment
                    const payosStatusUpper = (payosResponse.status || '').toString().toUpperCase();
                    if ((payosStatusUpper === 'PAID' || payosStatusUpper === 'SUCCESS' || payosStatusUpper === 'COMPLETED') && payment.status !== PaymentStatusEnum.COMPLETED) {
                        // Mark payment as completed
                        await this.paymentSchema.findByIdAndUpdate(payment._id, {
                            status: PaymentStatusEnum.COMPLETED,
                            updated_at: new Date()
                        });

                        // Mark appointment as paid
                        try {
                            await this.appointmentSchema.findByIdAndUpdate(
                                payment.appointment_id,
                                { payment_status: AppointmentPaymentStatusEnum.PAID },
                                { new: true }
                            );
                        } catch (appErr) {
                            console.error('Failed to update appointment payment_status to PAID:', appErr);
                        }
                    }

                    return {
                        paymentNo: payment.payment_no || paymentIdentifier,
                        payment_status: payment.status, // Return local status, not PayOS status
                        appointment_id: payment.appointment_id || '',
                        payos_status: payosResponse.status,
                        last_verified_at: new Date()
                    };

                } catch (payosError: any) {
                    console.error(`PayOS API error for payment ${paymentIdentifier}:`, payosError.message);

                    // If PayOS API fails, return current local status
                    return {
                        paymentNo: payment.payment_no || paymentIdentifier,
                        payment_status: payment.status,
                        appointment_id: payment.appointment_id || '',
                        payos_status: 'API_ERROR',
                        last_verified_at: new Date()
                    };
                }
            }

            // For other payment methods or PayOS without order code, return current status
            console.log(`Returning current payment status: ${payment.status}`);
            return {
                paymentNo: payment.payment_no || paymentIdentifier,
                payment_status: payment.status,
                appointment_id: payment.appointment_id || '',
                last_verified_at: new Date()
            };

        } catch (error) {
            console.error(`Error verifying payment ${paymentIdentifier}:`, error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error verifying payment status');
        }
    }

    /**
     * Cancel payment
     * @param paymentNo Payment number to cancel
     * @returns Cancelled payment status
     */
    public async cancelPayment(paymentNo: string): Promise<{
        success: boolean;
        message: string;
    }> {
        try {
            const payment = await this.paymentSchema.findOne({
                $or: [
                    { payment_no: paymentNo },
                    { order_code: paymentNo }
                ],
                status: PaymentStatusEnum.PENDING
            });

            if (!payment) {
                throw new HttpException(HttpStatus.NotFound, 'Pending payment not found');
            }

            // Update payment status to failed
            payment.status = PaymentStatusEnum.FAILED;
            payment.updated_at = new Date();
            await payment.save();

            // Update appointment payment status to failed
            const appointment = await this.appointmentSchema.findByIdAndUpdate(
                payment.appointment_id,
                { payment_status: AppointmentPaymentStatusEnum.FAILED },
                { new: true }
            );

            // Send payment cancelled email
            try {
                if (appointment) {
                    await this.sendPaymentCancelledEmail(payment, appointment);
                }
            } catch (emailError) {
                console.error('Failed to send payment cancelled email:', emailError);
            }

            return {
                success: true,
                message: 'Payment cancelled successfully'
            };
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error cancelling payment');
        }
    }

    /**
     * Get samples for a payment
     * @param paymentId ID of the payment
     * @returns Array of samples associated with the payment
     */
    public async getPaymentSamples(paymentId: string): Promise<any[]> {
        try {
            const payment = await this.paymentSchema.findById(paymentId);
            if (!payment) {
                throw new HttpException(HttpStatus.NotFound, 'Payment not found');
            }

            if (!payment.sample_ids || payment.sample_ids.length === 0) {
                // If no sample IDs are stored in the payment, fetch all samples for the appointment
                return await this.sampleService.getSamplesByAppointmentId(payment.appointment_id || '');
            }

            // Fetch samples by their IDs
            const samples = [];
            for (const sampleId of payment.sample_ids) {
                try {
                    const sample = await this.sampleService.getSampleById(sampleId.toString());
                    samples.push(sample);
                } catch (error: any) {
                    console.error(`Error fetching sample ${sampleId}: ${error.message}`);
                    // Continue with the next sample
                }
            }

            return samples;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching samples for payment');
        }
    }

    public async findPaymentByOrderCode(orderCode: number) {
        return this.paymentSchema.findOne({ payos_order_code: orderCode });
    }

    /**
     * Send email notification for payment initiation
     */
    private async sendPaymentInitiatedEmail(payment: any, appointment: any, userId: string): Promise<void> {
        try {
            // Get user details
            const user = await this.userService.getUserById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Initiated';
            let message = `
                Your payment for ${service.name} has been initiated.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br><br>
            `;

            // Add specific instructions based on payment method
            if (payment.payment_method === PaymentMethodEnum.PAY_OS) {
                message += `
                    Please complete your payment by clicking on the checkout link that has been provided.
                    <br>
                    The payment link will expire in 15 minutes.
                `;
            } else if (payment.payment_method === PaymentMethodEnum.CASH) {
                message += `
                    Please prepare the exact amount for your appointment.
                    <br>
                    You will need to pay in cash when you arrive at our facility.
                `;
            }

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Initiated - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment initiated email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment initiated email:', error);
        }
    }

    /**
     * Send email notification for successful payment
     */
    private async sendPaymentSuccessEmail(payment: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await this.userService.getUserById(userId.toString());
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Successful';
            const message = `
                Your payment for ${service.name} has been successfully processed.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br>
                Payment Date: ${new Date().toLocaleString()}
                <br><br>
                Your appointment is now confirmed and our team will proceed with the next steps.
                <br><br>
                Thank you for choosing our services.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Successful - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment success email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment success email:', error);
        }
    }

    /**
     * Send email notification for failed payment
     */
    private async sendPaymentFailedEmail(payment: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await this.userService.getUserById(userId.toString());
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Failed';
            const message = `
                Your payment for ${service.name} could not be processed.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br><br>
                Please try again or contact our support team for assistance.
                <br><br>
                If you believe this is an error, please contact us immediately.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Failed - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment failed email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment failed email:', error);
        }
    }

    /**
     * Send email notification for cancelled payment
     */
    private async sendPaymentCancelledEmail(payment: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await this.userService.getUserById(userId.toString());
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Cancelled';
            const message = `
                Your payment for ${service.name} has been cancelled.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br><br>
                If you would like to proceed with your appointment, please make a new payment.
                <br><br>
                If you did not cancel this payment, please contact our support team immediately.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Cancelled - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment cancelled email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment cancelled email:', error);
        }
    }

    /**
     * Create payment for ADMINISTRATIVE appointment (government paid)
     */
    public async createAdministrativePayment(appointmentId: string, userId: string) {
        // Kiểm tra đã có payment chưa
        const existing = await this.paymentSchema.findOne({ appointment_id: appointmentId });
        if (existing) return existing;
        return this.paymentSchema.create({
            appointment_id: appointmentId,
            user_id: userId,
            amount: 0,
            method: PaymentMethodEnum.GOVERNMENT,
            status: PaymentStatusEnum.COMPLETED,
            created_at: new Date(),
            updated_at: new Date()
        });
    }
}


================================================
FILE: src/modules/payment/payment.util.ts
================================================
import PayOS from '@payos/node';
import dotenv from 'dotenv';
import crypto from 'crypto';

dotenv.config();

// PayOS credentials
const clientId = process.env.PAYOS_CLIENT_ID;
const apiKey = process.env.PAYOS_API_KEY;
const checksumKey = process.env.PAYOS_CHECKSUM_KEY;

// Validate credentials
if (!clientId || !apiKey || !checksumKey) {
    throw new Error('Missing PayOS configuration: CLIENT_ID, API_KEY, or CHECKSUM_KEY');
}

// Initialize PayOS client
const payosClient = new PayOS(clientId, apiKey, checksumKey);

/**
 * Create a payment link using PayOS
 */
export async function createPayosPayment(
    amount: number,
    orderCode?: string,
    description?: string,
    buyerName?: string,
    buyerEmail?: string,
    buyerPhone?: string
): Promise<{ checkoutUrl: string, orderCode: number }> {
    try {
        // Validate input
        if (!amount || amount < 1000) {
            throw new Error('Amount must be a positive integer >= 1000 VND');
        }
        if (!orderCode) {
            throw new Error('Order code is required');
        }
        if (!description) {
            throw new Error('Description is required');
        }
        // Giới hạn description tối đa 25 ký tự
        const trimmedDescription = description.length > 25 ? description.substring(0, 25) : description;
        if (description.length > 25) {
            console.warn(`Description truncated to 25 characters: ${trimmedDescription}`);
        }

        // Convert order code to number
        const numericOrderCode = parseInt(orderCode.replace(/\D/g, ''), 10) || Math.floor(Date.now() / 1000);

        // Create payment data
        const paymentData = {
            amount: Math.floor(amount),
            orderCode: numericOrderCode,
            description: trimmedDescription,
            ...(buyerName && { buyerName }),
            ...(buyerEmail && { buyerEmail }),
            ...(buyerPhone && { buyerPhone }),
            cancelUrl: process.env.PAYOS_CANCEL_URL || '',
            returnUrl: process.env.PAYOS_RETURN_URL || '',
            items: [
                {
                    name: trimmedDescription,
                    quantity: 1,
                    price: Math.floor(amount),
                },
            ],
        };

        console.log('PayOS Request:', paymentData);

        // Get payment link
        const response = await payosClient.createPaymentLink(paymentData);

        console.log('PayOS Response:', response);

        if (response && response.checkoutUrl && response.orderCode) {
            return { checkoutUrl: response.checkoutUrl, orderCode: response.orderCode };
        }

        throw new Error('Invalid PayOS response: Missing checkoutUrl or orderCode');
    } catch (error: any) {
        console.error('PayOS Error:', {
            message: error.message,
            response: error.response?.data,
            code: error.code,
        });
        throw new Error(`Failed to create payment link: ${error.message}`);
    }
}

/**
 * Verify webhook signature - Fixed and simplified version
 */
export function verifyPayosWebhook(data: any, receivedSignature: string): boolean {
    try {
        // Validate inputs
        if (!checksumKey) {
            console.error('PayOS webhook verification: Missing checksum key');
            return false;
        }

        if (!receivedSignature) {
            console.error('PayOS webhook verification: Missing signature');
            return false;
        }

        // Create a copy of data without the signature field
        const { signature, ...dataWithoutSignature } = data;

        // Sort keys alphabetically and create consistent string representation
        const sortedKeys = Object.keys(dataWithoutSignature).sort();
        const sortedData: any = {};

        for (const key of sortedKeys) {
            sortedData[key] = dataWithoutSignature[key];
        }

        // Convert to JSON string for signature calculation
        const jsonString = JSON.stringify(sortedData);

        // Create HMAC signature using SHA256
        const hmac = crypto.createHmac('sha256', checksumKey);
        hmac.update(jsonString);
        const calculatedSignature = hmac.digest('hex');

        // If lengths differ, signature is definitely invalid – avoid timingSafeEqual error
        if (calculatedSignature.length !== receivedSignature.length) {
            console.error('PayOS webhook verification failed: Signature length mismatch');
            return false;
        }

        // Compare signatures using secure comparison
        let isValid = false;
        try {
            isValid = crypto.timingSafeEqual(
                Buffer.from(calculatedSignature, 'hex'),
                Buffer.from(receivedSignature, 'hex')
            );
        } catch (cmpErr: any) {
            console.error('PayOS webhook verification error during comparison:', cmpErr.message);
            return false;
        }

        if (!isValid) {
            console.error('PayOS webhook verification failed: Signature mismatch');
            console.error('Data used for verification:', jsonString);
        } else {
            console.log('PayOS webhook signature verified successfully');
        }

        return isValid;

    } catch (error: any) {
        console.error('PayOS webhook verification error:', error.message);
        return false;
    }
}

/**
 * Generate signature for testing purposes
 */
export function generatePayosSignature(data: any): string {
    try {
        if (!checksumKey) {
            console.error('Missing checksum key for signature generation');
            return '';
        }

        // Remove any existing signature field
        const { signature: _, ...dataWithoutSignature } = data;

        // Sort keys alphabetically
        const sortedKeys = Object.keys(dataWithoutSignature).sort();
        const sortedData: any = {};

        for (const key of sortedKeys) {
            sortedData[key] = dataWithoutSignature[key];
        }

        // Convert to JSON string
        const jsonString = JSON.stringify(sortedData);

        // Create HMAC signature using SHA256
        const hmac = crypto.createHmac('sha256', checksumKey);
        hmac.update(jsonString);
        const generatedSignature = hmac.digest('hex');

        console.log('Generated PayOS signature for data:', jsonString);
        return generatedSignature;

    } catch (error: any) {
        console.error('Error generating PayOS signature:', error.message);
        return '';
    }
}

// Remove the old generateTestSignature function and replace with the new one
export { generatePayosSignature as generateTestSignature };


================================================
FILE: src/modules/payment/dtos/createAppointmentPayment.dto.ts
================================================
import { IsNotEmpty, IsString, IsEnum, IsArray, IsOptional, ArrayNotEmpty, IsNumber, Min } from 'class-validator';
import { PaymentMethodEnum } from '../payment.enum';
import { Schema } from 'mongoose';

/**
 * DTO tạo thanh toán cho lịch hẹn khám
 * Định nghĩa dữ liệu cần thiết để tạo một giao dịch thanh toán cho cuộc hẹn xét nghiệm DNA
 */
export class CreateAppointmentPaymentDto {
    // ID của lịch hẹn cần thanh toán - Bắt buộc
    @IsNotEmpty({ message: 'ID lịch hẹn không được để trống' })
    @IsString({ message: 'ID lịch hẹn phải là chuỗi ký tự' })
    appointment_id!: string;

    // Phương thức thanh toán (CASH - tiền mặt, PAY_OS - thanh toán online)
    @IsNotEmpty({ message: 'Phương thức thanh toán không được để trống' })
    @IsEnum(PaymentMethodEnum, { message: 'Phương thức thanh toán không hợp lệ' })
    payment_method!: PaymentMethodEnum;

    // Danh sách ID mẫu xét nghiệm cần thanh toán - Tùy chọn
    // Nếu không cung cấp, hệ thống sẽ tự động lấy tất cả mẫu của lịch hẹn
    @IsOptional()
    @IsArray({ message: 'Danh sách ID mẫu phải là một mảng' })
    @IsString({ each: true, message: 'Mỗi ID mẫu phải là chuỗi ký tự' })
    sample_ids?: string[];

    // Số tiền tùy chỉnh - Tùy chọn, nếu không cung cấp sẽ tính tự động
    @IsOptional()
    @IsNumber({}, { message: 'Số tiền phải là số' })
    @Min(1000, { message: 'Số tiền tối thiểu là 1,000 VND' })
    custom_amount?: number;

    // Ghi chú thanh toán - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Ghi chú phải là chuỗi ký tự' })
    note?: string;

    // Thông tin người thanh toán - Tùy chọn cho PayOS
    @IsOptional()
    @IsString({ message: 'Tên người thanh toán phải là chuỗi ký tự' })
    payer_name?: string;

    // Email người thanh toán - Tùy chọn cho PayOS
    @IsOptional()
    @IsString({ message: 'Email người thanh toán phải là chuỗi ký tự' })
    payer_email?: string;

    // Số điện thoại người thanh toán - Tùy chọn cho PayOS
    @IsOptional()
    @IsString({ message: 'Số điện thoại người thanh toán phải là chuỗi ký tự' })
    payer_phone?: string;
} 


================================================
FILE: src/modules/payment/dtos/createPayosPayment.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsOptional, Min, MaxLength, IsEmail, Matches } from 'class-validator';

/**
 * DTO tạo thanh toán PayOS
 * Định nghĩa dữ liệu cần thiết để tạo link thanh toán online qua cổng PayOS
 */
export class CreatePayosPaymentDto {
    constructor(
        amount: number,
        order_code: string,
        description: string,
        buyer_name?: string,
        buyer_email?: string,
        buyer_phone?: string,
        appointment_id?: string
    ) {
        this.amount = amount;
        this.order_code = order_code;
        this.description = description;
        this.buyer_name = buyer_name;
        this.buyer_email = buyer_email;
        this.buyer_phone = buyer_phone;
        this.appointment_id = appointment_id;
    }

    // Số tiền thanh toán - Bắt buộc, tối thiểu 1,000 VND theo quy định PayOS
    @IsNotEmpty({ message: 'Số tiền thanh toán không được để trống' })
    @IsNumber({}, { message: 'Số tiền phải là một số hợp lệ' })
    @Min(1000, { message: 'Số tiền tối thiểu là 1,000 VND' })
    amount: number;

    // ID lịch hẹn liên quan - Tùy chọn, để liên kết thanh toán với lịch hẹn
    @IsOptional()
    @IsString({ message: 'ID lịch hẹn phải là chuỗi ký tự' })
    appointment_id?: string;

    // Mã đơn hàng duy nhất - Bắt buộc, được tạo tự động bởi hệ thống
    @IsNotEmpty({ message: 'Mã đơn hàng không được để trống' })
    @IsString({ message: 'Mã đơn hàng phải là chuỗi ký tự' })
    @MaxLength(50, { message: 'Mã đơn hàng không được quá 50 ký tự' })
    order_code: string;

    // Mô tả giao dịch - Bắt buộc, hiển thị cho người dùng
    @IsNotEmpty({ message: 'Mô tả giao dịch không được để trống' })
    @IsString({ message: 'Mô tả giao dịch phải là chuỗi ký tự' })
    @MaxLength(25, { message: 'Mô tả không được quá 25 ký tự theo quy định PayOS' })
    description: string;

    // Tên người mua - Tùy chọn, hiển thị trên giao diện thanh toán
    @IsOptional()
    @IsString({ message: 'Tên người mua phải là chuỗi ký tự' })
    @MaxLength(100, { message: 'Tên người mua không được quá 100 ký tự' })
    buyer_name?: string;

    // Email người mua - Tùy chọn, để gửi hóa đơn điện tử
    @IsOptional()
    @IsString({ message: 'Email phải là chuỗi ký tự' })
    @IsEmail({}, { message: 'Email không đúng định dạng' })
    buyer_email?: string;

    // Số điện thoại người mua - Tùy chọn, để liên hệ xác nhận
    @IsOptional()
    @IsString({ message: 'Số điện thoại phải là chuỗi ký tự' })
    @Matches(/^[0-9+\-\s()]{10,15}$/, { message: 'Số điện thoại không đúng định dạng' })
    buyer_phone?: string;
}


================================================
FILE: src/modules/payment/dtos/createSamplePayment.dto.ts
================================================
import { IsNumber, Min, IsNotEmpty, IsOptional, IsString, MaxLength } from 'class-validator';

/**
 * DTO tạo thanh toán mẫu xét nghiệm
 * Định nghĩa dữ liệu cần thiết để tạo thanh toán cho các mẫu xét nghiệm riêng lẻ
 */
export class CreateSamplePaymentDto {
    // Số tiền thanh toán - Bắt buộc, tối thiểu 1,000 VND
    @IsNotEmpty({ message: 'Số tiền thanh toán không được để trống' })
    @IsNumber({}, { message: 'Số tiền phải là một số hợp lệ' })
    @Min(1000, { message: 'Số tiền tối thiểu là 1,000 VND' })
    amount: number;

    // ID mẫu xét nghiệm - Tùy chọn, để liên kết thanh toán với mẫu cụ thể
    @IsOptional()
    @IsString({ message: 'ID mẫu xét nghiệm phải là chuỗi ký tự' })
    sample_id?: string;

    // Ghi chú thanh toán - Tùy chọn, mô tả thêm về thanh toán
    @IsOptional()
    @IsString({ message: 'Ghi chú phải là chuỗi ký tự' })
    @MaxLength(500, { message: 'Ghi chú không được quá 500 ký tự' })
    note?: string;

    constructor(amount: number, sample_id?: string, note?: string) {
        this.amount = amount;
        this.sample_id = sample_id;
        this.note = note;
    }
} 


================================================
FILE: src/modules/payment/dtos/createWebhook.dto.ts
================================================
import { IsNotEmpty, IsOptional, IsString, IsNumber, IsDateString } from 'class-validator';

/**
 * DTO xử lý webhook từ PayOS
 * Định nghĩa cấu trúc dữ liệu nhận từ webhook PayOS khi có sự thay đổi trạng thái thanh toán
 */
export class CreateWebhookDto {
    // Mã số thanh toán - Bắt buộc phải có trong mọi webhook
    @IsNotEmpty({ message: 'Mã thanh toán không được để trống' })
    @IsString({ message: 'Mã thanh toán phải là chuỗi ký tự' })
    payment_no!: string;

    // Số tiền thanh toán - Tùy chọn, PayOS có thể gửi hoặc không
    @IsOptional()
    @IsString({ message: 'Số tiền phải là chuỗi ký tự' })
    amount?: string;

    // Trạng thái thanh toán - Bắt buộc để biết kết quả thanh toán
    @IsNotEmpty({ message: 'Trạng thái thanh toán không được để trống' })
    @IsString({ message: 'Trạng thái thanh toán phải là chuỗi ký tự' })
    status!: string;

    // Chữ ký điện tử để xác thực webhook từ PayOS - Bắt buộc cho bảo mật
    @IsNotEmpty({ message: 'Chữ ký xác thực không được để trống' })
    @IsString({ message: 'Chữ ký xác thực phải là chuỗi ký tự' })
    signature!: string;

    // Mã đơn hàng số từ PayOS - Tùy chọn
    @IsOptional()
    @IsNumber({}, { message: 'Mã đơn hàng phải là số' })
    orderCode?: number;

    // Mô tả giao dịch - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Mô tả phải là chuỗi ký tự' })
    description?: string;

    // Số tài khoản người thanh toán - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Số tài khoản phải là chuỗi ký tự' })
    accountNumber?: string;

    // Mã tham chiếu giao dịch - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Mã tham chiếu phải là chuỗi ký tự' })
    reference?: string;

    // Thời gian thực hiện giao dịch - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Thời gian giao dịch phải là chuỗi ký tự' })
    transactionDateTime?: string;

    // Đơn vị tiền tệ (VND, USD...) - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Đơn vị tiền tệ phải là chuỗi ký tự' })
    currency?: string;

    // ID liên kết thanh toán từ PayOS - Tùy chọn
    @IsOptional()
    @IsString({ message: 'ID liên kết thanh toán phải là chuỗi ký tự' })
    paymentLinkId?: string;

    // Mã phản hồi từ PayOS - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Mã phản hồi phải là chuỗi ký tự' })
    code?: string;

    // Mô tả chi tiết phản hồi - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Mô tả phản hồi phải là chuỗi ký tự' })
    desc?: string;

    // ID ngân hàng của tài khoản nhận - Tùy chọn
    @IsOptional()
    @IsString({ message: 'ID ngân hàng phải là chuỗi ký tự' })
    counterAccountBankId?: string;

    // Tên ngân hàng của tài khoản nhận - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Tên ngân hàng phải là chuỗi ký tự' })
    counterAccountBankName?: string;

    // Tên chủ tài khoản nhận - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Tên chủ tài khoản phải là chuỗi ký tự' })
    counterAccountName?: string;

    // Số tài khoản nhận - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Số tài khoản nhận phải là chuỗi ký tự' })
    counterAccountNumber?: string;

    // Tên tài khoản ảo (nếu có) - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Tên tài khoản ảo phải là chuỗi ký tự' })
    virtualAccountName?: string;

    // Số tài khoản ảo (nếu có) - Tùy chọn
    @IsOptional()
    @IsString({ message: 'Số tài khoản ảo phải là chuỗi ký tự' })
    virtualAccountNumber?: string;
}



================================================
FILE: src/modules/payment/swagger/payment-webhook.md
================================================
# PayOS Webhook Handling Documentation

## Overview
This document describes the process flow for handling PayOS payment webhooks in the system.

## Webhook Flow

1. **Webhook Received**
   - PayOS sends a webhook notification to our API endpoint (`/api/payment/webhook`)
   - The webhook contains payment status information, amount, payment number, and a signature

2. **Signature Verification**
   - The system verifies the webhook signature using HMAC-SHA256
   - If the signature is invalid, the request is rejected

3. **Payment Lookup**
   - The system looks up the payment using the payment number
   - Verifies that the payment exists and is in PENDING or PROCESSING status
   - Validates that the amount matches the expected amount

4. **Payment Status Update**
   - If payment status is SUCCESS:
     - Updates payment status to COMPLETED
     - Updates appointment status to CONFIRMED and payment_status to PAID
     - Creates or updates transactions for each sample
     - Sends a payment success email to the customer

   - If payment status is FAILED or other:
     - Updates payment status to FAILED
     - Updates appointment payment status to FAILED
     - Updates any existing transactions to FAILED status
     - Sends a payment failed email to the customer

5. **Response**
   - Returns a success response to PayOS to acknowledge receipt

## Transaction Handling

For successful payments, the system creates a transaction record for each sample associated with the payment. If no samples are found, a single transaction record is created as a fallback.

Each transaction includes:
- Payment ID
- Receipt number (formatted as `{payment_no}-{sample_id_prefix}`)
- Transaction date
- Sample ID (if available)
- PayOS transaction ID
- Payment status and timestamp
- Webhook received timestamp

## Error Handling

The system implements comprehensive error handling:
- Invalid signatures are rejected
- Missing payments are reported
- Amount mismatches are detected
- Transaction creation errors are logged but don't block the process
- Email sending errors are logged but don't block the process

## Testing Webhooks

To test the webhook functionality:
1. Create a test payment using the PayOS sandbox environment
2. Use a tool like Postman to send a simulated webhook to the endpoint
3. Verify that the payment and appointment statuses are updated correctly
4. Check that transaction records are created
5. Verify that the appropriate email is sent 


================================================
FILE: src/modules/payment/swagger/payment.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     # ================== ENUM SCHEMAS ==================
 *     PaymentStatus:
 *       type: string
 *       enum: [pending, processing, completed, cancelled, failed, refunded]
 *       description: |
 *         Trạng thái thanh toán trong hệ thống:
 *         - pending: Đang chờ xử lý
 *         - processing: Đang được xử lý bởi cổng thanh toán
 *         - completed: Hoàn thành thành công
 *         - cancelled: Đã bị hủy
 *         - failed: Thất bại
 *         - refunded: Đã hoàn tiền
 *       example: completed
 *     
 *     PaymentMethod:
 *       type: string
 *       enum: [CASH, PAY_OS]
 *       description: |
 *         Phương thức thanh toán được hỗ trợ:
 *         - CASH: Thanh toán tiền mặt tại phòng khám
 *         - PAY_OS: Thanh toán online qua cổng PayOS
 *       example: PAY_OS
 *     
 *     SampleType:
 *       type: string
 *       enum: [blood, saliva, hair, tissue]
 *       description: |
 *         Loại mẫu xét nghiệm DNA:
 *         - blood: Mẫu máu
 *         - saliva: Mẫu nước bọt
 *         - hair: Mẫu tóc
 *         - tissue: Mẫu mô
 *       example: blood
 *     
 *     SampleStatus:
 *       type: string
 *       enum: [pending, collected, processing, completed, failed]
 *       description: |
 *         Trạng thái xử lý mẫu xét nghiệm:
 *         - pending: Chờ lấy mẫu
 *         - collected: Đã lấy mẫu
 *         - processing: Đang xét nghiệm
 *         - completed: Hoàn thành xét nghiệm
 *         - failed: Xét nghiệm thất bại
 *       example: pending
 *     
 *     # ================== PAYMENT SCHEMAS ==================
 *     Payment:
 *       type: object
 *       description: Schema đầy đủ của một thanh toán trong hệ thống
 *       properties:
 *         _id:
 *           type: string
 *           description: ID duy nhất của thanh toán trong MongoDB
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *         payment_no:
 *           type: string
 *           description: Mã số thanh toán duy nhất, dễ đọc cho người dùng
 *           example: "PAY_123456789"
 *         appointment_id:
 *           type: string
 *           description: ID của lịch hẹn liên quan đến thanh toán này
 *           example: "64a1b2c3d4e5f6789abcdef1"
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Danh sách ID các mẫu xét nghiệm được thanh toán
 *           example: ["64a1b2c3d4e5f6789abcdef2", "64a1b2c3d4e5f6789abcdef3"]
 *         amount:
 *           type: number
 *           description: Tổng số tiền thanh toán (VND)
 *           minimum: 1000
 *           example: 500000
 *         payment_method:
 *           $ref: '#/components/schemas/PaymentMethod'
 *         status:
 *           $ref: '#/components/schemas/PaymentStatus'
 *         note:
 *           type: string
 *           description: Ghi chú của người thanh toán
 *           example: "Thanh toán xét nghiệm DNA cơ bản"
 *         # PayOS specific fields - Các trường dành riêng cho PayOS
 *         payos_payment_id:
 *           type: string
 *           description: ID thanh toán từ PayOS (nếu thanh toán qua PayOS)
 *           example: "payos_12345_67890"
 *         payos_checkout_url:
 *           type: string
 *           description: Link thanh toán PayOS cho người dùng
 *           example: "https://pay.payos.vn/web/payment/123456"
 *         payos_web_id:
 *           type: string
 *           description: ID web thanh toán PayOS
 *           example: "web_123456"
 *         payos_payment_status:
 *           type: string
 *           description: Trạng thái thanh toán trả về từ PayOS
 *           enum: [PENDING, PAID, CANCELLED, EXPIRED]
 *           example: "PAID"
 *         payos_payment_status_time:
 *           type: string
 *           format: date-time
 *           description: Thời gian cập nhật trạng thái từ PayOS
 *           example: "2024-01-01T10:30:00.000Z"
 *         payos_webhook_received_at:
 *           type: string
 *           format: date-time
 *           description: Thời gian nhận webhook từ PayOS
 *           example: "2024-01-01T10:30:05.000Z"
 *         order_code:
 *           type: number
 *           description: Mã đơn hàng số cho PayOS
 *           example: 123456789
 *         # Payer information - Thông tin người thanh toán
 *         payer_name:
 *           type: string
 *           description: Tên người thanh toán
 *           example: "Nguyễn Văn A"
 *         payer_email:
 *           type: string
 *           format: email
 *           description: Email người thanh toán
 *           example: "nguyenvana@email.com"
 *         payer_phone:
 *           type: string
 *           description: Số điện thoại người thanh toán
 *           example: "0987654321"
 *         # Timestamps - Thời gian
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Thời gian tạo thanh toán
 *           example: "2024-01-01T10:00:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Thời gian cập nhật gần nhất
 *           example: "2024-01-01T10:30:00.000Z"
 *     
 *     # ================== REQUEST SCHEMAS ==================
 *     CreateAppointmentPaymentRequest:
 *       type: object
 *       description: Schema yêu cầu tạo thanh toán cho lịch hẹn
 *       required:
 *         - appointment_id
 *         - payment_method
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID của lịch hẹn cần thanh toán (bắt buộc)
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *         payment_method:
 *           $ref: '#/components/schemas/PaymentMethod'
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: |
 *             Danh sách ID mẫu xét nghiệm cần thanh toán (tùy chọn).
 *             Nếu không cung cấp, hệ thống sẽ tự động lấy tất cả mẫu của lịch hẹn.
 *           example: ["64a1b2c3d4e5f6789abcdef1", "64a1b2c3d4e5f6789abcdef2"]
 *     PaymentWebhookRequest:
 *       type: object
 *       description: Schema webhook từ PayOS
 *       required:
 *         - payment_no
 *         - status
 *         - signature
 *       properties:
 *         payment_no:
 *           type: string
 *           description: Mã số thanh toán (bắt buộc)
 *           example: "PAY_123456789"
 *         amount:
 *           type: string
 *           description: Số tiền thanh toán (tùy chọn)
 *           example: "500000"
 *         status:
 *           type: string
 *           enum: [pending, paid, cancelled, expired]
 *           description: Trạng thái thanh toán từ PayOS (bắt buộc)
 *           example: "PAID"
 *         signature:
 *           type: string
 *           description: Chữ ký HMAC-SHA256 để xác thực webhook (bắt buộc)
 *           example: "abc123def456..."
 *         orderCode:
 *           type: number
 *           description: Mã đơn hàng số (tùy chọn)
 *           example: 123456789
 *         description:
 *           type: string
 *           description: Mô tả giao dịch (tùy chọn)
 *           example: "Thanh toan xet nghiem DNA"
 *         # Các trường bổ sung từ PayOS
 *         accountNumber:
 *           type: string
 *           description: Số tài khoản thanh toán
 *         reference:
 *           type: string
 *           description: Mã tham chiếu giao dịch
 *         transactionDateTime:
 *           type: string
 *           description: Thời gian thực hiện giao dịch
 *         currency:
 *           type: string
 *           description: Đơn vị tiền tệ
 *           example: "VND"
 *     
 *     # ================== RESPONSE SCHEMAS ==================
 *     PaymentResponse:
 *       type: object
 *       description: Schema phản hồi khi tạo/lấy thông tin thanh toán
 *       properties:
 *         id:
 *           type: string
 *           description: ID thanh toán trong database
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *         payment_no:
 *           type: string
 *           description: Mã số thanh toán
 *           example: "PAY_123456789"
 *         amount:
 *           type: number
 *           description: Số tiền thanh toán (VND)
 *           example: 500000
 *         status:
 *           $ref: '#/components/schemas/PaymentStatus'
 *         payment_method:
 *           $ref: '#/components/schemas/PaymentMethod'
 *         appointment_id:
 *           type: string
 *           description: ID lịch hẹn liên quan
 *           example: "64a1b2c3d4e5f6789abcdef1"
 *         payos_checkout_url:
 *           type: string
 *           description: Link thanh toán PayOS (chỉ có khi thanh toán qua PayOS)
 *           example: "https://pay.payos.vn/web/payment/123456"
 *         note:
 *           type: string
 *           description: Ghi chú thanh toán
 *           example: "Thanh toán xét nghiệm DNA cơ bản"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Thời gian tạo thanh toán
 *           example: "2024-01-01T10:00:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Thời gian cập nhật gần nhất
 *           example: "2024-01-01T10:30:00.000Z"
 *     
 *     PaymentVerificationResponse:
 *       type: object
 *       description: Schema phản hồi khi xác minh trạng thái thanh toán
 *       properties:
 *         payment_status:
 *           $ref: '#/components/schemas/PaymentStatus'
 *         payment_info:
 *           $ref: '#/components/schemas/PaymentResponse'
 *         verification_time:
 *           type: string
 *           format: date-time
 *           description: Thời gian thực hiện xác minh
 *           example: "2024-01-01T10:35:00.000Z"
 *         payos_status:
 *           type: string
 *           description: Trạng thái từ PayOS API
 *           example: "PAID"
 *     
 *     # ================== SAMPLE SCHEMAS ==================
 *     SampleInfo:
 *       type: object
 *       description: Schema thông tin mẫu xét nghiệm
 *       properties:
 *         sample_id:
 *           type: string
 *           description: ID duy nhất của mẫu xét nghiệm
 *           example: "64a1b2c3d4e5f6789abcdef1"
 *         sample_code:
 *           type: string
 *           description: Mã mẫu để theo dõi
 *           example: "DNA_SAMPLE_001"
 *         sample_type:
 *           $ref: '#/components/schemas/SampleType'
 *         test_type:
 *           type: string
 *           description: Loại xét nghiệm DNA
 *           example: "Paternity Test"
 *         amount:
 *           type: number
 *           description: Giá tiền cho mẫu này (VND)
 *           example: 250000
 *         status:
 *           $ref: '#/components/schemas/SampleStatus'
 *         patient_info:
 *           type: object
 *           description: Thông tin bệnh nhân liên quan
 *           properties:
 *             name:
 *               type: string
 *               description: Tên bệnh nhân
 *               example: "Nguyễn Văn A"
 *             relationship:
 *               type: string
 *               description: Mối quan hệ (Father, Mother, Child, etc.)
 *               example: "Father"
 *             age:
 *               type: number
 *               description: Tuổi bệnh nhân
 *               example: 35
 *             gender:
 *               type: string
 *               enum: [male, female, other]
 *               description: Giới tính
 *               example: "male"
 *         collected_at:
 *           type: string
 *           format: date-time
 *           description: Thời gian lấy mẫu
 *           example: "2024-01-01T09:00:00.000Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Thời gian tạo record mẫu
 *           example: "2024-01-01T08:30:00.000Z"
 *     
 *     # ================== ERROR SCHEMAS ==================
 *     ErrorResponse:
 *       type: object
 *       description: Schema chuẩn cho phản hồi lỗi
 *       properties:
 *         success:
 *           type: boolean
 *           description: Luôn false khi có lỗi
 *           example: false
 *         message:
 *           type: string
 *           description: Thông báo lỗi chính
 *           example: "Payment not found"
 *         error:
 *           type: string
 *           description: Chi tiết lỗi hoặc mã lỗi
 *           example: "No payment found with the provided ID"
 *         statusCode:
 *           type: integer
 *           description: HTTP status code
 *           example: 404
 *         timestamp:
 *           type: string
 *           format: date-time
 *           description: Thời gian xảy ra lỗi
 *           example: "2024-01-01T10:00:00.000Z"
 *     
 *     ValidationErrorResponse:
 *       type: object
 *       description: Schema lỗi validation cho dữ liệu đầu vào
 *       properties:
 *         success:
 *           type: boolean
 *           example: false
 *         message:
 *           type: string
 *           example: "Validation failed"
 *         errors:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               field:
 *                 type: string
 *                 description: Tên trường bị lỗi
 *                 example: "appointment_id"
 *               message:
 *                 type: string
 *                 description: Thông báo lỗi cho trường này
 *                 example: "ID lịch hẹn không được để trống"
 *               value:
 *                 description: Giá trị bị lỗi
 *                 example: ""
 *         statusCode:
 *           type: integer
 *           example: 400
 *     
 *     # ================== SUCCESS RESPONSE WRAPPERS ==================
 *     SuccessResponse:
 *       type: object
 *       description: Schema wrapper cho phản hồi thành công
 *       properties:
 *         success:
 *           type: boolean
 *           description: Luôn true khi thành công
 *           example: true
 *         data:
 *           description: Dữ liệu thực tế được trả về
 *         message:
 *           type: string
 *           description: Thông báo thành công
 *           example: "Operation completed successfully"
 *         timestamp:
 *           type: string
 *           format: date-time
 *           description: Thời gian xử lý
 *           example: "2024-01-01T10:00:00.000Z"
 *     
 *     PaginatedResponse:
 *       type: object
 *       description: Schema cho phản hồi có phân trang
 *       properties:
 *         success:
 *           type: boolean
 *           example: true
 *         data:
 *           type: array
 *           description: Mảng dữ liệu cho trang hiện tại
 *         pagination:
 *           type: object
 *           properties:
 *             current_page:
 *               type: integer
 *               description: Trang hiện tại
 *               example: 1
 *             total_pages:
 *               type: integer
 *               description: Tổng số trang
 *               example: 5
 *             page_size:
 *               type: integer
 *               description: Số item mỗi trang
 *               example: 10
 *             total_items:
 *               type: integer
 *               description: Tổng số item
 *               example: 47
 *             has_next:
 *               type: boolean
 *               description: Có trang tiếp theo không
 *               example: true
 *             has_prev:
 *               type: boolean
 *               description: Có trang trước không
 *               example: false
 *         message:
 *           type: string
 *           example: "Data retrieved successfully"
 */ 


================================================
FILE: src/modules/payment/swagger/payment.swagger.js
================================================
/**
 * @swagger
 * /api/payments/webhook/payos:
 *   post:
 *     tags:
 *       - payment
 *     summary: Webhook xử lý callback từ PayOS
 *     description: |
 *       Endpoint nhận và xử lý webhook từ cổng thanh toán PayOS khi có thay đổi trạng thái thanh toán.
 *       
 *       **Quy trình xử lý webhook:**
 *       1. Xác thực chữ ký webhook bằng HMAC-SHA256
 *       2. Kiểm tra thanh toán tồn tại và số tiền khớp
 *       3. Cập nhật trạng thái thanh toán và lịch hẹn liên quan
 *       4. Tạo hoặc cập nhật giao dịch cho từng mẫu xét nghiệm
 *       5. Gửi email thông báo dựa trên trạng thái thanh toán
 *       
 *       **Lưu ý bảo mật:**
 *       - Endpoint này chỉ dành cho PayOS system
 *       - Không được gọi trực tiếp từ client
 *       - Yêu cầu chữ ký hợp lệ từ PayOS
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/PaymentWebhookRequest'
 *     responses:
 *       '200':
 *         description: Webhook được xử lý thành công
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Webhook processed successfully"
 *       '400':
 *         description: Dữ liệu webhook không hợp lệ (chữ ký sai, không tìm thấy thanh toán, số tiền không khớp)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '500':
 *         description: Lỗi máy chủ nội bộ
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/test-webhook-signature:
 *   post:
 *     tags:
 *       - payment
 *     summary: Tạo chữ ký webhook test (chỉ development)
 *     description: |
 *       Endpoint hỗ trợ developer test tích hợp webhook PayOS trong môi trường development.
 *       
 *       **Tính năng:**
 *       - Tạo chữ ký HMAC-SHA256 cho dữ liệu test
 *       - Giúp kiểm tra logic xử lý webhook
 *       - Chỉ hoạt động trong môi trường development
 *       
 *       **Hạn chế:**
 *       - Không khả dụng trên production (trả về 403 Forbidden)
 *       - Chỉ dành cho mục đích testing và debugging
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             description: Dữ liệu test để tạo chữ ký webhook
 *             properties:
 *               payment_no:
 *                 type: string
 *                 example: "TEST_PAY_123456"
 *                 description: Mã thanh toán test
 *               amount:
 *                 type: number
 *                 example: 50000
 *                 description: Số tiền test (VND)
 *               status:
 *                 type: string
 *                 enum: [PAID, CANCELLED, PENDING]
 *                 example: "PAID"
 *                 description: Trạng thái thanh toán test
 *     responses:
 *       '200':
 *         description: Chữ ký test được tạo thành công
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     signature:
 *                       type: string
 *                       description: Chữ ký HMAC-SHA256 được tạo
 *                     data:
 *                       type: object
 *                       description: Dữ liệu gốc được ký
 *                     signedData:
 *                       type: object
 *                       description: Dữ liệu kèm chữ ký hoàn chỉnh
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Test signature generated successfully"
 *       '403':
 *         description: Không khả dụng trên production
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '400':
 *         description: Không có dữ liệu test được cung cấp
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/return/payos:
 *   get:
 *     tags:
 *       - payment
 *     summary: Xử lý return URL từ PayOS
 *     description: |
 *       Endpoint xử lý khi người dùng hoàn thành thanh toán và được PayOS redirect về website.
 *       
 *       **Quy trình xử lý:**
 *       1. Nhận orderCode từ query parameters
 *       2. Tìm thanh toán trong database theo orderCode
 *       3. Verify trạng thái thanh toán với PayOS API
 *       4. Redirect người dùng đến frontend với thông tin kết quả
 *       
 *       **Lưu ý:**
 *       - Endpoint này được PayOS gọi tự động
 *       - Không nên gọi trực tiếp từ ứng dụng
 *       - Luôn redirect về frontend với thông tin thanh toán
 *     parameters:
 *       - name: orderCode
 *         in: query
 *         required: true
 *         description: Mã đơn hàng từ PayOS
 *         schema:
 *           type: string
 *           example: "123456789"
 *       - name: code
 *         in: query
 *         description: Mã kết quả từ PayOS
 *         schema:
 *           type: string
 *           example: "00"
 *       - name: id
 *         in: query
 *         description: ID giao dịch PayOS
 *         schema:
 *           type: string
 *           example: "payos_txn_123456"
 *     responses:
 *       '302':
 *         description: Redirect đến frontend với thông tin kết quả thanh toán
 *         headers:
 *           Location:
 *             description: URL frontend kèm thông tin thanh toán
 *             schema:
 *               type: string
 *               example: "https://frontend.com/payos?code=00&id=payos_123&orderCode=123456&status=completed"
 *       '400':
 *         description: Thiếu orderCode trong query parameters
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Missing orderCode"
 *       '404':
 *         description: Không tìm thấy thanh toán với orderCode được cung cấp
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Payment not found"
 */

/**
 * @swagger
 * /api/payments/appointment:
 *   post:
 *     tags:
 *       - payment
 *     summary: Tạo thanh toán cho lịch hẹn xét nghiệm DNA
 *     description: |
 *       Tạo giao dịch thanh toán cho một lịch hẹn xét nghiệm DNA với các mẫu được chọn.
 *       
 *       **Tính năng chính:**
 *       - Hỗ trợ thanh toán tiền mặt (CASH) và online (PAY_OS)
 *       - Tự động tính toán tổng tiền dựa trên các mẫu xét nghiệm
 *       - Hỗ trợ thanh toán một phần với custom_amount
 *       - Tạo link thanh toán PayOS cho thanh toán online
 *       - Tự động lấy tất cả mẫu nếu không chỉ định sample_ids
 *       
 *       **Quy trình thanh toán:**
 *       1. Xác thực người dùng và quyền truy cập lịch hẹn
 *       2. Lấy thông tin mẫu xét nghiệm và tính toán tổng tiền
 *       3. Tạo payment record trong database
 *       4. Tạo link PayOS nếu chọn thanh toán online
 *       5. Trả về thông tin thanh toán và link checkout
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateAppointmentPaymentRequest'
 *           examples:
 *             payos_payment:
 *               summary: Thanh toán online qua PayOS
 *               value:
 *                 appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                 payment_method: "pay_os"
 *             cash_payment:
 *               summary: Thanh toán tiền mặt
 *               value:
 *                 appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                 payment_method: "cash"
 *             partial_payment:
 *               summary: Thanh toán một phần với mẫu được chọn
 *               value:
 *                 appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                 payment_method: "pay_os"
 *                 sample_ids: ["64a1b2c3d4e5f6789abcdef1", "64a1b2c3d4e5f6789abcdef2"]
 *     responses:
 *       '200':
 *         description: Thanh toán được tạo thành công
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: '#/components/schemas/PaymentResponse'
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Appointment payment created successfully"
 *             examples:
 *               payos_success:
 *                 summary: Thành công tạo thanh toán PayOS
 *                 value:
 *                   data:
 *                     id: "64a1b2c3d4e5f6789abcdef0"
 *                     payment_no: "PAY_123456789"
 *                     amount: 500000
 *                     status: "pending"
 *                     payment_method: "pay_os"
 *                     appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                     payos_checkout_url: "https://pay.payos.vn/web/payment/123456"
 *                     created_at: "2024-01-01T10:00:00.000Z"
 *                   success: true
 *                   message: "Appointment payment created successfully"
 *               cash_success:
 *                 summary: Thành công tạo thanh toán tiền mặt
 *                 value:
 *                   data:
 *                     id: "64a1b2c3d4e5f6789abcdef0"
 *                     payment_no: "PAY_123456789"
 *                     amount: 500000
 *                     status: "pending"
 *                     payment_method: "cash"
 *                     appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                     created_at: "2024-01-01T10:00:00.000Z"
 *                   success: true
 *                   message: "Appointment payment created successfully"
 *       '401':
 *         description: Chưa xác thực người dùng hoặc token không hợp lệ
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '400':
 *         description: Dữ liệu đầu vào không hợp lệ (thiếu trường bắt buộc, sai định dạng)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '404':
 *         description: Không tìm thấy lịch hẹn hoặc mẫu xét nghiệm
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '403':
 *         description: Không có quyền truy cập lịch hẹn này
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/{paymentNo}/verify:
 *   get:
 *     tags:
 *       - payment
 *     summary: Xác minh trạng thái thanh toán với PayOS
 *     description: |
 *       Kiểm tra và cập nhật trạng thái thanh toán bằng cách gọi API PayOS.
 *       
 *       **Quy trình xác minh:**
 *       1. Tìm thanh toán trong database theo payment number
 *       2. Gọi API PayOS để lấy trạng thái mới nhất
 *       3. So sánh và cập nhật trạng thái trong database
 *       4. Cập nhật trạng thái lịch hẹn nếu thanh toán hoàn thành
 *       5. Trả về thông tin chi tiết thanh toán
 *       
 *       **Sử dụng khi:**
 *       - Người dùng muốn kiểm tra trạng thái thanh toán thủ công
 *       - Đồng bộ trạng thái khi webhook bị miss
 *       - Troubleshooting vấn đề thanh toán
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: paymentNo
 *         in: path
 *         required: true
 *         description: Mã số thanh toán cần xác minh
 *         schema:
 *           type: string
 *           example: "PAY_123456789"
 *     responses:
 *       '200':
 *         description: Xác minh thanh toán hoàn tất
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     payment_status:
 *                       type: string
 *                       enum: [pending, completed, cancelled, failed]
 *                       description: Trạng thái thanh toán sau khi xác minh
 *                       example: "completed"
 *                     payment_info:
 *                       $ref: '#/components/schemas/PaymentResponse'
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Payment verification completed"
 *             examples:
 *               completed_payment:
 *                 summary: Thanh toán đã hoàn thành
 *                 value:
 *                   data:
 *                     payment_status: "completed"
 *                     payment_info:
 *                       id: "64a1b2c3d4e5f6789abcdef0"
 *                       payment_no: "PAY_123456789"
 *                       amount: 500000
 *                       status: "completed"
 *                       payment_method: "pay_os"
 *                   success: true
 *                   message: "Payment verification completed"
 *               pending_payment:
 *                 summary: Thanh toán đang chờ
 *                 value:
 *                   data:
 *                     payment_status: "pending"
 *                     payment_info:
 *                       id: "64a1b2c3d4e5f6789abcdef0"
 *                       payment_no: "PAY_123456789"
 *                       amount: 500000
 *                       status: "pending"
 *                       payment_method: "pay_os"
 *                   success: true
 *                   message: "Payment verification completed"
 *       '404':
 *         description: Không tìm thấy thanh toán với mã số được cung cấp
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '500':
 *         description: Lỗi khi gọi API PayOS hoặc lỗi máy chủ
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/{paymentNo}/cancel:
 *   post:
 *     tags:
 *       - payment
 *     summary: Hủy thanh toán đang chờ xử lý
 *     description: |
 *       Hủy một giao dịch thanh toán đang ở trạng thái pending.
 *       
 *       **Quy tắc hủy thanh toán:**
 *       - Chỉ có thể hủy thanh toán có trạng thái 'pending'
 *       - Thanh toán đã hoàn thành, thất bại hoặc đã hủy không thể hủy lại
 *       - Thanh toán PAY_OS sẽ được hủy trên cổng thanh toán PayOS
 *       - Thanh toán CASH có thể hủy trực tiếp trong hệ thống
 *       
 *       **Hậu quả khi hủy:**
 *       - Trạng thái thanh toán chuyển thành 'cancelled'
 *       - Trạng thái lịch hẹn có thể được cập nhật
 *       - Link thanh toán PayOS (nếu có) sẽ không còn hiệu lực
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: paymentNo
 *         in: path
 *         required: true
 *         description: Mã số thanh toán cần hủy
 *         schema:
 *           type: string
 *           example: "PAY_123456789"
 *     responses:
 *       '200':
 *         description: Hủy thanh toán thành công
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     cancelled:
 *                       type: boolean
 *                       example: true
 *                       description: Xác nhận thanh toán đã được hủy
 *                     payment_no:
 *                       type: string
 *                       example: "PAY_123456789"
 *                       description: Mã số thanh toán đã hủy
 *                     previous_status:
 *                       type: string
 *                       example: "pending"
 *                       description: Trạng thái trước khi hủy
 *                     cancelled_at:
 *                       type: string
 *                       format: date-time
 *                       example: "2024-01-01T10:30:00.000Z"
 *                       description: Thời gian hủy thanh toán
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Payment cancelled successfully"
 *       '400':
 *         description: Không thể hủy thanh toán (đã hoàn thành, đã hủy, hoặc thất bại)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *             examples:
 *               already_completed:
 *                 summary: Thanh toán đã hoàn thành
 *                 value:
 *                   success: false
 *                   message: "Cannot cancel completed payment"
 *                   error: "Payment status: completed"
 *               already_cancelled:
 *                 summary: Thanh toán đã bị hủy
 *                 value:
 *                   success: false
 *                   message: "Payment already cancelled"
 *                   error: "Payment status: cancelled"
 *       '404':
 *         description: Không tìm thấy thanh toán với mã số được cung cấp
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/success:
 *   get:
 *     tags:
 *       - payment
 *     summary: Xử lý callback thành công từ PayOS
 *     description: |
 *       Endpoint xử lý khi thanh toán thành công và PayOS redirect người dùng về website.
 *       
 *       **Quy trình xử lý success callback:**
 *       1. Nhận orderCode và thông tin thanh toán từ query parameters
 *       2. Verify trạng thái thanh toán thực tế với PayOS API
 *       3. Xác định trang đích dựa trên kết quả verify:
 *          - Success: Redirect đến trang thành công
 *          - Pending: Redirect đến trang đang xử lý
 *          - Failed: Redirect đến trang thất bại
 *       
 *       **Các trường hợp redirect:**
 *       - Thanh toán hoàn thành → Success page
 *       - Thanh toán đang chờ → Pending page  
 *       - Thanh toán thất bại → Failed page
 *       - Lỗi xác minh → Error page
 *     parameters:
 *       - name: orderCode
 *         in: query
 *         required: true
 *         description: Mã đơn hàng từ PayOS callback
 *         schema:
 *           type: string
 *           example: "123456789"
 *       - name: amount
 *         in: query
 *         description: Số tiền thanh toán từ PayOS
 *         schema:
 *           type: string
 *           example: "500000"
 *       - name: status
 *         in: query
 *         description: Trạng thái từ PayOS callback
 *         schema:
 *           type: string
 *           example: "PAID"
 *     responses:
 *       '302':
 *         description: Redirect đến trang kết quả phù hợp trên frontend
 *         headers:
 *           Location:
 *             description: URL trang đích với thông tin thanh toán
 *             schema:
 *               type: string
 *             examples:
 *               success_redirect:
 *                 summary: Redirect đến trang thành công
 *                 value: "https://frontend.com/payments/success?orderCode=123456&status=success"
 *               pending_redirect:
 *                 summary: Redirect đến trang đang xử lý
 *                 value: "https://frontend.com/payments/pending?orderCode=123456"
 *               failed_redirect:
 *                 summary: Redirect đến trang thất bại
 *                 value: "https://frontend.com/payments/failed?orderCode=123456&status=failed"
 */

/**
 * @swagger
 * /api/payments/failure:
 *   get:
 *     tags:
 *       - payment
 *     summary: Xử lý callback thất bại từ PayOS
 *     description: |
 *       Endpoint xử lý khi thanh toán thất bại, bị hủy hoặc gặp lỗi và PayOS redirect về.
 *       
 *       **Quy trình xử lý failure callback:**
 *       1. Nhận orderCode từ query parameters (nếu có)
 *       2. Tự động hủy thanh toán nếu orderCode được cung cấp
 *       3. Log thông tin lỗi để phục vụ debugging
 *       4. Redirect người dùng đến trang thông báo lỗi trên frontend
 *       
 *       **Các nguyên nhân thất bại:**
 *       - Người dùng hủy thanh toán
 *       - Thẻ/tài khoản không đủ số dư
 *       - Lỗi kết nối với ngân hàng
 *       - Timeout trong quá trình thanh toán
 *       - Lỗi hệ thống PayOS
 *     parameters:
 *       - name: orderCode
 *         in: query
 *         description: Mã đơn hàng (nếu có từ PayOS callback)
 *         schema:
 *           type: string
 *           example: "123456789"
 *       - name: code
 *         in: query
 *         description: Mã lỗi từ PayOS
 *         schema:
 *           type: string
 *           example: "CANCELLED"
 *       - name: desc
 *         in: query
 *         description: Mô tả lỗi từ PayOS
 *         schema:
 *           type: string
 *           example: "Payment cancelled by user"
 *     responses:
 *       '302':
 *         description: Redirect đến trang thông báo lỗi trên frontend
 *         headers:
 *           Location:
 *             description: URL trang lỗi với thông tin chi tiết
 *             schema:
 *               type: string
 *             examples:
 *               cancelled_redirect:
 *                 summary: Redirect khi người dùng hủy
 *                 value: "https://frontend.com/payments/failed?orderCode=123456&status=cancelled"
 *               error_redirect:
 *                 summary: Redirect khi có lỗi hệ thống
 *                 value: "https://frontend.com/payments/failed?error=internal"
 *               unknown_redirect:
 *                 summary: Redirect khi không xác định được lỗi
 *                 value: "https://frontend.com/payments/failed?orderCode=unknown&status=cancelled"
 */

/**
 * @swagger
 * /api/payments/{paymentId}/samples:
 *   get:
 *     tags:
 *       - payment
 *     summary: Lấy danh sách mẫu xét nghiệm của thanh toán
 *     description: |
 *       Lấy thông tin chi tiết các mẫu xét nghiệm liên quan đến một thanh toán cụ thể.
 *       
 *       **Thông tin trả về cho mỗi mẫu:**
 *       - ID và thông tin cơ bản của mẫu
 *       - Loại mẫu xét nghiệm (máu, nước bọt, etc.)
 *       - Loại xét nghiệm DNA được thực hiện
 *       - Giá tiền cho từng mẫu
 *       - Trạng thái xử lý mẫu hiện tại
 *       - Thông tin bệnh nhân liên quan
 *       
 *       **Sử dụng khi:**
 *       - Hiển thị chi tiết hóa đơn thanh toán
 *       - Theo dõi tiến độ xử lý mẫu
 *       - Xuất báo cáo thanh toán chi tiết
 *       - Xác minh thông tin trước khi xử lý mẫu
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: paymentId
 *         in: path
 *         required: true
 *         description: ID thanh toán cần lấy thông tin mẫu
 *         schema:
 *           type: string
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *     responses:
 *       '200':
 *         description: Lấy danh sách mẫu xét nghiệm thành công
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       sample_id:
 *                         type: string
 *                         description: ID duy nhất của mẫu xét nghiệm
 *                         example: "64a1b2c3d4e5f6789abcdef1"
 *                       sample_code:
 *                         type: string
 *                         description: Mã mẫu để theo dõi
 *                         example: "DNA_SAMPLE_001"
 *                       sample_type:
 *                         type: string
 *                         description: Loại mẫu xét nghiệm
 *                         enum: [blood, saliva, hair, tissue]
 *                         example: "blood"
 *                       test_type:
 *                         type: string
 *                         description: Loại xét nghiệm DNA
 *                         example: "Paternity Test"
 *                       amount:
 *                         type: number
 *                         description: Giá tiền cho mẫu này (VND)
 *                         example: 250000
 *                       status:
 *                         type: string
 *                         description: Trạng thái xử lý mẫu
 *                         enum: [pending, processing, completed, failed]
 *                         example: "pending"
 *                       patient_info:
 *                         type: object
 *                         description: Thông tin bệnh nhân liên quan
 *                         properties:
 *                           name:
 *                             type: string
 *                             example: "Nguyễn Văn A"
 *                           relationship:
 *                             type: string
 *                             example: "Father"
 *                       collected_at:
 *                         type: string
 *                         format: date-time
 *                         description: Thời gian lấy mẫu
 *                         example: "2024-01-01T09:00:00.000Z"
 *                       created_at:
 *                         type: string
 *                         format: date-time
 *                         description: Thời gian tạo record mẫu
 *                         example: "2024-01-01T08:30:00.000Z"
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Samples retrieved successfully"
 *             examples:
 *               paternity_test_samples:
 *                 summary: Mẫu xét nghiệm huyết thống
 *                 value:
 *                   data:
 *                     - sample_id: "64a1b2c3d4e5f6789abcdef1"
 *                       sample_code: "DNA_PAT_001_FATHER"
 *                       sample_type: "blood"
 *                       test_type: "Paternity Test"
 *                       amount: 250000
 *                       status: "pending"
 *                       patient_info:
 *                         name: "Nguyễn Văn A"
 *                         relationship: "Father"
 *                       collected_at: "2024-01-01T09:00:00.000Z"
 *                     - sample_id: "64a1b2c3d4e5f6789abcdef2"
 *                       sample_code: "DNA_PAT_001_CHILD"
 *                       sample_type: "saliva"
 *                       test_type: "Paternity Test"
 *                       amount: 250000
 *                       status: "pending"
 *                       patient_info:
 *                         name: "Nguyễn Văn B"
 *                         relationship: "Child"
 *                       collected_at: "2024-01-01T09:15:00.000Z"
 *                   success: true
 *                   message: "Samples retrieved successfully"
 *       '404':
 *         description: Không tìm thấy thanh toán hoặc không có mẫu nào liên quan
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *             examples:
 *               payment_not_found:
 *                 summary: Không tìm thấy thanh toán
 *                 value:
 *                   success: false
 *                   message: "Payment not found"
 *                   error: "No payment found with the provided ID"
 *               no_samples:
 *                 summary: Thanh toán không có mẫu
 *                 value:
 *                   success: false
 *                   message: "No samples found for this payment"
 *                   error: "Payment exists but no associated samples"
 *       '500':
 *         description: Lỗi máy chủ khi truy xuất thông tin mẫu
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */ 


================================================
FILE: src/modules/payment/swagger/payment.tag.js
================================================
/**
 * @swagger
 * tags:
 *   - name: payment
 *     description: |
 *       **API Quản lý Thanh toán**
 *       
 *       Hệ thống thanh toán tích hợp với PayOS cho phép xử lý các giao dịch thanh toán
 *       cho dịch vụ xét nghiệm DNA. Bao gồm các tính năng:
 *       
 *       - **Thanh toán tiền mặt:** Thanh toán trực tiếp tại phòng khám
 *       - **Thanh toán online:** Tích hợp với cổng PayOS
 *       - **Webhook processing:** Xử lý callback từ PayOS
 *       - **Xác minh thanh toán:** Kiểm tra trạng thái với PayOS
 *       - **Quản lý đơn hàng:** Hủy, hoàn tiền, theo dõi
 *       
 *       **Luồng thanh toán PayOS:**
 *       1. Tạo thanh toán → Nhận checkout URL
 *       2. Người dùng thanh toán trên PayOS
 *       3. PayOS gửi webhook → Cập nhật trạng thái
 *       4. Redirect người dùng về trang kết quả
 *       
 *       **Bảo mật:**
 *       - HMAC-SHA256 signature verification
 *       - JWT authentication cho API
 *       - Input validation với class-validator
 *     externalDocs:
 *       description: PayOS Documentation
 *       url: https://payos.vn/docs
 */ 


================================================
FILE: src/modules/refund/index.ts
================================================
import RefundSchema from './refund.model';
import { IRefund, RefundStatus, RefundMethod } from './refund.interface';
import { RefundStatusEnum, RefundMethodEnum } from './refund.enum';
import { RefundStatuses, RefundMethods } from './refund.constant';

export {
    RefundSchema,
    IRefund,
    RefundStatus,
    RefundMethod,
    RefundStatusEnum,
    RefundMethodEnum,
    RefundStatuses,
    RefundMethods
}; 


================================================
FILE: src/modules/refund/refund.constant.ts
================================================
import { RefundMethodEnum, RefundStatusEnum } from './refund.enum';

export const RefundStatuses = [
    '',
    RefundStatusEnum.PENDING,
    RefundStatusEnum.APPROVED,
    RefundStatusEnum.REJECTED,
    RefundStatusEnum.COMPLETED
];

export const RefundMethods = [
    '',
    RefundMethodEnum.CASH,
    RefundMethodEnum.BANK_TRANSFER,
    RefundMethodEnum.OTHER
]; 


================================================
FILE: src/modules/refund/refund.enum.ts
================================================
export enum RefundStatusEnum {
    PENDING = 'pending',
    APPROVED = 'approved',
    REJECTED = 'rejected',
    COMPLETED = 'completed'
}

export enum RefundMethodEnum {
    CASH = 'cash',
    BANK_TRANSFER = 'bank_transfer',
    OTHER = 'other'
} 


================================================
FILE: src/modules/refund/refund.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { RefundMethodEnum, RefundStatusEnum } from './refund.enum';

export type RefundStatus =
    RefundStatusEnum.PENDING |
    RefundStatusEnum.APPROVED |
    RefundStatusEnum.REJECTED |
    RefundStatusEnum.COMPLETED;

export type RefundMethod =
    RefundMethodEnum.CASH |
    RefundMethodEnum.BANK_TRANSFER |
    RefundMethodEnum.OTHER;

export interface IRefund extends Document {
    _id: string;
    payment_id: Schema.Types.ObjectId;
    requester_id: Schema.Types.ObjectId;
    approver_id?: Schema.Types.ObjectId;
    amount: number;
    reason: string;
    status: RefundStatus;
    refund_method: RefundMethod;
    refund_transaction_id?: string;
    refund_date?: Date;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/refund/refund.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { RefundMethods, RefundStatuses } from './refund.constant';
import { IRefund } from './refund.interface';

const RefundSchemaEntity: Schema<IRefund> = new Schema({
    payment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.PAYMENT, required: true, unique: true },
    requester_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    approver_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    amount: { type: Number, required: true },
    reason: { type: String, required: true },
    status: {
        type: String,
        enum: RefundStatuses,
        required: true
    },
    refund_method: {
        type: String,
        enum: RefundMethods,
        required: true
    },
    refund_transaction_id: { type: String },
    refund_date: { type: Date },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const RefundSchema = mongoose.model<IRefund & mongoose.Document>(
    COLLECTION_NAME.REFUND,
    RefundSchemaEntity
);

export default RefundSchema; 


================================================
FILE: src/modules/registration_form/index.ts
================================================
import RegistrationFormSchema from './registration_form.model';
import { IRegistrationForm } from './registration_form.interface';
import RegistrationFormController from './registration_form.controller';
import RegistrationFormService from './registration_form.service';
import RegistrationFormRepository from './registration_form.repository';
import RegistrationFormRoute from './registration_form.route';
import { CreateRegistrationFormDto, UpdateRegistrationFormDto } from './dtos';

export {
    RegistrationFormSchema,
    IRegistrationForm,
    RegistrationFormController,
    RegistrationFormService,
    RegistrationFormRepository,
    RegistrationFormRoute,
    CreateRegistrationFormDto,
    UpdateRegistrationFormDto
}; 


================================================
FILE: src/modules/registration_form/registration_form.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IRegistrationForm } from './registration_form.interface';
import RegistrationFormService from './registration_form.service';
import { CreateRegistrationFormDto } from './dtos/createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './dtos/updateRegistrationForm.dto';
import { UserRoleEnum } from '../user/user.enum';

export default class RegistrationFormController {
    private registrationFormService = new RegistrationFormService();

    /**
     * Create a new registration form (by laboratory technician)
     */
    public createRegistrationForm = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can create registration forms
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can create registration forms');
            }

            const formData: CreateRegistrationFormDto = req.body;
            const form = await this.registrationFormService.createRegistrationForm(formData, laboratoryTechnicianId);

            res.status(HttpStatus.Created).json(formatResponse<IRegistrationForm>(form));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Update an existing registration form (by laboratory technician)
     */
    public updateRegistrationForm = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;
            const formId = req.params.id;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can update registration forms
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can update registration forms');
            }

            const updateData: UpdateRegistrationFormDto = req.body;
            const updatedForm = await this.registrationFormService.updateRegistrationForm(formId, updateData, laboratoryTechnicianId);

            res.status(HttpStatus.Success).json(formatResponse<IRegistrationForm>(updatedForm));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get registration form by ID (accessible by laboratory technician, staff, manager, admin)
     */
    public getRegistrationFormById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only staff, laboratory technicians, managers, and admins can view registration forms
            if (![UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.MANAGER, UserRoleEnum.ADMIN].includes(userRole)) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to view registration forms');
            }

            const formId = req.params.id;
            const form = await this.registrationFormService.getRegistrationFormById(formId);

            res.status(HttpStatus.Success).json(formatResponse<IRegistrationForm>(form));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get registration form by sample ID (accessible by laboratory technician, staff, manager, admin)
     */
    public getRegistrationFormBySampleId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only staff, laboratory technicians, managers, and admins can view registration forms
            if (![UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.MANAGER, UserRoleEnum.ADMIN].includes(userRole)) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to view registration forms');
            }

            const sampleId = req.params.sampleId;
            const form = await this.registrationFormService.getRegistrationFormBySampleId(sampleId);

            res.status(HttpStatus.Success).json(formatResponse<IRegistrationForm>(form));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get all registration forms with pagination (accessible by laboratory technician, staff, manager, admin)
     */
    public getAllRegistrationForms = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only staff, laboratory technicians, managers, and admins can view registration forms
            if (![UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.MANAGER, UserRoleEnum.ADMIN].includes(userRole)) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to view registration forms');
            }

            const page = parseInt(req.query.page as string) || 1;
            const limit = parseInt(req.query.limit as string) || 10;

            const result = await this.registrationFormService.getAllRegistrationForms(page, limit);

            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/registration_form/registration_form.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { SampleTypeEnum } from '../sample/sample.enum';
import { UserGenderEnum } from '../user/user.enum';

export interface IRegistrationForm extends Document {
    _id: string;
    sample_id: string | undefined;
    patient_name: string;
    gender: UserGenderEnum;
    phone_number: string;
    email: string;
    sample_type: SampleTypeEnum;
    relationship: string;
    collection_date: Date;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/registration_form/registration_form.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { UserGenders } from '../user/user.constant';
import { SampleTypes } from '../sample/sample.constant';
import { IRegistrationForm } from './registration_form.interface';

const RegistrationFormSchemaEntity: Schema<IRegistrationForm> = new Schema({
    sample_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SAMPLE },
    patient_name: { type: String, required: true },
    gender: {
        type: String,
        enum: UserGenders,
        required: true
    },
    phone_number: { type: String, required: true },
    email: { type: String, required: true },
    sample_type: {
        type: String,
        enum: SampleTypes,
        required: true
    },
    relationship: { type: String, required: true },
    collection_date: { type: Date, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const RegistrationFormSchema = mongoose.model<IRegistrationForm & mongoose.Document>(
    COLLECTION_NAME.REGISTRATION_FORM,
    RegistrationFormSchemaEntity
);

export default RegistrationFormSchema; 


================================================
FILE: src/modules/registration_form/registration_form.repository.ts
================================================
import RegistrationFormSchema from './registration_form.model';
import { IRegistrationForm } from './registration_form.interface';

export default class RegistrationFormRepository {
    public async create(data: Partial<IRegistrationForm>): Promise<IRegistrationForm> {
        return RegistrationFormSchema.create(data);
    }

    public async findOne(query: any): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findOne(query);
    }

    public async findById(id: string): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IRegistrationForm>, options: any = {}): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return RegistrationFormSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IRegistrationForm[]> {
        return RegistrationFormSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IRegistrationForm[]> {
        return RegistrationFormSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IRegistrationForm[]> {
        return RegistrationFormSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('sample_id');
    }

    public async findByIdWithPopulate(id: string): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findById(id)
            .populate('sample_id');
    }

    public async findBySampleId(sampleId: string): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findOne({ sample_id: sampleId })
            .populate('sample_id');
    }
} 


================================================
FILE: src/modules/registration_form/registration_form.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import RegistrationFormController from './registration_form.controller';
import { CreateRegistrationFormDto } from './dtos/createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './dtos/updateRegistrationForm.dto';

export default class RegistrationFormRoute implements IRoute {
    public path = API_PATH.REGISTRATION_FORM;
    public router = Router();
    private registrationFormController = new RegistrationFormController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/registration-form -> Create a new registration form (laboratory technician only)
        this.router.post(
            `/`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(CreateRegistrationFormDto),
            this.registrationFormController.createRegistrationForm
        );

        // PUT: domain:/api/registration-form/:id -> Update an existing registration form (laboratory technician only)
        this.router.put(
            `/:id`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(UpdateRegistrationFormDto),
            this.registrationFormController.updateRegistrationForm
        );

        // GET: domain:/api/registration-form/:id -> Get registration form by ID (staff, laboratory technician, manager, admin)
        this.router.get(
            `/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.registrationFormController.getRegistrationFormById
        );

        // GET: domain:/api/registration-form/sample/:sampleId -> Get registration form by sample ID (staff, laboratory technician, manager, admin)
        this.router.get(
            `/sample/:sampleId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.registrationFormController.getRegistrationFormBySampleId
        );

        // GET: domain:/api/registration-form -> Get all registration forms with pagination (staff, laboratory technician, manager, admin)
        this.router.get(
            `/`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.registrationFormController.getAllRegistrationForms
        );
    }
} 


================================================
FILE: src/modules/registration_form/registration_form.service.ts
================================================
import mongoose from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IRegistrationForm } from './registration_form.interface';
import RegistrationFormRepository from './registration_form.repository';
import { CreateRegistrationFormDto } from './dtos/createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './dtos/updateRegistrationForm.dto';
import SampleService from '../sample/sample.service';
import { UserGenderEnum } from '../user/user.enum';
import { SampleTypeEnum } from '../sample/sample.enum';

export default class RegistrationFormService {
    private registrationFormRepository = new RegistrationFormRepository();
    private sampleService = new SampleService();

    /**
     * Create a new registration form
     */
    public async createRegistrationForm(formData: CreateRegistrationFormDto, laboratoryTechnicianId: string): Promise<IRegistrationForm> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(formData.sample_id)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Check if sample exists
            const sample = await this.sampleService.getSampleById(formData.sample_id);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Check if registration form already exists for this sample
            const existingForm = await this.registrationFormRepository.findBySampleId(formData.sample_id);
            if (existingForm) {
                throw new HttpException(
                    HttpStatus.Conflict,
                    'A registration form already exists for this sample'
                );
            }

            // Create the registration form
            const registrationForm = await this.registrationFormRepository.create({
                sample_id: formData.sample_id as any,
                patient_name: formData.patient_name,
                gender: formData.gender as UserGenderEnum,
                phone_number: formData.phone_number || '',
                email: formData.email || '',
                sample_type: formData.sample_type as SampleTypeEnum,
                relationship: formData.relationship,
                collection_date: new Date(formData.collection_date),
                created_at: new Date(),
                updated_at: new Date()
            });

            return registrationForm;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating registration form');
        }
    }

    /**
     * Update an existing registration form
     */
    public async updateRegistrationForm(formId: string, updateData: UpdateRegistrationFormDto, laboratoryTechnicianId: string): Promise<IRegistrationForm> {
        try {
            // Validate formId
            if (!mongoose.Types.ObjectId.isValid(formId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid registration form ID');
            }

            // Check if form exists
            const form = await this.registrationFormRepository.findById(formId);
            if (!form) {
                throw new HttpException(HttpStatus.NotFound, 'Registration form not found');
            }

            // Prepare update data
            const updateFields: Partial<IRegistrationForm> = {
                patient_name: updateData.patient_name,
                gender: updateData.gender as UserGenderEnum,
                phone_number: updateData.phone_number,
                email: updateData.email,
                sample_type: updateData.sample_type as SampleTypeEnum,
                relationship: updateData.relationship,
                updated_at: new Date()
            };

            // Convert collection_date to Date object if provided
            if (updateData.collection_date) {
                updateFields.collection_date = new Date(updateData.collection_date);
            }

            // Remove undefined fields
            Object.keys(updateFields).forEach(key => {
                if (updateFields[key as keyof Partial<IRegistrationForm>] === undefined) {
                    delete updateFields[key as keyof Partial<IRegistrationForm>];
                }
            });

            // Update the form
            const updatedForm = await this.registrationFormRepository.findByIdAndUpdate(
                formId,
                updateFields,
                { new: true }
            );

            if (!updatedForm) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update registration form');
            }

            return updatedForm;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating registration form');
        }
    }

    /**
     * Get registration form by ID
     */
    public async getRegistrationFormById(id: string): Promise<IRegistrationForm> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid registration form ID');
        }

        const form = await this.registrationFormRepository.findByIdWithPopulate(id);
        if (!form) {
            throw new HttpException(HttpStatus.NotFound, 'Registration form not found');
        }

        return form;
    }

    /**
     * Get registration form by sample ID
     */
    public async getRegistrationFormBySampleId(sampleId: string): Promise<IRegistrationForm> {
        if (!mongoose.Types.ObjectId.isValid(sampleId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
        }

        const form = await this.registrationFormRepository.findBySampleId(sampleId);
        if (!form) {
            throw new HttpException(HttpStatus.NotFound, 'Registration form not found for this sample');
        }

        return form;
    }

    /**
     * Get all registration forms with pagination
     */
    public async getAllRegistrationForms(page: number = 1, limit: number = 10): Promise<{ forms: IRegistrationForm[], total: number, page: number, limit: number }> {
        try {
            const skip = (page - 1) * limit;
            const forms = await this.registrationFormRepository.findWithPopulate({}, { created_at: -1 }, skip, limit);
            const total = await this.registrationFormRepository.countDocuments({});

            return {
                forms,
                total,
                page,
                limit
            };
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching registration forms');
        }
    }
} 


================================================
FILE: src/modules/registration_form/dtos/createRegistrationForm.dto.ts
================================================
import { IsDateString, IsEnum, IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { SampleTypeEnum } from '../../sample/sample.enum';

export class CreateRegistrationFormDto {
    @IsNotEmpty({ message: 'Sample ID is required' })
    @IsMongoId({ message: 'Sample ID must be a valid MongoDB ID' })
    sample_id: string = '';

    @IsNotEmpty({ message: 'Patient name is required' })
    @IsString({ message: 'Patient name must be a string' })
    patient_name: string = '';

    @IsNotEmpty({ message: 'Gender is required' })
    @IsString({ message: 'Gender must be a string' })
    gender: string = '';

    @IsOptional()
    @IsString({ message: 'Phone number must be a string' })
    phone_number?: string;

    @IsOptional()
    @IsString({ message: 'Email must be a string' })
    email?: string;

    @IsNotEmpty({ message: 'Sample type is required' })
    @IsEnum(SampleTypeEnum, { message: 'Sample type must be a valid type' })
    sample_type: string = '';

    @IsNotEmpty({ message: 'Relationship is required' })
    @IsString({ message: 'Relationship must be a string' })
    relationship: string = '';

    @IsNotEmpty({ message: 'Collection date is required' })
    @IsDateString({}, { message: 'Collection date must be a valid date' })
    collection_date: string = '';
} 


================================================
FILE: src/modules/registration_form/dtos/index.ts
================================================
import { CreateRegistrationFormDto } from './createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './updateRegistrationForm.dto';

export {
    CreateRegistrationFormDto,
    UpdateRegistrationFormDto
}; 


================================================
FILE: src/modules/registration_form/dtos/updateRegistrationForm.dto.ts
================================================
import { IsDateString, IsEnum, IsOptional, IsString } from 'class-validator';
import { SampleTypeEnum } from '../../sample/sample.enum';

export class UpdateRegistrationFormDto {
    @IsOptional()
    @IsString({ message: 'Patient name must be a string' })
    patient_name?: string;

    @IsOptional()
    @IsString({ message: 'Gender must be a string' })
    gender?: string;

    @IsOptional()
    @IsString({ message: 'Phone number must be a string' })
    phone_number?: string;

    @IsOptional()
    @IsString({ message: 'Email must be a string' })
    email?: string;

    @IsOptional()
    @IsEnum(SampleTypeEnum, { message: 'Sample type must be a valid type' })
    sample_type?: string;

    @IsOptional()
    @IsString({ message: 'Relationship must be a string' })
    relationship?: string;

    @IsOptional()
    @IsDateString({}, { message: 'Collection date must be a valid date' })
    collection_date?: string;
} 


================================================
FILE: src/modules/registration_form/swagger/registrationForm.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateRegistrationFormDto:
 *       type: object
 *       required:
 *         - sample_id
 *         - patient_name
 *         - gender
 *         - sample_type
 *         - relationship
 *         - collection_date
 *       properties:
 *         sample_id:
 *           type: string
 *           description: ID of the sample associated with this registration form
 *           example: "60c72b2f9b1e8b3b4c8d6e26"
 *         patient_name:
 *           type: string
 *           description: Name of the patient
 *           example: "John Doe"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: Gender of the patient
 *           example: "male"
 *         phone_number:
 *           type: string
 *           description: Phone number of the patient
 *           example: "0123456789"
 *         email:
 *           type: string
 *           description: Email of the patient
 *           example: "john.doe@example.com"
 *         sample_type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample collected
 *           example: "saliva"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "father"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when the sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *
 *     UpdateRegistrationFormDto:
 *       type: object
 *       properties:
 *         patient_name:
 *           type: string
 *           description: Name of the patient
 *           example: "John Doe"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: Gender of the patient
 *           example: "male"
 *         phone_number:
 *           type: string
 *           description: Phone number of the patient
 *           example: "0123456789"
 *         email:
 *           type: string
 *           description: Email of the patient
 *           example: "john.doe@example.com"
 *         sample_type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample collected
 *           example: "saliva"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "father"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when the sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *
 *     RegistrationFormResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Registration Form ID
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *         sample_id:
 *           type: object
 *           description: Associated sample
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e26"
 *             type:
 *               type: string
 *               example: "saliva"
 *             status:
 *               type: string
 *               example: "received"
 *         patient_name:
 *           type: string
 *           description: Name of the patient
 *           example: "John Doe"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: Gender of the patient
 *           example: "male"
 *         phone_number:
 *           type: string
 *           description: Phone number of the patient
 *           example: "0123456789"
 *         email:
 *           type: string
 *           description: Email of the patient
 *           example: "john.doe@example.com"
 *         sample_type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample collected
 *           example: "saliva"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "father"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when the sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2025-05-27T09:12:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2025-05-27T09:13:00Z"
 */ 


================================================
FILE: src/modules/registration_form/swagger/registrationForm.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: registration-forms
 *   description: Registration Form management APIs
 */

/**
 * @swagger
 * /api/registration-form:
 *   post:
 *     tags:
 *       - registration-forms
 *     summary: Create a new registration form (Laboratory Technician only)
 *     description: Create a new registration form for a sample
 *     operationId: createRegistrationForm
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateRegistrationFormDto'
 *     responses:
 *       201:
 *         description: Registration form created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid input data or sample ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Laboratory technician access required
 *       404:
 *         description: Sample not found
 *       409:
 *         description: Registration form already exists for this sample
 *   get:
 *     tags:
 *       - registration-forms
 *     summary: Get all registration forms with pagination (Staff, Laboratory Technician, Manager, Admin)
 *     description: Retrieve a paginated list of registration forms
 *     operationId: getAllRegistrationForms
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: Registration forms retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 forms:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/RegistrationFormResponse'
 *                 total:
 *                   type: integer
 *                   example: 50
 *                 page:
 *                   type: integer
 *                   example: 1
 *                 limit:
 *                   type: integer
 *                   example: 10
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff, Laboratory technician, Manager, or Admin access required
 */

/**
 * @swagger
 * /api/registration-form/{id}:
 *   get:
 *     tags:
 *       - registration-forms
 *     summary: Get registration form by ID (Staff, Laboratory Technician, Manager, Admin)
 *     description: Retrieve detailed information about a specific registration form
 *     operationId: getRegistrationFormById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Registration Form ID
 *         example: "60c72b2f9b1e8b3b4c8d6e27"
 *     responses:
 *       200:
 *         description: Registration form details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid registration form ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff, Laboratory technician, Manager, or Admin access required
 *       404:
 *         description: Registration form not found
 *   put:
 *     tags:
 *       - registration-forms
 *     summary: Update an existing registration form (Laboratory Technician only)
 *     description: Update details of an existing registration form
 *     operationId: updateRegistrationForm
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Registration Form ID
 *         example: "60c72b2f9b1e8b3b4c8d6e27"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateRegistrationFormDto'
 *     responses:
 *       200:
 *         description: Registration form updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid input data or registration form ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Laboratory technician access required
 *       404:
 *         description: Registration form not found
 */

/**
 * @swagger
 * /api/registration-form/sample/{sampleId}:
 *   get:
 *     tags:
 *       - registration-forms
 *     summary: Get registration form by sample ID (Staff, Laboratory Technician, Manager, Admin)
 *     description: Retrieve registration form information for a specific sample
 *     operationId: getRegistrationFormBySampleId
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: sampleId
 *         required: true
 *         schema:
 *           type: string
 *         description: Sample ID
 *         example: "60c72b2f9b1e8b3b4c8d6e26"
 *     responses:
 *       200:
 *         description: Registration form details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid sample ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff, Laboratory technician, Manager, or Admin access required
 *       404:
 *         description: Registration form not found for this sample
 */ 


================================================
FILE: src/modules/result/index.ts
================================================
import ResultSchema from './result.model';
import { IResult, ResultMatch, IResultData } from './result.interface';
import { ResultMatchEnum } from './result.enum';
import ResultController from './result.controller';
import ResultService from './result.service';
import ResultRepository from './result.repository';
import ResultRoute from './result.route';
import { CreateResultDto, UpdateResultDto, StartTestingDto } from './dtos';

export {
    ResultSchema,
    IResult,
    ResultMatch,
    IResultData,
    ResultMatchEnum,
    ResultController,
    ResultService,
    ResultRepository,
    ResultRoute,
    CreateResultDto,
    UpdateResultDto,
    StartTestingDto
}; 


================================================
FILE: src/modules/result/result.constant.ts
================================================
import { ResultMatchEnum } from './result.enum';

export const ResultMatches = [
    '',
    ResultMatchEnum.MATCH,
    ResultMatchEnum.NO_MATCH,
    ResultMatchEnum.INCONCLUSIVE
]; 


================================================
FILE: src/modules/result/result.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IResult } from './result.interface';
import ResultService from './result.service';
import { CreateResultDto } from './dtos/createResult.dto';
import { UpdateResultDto } from './dtos/updateResult.dto';
import { StartTestingDto } from './dtos/startTesting.dto';
import { UserRoleEnum } from '../user/user.enum';

export default class ResultController {
    private resultService = new ResultService();

    /**
     * Create a new test result (by laboratory technician)
     */
    public createResult = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can create results
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can create test results');
            }

            // Validate that sample_ids is provided and is an array
            if (!req.body.sample_ids || !Array.isArray(req.body.sample_ids) || req.body.sample_ids.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'At least one sample ID is required');
            }

            const resultData: CreateResultDto = req.body;
            const result = await this.resultService.createResult(resultData, laboratoryTechnicianId);

            res.status(HttpStatus.Created).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Update an existing test result (by laboratory technician)
     */
    public updateResult = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;
            const resultId = req.params.id;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can update results
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can update test results');
            }

            const updateData: UpdateResultDto = req.body;
            const updatedResult = await this.resultService.updateResult(resultId, updateData, laboratoryTechnicianId);

            res.status(HttpStatus.Success).json(formatResponse<IResult>(updatedResult));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get result by ID (accessible by customer, staff, laboratory technician, manager, admin)
     */
    public getResultById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const resultId = req.params.id;
            const result = await this.resultService.getResultById(resultId);

            // If user is customer, check if they have access to this result
            if (req.user.role === UserRoleEnum.CUSTOMER &&
                result.customer_id?.toString() !== req.user.id) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have access to this result');
            }

            res.status(HttpStatus.Success).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get result by sample ID (accessible by customer, staff, laboratory technician, manager, admin)
     */
    public getResultBySampleId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const sampleId = req.params.sampleId;
            const result = await this.resultService.getResultBySampleId(sampleId);

            // If user is customer, check if they have access to this result
            if (req.user.role === UserRoleEnum.CUSTOMER &&
                result.customer_id?.toString() !== req.user.id) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have access to this result');
            }

            res.status(HttpStatus.Success).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get result by appointment ID (accessible by customer, staff, laboratory technician, manager, admin)
     */
    public getResultByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            const result = await this.resultService.getResultByAppointmentId(appointmentId);

            // If user is customer, check if they have access to this result
            if (req.user.role === UserRoleEnum.CUSTOMER &&
                result.customer_id?.toString() !== req.user.id) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have access to this result');
            }

            res.status(HttpStatus.Success).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Start testing process for a sample or multiple samples (by laboratory technician)
     */
    public startTesting = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;
            const sampleId = req.params.sampleId;

            console.log(`Starting testing process by user ${laboratoryTechnicianId} with role ${userRole}`);

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can start testing
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can start testing');
            }

            const testingData: StartTestingDto = req.body;
            console.log('Testing data:', testingData);

            // If sample_ids are provided in the body, use them for batch processing
            if (testingData.sample_ids && testingData.sample_ids.length > 0) {
                console.log(`Batch processing ${testingData.sample_ids.length} samples`);

                // Process each sample ID
                const results = await Promise.all(
                    testingData.sample_ids.map(async (id) => {
                        try {
                            await this.resultService.startTesting(id, testingData, laboratoryTechnicianId);
                            return { id, success: true };
                        } catch (error: any) {
                            console.error(`Error processing sample ${id}:`, error);
                            return {
                                id,
                                success: false,
                                error: error instanceof HttpException ?
                                    error.message :
                                    'Failed to start testing for this sample'
                            };
                        }
                    })
                );

                // Count successes and failures
                const successful = results.filter(r => r.success).length;
                const failed = results.filter(r => !r.success).length;

                res.status(HttpStatus.Success).json(formatResponse({
                    message: `Testing process started for ${successful} samples, ${failed} failed`,
                    results
                }));
            } else if (sampleId) {
                // Single sample processing using the sample ID from the URL parameter
                await this.resultService.startTesting(sampleId, testingData, laboratoryTechnicianId);
                res.status(HttpStatus.Success).json(formatResponse({
                    message: 'Testing process started successfully',
                    sample_id: sampleId
                }));
            } else {
                // Neither sample_ids in body nor sampleId in URL parameters
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'No sample ID provided. Please provide a sample ID in the URL or sample_ids in the request body.'
                );
            }
        } catch (error) {
            console.error('Error in startTesting controller:', error);
            next(error);
        }
    };
} 


================================================
FILE: src/modules/result/result.enum.ts
================================================
export enum ResultMatchEnum {
    MATCH = 'match',
    NO_MATCH = 'no_match',
    INCONCLUSIVE = 'inconclusive'
} 


================================================
FILE: src/modules/result/result.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { ResultMatchEnum } from './result.enum';

export type ResultMatch =
    ResultMatchEnum.MATCH |
    ResultMatchEnum.NO_MATCH |
    ResultMatchEnum.INCONCLUSIVE;

export interface IResultData {
    [key: string]: any;
}

export interface IResult extends Document {
    _id: string;
    sample_ids: string[] | undefined;
    customer_id: string | undefined;
    appointment_id: string | undefined;
    laboratory_technician_id: string | undefined;
    is_match: boolean;
    result_data: IResultData | null;
    report_url: string | null;
    completed_at: Date | null;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/result/result.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IResult } from './result.interface';

const ResultSchemaEntity: Schema<IResult> = new Schema({
    sample_ids: { type: [Schema.Types.ObjectId], ref: COLLECTION_NAME.SAMPLE, required: true },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    laboratory_technician_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    is_match: { type: Boolean, required: true },
    result_data: { type: Schema.Types.Mixed },
    report_url: { type: String },
    completed_at: { type: Date },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const ResultSchema = mongoose.model<IResult & mongoose.Document>(
    COLLECTION_NAME.RESULT,
    ResultSchemaEntity
);

export default ResultSchema; 


================================================
FILE: src/modules/result/result.repository.ts
================================================
import mongoose from 'mongoose';
import { IResult } from './result.interface';
import ResultSchema from './result.model';

export default class ResultRepository {
    /**
     * Create a new result
     */
    public async create(resultData: Partial<IResult>): Promise<IResult> {
        const newResult = new ResultSchema(resultData);
        return await newResult.save();
    }

    /**
     * Find result by ID
     */
    public async findById(id: string): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return null;
        }
        return await ResultSchema.findById(id).exec();
    }

    /**
     * Find result by sample ID
     */
    public async findBySampleId(sampleId: string): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(sampleId)) {
            return null;
        }
        return await ResultSchema.findOne({ sample_ids: { $in: [sampleId] } }).exec();
    }

    /**
     * Find one result by query
     */
    public async findOne(query: any): Promise<IResult | null> {
        return await ResultSchema.findOne(query).exec();
    }

    /**
     * Find results by query
     */
    public async find(query: any): Promise<IResult[]> {
        return await ResultSchema.find(query).exec();
    }

    /**
     * Update result by ID
     */
    public async findByIdAndUpdate(id: string, updateData: Partial<IResult>, options?: any): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return null;
        }
        return await ResultSchema.findByIdAndUpdate(id, updateData, options).exec();
    }

    /**
     * Delete result by ID
     */
    public async findByIdAndDelete(id: string): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return null;
        }
        return await ResultSchema.findByIdAndDelete(id).exec();
    }

    public async countDocuments(query: any): Promise<number> {
        return ResultSchema.countDocuments(query);
    }

    public async findAll(query: any): Promise<IResult[]> {
        return ResultSchema.find(query)
            .populate('sample_ids')
            .populate('customer_id')
            .populate('appointment_id');
    }

    /**
     * Find result by appointment ID with populated fields
     */
    public async findByAppointmentId(appointmentId: string): Promise<IResult | null> {
        return ResultSchema.findOne({ appointment_id: appointmentId })
            .populate('sample_ids')
            .populate('customer_id')
            .populate('appointment_id')
            .populate('laboratory_technician_id');
    }
} 


================================================
FILE: src/modules/result/result.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import ResultController from './result.controller';
import { CreateResultDto } from './dtos/createResult.dto';
import { UpdateResultDto } from './dtos/updateResult.dto';
import { StartTestingDto } from './dtos/startTesting.dto';

export default class ResultRoute implements IRoute {
    public path = API_PATH.RESULT;
    public router = Router();
    private resultController = new ResultController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/result -> Create a new test result (laboratory technician only)
        this.router.post(
            `${API_PATH.RESULT}/`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            // validationMiddleware(CreateResultDto),
            this.resultController.createResult
        );

        // PUT: domain:/api/result/:id -> Update an existing test result (laboratory technician only)
        this.router.put(
            `${API_PATH.RESULT}/:id`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(UpdateResultDto),
            this.resultController.updateResult
        );

        // GET: domain:/api/result/:id -> Get result by ID (all authenticated users)
        this.router.get(
            `${API_PATH.RESULT}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.resultController.getResultById
        );

        // GET: domain:/api/result/sample/:sampleId -> Get result by sample ID (all authenticated users)
        this.router.get(
            `${API_PATH.RESULT}/sample/:sampleId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.resultController.getResultBySampleId
        );

        // GET: domain:/api/result/appointment/:appointmentId -> Get result by appointment ID (all authenticated users)
        this.router.get(
            `${API_PATH.RESULT}/appointment/:appointmentId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.resultController.getResultByAppointmentId
        );

        // PUT: domain:/api/result/sample/start-testing -> Start testing process for a single sample (laboratory technician only)
        // this.router.put(
        //     `${API_PATH.RESULT}/sample/start-testing`,
        //     authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
        //     validationMiddleware(StartTestingDto),
        //     this.resultController.startTesting
        // );

        // POST: domain:/api/result/samples/start-testing -> Start testing process for multiple samples (laboratory technician only)
        this.router.post(
            `${API_PATH.RESULT}/sample/start-testing`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(StartTestingDto),
            this.resultController.startTesting
        );
    }
} 


================================================
FILE: src/modules/result/result.service.ts
================================================
import mongoose from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IResult } from './result.interface';
import ResultRepository from './result.repository';
import { CreateResultDto } from './dtos/createResult.dto';
import { UpdateResultDto } from './dtos/updateResult.dto';
import { StartTestingDto } from './dtos/startTesting.dto';
import SampleService from '../sample/sample.service';
import { SampleStatusEnum } from '../sample/sample.enum';
import AppointmentService from '../appointment/appointment.service';
import { AppointmentStatusEnum, PaymentStatusEnum } from '../appointment/appointment.enum';
import { AppointmentLogService } from '../appointment_log';
import { AppointmentLogTypeEnum } from '../appointment_log/appointment_log.enum';
import ReportGeneratorService from './services/reportGenerator.service';
import { sendMail, createNotificationEmailTemplate } from '../../core/utils';
import { ISendMailDetail } from '../../core/interfaces';
import UserSchema from '../user/user.model';
import ServiceSchema from '../service/service.model';
import AppointmentSchema from '../appointment/appointment.model';
import { ServiceTypeEnum } from '../service/service.enum';

export default class ResultService {
    private resultRepository = new ResultRepository();
    private sampleService = new SampleService();
    private appointmentService = new AppointmentService();
    private appointmentLogService = new AppointmentLogService();
    private reportGeneratorService = new ReportGeneratorService();

    /**
     * Create a new test result
     */
    public async createResult(resultData: CreateResultDto, laboratoryTechnicianId: string): Promise<IResult> {
        try {
            // Validate IDs
            if (!resultData.sample_ids || resultData.sample_ids.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'At least one sample ID is required');
            }

            // Validate all sample IDs
            for (const sampleId of resultData.sample_ids) {
                if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                    throw new HttpException(HttpStatus.BadRequest, `Invalid sample ID format: ${sampleId}`);
                }
            }

            if (!mongoose.Types.ObjectId.isValid(resultData.appointment_id)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID format');
            }

            // Check if all samples exist
            for (const sampleId of resultData.sample_ids) {
                const sample = await this.sampleService.getSampleById(sampleId);
                if (!sample) {
                    throw new HttpException(HttpStatus.NotFound, `Sample not found: ${sampleId}`);
                }

                // Check if sample is in TESTING status
                if (sample.status !== SampleStatusEnum.TESTING) {
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        `Cannot create result for sample ${sampleId} that is not in testing status`
                    );
                }

                // Check if result already exists for this sample
                const existingResult = await this.resultRepository.findOne({
                    sample_ids: { $in: [sampleId] }
                });

                if (existingResult) {
                    throw new HttpException(
                        HttpStatus.Conflict,
                        `A result already exists for sample ${sampleId}`
                    );
                }
            }

            // Check if appointment exists
            let appointmentId = resultData.appointment_id;

            // Handle potential ObjectId conversion issues
            try {
                appointmentId = new mongoose.Types.ObjectId(resultData.appointment_id).toString();
            } catch (error) {
                console.error('Error converting appointment ID:', error);
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID format');
            }

            const appointment = await this.appointmentService.getAppointmentById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            // Lấy service để kiểm tra loại
            const service = await ServiceSchema.findById(appointment.service_id);
            let reportTemplate = 'default_report_template';
            let recipientEmail = undefined;
            if (service && service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                reportTemplate = 'administrative_report_template';
                // Ưu tiên lấy email agency từ appointment, nếu không có thì lấy từ user
                recipientEmail = appointment.agency_contact_email;
                if (!recipientEmail) {
                    const user = await AppointmentSchema.findById(appointment.user_id);
                    recipientEmail = user?.email;
                }
            }

            let customerId: string;
            if (resultData.customer_id) {
                if (!mongoose.Types.ObjectId.isValid(resultData.customer_id)) {
                    throw new HttpException(HttpStatus.BadRequest, 'Invalid customer ID format');
                }
                customerId = resultData.customer_id;
                console.log(`Using provided customer_id: ${customerId}`);
            } else if (appointment.user_id) {
                // Handle different possible types of user_id
                if (typeof appointment.user_id === 'string') {
                    // If it's a string, use it directly
                    customerId = appointment.user_id;
                } else if (typeof appointment.user_id === 'object') {
                    // If it's an object (including ObjectId), convert to string
                    try {
                        // Try accessing properties safely with type assertions
                        const userIdObj = appointment.user_id as any;
                        if (userIdObj && userIdObj._id) {
                            customerId = userIdObj._id.toString();
                        } else {
                            // Direct ObjectId or similar
                            customerId = appointment.user_id || '';
                        }
                    } catch (err) {
                        console.error('Error extracting user_id:', err);
                        console.error('appointment.user_id:', appointment.user_id);
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            'Invalid user ID format in appointment'
                        );
                    }
                } else {
                    console.error('Invalid user_id format in appointment:', appointment.user_id);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'Invalid user ID format in appointment'
                    );
                }

                // Validate that we have a valid MongoDB ID
                if (!mongoose.Types.ObjectId.isValid(customerId)) {
                    console.error(`Invalid user_id extracted from appointment: ${customerId}`);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'Invalid user ID format extracted from appointment'
                    );
                }

                console.log(`Using user_id from appointment: ${customerId}`);
            } else {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Customer ID not found in appointment'
                );
            }

            // Check if appointment has been paid for
            if (appointment.payment_status !== PaymentStatusEnum.PAID) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot create result for appointment that hasn't been paid for (payment status: ${appointment.payment_status})`
                );
            }

            // Check if appointment is in TESTING status
            if (appointment.status !== AppointmentStatusEnum.TESTING) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot create result for appointment that is not in testing status`
                );
            }

            try {
                // Log all IDs for debugging
                console.log('Creating result with:');
                console.log('sample_ids:', resultData.sample_ids);
                console.log('appointment_id:', appointmentId);
                console.log('customer_id:', customerId);
                console.log('laboratory_technician_id:', laboratoryTechnicianId);

                // Validate all IDs one more time
                if (!mongoose.Types.ObjectId.isValid(customerId)) {
                    throw new Error(`Invalid customer_id format: ${customerId}`);
                }

                if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                    throw new Error(`Invalid appointment_id format: ${appointmentId}`);
                }

                if (!mongoose.Types.ObjectId.isValid(laboratoryTechnicianId)) {
                    throw new Error(`Invalid laboratory_technician_id format: ${laboratoryTechnicianId}`);
                }

                for (const sampleId of resultData.sample_ids) {
                    if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                        throw new Error(`Invalid sample_id format: ${sampleId}`);
                    }
                }

                // Create the initial result
                const result = await this.resultRepository.create({
                    sample_ids: resultData.sample_ids.map(id => new mongoose.Types.ObjectId(id)) as any,
                    appointment_id: new mongoose.Types.ObjectId(appointmentId) as any,
                    customer_id: new mongoose.Types.ObjectId(customerId) as any,
                    laboratory_technician_id: new mongoose.Types.ObjectId(laboratoryTechnicianId) as any,
                    is_match: resultData.is_match,
                    result_data: resultData.result_data || {},
                    report_url: '',
                    completed_at: new Date(),
                    created_at: new Date(),
                    updated_at: new Date()
                });

                // Generate PDF report synchronously to ensure report_url is available
                try {
                    console.log('Generating PDF report...');
                    const reportUrl = await this.reportGeneratorService.generateReport(
                        result._id.toString(),
                        laboratoryTechnicianId,
                        reportTemplate
                    );

                    // Update the result with the report URL
                    await this.resultRepository.findByIdAndUpdate(
                        result._id.toString(),
                        { report_url: reportUrl },
                        { new: true }
                    );

                    // Update the result object to return to the client
                    result.report_url = reportUrl;
                    console.log(`PDF report generated successfully: ${reportUrl}`);
                } catch (error: any) {
                    console.error('Failed to generate PDF report:', error);

                    // If the error is related to AWS configuration, provide a clear message
                    if (error.message && (
                        error.message.includes('AWS credentials not configured') ||
                        error.message.includes('AWS S3 bucket not configured')
                    )) {
                        throw new HttpException(
                            HttpStatus.InternalServerError,
                            'AWS S3 is not properly configured. Please check your AWS credentials and bucket settings.'
                        );
                    }

                    // For other errors, continue with the process but report the error
                    throw new HttpException(
                        HttpStatus.InternalServerError,
                        `Failed to generate PDF report: ${error.message}`
                    );
                }

                // Update all samples status to COMPLETED
                for (const sampleId of resultData.sample_ids) {
                    await this.sampleService.updateSampleStatus(sampleId, SampleStatusEnum.COMPLETED);
                }

                // Update appointment status to COMPLETED
                await this.appointmentService.updateAppointmentStatus(
                    appointmentId,
                    AppointmentStatusEnum.COMPLETED
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.COMPLETED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for result creation:', logError);
                }

                // Send result notification email
                try {
                    await this.sendResultReadyEmail(result, appointment, recipientEmail);
                } catch (emailError) {
                    console.error('Failed to send result ready email:', emailError);
                }

                return result;
            } catch (createError: any) {
                console.error('Error creating result document:', createError);
                throw new HttpException(
                    HttpStatus.InternalServerError,
                    `Failed to create result: ${createError.message}`
                );
            }
        } catch (error: any) {
            console.error('Error in createResult:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(
                HttpStatus.InternalServerError,
                `Error creating result: ${error.message}`
            );
        }
    }

    /**
     * Generate PDF report for a test result
     * This is called automatically after result creation
     */
    private async generateResultReport(resultId: string, laboratoryTechnicianId: string): Promise<void> {
        try {
            // Generate the PDF report and get the URL
            const reportUrl = await this.reportGeneratorService.generateReport(resultId, laboratoryTechnicianId);

            // Update the result with the report URL
            await this.resultRepository.findByIdAndUpdate(
                resultId,
                { report_url: reportUrl },
                { new: true }
            );

            console.log(`PDF report generated successfully for result ${resultId}: ${reportUrl}`);
        } catch (error) {
            console.error(`Failed to generate PDF report for result ${resultId}:`, error);
            // We don't throw here as this is run asynchronously after the main transaction
        }
    }

    /**
     * Update an existing test result
     */
    public async updateResult(resultId: string, updateData: UpdateResultDto, laboratoryTechnicianId: string): Promise<IResult> {
        try {
            // Validate resultId
            if (!mongoose.Types.ObjectId.isValid(resultId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid result ID');
            }

            // Check if result exists
            const result = await this.resultRepository.findById(resultId);
            if (!result) {
                throw new HttpException(HttpStatus.NotFound, 'Result not found');
            }

            // Update the result
            const updatedResult = await this.resultRepository.findByIdAndUpdate(
                resultId,
                {
                    ...updateData,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedResult) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update result');
            }

            // If critical data changed (is_match or result_data), regenerate the PDF report
            if (updateData.is_match !== undefined || updateData.result_data) {
                // Generate PDF report asynchronously
                this.generateResultReport(resultId, laboratoryTechnicianId)
                    .catch(error => {
                        console.error('Failed to regenerate PDF report:', error);
                    });

                // Send result updated email
                try {
                    if (updatedResult.appointment_id) {
                        const appointment = await this.appointmentService.getAppointmentById(updatedResult.appointment_id.toString());
                        await this.sendResultUpdatedEmail(updatedResult, appointment);
                    } else {
                        console.error('Cannot send result updated email: appointment_id is undefined');
                    }
                } catch (emailError) {
                    console.error('Failed to send result updated email:', emailError);
                }
            }

            return updatedResult;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating result');
        }
    }

    /**
     * Get result by ID
     */
    public async getResultById(id: string): Promise<IResult> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid result ID');
        }

        const result = await this.resultRepository.findById(id);
        if (!result) {
            throw new HttpException(HttpStatus.NotFound, 'Result not found');
        }

        return result;
    }

    /**
     * Get result by sample ID
     */
    public async getResultBySampleId(sampleId: string): Promise<IResult> {
        try {
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            const result = await this.resultRepository.findOne({ sample_ids: { $in: [sampleId] } });

            if (!result) {
                throw new HttpException(HttpStatus.NotFound, 'Result not found for this sample');
            }

            return result;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving result');
        }
    }

    /**
     * Get result by appointment ID
     */
    public async getResultByAppointmentId(appointmentId: string): Promise<IResult> {
        if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
        }

        const result = await this.resultRepository.findByAppointmentId(appointmentId);
        if (!result) {
            throw new HttpException(HttpStatus.NotFound, 'Result not found for this appointment');
        }

        return result;
    }

    /**
     * Start testing process for a sample
     */
    public async startTesting(sampleId: string, testingData: StartTestingDto, laboratoryTechnicianId: string): Promise<void> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Check if sample exists
            const sample = await this.sampleService.getSampleById(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Extract appointment ID as string
            let appointmentId: string;
            if (typeof sample.appointment_id === 'object' && sample.appointment_id !== null) {
                appointmentId = sample.appointment_id || '';
            } else {
                appointmentId = String(sample.appointment_id) || '';
            }

            // Check if appointment exists and has been paid for
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, `Appointment not found with ID: ${appointmentId}`);
            }

            if (appointment.payment_status !== PaymentStatusEnum.PAID) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot start testing for appointment that hasn't been paid for (payment status: ${appointment.payment_status})`
                );
            }

            // Check if sample is in RECEIVED status
            if (sample.status !== SampleStatusEnum.RECEIVED) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot start testing for sample with status ${sample.status}`
                );
            }

            // Update sample status to TESTING
            await this.sampleService.updateSampleStatus(sampleId, SampleStatusEnum.TESTING);

            // Get appointment ID as string for updating
            const appointmentObjectId = appointment._id.toString();

            // Update appointment status to TESTING
            if (appointment.status !== AppointmentStatusEnum.TESTING) {
                await this.appointmentService.updateAppointmentStatus(
                    appointmentObjectId,
                    AppointmentStatusEnum.TESTING
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.TESTING
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for testing start:', logError);
                }

                // Send testing started email
                try {
                    await this.sendTestingStartedEmail(sample, appointment);
                } catch (emailError) {
                    console.error('Failed to send testing started email:', emailError);
                }
            }
        } catch (error) {
            console.error('Error in startTesting:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error starting testing process');
        }
    }

    /**
     * Send email notification when test result is ready
     */
    private async sendResultReadyEmail(result: IResult, appointment: any, recipientEmail?: string): Promise<void> {
        try {
            // Get user details
            let userId = result.customer_id;
            if (!userId && appointment && appointment.user_id) {
                userId = appointment.user_id;
            }

            if (!userId) {
                console.error('Cannot send email: User ID not found');
                return;
            }

            const user = await UserSchema.findById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details if available
            let serviceName = 'DNA Testing Service';
            if (appointment && appointment.service_id) {
                try {
                    const service = await mongoose.model('Service').findById(appointment.service_id);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                } catch (error) {
                    console.error('Error fetching service details:', error);
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Your Test Results Are Ready';
            const message = `
                Your test results for ${serviceName} are now ready.
                <br><br>
                <strong>Result Details:</strong>
                <br>
                Result ID: ${result._id}
                <br>
                Date Completed: ${result.completed_at ? new Date(result.completed_at).toLocaleString() : new Date().toLocaleString()}
                <br><br>
                ${result.is_match !== undefined ? `<strong>Result Match:</strong> ${result.is_match ? 'Positive' : 'Negative'}<br><br>` : ''}
                You can view your detailed results by logging into your account and accessing the Results section.
                ${result.report_url ? `<br><br>A detailed report has been generated and is available for viewing.` : ''}
                <br><br>
                If you have any questions about your results, please contact our medical team for assistance.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: recipientEmail || user.email,
                subject: 'Test Results Ready - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Result ready email sent to ${recipientEmail || user.email}`);
        } catch (error) {
            console.error('Error sending result ready email:', error);
        }
    }

    /**
     * Send email notification when test result is updated
     */
    private async sendResultUpdatedEmail(result: IResult, appointment: any): Promise<void> {
        try {
            // Get user details
            let userId = result.customer_id;
            if (!userId && appointment && appointment.user_id) {
                userId = appointment.user_id;
            }

            if (!userId) {
                console.error('Cannot send email: User ID not found');
                return;
            }

            const user = await UserSchema.findById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details if available
            let serviceName = 'DNA Testing Service';
            if (appointment && appointment.service_id) {
                try {
                    const service = await mongoose.model('Service').findById(appointment.service_id);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                } catch (error) {
                    console.error('Error fetching service details:', error);
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Your Test Results Have Been Updated';
            const message = `
                Your test results for ${serviceName} have been updated.
                <br><br>
                <strong>Result Details:</strong>
                <br>
                Result ID: ${result._id}
                <br>
                Last Updated: ${result.updated_at ? new Date(result.updated_at).toLocaleString() : new Date().toLocaleString()}
                <br><br>
                ${result.is_match !== undefined ? `<strong>Result Match:</strong> ${result.is_match ? 'Positive' : 'Negative'}<br><br>` : ''}
                Please log into your account to view the updated results.
                ${result.report_url ? `<br><br>An updated report has been generated and is available for viewing.` : ''}
                <br><br>
                If you have any questions about these changes, please contact our medical team for assistance.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Test Results Updated - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Result updated email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending result updated email:', error);
        }
    }

    /**
     * Send email notification when testing process starts
     */
    private async sendTestingStartedEmail(sample: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await UserSchema.findById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details if available
            let serviceName = 'DNA Testing Service';
            if (appointment && appointment.service_id) {
                try {
                    const service = await mongoose.model('Service').findById(appointment.service_id);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                } catch (error) {
                    console.error('Error fetching service details:', error);
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Sample Testing Started';
            const message = `
                We are pleased to inform you that the laboratory has started processing your sample for ${serviceName}.
                <br><br>
                <strong>Testing Details:</strong>
                <br>
                Sample ID: ${sample._id}
                <br>
                Sample Type: ${sample.sample_type || 'DNA Sample'}
                <br>
                Testing Started: ${new Date().toLocaleString()}
                <br><br>
                The testing process typically takes 3-5 business days to complete. We will notify you as soon as your results are ready.
                <br><br>
                If you have any questions during this process, please don't hesitate to contact our customer support team.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Sample Testing Started - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Testing started email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending testing started email:', error);
        }
    }
} 


================================================
FILE: src/modules/result/dtos/createResult.dto.ts
================================================
import { IsArray, IsBoolean, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

export class ResultDataDto {
    [key: string]: any;
}

export class CreateResultDto {
    @IsNotEmpty({ message: 'Sample IDs are required' })
    @IsArray({ message: 'Sample IDs must be an array' })
    @IsMongoId({ each: true, message: 'Each Sample ID must be a valid MongoDB ID' })
    sample_ids: string[] = [];

    @IsNotEmpty({ message: 'Appointment ID is required' })
    @IsMongoId({ message: 'Appointment ID must be a valid MongoDB ID' })
    appointment_id: string = '';

    @IsOptional()
    @IsMongoId({ message: 'Customer ID must be a valid MongoDB ID' })
    customer_id?: string;

    @IsNotEmpty({ message: 'Is match status is required' })
    @IsBoolean({ message: 'Is match must be a boolean value' })
    is_match: boolean = false;

    @IsOptional()
    @ValidateNested()
    @Type(() => ResultDataDto)
    result_data?: Record<string, any>;

    @IsOptional()
    @IsString({ message: 'Report URL must be a string' })
    report_url?: string;
} 


================================================
FILE: src/modules/result/dtos/index.ts
================================================
import { CreateResultDto } from './createResult.dto';
import { UpdateResultDto } from './updateResult.dto';
import { StartTestingDto } from './startTesting.dto';

export {
    CreateResultDto,
    UpdateResultDto,
    StartTestingDto
}; 


================================================
FILE: src/modules/result/dtos/startTesting.dto.ts
================================================
import { IsArray, IsDateString, IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { Type } from 'class-transformer';

export class StartTestingDto {
    @IsNotEmpty({ message: 'Testing start date is required' })
    @IsDateString({}, { message: 'Testing start date must be a valid date' })
    testing_start_date: string = '';

    @IsOptional()
    @IsString({ message: 'Notes must be a string' })
    notes?: string;

    @IsOptional()
    @IsArray({ message: 'Sample IDs must be an array' })
    @IsMongoId({ each: true, message: 'Each sample ID must be a valid MongoDB ID' })
    @Type(() => String)
    sample_ids?: string[];
} 


================================================
FILE: src/modules/result/dtos/updateResult.dto.ts
================================================
import { IsBoolean, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

export class ResultDataDto {
    [key: string]: any;
}

export class UpdateResultDto {
    @IsOptional()
    @IsBoolean({ message: 'Is match must be a boolean value' })
    is_match?: boolean;

    @IsOptional()
    @ValidateNested()
    @Type(() => ResultDataDto)
    result_data?: Record<string, any>;

    @IsOptional()
    @IsString({ message: 'Report URL must be a string' })
    report_url?: string;
} 


================================================
FILE: src/modules/result/services/reportGenerator.service.ts
================================================
import { SampleService } from '../../sample';
import { AppointmentService } from '../../appointment';
import UserService from '../../user/user.service';
import ServiceService from '../../service/service.service';
import { TestResultReportData } from '../utils/pdfGenerator.util';
import ResultRepository from '../result.repository';
import { IResult } from '../result.interface';
import mongoose from 'mongoose';
import { HttpException } from '../../../core/exceptions';
import { HttpStatus } from '../../../core/enums';

export default class ReportGeneratorService {
    private sampleService = new SampleService();
    private appointmentService = new AppointmentService();
    private serviceService = new ServiceService();
    private userService = new UserService();
    private resultRepository = new ResultRepository();

    /**
     * Collect all data needed for the test result report
     */
    public async collectReportData(resultId: string, labTechnicianId: string): Promise<TestResultReportData> {
        // Validate resultId
        if (!mongoose.Types.ObjectId.isValid(resultId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid result ID');
        }

        // Get the result
        const result = await this.resultRepository.findById(resultId);
        if (!result) {
            throw new HttpException(HttpStatus.NotFound, 'Result not found');
        }

        // Check if there are any samples
        if (!result.sample_ids || result.sample_ids.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'No samples associated with this result');
        }

        // Get all samples with their data
        const samples = [];
        const sampleIds = result.sample_ids.map(id => id.toString());

        for (const sampleId of sampleIds) {
            const sample = await this.sampleService.getSampleById(sampleId);
            if (sample) {
                samples.push(sample);
            }
        }

        if (samples.length === 0) {
            throw new HttpException(HttpStatus.NotFound, 'No samples found');
        }

        // Get primary sample data (using the first sample for basic report data)
        const primarySample = samples[0];

        // Get appointment data
        const appointment = await this.appointmentService.getAppointmentById(result.appointment_id?.toString() || '');
        if (!appointment) {
            throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
        }

        // Get customer data
        const customer = await this.userService.getUserById(result.customer_id?.toString() || '');
        if (!customer) {
            throw new HttpException(HttpStatus.NotFound, 'Customer not found');
        }

        // Get lab technician data
        const labTechnician = await this.userService.getUserById(labTechnicianId);
        if (!labTechnician) {
            throw new HttpException(HttpStatus.NotFound, 'Laboratory technician not found');
        }

        // Get service data
        let serviceName = 'Unknown Service';

        try {
            if (appointment.service_id) {
                // Extract the service ID properly from the appointment
                let serviceId: string;

                // Handle different possible formats of service_id
                if (typeof appointment.service_id === 'object') {
                    if (appointment.service_id && (appointment.service_id as any)._id) {
                        serviceId = (appointment.service_id as any)._id.toString();
                    } else {
                        serviceId = (appointment.service_id as any).toString();
                    }
                } else {
                    serviceId = (appointment.service_id as any).toString();
                }

                // Now get the service with the extracted ID
                if (mongoose.Types.ObjectId.isValid(serviceId)) {
                    const service = await this.serviceService.getServiceById(serviceId);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                }
            }
        } catch (error) {
            console.error('Error getting service data:', error);
            // Continue with unknown service name
        }

        // Compile person information from samples
        const personsInfo = samples
            .filter(sample => sample.person_info)
            .map(sample => ({
                name: sample.person_info?.name || 'Unknown',
                relationship: sample.person_info?.relationship || 'Unknown',
                dob: sample.person_info?.dob || null,
                birthPlace: sample.person_info?.birth_place || 'Unknown',
                nationality: sample.person_info?.nationality || 'Unknown',
                identityDocument: sample.person_info?.identity_document || 'Unknown',
                sampleId: sample._id.toString(),
                imageUrl: sample.person_info?.image_url
            }));

        // Compile all data
        const reportData: TestResultReportData = {
            // Result data
            resultId: result._id.toString(),
            isMatch: result.is_match,
            resultData: result.result_data,
            completedAt: result.completed_at || new Date(),

            // Sample data
            sampleId: primarySample._id.toString(),
            sampleType: primarySample.type || 'Unknown',
            collectionMethod: primarySample.collection_method || 'Unknown',
            collectionDate: primarySample.collection_date || new Date(),

            // Additional data for multiple samples
            allSampleIds: sampleIds,
            personsInfo: personsInfo.length > 0 ? personsInfo : undefined,

            // Appointment data
            appointmentId: appointment._id.toString(),
            appointmentDate: appointment.appointment_date,
            serviceType: serviceName,

            // Customer data
            customerId: customer._id.toString(),
            customerName: `${customer.first_name} ${customer.last_name}`,
            customerGender: customer.gender || 'Not specified',
            customerDateOfBirth: customer.dob || new Date(),
            customerContactInfo: {
                email: customer.email || 'Not provided',
                phone: customer.phone_number || 'Not provided',
                address: customer.address || 'Not provided'
            },

            // Laboratory technician data
            labTechnicianId: labTechnician._id.toString(),
            labTechnicianName: `${labTechnician.first_name} ${labTechnician.last_name}`
        };

        return reportData;
    }

    /**
     * Generate a PDF report for a test result using the PDF generator
     * @param resultId ID of the result to generate a report for
     * @param labTechnicianId ID of the laboratory technician generating the report
     * @returns URL of the generated PDF
     */
    public async generateReport(resultId: string, labTechnicianId: string, reportTemplate?: string): Promise<string> {
        try {
            // Import the PDF generator dynamically to avoid circular dependencies
            const { generateTestResultPDF } = await import('../utils/pdfGenerator.util');

            // Collect all necessary data
            const reportData = await this.collectReportData(resultId, labTechnicianId);

            // Generate the PDF and get the URL
            const pdfUrl = await generateTestResultPDF(reportData, reportTemplate);

            // Update the result with the report URL
            await this.resultRepository.findByIdAndUpdate(
                resultId,
                { report_url: pdfUrl, updated_at: new Date() },
                { new: true }
            );

            return pdfUrl;
        } catch (error) {
            console.error('Failed to generate report:', error);
            throw new HttpException(
                HttpStatus.InternalServerError,
                'Failed to generate PDF report'
            );
        }
    }
} 


================================================
FILE: src/modules/result/swagger/result.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateResultDto:
 *       type: object
 *       required:
 *         - sample_ids
 *         - appointment_id
 *         - is_match
 *       properties:
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: IDs of the samples being tested
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment associated with the test
 *           example: "60c72b2f9b1e8b3b4c8d6e25"
 *         is_match:
 *           type: boolean
 *           description: Whether the DNA test resulted in a match
 *           example: true
 *         result_data:
 *           type: object
 *           description: Additional result data specific to the test type
 *           example: 
 *             probability: 99.99
 *             confidence_interval: "99.9% - 100%"
 *             markers_tested: 24
 *             markers_matched: 24
 *             dna_match_percentage: 99.99
 *             confidence_level: "High"
 *         report_url:
 *           type: string
 *           description: URL to the detailed test report
 *           example: "https://example.com/reports/dna-test-123456.pdf"
 *
 *     UpdateResultDto:
 *       type: object
 *       properties:
 *         is_match:
 *           type: boolean
 *           description: Whether the DNA test resulted in a match
 *           example: true
 *         result_data:
 *           type: object
 *           description: Additional result data specific to the test type
 *           example: 
 *             probability: 99.99
 *             confidence_interval: "99.9% - 100%"
 *             markers_tested: 24
 *             markers_matched: 24
 *         report_url:
 *           type: string
 *           description: URL to the detailed test report
 *           example: "https://example.com/reports/dna-test-123456.pdf"
 *
 *     StartTestingDto:
 *       type: object
 *       required:
 *         - testing_start_date
 *       properties:
 *         testing_start_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the testing process started
 *           example: "2025-06-01T09:00:00Z"
 *         notes:
 *           type: string
 *           description: Optional notes about the testing process
 *           example: "Sample appears to be in good condition"
 *
 *     ResultResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Result ID
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *         sample_ids:
 *           type: array
 *           description: Associated samples
 *           items:
 *             type: object
 *             properties:
 *               _id:
 *                 type: string
 *                 example: "60c72b2f9b1e8b3b4c8d6e26"
 *               type:
 *                 type: string
 *                 example: "saliva"
 *               status:
 *                 type: string
 *                 example: "completed"
 *               person_info:
 *                 type: object
 *                 properties:
 *                   name:
 *                     type: string
 *                     example: "Nguyễn Văn A"
 *                   relationship:
 *                     type: string
 *                     example: "Cha giả định"
 *                   dob:
 *                     type: string
 *                     format: date-time
 *                     example: "1978-04-19T00:00:00Z"
 *         customer_id:
 *           type: object
 *           description: Customer who ordered the test
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e24"
 *             first_name:
 *               type: string
 *               example: "John"
 *             last_name:
 *               type: string
 *               example: "Doe"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e25"
 *             status:
 *               type: string
 *               example: "completed"
 *         laboratory_technician_id:
 *           type: object
 *           description: Laboratory technician who performed the test
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e28"
 *             first_name:
 *               type: string
 *               example: "Jane"
 *             last_name:
 *               type: string
 *               example: "Smith"
 *         is_match:
 *           type: boolean
 *           description: Whether the DNA test resulted in a match
 *           example: true
 *         result_data:
 *           type: object
 *           description: Additional result data specific to the test type
 *           example: 
 *             probability: 99.99
 *             confidence_interval: "99.9% - 100%"
 *             markers_tested: 24
 *             markers_matched: 24
 *         report_url:
 *           type: string
 *           description: URL to the detailed test report
 *           example: "https://example.com/reports/dna-test-123456.pdf"
 *         completed_at:
 *           type: string
 *           format: date-time
 *           description: Date and time when the test was completed
 *           example: "2025-06-03T14:30:00Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2025-06-01T09:00:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2025-06-03T14:30:00Z"
 */ 


================================================
FILE: src/modules/result/swagger/result.swagger.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     ResultData:
 *       type: object
 *       properties:
 *         probability:
 *           type: number
 *           description: Probability of match in percentage
 *           example: 99.99
 *         confidence_interval:
 *           type: string
 *           description: Confidence interval for the result
 *           example: "99.9% - 100%"
 *         markers_tested:
 *           type: number
 *           description: Number of markers tested
 *           example: 24
 *         markers_matched:
 *           type: number
 *           description: Number of markers that matched
 *           example: 24
 *         dna_match_percentage:
 *           type: number
 *           description: DNA match percentage
 *           example: 99.99
 *         confidence_level:
 *           type: string
 *           description: Confidence level classification
 *           example: "high"
 *     
 *     CreateResult:
 *       type: object
 *       required:
 *         - sample_ids
 *         - appointment_id
 *         - customer_id
 *         - is_match
 *       properties:
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: IDs of the samples being tested
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment
 *           example: 5f8d0e0e9d3b9a0017c1a7a2
 *         customer_id:
 *           type: string
 *           description: ID of the customer
 *           example: 5f8d0e0e9d3b9a0017c1a7a3
 *         is_match:
 *           type: boolean
 *           description: Whether the test result is a match
 *           example: true
 *         result_data:
 *           $ref: '#/components/schemas/ResultData'
 *       description: >
 *         Create a new test result. 
 *         A PDF report will be automatically generated and the report_url field will be populated.
 *         The PDF will include customer information, sample details, and test results.
 * 
 *     UpdateResult:
 *       type: object
 *       properties:
 *         is_match:
 *           type: boolean
 *           description: Whether the test result is a match
 *           example: true
 *         result_data:
 *           $ref: '#/components/schemas/ResultData'
 *       description: >
 *         Update a test result. 
 *         If is_match or result_data is changed, a new PDF report will be generated automatically.
 * 
 *     Result:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Result ID
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: IDs of the samples
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment
 *         customer_id:
 *           type: string
 *           description: ID of the customer
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the laboratory technician who performed the test
 *         is_match:
 *           type: boolean
 *           description: Whether the test result is a match
 *         result_data:
 *           $ref: '#/components/schemas/ResultData'
 *         report_url:
 *           type: string
 *           description: URL to the PDF report of the test result
 *           example: https://medical-test-results.s3.us-east-1.amazonaws.com/test-results/5f8d0e0e9d3b9a0017c1a7a3/5f8d0e0e9d3b9a0017c1a7a4-20231025.pdf
 *         completed_at:
 *           type: string
 *           format: date-time
 *           description: When the test was completed
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: When the result was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: When the result was last updated
 * 
 *     StartTesting:
 *       type: object
 *       required:
 *         - testing_start_date
 *       properties:
 *         testing_start_date:
 *           type: string
 *           format: date-time
 *           description: Date when the testing process started
 *           example: "2023-10-25T10:00:00.000Z"
 *         notes:
 *           type: string
 *           description: Notes about the testing process
 *           example: "Starting DNA testing process"
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Array of sample IDs to start testing (for batch processing)
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 */

/**
 * @swagger
 * /api/result:
 *   post:
 *     summary: Create a new test result (Lab only)
 *     description: >
 *       Create a new test result with automatic PDF report generation.
 *       The report will include detailed information about the test and results.
 *       Only laboratory technicians can create test results.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateResult'
 *     responses:
 *       201:
 *         description: Result created successfully, PDF generation started
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *                 message:
 *                   type: string
 *                   example: Result created successfully. PDF report will be generated and available shortly.
 *       400:
 *         description: Invalid request data
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden, only laboratory technicians can create results
 * 
 * /api/result/{id}:
 *   get:
 *     summary: Get result by ID (All authenticated users)
 *     description: Get a test result by its ID. Includes PDF report URL.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Result ID
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *       404:
 *         description: Result not found
 * 
 *   put:
 *     summary: Update a test result (Lab only)
 *     description: >
 *       Update a test result. If the is_match or result_data fields are changed,
 *       a new PDF report will be automatically generated.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Result ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateResult'
 *     responses:
 *       200:
 *         description: Result updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *                 message:
 *                   type: string
 *                   example: Result updated successfully. If test data was changed, a new PDF report will be generated.
 *       404:
 *         description: Result not found
 * 
 * /api/result/sample/start-testing:
 *   post:
 *     summary: Start testing process for multiple samples (batch processing) (Lab only)
 *     description: >
 *       Mark multiple samples as being tested in a single request. 
 *       Updates each sample status to TESTING and their associated appointment statuses to TESTING.
 *       Only laboratory technicians can start testing.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/StartTesting'
 *     responses:
 *       200:
 *         description: Testing process started for multiple samples
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Testing process started for 2 samples, 0 failed
 *                 results:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                         description: Sample ID
 *                         example: 60c72b2f9b1e8b3b4c8d6e26
 *                       success:
 *                         type: boolean
 *                         description: Whether testing started successfully for this sample
 *                         example: true
 *                       error:
 *                         type: string
 *                         description: Error message if testing failed for this sample
 *                         example: Sample not found
 *       400:
 *         description: No sample IDs provided or invalid request
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden, only laboratory technicians can start testing
 * 
 * /api/result/sample/{sampleId}:
 *   get:
 *     summary: Get result by sample ID (All authenticated users)
 *     description: Get a test result by its associated sample ID. Searches for the sample ID in the sample_ids array. Includes PDF report URL.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: sampleId
 *         required: true
 *         schema:
 *           type: string
 *         description: Sample ID
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *       404:
 *         description: Result not found for this sample
 * 
 * /api/result/appointment/{appointmentId}:
 *   get:
 *     summary: Get result by appointment ID (All authenticated users)
 *     description: Get a test result by its associated appointment ID. Includes PDF report URL.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *       404:
 *         description: Result not found for this appointment
 */ 


================================================
FILE: src/modules/result/utils/pdfGenerator.util.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import PDFDocument from 'pdfkit';
import moment from 'moment';
import axios from 'axios';
import * as AWS from 'aws-sdk';
import { v4 as uuidv4 } from 'uuid';
import dotenv from 'dotenv';
import { HttpException } from '../../../core/exceptions';
import { HttpStatus } from '../../../core/enums';

dotenv.config();

const s3 = new AWS.S3({
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    region: process.env.AWS_REGION
});

// Path to default Times-Roman font available in PDFKit
// PDFKit includes these fonts: 'Courier', 'Courier-Bold', 'Courier-Oblique', 'Courier-BoldOblique',
// 'Helvetica', 'Helvetica-Bold', 'Helvetica-Oblique', 'Helvetica-BoldOblique',
// 'Times-Roman', 'Times-Bold', 'Times-Italic', 'Times-BoldItalic'

/**
 * Information about persons related to the sample
 */
export interface PersonInfo {
    name: string;
    relationship: string;
    dob: Date | null;
    birthPlace: string;
    nationality: string;
    identityDocument: string;
    sampleId: string;
    imageUrl?: string; // URL to the person's image
}

/**
 * Interface for data required to generate a test result PDF
 */
export interface TestResultReportData {
    // Test result data
    resultId: string;
    isMatch: boolean;
    resultData: any;
    completedAt: Date;

    // Sample data
    sampleId: string;
    sampleType: string;
    collectionMethod: string;
    collectionDate: Date;

    // Additional data for multiple samples
    allSampleIds?: string[];
    personsInfo?: PersonInfo[];

    // Appointment data
    appointmentId: string;
    appointmentDate: Date;
    serviceType: string;

    // Customer data
    customerId: string;
    customerName: string;
    customerGender: string;
    customerDateOfBirth: Date;
    customerContactInfo: {
        email: string;
        phone: string;
        address: string;
    };

    // Laboratory technician data
    labTechnicianId: string;
    labTechnicianName: string;
}

/**
 * Generate a PDF report for a test result in Vietnamese
 */
export async function generateTestResultPDF(data: TestResultReportData, template?: string): Promise<string> {
    // Validate AWS environment variables
    if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY || !process.env.AWS_REGION) {
        throw new HttpException(
            HttpStatus.InternalServerError,
            'AWS credentials not configured. Please set AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_REGION environment variables.'
        );
    }

    if (!process.env.AWS_S3_BUCKET_NAME) {
        throw new HttpException(
            HttpStatus.InternalServerError,
            'AWS S3 bucket not configured. Please set AWS_S3_BUCKET_NAME environment variable.'
        );
    }

    const tempFilePath = path.join(__dirname, `temp-report-${uuidv4()}.pdf`);

    try {
        // Create PDF document with improved margins for professional presentation
        const doc = new PDFDocument({
            margin: 50,
            size: 'A4',
            info: {
                Title: `Test Results Report - ${data.resultId}`,
                Author: 'Healthcare System',
                Subject: 'Medical Test Results',
                Keywords: 'test, medical, results'
            },
            autoFirstPage: true
        });
        const writeStream = fs.createWriteStream(tempFilePath);

        // Pipe the PDF to the file
        doc.pipe(writeStream);

        // === ADMINISTRATIVE PDF CUSTOMIZATION ===
        if (template === 'administrative_report_template') {
            // Watermark
            doc.fontSize(60).fillColor('#eeeeee').opacity(0.3).text('ADMINISTRATIVE', 100, 300);
            doc.opacity(1);
            // Header
            doc.fontSize(18).fillColor('#cc0000').text('ADMINISTRATIVE DNA TEST REPORT', { align: 'center' });
            doc.moveDown(0.5);
            // Số hiệu vụ việc
            if ((data as any).caseNumber) {
                doc.fontSize(12).fillColor('#333333').text(`Case Number: ${(data as any).caseNumber}`, { align: 'right' });
            }
            // Thêm section xác nhận của cơ quan
            doc.moveDown(2);
        } else {
            // Add decorative line for header
            doc.lineWidth(1)
                .moveTo(50, 110)
                .lineTo(550, 110)
                .stroke('#0066cc');
            // Add header with better styling - using ASCII instead of Unicode
            doc.fontSize(22).fillColor('#0066cc').text('TEST RESULTS REPORT', { align: 'center' });
            doc.moveDown(0.5);
        }

        // Add report identification with improved formatting - using ASCII instead of Unicode
        const dateStr = moment().locale('vi').format('DD/MM/YYYY');
        doc.fontSize(11).fillColor('#666666').text(`Report ID: ${data.resultId}`, { align: 'right' });
        doc.text(`Date created: ${dateStr}`, { align: 'right' });
        doc.moveDown(2);

        // Add customer information with better styling
        doc.roundedRect(50, doc.y, 500, 140, 5).fillAndStroke('#f6f6f6', '#dddddd');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('CUSTOMER INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        doc.text(`Full name: ${convertToASCII(data.customerName)}`, 70);
        doc.text(`Gender: ${convertToASCII(translateGender(data.customerGender))}`);
        doc.text(`Date of birth: ${moment(data.customerDateOfBirth).format('DD/MM/YYYY')}`);
        doc.text(`Phone: ${data.customerContactInfo.phone}`);
        doc.text(`Email: ${data.customerContactInfo.email}`);
        doc.text(`Address: ${data.customerContactInfo.address}`);
        doc.moveDown(1);
        doc.y += 10;

        // Display information about persons related to the sample if available
        if (data.personsInfo && data.personsInfo.length > 0) {
            doc.addPage();
            doc.fontSize(18).fillColor('#0066cc').text('RELATED PERSONS INFORMATION', { align: 'center' });
            doc.moveDown(1);

            // Display information for each person
            for (let i = 0; i < data.personsInfo.length; i++) {
                const person = data.personsInfo[i];

                doc.roundedRect(50, doc.y, 500, 220, 5).fillAndStroke('#f0f7ff', '#bbddff');
                doc.y += 10;

                doc.fontSize(14).fillColor('#0066cc').text(`PERSON ${i + 1}`, 70, doc.y);
                doc.moveDown(0.2);

                // Add person image if available
                if (person.imageUrl) {
                    try {
                        // Download the image from the URL
                        const response = await axios.get(person.imageUrl, {
                            responseType: 'arraybuffer'
                        });

                        // Create a buffer from the response data
                        const imageBuffer = Buffer.from(response.data, 'binary');

                        // Calculate image position (right side of the person info)
                        const imageX = 400;
                        const imageY = doc.y;

                        // Add the image to the PDF with a maximum width/height of 100px
                        doc.image(imageBuffer, imageX, imageY, {
                            fit: [100, 100],
                            align: 'right'
                        });
                    } catch (error) {
                        console.error(`Error adding person image for ${person.name}:`, error);
                        // Continue without the image if there's an error
                    }
                }

                doc.fontSize(10).fillColor('#333333');
                doc.text(`Full name: ${person.name}`, 70);
                doc.text(`Relationship: ${convertToASCII(person.relationship)}`);
                if (person.dob) {
                    doc.text(`Date of birth: ${moment(person.dob).format('DD/MM/YYYY')}`);
                }
                doc.text(`Place of birth: ${convertToASCII(person.birthPlace)}`);
                doc.text(`Nationality: ${convertToASCII(person.nationality)}`);
                if (person.identityDocument) {
                    doc.text(`Identity document: ${person.identityDocument}`);
                }
                doc.text(`Sample ID: ${person.sampleId}`);

                doc.moveDown(1);
                doc.y += 20;

                // Add new page if there are more people and not enough space
                if (i < data.personsInfo.length - 1 && doc.y > 650) {
                    doc.addPage();
                }
            }
        }

        // Add sample information with styled section
        doc.addPage();
        doc.roundedRect(50, doc.y, 500, 110, 5).fillAndStroke('#f0f7ff', '#bbddff');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('SAMPLE INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        // Display information about additional samples if available
        if (data.allSampleIds && data.allSampleIds.length > 1) {
            doc.moveDown(0.2);
            doc.text(`Number of samples: ${data.allSampleIds.length}`, 70);

            // Display list of sample IDs (maximum 5 samples to avoid excessive length)
            const displaySampleIds = data.allSampleIds.slice(0, 5);
            const remainingSamples = data.allSampleIds.length - 5;

            doc.text(`Sample ID list: ${displaySampleIds.join(', ')}${remainingSamples > 0 ? ` and ${remainingSamples} other samples` : ''}`, 70);
        }
        doc.text(`Sample type: ${convertToASCII(translateSampleType(data.sampleType))}`);
        doc.text(`Collection method: ${convertToASCII(translateCollectionMethod(data.collectionMethod))}`);
        doc.text(`Collection date: ${moment(data.collectionDate).format('DD/MM/YYYY')}`);

        doc.moveDown(1);
        doc.y += 10;

        // Add appointment information with styled section
        doc.roundedRect(50, doc.y, 500, 90, 5).fillAndStroke('#f5f0ff', '#ccbbff');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('APPOINTMENT INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        doc.text(`Appointment ID: ${data.appointmentId}`, 70);
        doc.text(`Appointment date: ${moment(data.appointmentDate).format('DD/MM/YYYY')}`);
        doc.text(`Service type: ${convertToASCII(translateServiceType(data.serviceType))}`);
        doc.moveDown(1);
        doc.y += 10;

        // Add test results with prominent styling
        doc.addPage();

        // Add decorative line for results page
        doc.lineWidth(2)
            .moveTo(50, 70)
            .lineTo(550, 70)
            .stroke('#0066cc');

        doc.fontSize(20).fillColor('#0066cc').text('TEST RESULTS', { align: 'center' });
        doc.moveDown(1);

        // Display match results prominently with improved visual indicator
        const resultBoxHeight = 60;
        const resultBoxY = doc.y;

        doc.roundedRect(150, resultBoxY, 300, resultBoxHeight, 10)
            .fillAndStroke(data.isMatch ? '#e6ffe6' : '#ffe6e6', data.isMatch ? '#00cc00' : '#cc0000');

        doc.fontSize(18).fillColor(data.isMatch ? '#006600' : '#990000');
        doc.text(`Result: ${data.isMatch ? 'MATCH' : 'NO MATCH'}`, 150, resultBoxY + 20, {
            align: 'center',
            width: 300
        });

        doc.y = resultBoxY + resultBoxHeight + 20;

        // Add detailed results with improved formatting
        if (data.resultData) {
            doc.fontSize(16).fillColor('#0066cc').text('Detailed test results:', { underline: true });
            doc.moveDown(0.5);

            // Get keys from result data
            const details = data.resultData;
            const keys = Object.keys(details);

            // Create table-like structure for results
            const startY = doc.y;
            let currentY = startY;

            // Draw table header
            doc.rect(50, currentY, 500, 30).fillAndStroke('#0066cc', '#0066cc');
            doc.fillColor('#ffffff').fontSize(14).text('Parameter', 70, currentY + 8);
            doc.text('Value', 350, currentY + 8);
            currentY += 30;

            // Add each result data point in alternating color rows
            keys.forEach((key, index) => {
                const isEvenRow = index % 2 === 0;
                const rowColor = isEvenRow ? '#f2f2f2' : '#ffffff';

                doc.rect(50, currentY, 500, 25).fill(rowColor);

                const formattedKey = convertToASCII(translateResultKey(key));
                doc.fillColor('#333333').fontSize(12)
                    .text(formattedKey, 70, currentY + 6);
                doc.text(`${details[key]}`, 350, currentY + 6);

                currentY += 25;
            });

            // Draw border around entire table
            doc.rect(50, startY, 500, currentY - startY).stroke('#cccccc');
        }

        doc.moveDown(1.5);

        // Add laboratory technician information with styled section
        doc.roundedRect(50, doc.y, 500, 80, 5).fillAndStroke('#f0f7ff', '#bbddff');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('LABORATORY INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        doc.text(`Laboratory technician: ${data.labTechnicianName}`, 70);
        doc.text(`Completion date: ${moment(data.completedAt).format('DD/MM/YYYY')}`);
        doc.moveDown(1.5);

        // Add signature line with improved styling
        doc.y += 20;
        doc.fontSize(12).fillColor('#333333').text('Signature', 70);
        doc.lineCap('butt')
            .moveTo(70, doc.y + 40)
            .lineTo(250, doc.y + 40)
            .stroke('#333333');
        doc.text('Laboratory technician', 70, doc.y + 45);

        // Add placeholder for company seal
        doc.circle(400, doc.y + 30, 40).stroke('#999999');
        doc.fontSize(10).fillColor('#999999').text('Official', 380, doc.y + 25);
        doc.text('seal', 385, doc.y + 38);

        // Add footer with disclaimer but no page numbering
        const footerY = doc.page.height - 50;
        doc.lineWidth(0.5)
            .moveTo(50, footerY - 15)
            .lineTo(550, footerY - 15)
            .stroke('#cccccc');

        doc.fontSize(10).fillColor('#666666').text(
            'This report is automatically generated and valid without signature. ' +
            'Results should be interpreted by qualified medical professionals.',
            50, footerY, { width: 500, align: 'center' }
        );

        // Finalize PDF
        doc.end();

        // Wait for file to be written
        await new Promise<void>((resolve) => {
            writeStream.on('finish', () => {
                resolve();
            });
        });

        // Upload to S3
        try {
            const fileContent = fs.readFileSync(tempFilePath);
            const timestamp = moment().format('YYYYMMDD-HHmmss');
            const fileName = `test-results/${data.customerId}/${data.resultId}-${timestamp}.pdf`;

            console.log(`Uploading PDF to S3 with filename: ${fileName}`);
            console.log(`Using bucket: ${process.env.AWS_S3_BUCKET_NAME}`);

            // Upload to S3
            const params = {
                Bucket: process.env.AWS_S3_BUCKET_NAME,
                Key: fileName,
                Body: fileContent,
                ContentType: 'application/pdf',
                // TODO: Uncomment this when we have a way to handle the ACL
                // ACL: 'public-read' 
            };

            console.log('Starting S3 upload...');
            const uploadResult = await s3.upload(params).promise();
            console.log('S3 upload completed successfully:', uploadResult.Location);

            // Delete temporary file
            fs.unlinkSync(tempFilePath);

            // Cuối file, nếu là ADMINISTRATIVE, thêm section xác nhận của cơ quan
            if (template === 'administrative_report_template') {
                doc.addPage();
                doc.fontSize(14).fillColor('#cc0000').text('AGENCY CONFIRMATION', { align: 'center' });
                doc.moveDown(1);
                doc.fontSize(12).fillColor('#333333').text('This report is issued for administrative/legal purposes.');
                doc.moveDown(1);
                doc.text('Agency Representative: ___________________________');
                doc.moveDown(0.5);
                doc.text('Position: _______________________________________');
                doc.moveDown(0.5);
                doc.text('Date: ___________________   Signature: ___________________');
            }

            return uploadResult.Location;
        } catch (error: any) {
            throw new HttpException(
                HttpStatus.InternalServerError,
                `Error processing PDF: ${error.message}`
            );
        }
    } catch (error: any) {
        // Clean up temporary file if it exists
        if (fs.existsSync(tempFilePath)) {
            try {
                fs.unlinkSync(tempFilePath);
            } catch (unlinkError) {
                console.error('Error deleting temporary file:', unlinkError);
            }
        }

        console.error('Error generating or uploading PDF:', error);
        throw new HttpException(
            HttpStatus.InternalServerError,
            `Failed to generate or upload PDF report: ${error.message}`
        );
    }
}

/**
 * Function to convert Vietnamese Unicode characters to ASCII
 */
function convertToASCII(text: string): string {
    return text
        .replace(/[àáạảãâầấậẩẫăằắặẳẵ]/g, 'a')
        .replace(/[èéẹẻẽêềếệểễ]/g, 'e')
        .replace(/[ìíịỉĩ]/g, 'i')
        .replace(/[òóọỏõôồốộổỗơờớợởỡ]/g, 'o')
        .replace(/[ùúụủũưừứựửữ]/g, 'u')
        .replace(/[ỳýỵỷỹ]/g, 'y')
        .replace(/đ/g, 'd')
        .replace(/[ÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴ]/g, 'A')
        .replace(/[ÈÉẸẺẼÊỀẾỆỂỄ]/g, 'E')
        .replace(/[ÌÍỊỈĨ]/g, 'I')
        .replace(/[ÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠ]/g, 'O')
        .replace(/[ÙÚỤỦŨƯỪỨỰỬỮ]/g, 'U')
        .replace(/[ỲÝỴỶỸ]/g, 'Y')
        .replace(/Đ/g, 'D');
}

/**
 * Helper functions to translate terms to Vietnamese
 */
function translateGender(gender: string): string {
    const genderMap: Record<string, string> = {
        'male': 'Nam',
        'female': 'Nữ',
        'other': 'Khác'
    };
    return genderMap[gender.toLowerCase()] || gender;
}

function translateSampleType(sampleType: string): string {
    const sampleTypeMap: Record<string, string> = {
        'blood': 'Máu',
        'urine': 'Nước tiểu',
        'hair': 'Tóc',
        'saliva': 'Nước bọt',
        'tissue': 'Mô',
        'swab': 'Tăm bông'
    };
    return sampleTypeMap[sampleType.toLowerCase()] || sampleType;
}

function translateCollectionMethod(method: string): string {
    const methodMap: Record<string, string> = {
        'venipuncture': 'Lấy máu tĩnh mạch',
        'finger prick': 'Lấy máu đầu ngón tay',
        'swab collection': 'Thu thập bằng tăm bông',
        'clean catch': 'Thu thập sạch',
        'self': 'Tự thu thập'
    };
    return methodMap[method.toLowerCase()] || method;
}

function translateServiceType(serviceType: string): string {
    const serviceTypeMap: Record<string, string> = {
        'general checkup': 'Khám tổng quát',
        'blood test': 'Xét nghiệm máu',
        'genetic test': 'Xét nghiệm di truyền',
        'allergy test': 'Xét nghiệm dị ứng',
        'covid test': 'Xét nghiệm COVID',
        'dna test': 'Xét nghiệm ADN',
        'DNA Paternity Test': 'Xét nghiệm ADN xác định huyết thống'
    };
    return serviceTypeMap[serviceType.toLowerCase()] || serviceType;
}

function translateResultKey(key: string): string {
    // Convert snake_case to readable format and translate
    const formattedKey = key
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

    const resultKeyMap: Record<string, string> = {
        'Blood Pressure': 'Huyết áp',
        'Heart Rate': 'Nhịp tim',
        'Glucose Level': 'Mức đường huyết',
        'Cholesterol': 'Cholesterol',
        'Hemoglobin': 'Hemoglobin',
        'White Blood Cell Count': 'Số lượng bạch cầu',
        'Red Blood Cell Count': 'Số lượng hồng cầu',
        'Platelet Count': 'Số lượng tiểu cầu',
        'Dna Match': 'Khớp ADN',
        'Match Percentage': 'Tỷ lệ khớp',
        'Match Score': 'Điểm khớp',
        'Confidence Level': 'Mức độ tin cậy'
    };

    return resultKeyMap[formattedKey] || formattedKey;
}         


================================================
FILE: src/modules/review/index.ts
================================================
import ReviewSchema from './review.model';
import { IReview } from './review.interface';
import ReviewController from './review.controller';
import ReviewService from './review.service';
import ReviewRoute from './review.route';

export {
    ReviewSchema,
    IReview,
    ReviewController,
    ReviewService,
    ReviewRoute
}; 


================================================
FILE: src/modules/review/review.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IReview } from './review.interface';
import ReviewService from './review.service'
import { CreateReviewDto, UpdateReviewDto } from './dtos';
import { UserRoleEnum } from '../user';
import { SearchPaginationResponseModel } from '../../core/models';

export default class ReviewController {
    private reviewService = new ReviewService();

    /**
     * Create a review
     */
    public createReview = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (!req.user) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }
            const reviewData: CreateReviewDto = req.body;
            // Set customer_id from the logged-in user
            const customer_id = req.user.id;
            const review = await this.reviewService.createReview(req.user, { customer_id, ...reviewData, });
            res.status(HttpStatus.Created).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }
    /**
     * Get reviews by appointment ID
     */
    public getReviewsByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            const reviews = await this.reviewService.getReviewsByAppointmentId(appointmentId);
            res.status(HttpStatus.Success).json(formatResponse<IReview[]>(reviews));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get review by ID
     */
    public getReviewById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const reviewId = req.params.id;
            const review = await this.reviewService.getReviewById(reviewId);
            res.status(HttpStatus.Success).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Update review
     */
    public updateReview = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const reviewId = req.params.id;
            const updateData: UpdateReviewDto = req.body;
            const customer_id = req.user.id;
            const review = await this.reviewService.updateReview(updateData, reviewId, customer_id);
            res.status(HttpStatus.Success).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Delete review
     */
    public deleteReview = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const reviewId = req.params.id;
            const review = await this.reviewService.deleteReview(reviewId);
            res.status(HttpStatus.Success).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }





}


================================================
FILE: src/modules/review/review.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IReview extends Document {
    _id: string;
    rating: number;
    comment: string;
    appointment_id: string | undefined;
    customer_id: string | undefined;
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
} 


================================================
FILE: src/modules/review/review.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IReview } from './review.interface';

const ReviewSchemaEntity: Schema<IReview> = new Schema({
    rating: { type: Number, required: true },
    comment: { type: String, required: true },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const ReviewSchema = mongoose.model<IReview & mongoose.Document>(
    COLLECTION_NAME.REVIEW,
    ReviewSchemaEntity
);

export default ReviewSchema; 


================================================
FILE: src/modules/review/review.repository.ts
================================================
import ReviewSchema from './review.model';
import { IReview } from './review.interface';
import { Types } from 'mongoose';

export const createReview = async (reviewData: Partial<IReview>) => {
    return await ReviewSchema.create(reviewData);
};

export const getReviewsByAppointment = async (appointmentId: string) => {
    return await ReviewSchema.find({ appointment_id: appointmentId, is_deleted: { $ne: true } });
};

export const getReviewById = async (id: string) => {
    return await ReviewSchema.findById(id);
};

export const updateReview = async (id: string, updateData: Partial<IReview>, customer_id: string) => {
    return await ReviewSchema.findOneAndUpdate(
        { _id: id, customer_id },
        updateData,
        { new: true }
    );
};

export const deleteReview = async (id: string) => {
    return await ReviewSchema.findByIdAndUpdate(id, { is_deleted: true }, { new: true });
};



================================================
FILE: src/modules/review/review.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import ReviewController from './review.controller';
import { CreateReviewDto, UpdateReviewDto } from './dtos';

export default class ReviewRoute implements IRoute {
    public path = API_PATH.REVIEW;
    public router = Router();
    private reviewController = new ReviewController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/review -> Create a review
        this.router.post(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(CreateReviewDto),
            this.reviewController.createReview
        );

        // GET: domain:/api/review/appointment/:appointmentId -> Get reviews by appointment ID
        this.router.get(
            `${this.path}/appointment/:appointmentId`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            this.reviewController.getReviewsByAppointmentId
        );

        // GET: domain:/api/review/:id -> Get review by ID
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            this.reviewController.getReviewById
        );

        // PUT: domain:/api/review/:id -> Update review 
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(UpdateReviewDto),
            this.reviewController.updateReview
        );

        // DELETE: domain:/api/review/:id -> Delete review
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            this.reviewController.deleteReview
        );
    }
}


================================================
FILE: src/modules/review/review.service.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { SearchPaginationResponseModel } from '../../core/models';
import * as reviewRepository from './review.repository';
import { IReview } from './review.interface';
import { AppointmentSchema } from '../appointment';
import { ResultSchema } from '../result';
import { CreateReviewDto, UpdateReviewDto } from './dtos'
import UserSchema from '../user/user.model';
import { UserRoleEnum } from '../user/user.enum';
import ServiceSchema from '../service/service.model';
import { ServiceTypeEnum } from '../service/service.enum';

export default class ReviewService {
    private readonly reviewRepository: typeof reviewRepository;
    private readonly appointmentSchema: typeof AppointmentSchema;
    private readonly userSchema: typeof UserSchema;
    private readonly resultSchema: typeof ResultSchema;


    constructor() {
        this.reviewRepository = reviewRepository;
        this.appointmentSchema = AppointmentSchema;
        this.userSchema = UserSchema;
        this.resultSchema = ResultSchema;
    }

    /**
     * Create a review
     */
    public async createReview(user: any, reviewData: any): Promise<IReview> {
        try {
            // Check if a result exists for the appointment and customer
            const result = await this.resultSchema.findOne({
                appointment_id: reviewData.appointment_id,
                customer_id: reviewData.customer_id
            });
            if (!result) {
                throw new HttpException(HttpStatus.NotFound, 'Result not found');
            }

            const service = await ServiceSchema.findById(reviewData.service_id);
            if (service && service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                if (user.role !== UserRoleEnum.ADMIN && user.role !== UserRoleEnum.MANAGER) {
                    throw new Error('Only ADMIN or MANAGER can review ADMINISTRATIVE services');
                }
            }

            // Create the review
            const review = await this.reviewRepository.createReview(reviewData);
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating review');
        }
    }

    /**
     * Get reviews by appointment ID
     */
    public async getReviewsByAppointmentId(appointmentId: string): Promise<IReview[]> {
        try {
            const reviews = await this.reviewRepository.getReviewsByAppointment(appointmentId);
            return reviews;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting reviews');
        }
    }

    /**
     * Get review by ID
     */
    public async getReviewById(id: string): Promise<IReview> {
        try {
            const review = await this.reviewRepository.getReviewById(id);
            if (!review) {
                throw new HttpException(HttpStatus.NotFound, 'Review not found');
            }
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting review');
        }
    }

    /**
     * Update review
     */
    public async updateReview(updateData: UpdateReviewDto, id: string, customer_id: string): Promise<IReview> {
        try {
            const review = await this.reviewRepository.updateReview(id, updateData, customer_id);
            if (!review) {
                throw new HttpException(HttpStatus.NotFound, 'Review not found');
            }
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating review');
        }
    }

    /**
     * Delete review
     */
    public async deleteReview(id: string): Promise<IReview> {
        try {
            const review = await this.reviewRepository.deleteReview(id);
            if (!review) {
                throw new HttpException(HttpStatus.NotFound, 'Review not found');
            }
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting review');
        }
    }

}


================================================
FILE: src/modules/review/dtos/createReview.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsOptional } from 'class-validator';

export class CreateReviewDto {
    @IsNotEmpty()
    @IsNumber()
    rating: number = 0;

    @IsNotEmpty()
    @IsString()
    comment: string = '';

    @IsNotEmpty()
    @IsString()
    appointment_id: string = '';

    @IsOptional()
    @IsString()
    customer_id?: string;
}


================================================
FILE: src/modules/review/dtos/index.ts
================================================
import { CreateReviewDto } from './createReview.dto';
import { UpdateReviewDto } from './updateReview.dto';

export { CreateReviewDto, UpdateReviewDto };


================================================
FILE: src/modules/review/dtos/updateReview.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class UpdateReviewDto {

    @IsNotEmpty()
    @IsNumber()
    rating: number = 0;

    @IsNotEmpty()
    @IsString()
    comment: string = '';

    @IsNotEmpty()
    @IsString()
    appointment_id: string = '';
};



================================================
FILE: src/modules/review/swagger/review.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Review:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Review ID
 *         rating:
 *           type: number
 *           description: Rating given by the user
 *         comment:
 *           type: string
 *           description: Review comment
 *         appointment_id:
 *           type: string
 *           description: Appointment ID being reviewed
 *         customer_id:
 *           type: string
 *           description: Customer (user) ID who wrote the review
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 *         is_deleted:
 *           type: boolean
 *           default: false
 *       required:
 *         - rating
 *         - comment
 *         - appointment_id
 *     CreateReviewDto:
 *       type: object
 *       properties:
 *         rating:
 *           type: number
 *           example: 5
 *         comment:
 *           type: string
 *           example: \"Excellent service\"
 *         appointment_id:
 *           type: string
 *           example: \"60f7c0b8b4d1c80015b4e8a1\"
 *       required:
 *         - rating
 *         - comment
 *         - appointment_id
 *     UpdateReviewDto:
 *       type: object
 *       properties:
 *         rating:
 *           type: number
 *           example: 4
 *         comment:
 *           type: string
 *           example: \"Updated comment\"
 *         appointment_id:
 *           type: string
 *           example: \"60f7c0b8b4d1c80015b4e8a1\"
 *       required:
 *         - rating
 *         - comment
 *         - appointment_id
 */


================================================
FILE: src/modules/review/swagger/review.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: Review
 *   description: Endpoints for managing reviews for appointments
 */

/**
 * @swagger
 * /api/review:
 *   post:
 *     summary: Create a new review for an appointment
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateReviewDto'
 *     responses:
 *       201:
 *         description: Review created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Result not found for appointment and user
 *       400:
 *         description: Invalid input
 *
 * /api/review/appointment/{appointmentId}:
 *   get:
 *     summary: Get all reviews for a specific appointment
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the appointment
 *     responses:
 *       200:
 *         description: List of reviews for the appointment
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Review'
 *       404:
 *         description: Appointment not found
 *
 * /api/review/{id}:
 *   get:
 *     summary: Get a review by its ID
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the review
 *     responses:
 *       200:
 *         description: Review found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Review not found
 *   put:
 *     summary: Update a review by its ID
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the review
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateReviewDto'
 *     responses:
 *       200:
 *         description: Review updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Review not found
 *   delete:
 *     summary: Delete a review by its ID
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the review
 *     responses:
 *       200:
 *         description: Review deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Review not found
 */


================================================
FILE: src/modules/sample/index.ts
================================================
import SampleSchema from './sample.model';
import { ISample, SampleType, SampleStatus, CollectionMethod } from './sample.interface';
import { SampleTypeEnum, SampleStatusEnum, CollectionMethodEnum } from './sample.enum';
import { SampleTypes, SampleStatuses, CollectionMethods } from './sample.constant';
import SampleController from './sample.controller';
import SampleService from './sample.service';
import SampleRepository from './sample.repository';
import SampleRoute from './sample.route';
import { SubmitSampleDto, ReceiveSampleDto } from './dtos';

export {
    SampleSchema,
    ISample,
    SampleType,
    SampleStatus,
    CollectionMethod,
    SampleTypeEnum,
    SampleStatusEnum,
    CollectionMethodEnum,
    SampleTypes,
    SampleStatuses,
    CollectionMethods,
    SampleController,
    SampleService,
    SampleRepository,
    SampleRoute,
    SubmitSampleDto,
    ReceiveSampleDto
}; 


================================================
FILE: src/modules/sample/sample.constant.ts
================================================
import { CollectionMethodEnum, SampleStatusEnum, SampleTypeEnum } from './sample.enum';

export const SampleTypes = [
    '',
    SampleTypeEnum.SALIVA,
    SampleTypeEnum.BLOOD,
    SampleTypeEnum.HAIR,
    SampleTypeEnum.OTHER
];

export const SampleStatuses = [
    '',
    SampleStatusEnum.PENDING,
    SampleStatusEnum.RECEIVED,
    SampleStatusEnum.TESTING,
    SampleStatusEnum.COMPLETED,
    SampleStatusEnum.INVALID
];

export const CollectionMethods = [
    '',
    CollectionMethodEnum.SELF,
    CollectionMethodEnum.FACILITY,
    CollectionMethodEnum.HOME
]; 


================================================
FILE: src/modules/sample/sample.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { ISample } from './sample.interface';
import SampleService from './sample.service';
import { SubmitSampleDto } from './dtos/submitSample.dto';
import { ReceiveSampleDto } from './dtos/receiveSample.dto';
import { UserRoleEnum } from '../user/user.enum';
import { AddSampleDto } from './dtos/addSample.dto';
import { AddSampleWithMultiplePersonInfoDto } from './dtos/addSampleWithMultiplePersonInfo.dto';
import { BatchSubmitSamplesDto } from './dtos/batchSubmitSamples.dto';
import { BatchReceiveSamplesDto } from './dtos/batchReceiveSamples.dto';
import { SearchSamplesDto } from './dtos/searchSamples.dto';
import { uploadFileToS3 } from '../../core/utils';
import { SampleStatusEnum, SampleTypeEnum } from './sample.enum';
import { CollectSampleDto } from './dtos/collect-sample.dto';
export default class SampleController {
    private sampleService = new SampleService();

    /**
     * Submit a sample (by customer)
     */
    public submitSample = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const sampleId = req.params.id;
            const submitData: SubmitSampleDto = req.body;

            const updatedSample = await this.sampleService.submitSample(
                sampleId,
                submitData.collection_date ?? new Date().toISOString(),
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample>(updatedSample));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Receive a sample (by staff)
     */
    public receiveSample = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            const userRole = req.user.role;

            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only staff can receive samples
            if (userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(HttpStatus.Forbidden, 'Only staff can receive samples');
            }

            const sampleId = req.params.id;
            const receiveData: ReceiveSampleDto = req.body;

            const updatedSample = await this.sampleService.receiveSample(
                sampleId,
                receiveData.received_date,
                staffId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample>(updatedSample));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get sample by ID
     */
    public getSampleById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const sampleId = req.params.id;
            const sample = await this.sampleService.getSampleById(sampleId);

            res.status(HttpStatus.Success).json(formatResponse<ISample>(sample));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get samples by appointment ID
     */
    public getSamplesByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            const samples = await this.sampleService.getSamplesByAppointmentId(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get samples ready for testing (samples with status RECEIVED)
     * This is used by laboratory technicians to find samples that are ready to be tested
     */
    public getSamplesReadyForTesting = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only laboratory technicians can access this endpoint
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(
                    HttpStatus.Forbidden,
                    'Only laboratory technicians can access samples ready for testing'
                );
            }

            // Get pagination parameters from query string
            const page = req.query.page ? parseInt(req.query.page as string) : 1;
            const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;

            const result = await this.sampleService.getSamplesReadyForTesting(page, limit);

            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Search samples by various criteria
     * This allows laboratory technicians to search for samples by different parameters
     */
    public searchSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only laboratory technicians and staff can search samples
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN && userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(
                    HttpStatus.Forbidden,
                    'Only laboratory technicians and staff can search samples'
                );
            }

            // Extract and safely convert query parameters
            let status, type, appointmentId, kitCode, personName, startDate, endDate, page, limit;

            try {
                // Handle status parameter
                if (req.query.status) {
                    status = String(req.query.status) as SampleStatusEnum;
                }

                // Handle type parameter
                if (req.query.type) {
                    type = String(req.query.type) as SampleTypeEnum;
                }

                // Handle appointmentId parameter
                if (req.query.appointmentId) {
                    appointmentId = String(req.query.appointmentId);
                }

                // Handle kitCode parameter
                if (req.query.kitCode) {
                    kitCode = String(req.query.kitCode);
                }

                // Handle personName parameter
                if (req.query.personName) {
                    personName = String(req.query.personName);
                }

                // Handle date parameters
                if (req.query.startDate) {
                    startDate = new Date(String(req.query.startDate));
                    if (isNaN(startDate.getTime())) {
                        startDate = undefined;
                    }
                }

                if (req.query.endDate) {
                    endDate = new Date(String(req.query.endDate));
                    if (isNaN(endDate.getTime())) {
                        endDate = undefined;
                    }
                }

                // Handle pagination parameters
                if (req.query.page) {
                    page = parseInt(String(req.query.page));
                    if (isNaN(page) || page < 1) {
                        page = 1;
                    }
                } else {
                    page = 1;
                }

                if (req.query.limit) {
                    limit = parseInt(String(req.query.limit));
                    if (isNaN(limit) || limit < 1) {
                        limit = 10;
                    }
                } else {
                    limit = 10;
                }
            } catch (error) {
                console.error('Error parsing search parameters:', error);
                // Continue with defaults if parsing fails
            }

            // Prepare search options
            const searchOptions = {
                status,
                type,
                appointmentId,
                kitCode,
                personName,
                startDate,
                endDate,
                page,
                limit
            };

            console.log('Search options in controller:', searchOptions);

            // Search samples
            const result = await this.sampleService.searchSamples(searchOptions);

            // Return formatted response
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get all samples with RECEIVED status for laboratory technicians
     * This endpoint returns all samples ready for testing with pagination
     */
    public getAllSamplesForTesting = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only laboratory technicians can access this endpoint
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(
                    HttpStatus.Forbidden,
                    'Only laboratory technicians can access samples for testing'
                );
            }

            // Get pagination parameters from query string
            const page = req.query.page ? parseInt(req.query.page as string) : 1;
            const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;

            const result = await this.sampleService.getSamplesForTesting(page, limit);

            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Add a sample to an existing appointment
     * @param req Request
     * @param res Response
     */
    public addSampleToAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Tạo DTO từ request body
            const addSampleData: AddSampleDto = req.body;

            // Nếu không có kit_id, hệ thống sẽ tự động gán kit có sẵn
            const samples = await this.sampleService.addSampleToAppointment(userId, addSampleData);

            res.status(HttpStatus.Created).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Add samples with multiple person information
     * Each sample type corresponds to a person_info entry in the person_info_list array
     * @param req Request
     * @param res Response
     */
    public addSamplesWithMultiplePersonInfo = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Create DTO from request body
            const addSampleData: AddSampleWithMultiplePersonInfoDto = req.body;

            // Validate that sample_types and person_info_list have the same length
            if (addSampleData.sample_types.length !== addSampleData.person_info_list.length) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'The number of sample types must match the number of person info entries'
                );
            }

            // Convert to AddSampleDto and set person_info_list
            const convertedData: AddSampleDto = {
                appointment_id: addSampleData.appointment_id,
                kit_id: addSampleData.kit_id,
                sample_types: addSampleData.sample_types,
                notes: addSampleData.notes,
                person_info_list: addSampleData.person_info_list
            };

            // Call the service to add samples
            const samples = await this.sampleService.addSampleToAppointment(userId, convertedData);

            res.status(HttpStatus.Created).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Batch submit multiple samples (by customer)
     * @param req Request
     * @param res Response
     * @param next NextFunction
     */
    public batchSubmitSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const batchSubmitData: BatchSubmitSamplesDto = req.body;

            const updatedSamples = await this.sampleService.batchSubmitSamples(
                batchSubmitData.sample_ids,
                batchSubmitData.collection_date,
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(updatedSamples));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Batch receive multiple samples (by staff)
     * @param req Request
     * @param res Response
     * @param next NextFunction
     */
    public batchReceiveSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            const userRole = req.user.role;

            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only staff can receive samples
            if (userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(HttpStatus.Forbidden, 'Only staff can receive samples');
            }

            const batchReceiveData: BatchReceiveSamplesDto = req.body;

            const updatedSamples = await this.sampleService.batchReceiveSamples(
                batchReceiveData.sample_ids,
                batchReceiveData.received_date,
                staffId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(updatedSamples));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Upload an image for a person in a sample
     * @param req Request
     * @param res Response
     * @param next NextFunction
     */
    public uploadPersonImage = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Get the sample ID from the request body or query parameters
            let sample_id = req.body.sample_id;

            // For multipart/form-data, sample_id might be in req.body as a string
            console.log("Request body:", req.body);
            console.log("Request file:", req.file);

            if (!sample_id) {
                throw new HttpException(HttpStatus.BadRequest, 'Sample ID is required');
            }

            // Check if file was uploaded
            if (!req.file) {
                throw new HttpException(HttpStatus.BadRequest, 'No file uploaded');
            }

            // Get the image URL - either from the file location (already uploaded to S3) or upload it
            let imageUrl = (req.file as any).location || req.file.path;

            // If the file path is not a URL (not already uploaded to S3), upload it
            if (!imageUrl || (!imageUrl.startsWith('http://') && !imageUrl.startsWith('https://'))) {
                imageUrl = await uploadFileToS3(req.file, sample_id);
            }

            console.log("File uploaded successfully to:", imageUrl);

            // Update the person's image URL in the sample
            const updatedSample = await this.sampleService.updatePersonImage(
                sample_id,
                imageUrl,
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse({
                sample: updatedSample,
                // image_url: imageUrl
            }));
        } catch (error) {
            console.error("Error in uploadPersonImage controller:", error);
            next(error);
        }
    };

    /**
     * Collect sample at facility
     * @route POST /samples/collect
     */
    public collectSampleAtFacility = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user?.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'Staff not authenticated');
            }

            const collectSampleData: CollectSampleDto = req.body;

            const result = await this.sampleService.collectSampleAtFacility(
                collectSampleData,
                staffId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(result));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/sample/sample.enum.ts
================================================
export enum SampleTypeEnum {
    SALIVA = 'saliva',
    BLOOD = 'blood',
    HAIR = 'hair',
    OTHER = 'other'
}

export enum SampleStatusEnum {
    PENDING = 'pending',
    RECEIVED = 'received',
    TESTING = 'testing',
    COMPLETED = 'completed',
    INVALID = 'invalid'
}

export enum CollectionMethodEnum {
    SELF = 'self',
    FACILITY = 'facility',
    HOME = 'home'
} 



================================================
FILE: src/modules/sample/sample.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { SampleStatusEnum, SampleTypeEnum } from './sample.enum';
import { CollectionMethodEnum } from './sample.enum';

export type SampleType =
    SampleTypeEnum.SALIVA |
    SampleTypeEnum.BLOOD |
    SampleTypeEnum.HAIR |
    SampleTypeEnum.OTHER;

export type SampleStatus =
    SampleStatusEnum.PENDING |
    SampleStatusEnum.RECEIVED |
    SampleStatusEnum.TESTING |
    SampleStatusEnum.COMPLETED |
    SampleStatusEnum.INVALID;

export type CollectionMethod =
    CollectionMethodEnum.SELF |
    CollectionMethodEnum.FACILITY |
    CollectionMethodEnum.HOME;

export interface IPersonInfo {
    name: string;
    dob?: Date;
    relationship?: string;
    birth_place?: string;
    nationality?: string;
    identity_document?: string;
    image_url?: string;
}

export interface ISample extends Document {
    _id: string;
    appointment_id: string | undefined;
    kit_id: string | undefined;
    type: SampleType | null;
    collection_method: CollectionMethod;
    collection_date: Date;
    received_date?: Date;
    status: SampleStatus;
    person_info?: IPersonInfo;
    person_info_list?: IPersonInfo[];
    created_at: Date;
    updated_at: Date;
    created_by?: string;
    updated_by?: string;
} 


================================================
FILE: src/modules/sample/sample.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { SampleStatuses, SampleTypes, CollectionMethods } from './sample.constant';
import { ISample } from './sample.interface';

const PersonInfoSchema = new Schema({
    name: { type: String, required: true },
    dob: { type: Date },
    relationship: { type: String },
    birth_place: { type: String },
    nationality: { type: String },
    identity_document: { type: String },
    image_url: { type: String }
}, { _id: false });

const SampleSchemaEntity: Schema<ISample> = new Schema({
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    kit_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.KIT, required: true },
    type: {
        type: String,
        enum: SampleTypes,
        required: true
    },
    collection_method: {
        type: String,
        enum: CollectionMethods,
        required: true
    },
    collection_date: { type: Date, required: true },
    received_date: { type: Date },
    status: {
        type: String,
        enum: SampleStatuses,
        required: true
    },
    person_info: { type: PersonInfoSchema },
    person_info_list: { type: [PersonInfoSchema] },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    created_by: { type: String },
    updated_by: { type: String }
});

const SampleSchema = mongoose.model<ISample & mongoose.Document>(COLLECTION_NAME.SAMPLE, SampleSchemaEntity);
export default SampleSchema; 


================================================
FILE: src/modules/sample/sample.repository.ts
================================================
import SampleSchema from './sample.model';
import { ISample } from './sample.interface';

export default class SampleRepository {
    public async create(data: Partial<ISample>): Promise<ISample> {
        return SampleSchema.create(data);
    }

    public async findOne(query: any): Promise<ISample | null> {
        return SampleSchema.findOne(query);
    }

    public async findById(id: string): Promise<ISample | null> {
        return SampleSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<ISample>, options: any = {}): Promise<ISample | null> {
        return SampleSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return SampleSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISample[]> {
        return SampleSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<ISample[]> {
        return SampleSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISample[]> {
        return SampleSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }

    public async findByIdWithPopulate(id: string): Promise<ISample | null> {
        return SampleSchema.findById(id)
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }

    /**
     * Find samples by appointment ID with populated data
     */
    public async findByAppointmentId(appointmentId: string): Promise<ISample[]> {
        return SampleSchema.find({ appointment_id: appointmentId })
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id payment_status created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }

    /**
     * Find multiple samples by their IDs with populated data
     * @param ids Array of sample IDs to find
     */
    public async findManyByIds(ids: string[]): Promise<ISample[]> {
        return SampleSchema.find({ _id: { $in: ids } })
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }
} 


================================================
FILE: src/modules/sample/sample.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware, uploadSingleFile } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import SampleController from './sample.controller';
import { SubmitSampleDto } from './dtos/submitSample.dto';
import { ReceiveSampleDto } from './dtos/receiveSample.dto';
import { AddSampleDto } from './dtos/addSample.dto';
import { AddSampleWithMultiplePersonInfoDto } from './dtos/addSampleWithMultiplePersonInfo.dto';
import { BatchSubmitSamplesDto } from './dtos/batchSubmitSamples.dto';
import { BatchReceiveSamplesDto } from './dtos/batchReceiveSamples.dto';
import { UploadPersonImageDto } from './dtos/uploadPersonImage.dto';
import { SearchSamplesDto } from './dtos/searchSamples.dto';
import { CollectSampleDto } from './dtos/collect-sample.dto';

export default class SampleRoute implements IRoute {
    public path = API_PATH.SAMPLE;
    public router = Router();
    private sampleController = new SampleController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/sample/search -> Search samples by various criteria
        this.router.get(
            `${API_PATH.SAMPLE}/search`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.sampleController.searchSamples
        );

        // GET: domain:/api/sample/testing/ready -> Get samples ready for testing (RECEIVED status)
        this.router.get(
            `${API_PATH.SAMPLE}/testing/ready`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.sampleController.getSamplesReadyForTesting
        );

        // GET: domain:/api/sample/testing/all -> Get all samples with TESTING status without pagination
        this.router.get(
            `${API_PATH.SAMPLE}/testing/all`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.sampleController.getAllSamplesForTesting
        );

        // GET: domain:/api/sample/appointment/:appointmentId -> Get samples by appointment ID
        this.router.get(
            `${API_PATH.SAMPLE}/appointment/:appointmentId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.sampleController.getSamplesByAppointmentId
        );

        // GET: domain:/api/sample/:id -> Get sample by ID
        this.router.get(
            `${API_PATH.SAMPLE}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.sampleController.getSampleById
        );

        // PUT: domain:/api/sample/:id/submit -> Submit a sample (by customer)
        this.router.put(
            `${API_PATH.SAMPLE}/:id/submit`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(SubmitSampleDto),
            this.sampleController.submitSample
        );

        // PUT: domain:/api/sample/:id/receive -> Receive a sample (by staff)
        this.router.put(
            `${API_PATH.SAMPLE}/:id/receive`,
            authMiddleWare([UserRoleEnum.STAFF]),
            validationMiddleware(ReceiveSampleDto),
            this.sampleController.receiveSample
        );

        // POST: domain:/api/sample/add-to-appointment -> Add a sample to an existing appointment
        this.router.post(
            `${API_PATH.SAMPLE}/add-to-appointment`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER]),
            validationMiddleware(AddSampleWithMultiplePersonInfoDto),
            this.sampleController.addSamplesWithMultiplePersonInfo
        );

        // POST: domain:/api/sample/add-multiple-person-samples -> Add samples with multiple person information
        // this.router.post(
        //     `${API_PATH.SAMPLE}/add-multiple-person-samples`,
        //     authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER]),
        //     validationMiddleware(AddSampleWithMultiplePersonInfoDto),
        //     this.sampleController.addSamplesWithMultiplePersonInfo
        // );

        // POST: domain:/api/sample/batch-submit -> Batch submit multiple samples (by customer)
        this.router.post(
            `${API_PATH.SAMPLE}/batch-submit`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(BatchSubmitSamplesDto),
            this.sampleController.batchSubmitSamples
        );

        // POST: domain:/api/sample/batch-receive -> Batch receive multiple samples (by staff)
        this.router.post(
            `${API_PATH.SAMPLE}/batch-receive`,
            authMiddleWare([UserRoleEnum.STAFF]),
            validationMiddleware(BatchReceiveSamplesDto),
            this.sampleController.batchReceiveSamples
        );

        // POST: domain:/api/sample/upload-person-image -> Upload person image for a sample
        this.router.post(
            `${API_PATH.SAMPLE}/upload-person-image`,
            authMiddleWare([UserRoleEnum.CUSTOMER, UserRoleEnum.STAFF]),
            uploadSingleFile('image'),
            this.sampleController.uploadPersonImage
        );

        // POST: domain:/api/samples/collect -> Collect sample at facility
        this.router.post(
            `${this.path}/collect`,
            authMiddleWare([UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(CollectSampleDto),
            this.sampleController.collectSampleAtFacility
        );
    }
} 


================================================
FILE: src/modules/sample/sample.service.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IPersonInfo, ISample } from './sample.interface';
import { SampleStatusEnum, SampleTypeEnum, CollectionMethodEnum } from './sample.enum';
import SampleRepository from './sample.repository';
import { AppointmentLogService } from '../appointment_log';
import { AppointmentLogTypeEnum } from '../appointment_log/appointment_log.enum';
import AppointmentService from '../appointment/appointment.service';
import { AppointmentStatusEnum } from '../appointment/appointment.enum';
import KitService from '../kit/kit.service';
import { KitStatusEnum } from '../kit/kit.enum';
import { SampleSelectionDto } from '../appointment/dtos/createAppointment.dto';
import { TypeEnum } from '../appointment/appointment.enum';
import { AddSampleDto } from './dtos/addSample.dto';
import { SearchPaginationResponseModel } from "../../core/models";
import { CollectSampleDto } from './dtos/collect-sample.dto';
import AppointmentSchema from '../appointment/appointment.model';
import ServiceSchema from '../service/service.model';
import { ServiceTypeEnum } from '../service/service.enum';

/**
 * Helper function to compare MongoDB ObjectIds or strings
 * @param id1 First ID
 * @param id2 Second ID
 * @returns True if the IDs are equal
 */
function areIdsEqual(id1: any, id2: any): boolean {
    if (!id1 || !id2) return false;

    // Convert both to strings and remove any quotes
    const str1 = String(id1).replace(/^"|"$/g, '').trim();
    const str2 = String(id2).replace(/^"|"$/g, '').trim();

    // Try direct string comparison first
    if (str1 === str2) return true;

    // If that fails, try comparing the last 24 chars (MongoDB ObjectId length)
    if (str1.length >= 24 && str2.length >= 24) {
        return str1.slice(-24) === str2.slice(-24); // Compare the last 24 characters of the strings
    }

    return false;
}

/**
 * Helper function to extract user ID from an appointment object that might have populated user_id
 * @param appointment The appointment object
 * @returns The extracted user ID as a string
 */
function extractUserIdFromAppointment(appointment: any): string {
    if (!appointment || !appointment.user_id) {
        throw new Error('User ID not found in appointment');
    }

    // If user_id is an object (populated)
    if (typeof appointment.user_id === 'object' && appointment.user_id !== null) {
        const userObj = appointment.user_id;

        // If populated with _id field
        if (userObj._id) {
            return userObj._id.toString();
        }

        // If populated with id field
        if (userObj.id) {
            return userObj.id.toString();
        }

        // If it's another type of object, try to convert to string
        return String(appointment.user_id);
    }

    // If user_id is a primitive (string or ObjectId)
    return String(appointment.user_id);
}

/**
 * Helper function to extract appointment ID from a sample object that might have populated appointment_id
 * @param sample The sample object
 * @returns The extracted appointment ID as a string
 */
function extractAppointmentIdFromSample(sample: any): string {
    if (!sample || !sample.appointment_id) {
        throw new Error('Appointment ID not found in sample');
    }

    // If appointment_id is an object (populated)
    if (typeof sample.appointment_id === 'object' && sample.appointment_id !== null) {
        const appointmentObj = sample.appointment_id;

        // If populated with _id field
        if (appointmentObj._id) {
            return appointmentObj._id.toString();
        }

        // If it's another type of object, try to convert to string
        return String(sample.appointment_id);
    }

    // If appointment_id is a primitive (string or ObjectId)
    return String(sample.appointment_id);
}

/**
 * Helper function to extract kit ID from a sample object that might have populated kit_id
 * @param sample The sample object
 * @returns The extracted kit ID as a string
 */
function extractKitIdFromSample(sample: any): string {
    if (!sample || !sample.kit_id) {
        throw new Error('Kit ID not found in sample');
    }

    // If kit_id is an object (populated)
    if (typeof sample.kit_id === 'object' && sample.kit_id !== null) {
        const kitObj = sample.kit_id;

        // If populated with _id field
        if (kitObj._id) {
            return kitObj._id.toString();
        }

        // If it's another type of object, try to convert to string
        return String(sample.kit_id);
    }

    // If kit_id is a primitive (string or ObjectId)
    return String(sample.kit_id);
}

export default class SampleService {
    private readonly sampleRepository: SampleRepository;
    private readonly appointmentLogService: AppointmentLogService;
    private readonly kitService: KitService;
    private readonly appointmentService: AppointmentService;

    constructor() {
        this.sampleRepository = new SampleRepository();
        this.appointmentLogService = new AppointmentLogService();
        this.kitService = new KitService();
        this.appointmentService = new AppointmentService();
    }

    /**
     * Submit a sample (by customer)
     */
    public async submitSample(sampleId: string, collectionDate: string, userId: string): Promise<ISample> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.sampleRepository.findByIdWithPopulate(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Log for debugging
            console.log('Original sample object:', JSON.stringify(sample, null, 2));

            // Extract appointment_id using the helper function
            const appointmentId = extractAppointmentIdFromSample(sample);
            console.log('Extracted appointment ID:', appointmentId);

            // Verify that the sample belongs to the user making the request
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Log for debugging
            console.log('Sample appointment_id:', sample.appointment_id, 'type:', typeof sample.appointment_id);
            console.log('Appointment:', JSON.stringify(appointment, null, 2));
            console.log('User ID passed to service:', userId);
            console.log('User ID type:', typeof userId);

            // Extract user_id using the helper function
            const appointmentUserId = extractUserIdFromAppointment(appointment);

            console.log(`Comparing appointment user ID: ${appointmentUserId} with current user ID: ${userId}`);
            console.log('Equal using === ?', appointmentUserId === userId);
            console.log('Equal using areIdsEqual?', areIdsEqual(appointmentUserId, userId));

            if (!areIdsEqual(appointmentUserId, userId)) {
                throw new HttpException(HttpStatus.Forbidden, 'You are not authorized to submit this sample');
            }

            // Verify that the sample is in PENDING status
            if (sample.status !== SampleStatusEnum.PENDING) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot submit sample with status ${sample.status}`
                );
            }

            // Update sample with collection date
            const updateData: any = {
                updated_at: new Date()
            };

            // Chỉ cập nhật collection_date nếu người dùng cung cấp giá trị mới
            if (collectionDate) {
                updateData.collection_date = new Date(collectionDate);
            }

            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                updateData,
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample');
            }

            // Update appointment status to SAMPLE_COLLECTED if not already
            if (appointment.status !== AppointmentStatusEnum.SAMPLE_COLLECTED) {
                await this.appointmentService.updateAppointmentStatus(
                    appointment._id.toString(),
                    AppointmentStatusEnum.SAMPLE_COLLECTED
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.SAMPLE_COLLECTED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for sample submission:', logError);
                }
            }

            // Update kit status to USED if not already
            try {
                // Extract kit_id using the helper function
                const kitId = extractKitIdFromSample(sample);
                console.log('Extracted kit ID:', kitId);

                const kit = await this.kitService.getKitById(kitId);
                console.log('Kit retrieved:', JSON.stringify(kit, null, 2));

                if (kit.status !== KitStatusEnum.USED) {
                    await this.kitService.changeKitStatus(kitId, KitStatusEnum.USED);
                }
            } catch (kitError) {
                console.error('Error updating kit status:', kitError);
                // Don't fail the sample submission if kit update fails
            }

            return updatedSample;
        } catch (error) {
            console.error('Error in submitSample:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error submitting sample: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error submitting sample');
        }
    }

    /**
     * Receive a sample (by staff)
     */
    public async receiveSample(sampleId: string, receivedDate: string, staffId: string): Promise<ISample> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.sampleRepository.findByIdWithPopulate(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Log for debugging
            console.log('Original sample object:', JSON.stringify(sample, null, 2));

            // Extract appointment_id using the helper function
            const appointmentId = extractAppointmentIdFromSample(sample);
            console.log('Extracted appointment ID:', appointmentId);

            // Verify that the sample is in PENDING status
            if (sample.status !== SampleStatusEnum.PENDING) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot receive sample with status ${sample.status}`
                );
            }

            // Verify that the sample has been collected
            if (!sample.collection_date) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Sample must be collected before it can be received'
                );
            }

            // Update sample with received date and status
            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                {
                    received_date: new Date(receivedDate),
                    status: SampleStatusEnum.RECEIVED,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample');
            }

            // Update appointment status to SAMPLE_RECEIVED
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Log for debugging
            console.log('Sample appointment_id:', sample.appointment_id, 'type:', typeof sample.appointment_id);
            console.log('Appointment:', JSON.stringify(appointment, null, 2));
            console.log('Staff ID passed to service:', staffId);

            // Xử lý và ghi log thông tin appointment để debug
            if (appointment.user_id) {
                if (typeof appointment.user_id === 'object') {
                    const userObj = appointment.user_id as any;
                    console.log('User ID in appointment is an object:', userObj);
                } else {
                    console.log('User ID in appointment is a primitive:', appointment.user_id);
                }
            }

            if (appointment.status !== AppointmentStatusEnum.SAMPLE_RECEIVED) {
                await this.appointmentService.updateAppointmentStatus(
                    appointment._id.toString(),
                    AppointmentStatusEnum.SAMPLE_RECEIVED
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.SAMPLE_RECEIVED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for sample reception:', logError);
                }
            }

            // Log kit_id debugging information
            try {
                const kitId = extractKitIdFromSample(sample);
                console.log('Sample kit_id:', sample.kit_id, 'type:', typeof sample.kit_id);
                console.log('Extracted kit ID:', kitId);

                const kit = await this.kitService.getKitById(kitId);
                console.log('Kit status:', kit.status);
            } catch (kitError) {
                console.error('Error retrieving kit information:', kitError);
                // Just log the error, don't fail the sample reception
            }

            return updatedSample;
        } catch (error) {
            console.error('Error in receiveSample:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error receiving sample: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error receiving sample');
        }
    }

    /**
     * Get sample by ID
     */
    public async getSampleById(id: string): Promise<ISample> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
        }

        const sample = await this.sampleRepository.findByIdWithPopulate(id);
        if (!sample) {
            throw new HttpException(HttpStatus.NotFound, 'Sample not found');
        }

        // Log sample details for debugging
        console.log('Retrieved sample:', {
            _id: sample._id,
            appointment_id: typeof sample.appointment_id === 'object' ?
                (sample.appointment_id as any)?._id : sample.appointment_id,
            kit_id: typeof sample.kit_id === 'object' ?
                (sample.kit_id as any)?._id : sample.kit_id,
            type: sample.type,
            status: sample.status
        });

        return sample;
    }

    /**
     * Update sample status
     */
    public async updateSampleStatus(sampleId: string, status: SampleStatusEnum): Promise<ISample> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.getSampleById(sampleId);

            // Update sample status
            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                {
                    status: status,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample status');
            }

            return updatedSample;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating sample status');
        }
    }

    /**
     * Get samples by appointment ID
     */
    public async getSamplesByAppointmentId(appointmentId: string): Promise<ISample[]> {
        try {
            // Validate appointmentId
            if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            console.log('Finding samples for appointment ID:', appointmentId);

            // Verify that the appointment exists
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Extract the ID to ensure we're using a consistent format
            const appointmentIdStr = appointment._id.toString();
            console.log('Found appointment:', appointmentIdStr);

            // Find samples associated with the appointment
            const samples = await this.sampleRepository.findByAppointmentId(appointmentIdStr);
            console.log(`Found ${samples.length} samples for appointment ${appointmentIdStr}`);

            return samples;
        } catch (error) {
            console.error('Error in getSamplesByAppointmentId:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving samples for appointment');
        }
    }

    /**
     * Create samples for an appointment
     * @param appointmentId The ID of the appointment
     * @param sampleTypes Array of sample types to create
     * @param collectionMethod The collection method (SELF, FACILITY, HOME)
     * @deprecated Use addSampleToAppointment instead
     */
    public async createSamplesForAppointment(
        appointmentId: string,
        sampleTypes: SampleSelectionDto[],
        collectionMethod: TypeEnum
    ): Promise<ISample[]> {
        console.warn('DEPRECATED: createSamplesForAppointment is deprecated. Use addSampleToAppointment instead.');
        try {
            if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            // If no sample types provided, use default SALIVA
            if (!sampleTypes || sampleTypes.length === 0) {
                console.log(`No sample types provided for appointment ${appointmentId}, using default SALIVA`);
                sampleTypes = [{ type: SampleTypeEnum.SALIVA }];
            } else {
                console.log(`Creating ${sampleTypes.length} samples for appointment ${appointmentId}:`,
                    sampleTypes.map(s => s.type).join(', '));
            }

            // Get available kits for the samples
            const kitService = this.kitService;
            const availableKits = await kitService.getAvailableKits();
            console.log(`Found ${availableKits.length} available kits`);

            if (availableKits.length < sampleTypes.length) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Not enough available kits. Need ${sampleTypes.length} but only ${availableKits.length} available.`
                );
            }

            // Get appointment data for logging
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Create samples with assigned kits
            const samples: ISample[] = [];
            const assignedKits: string[] = [];

            for (let i = 0; i < sampleTypes.length; i++) {
                const kit = availableKits[i];

                // First, assign the kit to the appointment
                try {
                    await kitService.changeKitStatus(kit._id.toString(), KitStatusEnum.ASSIGNED);
                    assignedKits.push(kit._id.toString());
                    console.log(`Kit ${kit.code || kit._id} assigned to appointment ${appointmentId}`);
                } catch (kitError) {
                    console.error(`Failed to assign kit ${kit._id} to appointment:`, kitError);
                    // If kit assignment fails, try to revert any previously assigned kits
                    for (const assignedKitId of assignedKits) {
                        try {
                            await kitService.changeKitStatus(assignedKitId, KitStatusEnum.AVAILABLE);
                        } catch (revertError) {
                            console.error(`Failed to revert kit ${assignedKitId} status:`, revertError);
                        }
                    }
                    throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign kits to appointment');
                }

                // Then create the sample with the assigned kit
                try {
                    const sample = await this.sampleRepository.create({
                        appointment_id: appointmentId as any,
                        kit_id: kit._id.toString() as any,
                        type: sampleTypes[i].type,
                        collection_method: collectionMethod as unknown as CollectionMethodEnum,
                        collection_date: new Date(),
                        status: SampleStatusEnum.PENDING,
                        created_at: new Date(),
                        updated_at: new Date()
                    });

                    console.log(`Sample created with ID ${sample._id}, type ${sample.type}`);
                    samples.push(sample);
                } catch (sampleError) {
                    console.error(`Failed to create sample for kit ${kit._id}:`, sampleError);
                    // If sample creation fails, try to revert kit status
                    try {
                        await kitService.changeKitStatus(kit._id.toString(), KitStatusEnum.AVAILABLE);
                    } catch (revertError) {
                        console.error(`Failed to revert kit ${kit._id} status:`, revertError);
                    }
                    throw new HttpException(HttpStatus.InternalServerError, 'Failed to create sample');
                }
            }

            // Log the sample creation event
            try {
                await this.appointmentLogService.logSampleCreation(appointment, samples);
                console.log(`Successfully logged sample creation for appointment ${appointmentId}`);
            } catch (logError) {
                console.error('Failed to create log for sample creation:', logError);
                // Don't fail the sample creation if logging fails
            }

            return samples;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            console.error('Error in createSamplesForAppointment:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating samples for appointment');
        }
    }

    /**
     * Add a sample to an existing appointment
     * @param userId ID of the user adding the sample
     * @param addSampleData Data for adding a sample
     */
    public async addSampleToAppointment(userId: string, addSampleData: AddSampleDto): Promise<ISample[]> {
        try {
            // Validate appointmentId
            if (!mongoose.Types.ObjectId.isValid(addSampleData.appointment_id)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            // Get the appointment
            const appointment = await this.appointmentService.getAppointmentById(addSampleData.appointment_id);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            // Check if the appointment belongs to the user
            const appointmentUserId = extractUserIdFromAppointment(appointment);
            if (!areIdsEqual(appointmentUserId, userId)) {
                throw new HttpException(HttpStatus.Forbidden, 'You are not authorized to add samples to this appointment');
            }

            // Validate that there are at least 2 sample types
            if (!addSampleData.sample_types || addSampleData.sample_types.length < 2) {
                throw new HttpException(HttpStatus.BadRequest, 'At least 2 sample types are required');
            }

            // Check if person_info_list is provided and matches the length of sample_types
            if (addSampleData.person_info_list &&
                addSampleData.person_info_list.length !== addSampleData.sample_types.length) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'The number of person_info entries must match the number of sample types'
                );
            }

            const samples: ISample[] = [];

            // Kiểm tra appointment
            const appointmentSchema = await AppointmentSchema.findById(addSampleData.appointment_id);
            if (!appointmentSchema) throw new Error('Appointment not found');
            // Lấy service để kiểm tra loại
            const service = await ServiceSchema.findById(appointmentSchema.service_id);
            if (service && service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                if (addSampleData.collection_method !== 'FACILITY') {
                    throw new Error('ADMINISTRATIVE chỉ cho phép thu mẫu tại cơ sở (FACILITY)');
                }
            }

            // Process each sample type
            for (let i = 0; i < addSampleData.sample_types.length; i++) {
                const sampleType = addSampleData.sample_types[i];

                // Get an available kit
                let kitId = addSampleData.kit_id;
                if (!kitId || i > 0) {
                    // Only use the specified kit for the first sample, get new kits for the rest
                    const availableKits = await this.kitService.getAvailableKits();
                    if (!availableKits || availableKits.length === 0) {
                        throw new HttpException(HttpStatus.BadRequest, 'No available kits found');
                    }
                    kitId = availableKits[0]._id.toString();
                }

                // Update the kit status to ASSIGNED
                await this.kitService.changeKitStatus(kitId, KitStatusEnum.ASSIGNED);

                // Create the sample
                const sampleData: any = {
                    appointment_id: addSampleData.appointment_id,
                    kit_id: kitId,
                    type: sampleType,
                    collection_method: CollectionMethodEnum.SELF, // Default to self collection
                    collection_date: new Date(),
                    status: SampleStatusEnum.PENDING,
                };

                // Set person_info from the corresponding entry in person_info_list if available
                if (addSampleData.person_info_list && addSampleData.person_info_list[i]) {
                    sampleData.person_info = addSampleData.person_info_list[i];
                } else if (addSampleData.person_info) {
                    // Fall back to the single person_info if available
                    sampleData.person_info = addSampleData.person_info;
                }

                const sample = await this.sampleRepository.create(sampleData);
                samples.push(sample);
            }

            // Log the sample addition
            await this.appointmentLogService.logSampleCreation(appointment, samples);

            // Change appointment status to SAMPLE_ASSIGNED if not already
            if (appointment.status !== AppointmentStatusEnum.SAMPLE_ASSIGNED) {
                await this.appointmentService.updateAppointmentStatus(
                    addSampleData.appointment_id,
                    AppointmentStatusEnum.SAMPLE_ASSIGNED
                );
                // Optionally, log the status change if you have a log method for this
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.SAMPLE_ASSIGNED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for SAMPLE_ASSIGNED:', logError);
                }
            }

            return samples;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            console.error('Error in addSampleToAppointment:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to add samples to appointment');
        }
    }

    /**
     * Submit multiple samples at once (by customer)
     * @param sampleIds Array of sample IDs to submit
     * @param collectionDate Optional collection date for all samples
     * @param userId ID of the user submitting the samples
     */
    public async batchSubmitSamples(sampleIds: string[], collectionDate: string | undefined, userId: string): Promise<ISample[]> {
        try {
            if (!sampleIds || sampleIds.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'No sample IDs provided');
            }

            // Validate all sample IDs
            for (const sampleId of sampleIds) {
                if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                    throw new HttpException(HttpStatus.BadRequest, `Invalid sample ID: ${sampleId}`);
                }
            }

            // Find all samples
            const samples = await this.sampleRepository.findManyByIds(sampleIds);
            if (samples.length !== sampleIds.length) {
                throw new HttpException(HttpStatus.NotFound, 'One or more samples not found');
            }

            // Group samples by appointment ID for efficient processing
            const samplesByAppointment = new Map<string, ISample[]>();

            for (const sample of samples) {
                const appointmentId = extractAppointmentIdFromSample(sample);

                if (!samplesByAppointment.has(appointmentId)) {
                    samplesByAppointment.set(appointmentId, []);
                }

                samplesByAppointment.get(appointmentId)!.push(sample);
            }

            // Verify authorization and validate samples for each appointment
            for (const [appointmentId, appointmentSamples] of samplesByAppointment.entries()) {
                // Verify that the samples belong to the user making the request
                const appointment = await this.appointmentService.getAppointmentById(appointmentId);
                const appointmentUserId = extractUserIdFromAppointment(appointment);

                if (!areIdsEqual(appointmentUserId, userId)) {
                    throw new HttpException(HttpStatus.Forbidden,
                        `You are not authorized to submit samples for appointment ${appointmentId}`);
                }

                // Verify that all samples are in PENDING status
                for (const sample of appointmentSamples) {
                    if (sample.status !== SampleStatusEnum.PENDING) {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Cannot submit sample ${sample._id} with status ${sample.status}`
                        );
                    }
                }
            }

            // Update all samples
            const updatedSamples: ISample[] = [];
            const updateData: any = {
                updated_at: new Date()
            };

            // Only update collection_date if provided
            if (collectionDate) {
                updateData.collection_date = new Date(collectionDate);
            }

            // Update each sample
            for (const sampleId of sampleIds) {
                const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                    sampleId,
                    updateData,
                    { new: true }
                );

                if (!updatedSample) {
                    throw new HttpException(HttpStatus.InternalServerError, `Failed to update sample ${sampleId}`);
                }

                updatedSamples.push(updatedSample);
            }

            // Update appointment status and kit status for each appointment
            for (const [appointmentId, appointmentSamples] of samplesByAppointment.entries()) {
                const appointment = await this.appointmentService.getAppointmentById(appointmentId);

                // Update appointment status to SAMPLE_COLLECTED if not already
                if (appointment.status !== AppointmentStatusEnum.SAMPLE_COLLECTED) {
                    await this.appointmentService.updateAppointmentStatus(
                        appointmentId,
                        AppointmentStatusEnum.SAMPLE_COLLECTED
                    );

                    // Log the status change
                    try {
                        await this.appointmentLogService.logStatusChange(
                            appointment,
                            AppointmentLogTypeEnum.SAMPLE_COLLECTED
                        );
                    } catch (logError) {
                        console.error('Failed to create appointment log for batch sample submission:', logError);
                    }
                }

                // Update kit status to USED for each sample
                for (const sample of appointmentSamples) {
                    try {
                        const kitId = extractKitIdFromSample(sample);
                        const kit = await this.kitService.getKitById(kitId);

                        if (kit.status !== KitStatusEnum.USED) {
                            await this.kitService.changeKitStatus(kitId, KitStatusEnum.USED);
                        }
                    } catch (kitError) {
                        console.error(`Error updating kit status for sample ${sample._id}:`, kitError);
                        // Don't fail the batch submission if kit update fails
                    }
                }
            }

            return updatedSamples;
        } catch (error) {
            console.error('Error in batchSubmitSamples:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error submitting samples: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error submitting samples');
        }
    }

    /**
     * Receive multiple samples at once (by staff)
     * @param sampleIds Array of sample IDs to receive
     * @param receivedDate Received date for all samples
     * @param staffId ID of the staff receiving the samples
     */
    public async batchReceiveSamples(sampleIds: string[], receivedDate: string, staffId: string): Promise<ISample[]> {
        try {
            if (!sampleIds || sampleIds.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'No sample IDs provided');
            }

            // Validate all sample IDs
            for (const sampleId of sampleIds) {
                if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                    throw new HttpException(HttpStatus.BadRequest, `Invalid sample ID: ${sampleId}`);
                }
            }

            // Find all samples
            const samples = await this.sampleRepository.findManyByIds(sampleIds);
            if (samples.length !== sampleIds.length) {
                throw new HttpException(HttpStatus.NotFound, 'One or more samples not found');
            }

            // Group samples by appointment ID for efficient processing
            const samplesByAppointment = new Map<string, ISample[]>();

            for (const sample of samples) {
                const appointmentId = extractAppointmentIdFromSample(sample);

                if (!samplesByAppointment.has(appointmentId)) {
                    samplesByAppointment.set(appointmentId, []);
                }

                samplesByAppointment.get(appointmentId)!.push(sample);
            }

            // Validate samples for each appointment
            for (const appointmentSamples of samplesByAppointment.values()) {
                // Verify that all samples are in PENDING status and have been collected
                for (const sample of appointmentSamples) {
                    if (sample.status !== SampleStatusEnum.PENDING) {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Cannot receive sample ${sample._id} with status ${sample.status}`
                        );
                    }

                    if (!sample.collection_date) {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Sample ${sample._id} must be collected before it can be received`
                        );
                    }
                }
            }

            // Update all samples
            const updatedSamples: ISample[] = [];
            const receivedDate_obj = new Date(receivedDate);

            // Update each sample
            for (const sampleId of sampleIds) {
                const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                    sampleId,
                    {
                        received_date: receivedDate_obj,
                        status: SampleStatusEnum.RECEIVED,
                        updated_at: new Date()
                    },
                    { new: true }
                );

                if (!updatedSample) {
                    throw new HttpException(HttpStatus.InternalServerError, `Failed to update sample ${sampleId}`);
                }

                updatedSamples.push(updatedSample);
            }

            // Update appointment status for each appointment
            for (const [appointmentId, _] of samplesByAppointment.entries()) {
                const appointment = await this.appointmentService.getAppointmentById(appointmentId);

                // Update appointment status to SAMPLE_RECEIVED if not already
                if (appointment.status !== AppointmentStatusEnum.SAMPLE_RECEIVED) {
                    await this.appointmentService.updateAppointmentStatus(
                        appointmentId,
                        AppointmentStatusEnum.SAMPLE_RECEIVED
                    );

                    // Log the status change
                    try {
                        await this.appointmentLogService.logStatusChange(
                            appointment,
                            AppointmentLogTypeEnum.SAMPLE_RECEIVED
                        );
                    } catch (logError) {
                        console.error('Failed to create appointment log for batch sample reception:', logError);
                    }
                }
            }

            return updatedSamples;
        } catch (error) {
            console.error('Error in batchReceiveSamples:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error receiving samples: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error receiving samples');
        }
    }

    /**
     * Update a person's image URL in a sample
     * @param sampleId ID of the sample
     * @param imageUrl URL of the uploaded image
     * @param userId ID of the user making the request
     */
    public async updatePersonImage(
        sampleId: string,
        imageUrl: string,
        userId: string
    ): Promise<ISample> {
        try {
            console.log("updatePersonImage called with:", { sampleId, imageUrl, userId });

            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.sampleRepository.findByIdWithPopulate(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            console.log("Sample found:", {
                id: sample._id,
                hasSinglePersonInfo: !!sample.person_info,
                hasPersonInfoList: !!sample.person_info_list,
                personInfoListLength: sample.person_info_list?.length
            });

            // Extract appointment_id using the helper function
            const appointmentId = extractAppointmentIdFromSample(sample);

            // Verify that the sample belongs to the user making the request
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);
            const appointmentUserId = extractUserIdFromAppointment(appointment);

            if (!areIdsEqual(appointmentUserId, userId)) {
                throw new HttpException(HttpStatus.Forbidden, 'You are not authorized to update this sample');
            }

            // Always update the single person_info object
            if (!sample.person_info) {
                sample.person_info = { name: 'Unknown', image_url: imageUrl };
            } else {
                sample.person_info.image_url = imageUrl;
            }

            // Update the sample
            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                { person_info: sample.person_info, updated_at: new Date() },
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample');
            }

            return updatedSample;
        } catch (error) {
            console.error('Error in updatePersonImage:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error updating person image: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating person image');
        }
    }

    /**
     * Get samples ready for testing (samples with status RECEIVED)
     * This is used by laboratory technicians to find samples that are ready to be tested
     */
    public async getSamplesReadyForTesting(page: number = 1, limit: number = 10): Promise<SearchPaginationResponseModel<ISample>> {
        try {
            const skip = (page - 1) * limit;

            // Find samples with status RECEIVED
            const query = { status: SampleStatusEnum.RECEIVED };

            // Get total count for pagination
            const total = await this.sampleRepository.countDocuments(query);

            // Find samples with pagination and populate related fields
            const samples = await this.sampleRepository.findWithPopulate(
                query,
                { received_date: -1 }, // Sort by received date, newest first
                skip,
                limit
            );

            // Calculate total pages
            const pages = Math.ceil(total / limit);

            return new SearchPaginationResponseModel<ISample>(
                samples,
                {
                    totalItems: total,
                    totalPages: pages,
                    pageNum: page,
                    pageSize: limit
                }
            );
        } catch (error) {
            console.error('Error in getSamplesReadyForTesting:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving samples ready for testing');
        }
    }

    /**
     * Get all samples with RECEIVED status
     * This endpoint is used by laboratory technicians to view all samples that need testing
     */
    public async getSamplesForTesting(page: number = 1, limit: number = 10): Promise<SearchPaginationResponseModel<ISample>> {
        try {
            const skip = (page - 1) * limit;

            const query = { status: SampleStatusEnum.TESTING };

            // Get total count for pagination
            const total = await this.sampleRepository.countDocuments(query);

            // Find samples with pagination and populate related fields
            const samples = await this.sampleRepository.findWithPopulate(
                query,
                { received_date: -1 }, // Sort by received date, newest first
                skip,
                limit
            );

            // Calculate total pages
            const pages = Math.ceil(total / limit);

            return new SearchPaginationResponseModel<ISample>(
                samples,
                {
                    totalItems: total,
                    totalPages: pages,
                    pageNum: page,
                    pageSize: limit
                }
            );
        } catch (error) {
            console.error('Error in getSamplesForTesting:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving samples for testing');
        }
    }

    /**
     * Search samples by various criteria
     * This allows laboratory technicians to search for samples by different parameters
     */
    public async searchSamples(
        options: {
            status?: SampleStatusEnum,
            type?: SampleTypeEnum,
            appointmentId?: string,
            kitCode?: string,
            personName?: string,
            startDate?: Date,
            endDate?: Date,
            page?: number,
            limit?: number
        }
    ): Promise<SearchPaginationResponseModel<ISample>> {
        try {
            // Extract options with default values and validation
            const {
                status,
                type,
                appointmentId,
                kitCode,
                personName,
                startDate,
                endDate
            } = options;

            // Ensure page and limit are valid numbers with defaults
            const page = options.page && options.page > 0 ? Math.floor(options.page) : 1;
            const limit = options.limit && options.limit > 0 ? Math.floor(options.limit) : 10;
            const skip = (page - 1) * limit;

            console.log('Search options in service:', {
                status, type, appointmentId, kitCode, personName,
                startDate, endDate, page, limit, skip
            });

            // Build query object
            const query: any = {};

            // Add status filter if provided and valid
            if (status) {
                // Check if status is a valid enum value
                try {
                    // Simple string check instead of using Object.values
                    const validStatuses = ['pending', 'received', 'testing', 'completed', 'invalid'];
                    if (validStatuses.includes(status.toLowerCase())) {
                        query.status = status;
                    }
                } catch (err) {
                    console.log('Error validating status:', err);
                }
            }

            // Add type filter if provided and valid
            if (type) {
                // Check if type is a valid enum value
                try {
                    // Simple string check instead of using Object.values
                    const validTypes = ['saliva', 'blood', 'hair', 'other'];
                    if (validTypes.includes(type.toLowerCase())) {
                        query.type = type;
                    }
                } catch (err) {
                    console.log('Error validating type:', err);
                }
            }

            // Add appointment ID filter if provided and valid
            if (appointmentId && mongoose.Types.ObjectId.isValid(appointmentId)) {
                query.appointment_id = new mongoose.Types.ObjectId(appointmentId);
            }

            // Add date range filter if either start or end date is provided
            if (startDate instanceof Date || endDate instanceof Date) {
                query.updated_at = {};

                // Add start date filter if valid
                if (startDate instanceof Date && !isNaN(startDate.getTime())) {
                    query.updated_at.$gte = startDate;
                }

                // Add end date filter if valid
                if (endDate instanceof Date && !isNaN(endDate.getTime())) {
                    query.updated_at.$lte = endDate;
                }

                // If no valid date filters were added, remove the empty updated_at filter
                if (Object.keys(query.updated_at).length === 0) {
                    delete query.updated_at;
                }
            }

            console.log('MongoDB query:', JSON.stringify(query, null, 2));

            // Get total count for pagination
            const total = await this.sampleRepository.countDocuments(query);

            // Find samples with pagination and populate related fields
            let samples = await this.sampleRepository.findWithPopulate(
                query,
                { updated_at: -1 }, // Sort by updated date, newest first
                skip,
                limit
            );

            // In-memory filtering for properties that can't be filtered in the database query
            let filteredTotal = total;

            // Filter by kit code if provided
            if (kitCode && kitCode.trim() !== '') {
                samples = samples.filter(sample => {
                    const kit = sample.kit_id as any;
                    return kit &&
                        kit.code &&
                        typeof kit.code === 'string' &&
                        kit.code.toLowerCase().includes(kitCode.toLowerCase());
                });
                filteredTotal = samples.length;
            }

            // Filter by person name if provided
            if (personName && personName.trim() !== '') {
                samples = samples.filter(sample => {
                    // Check in single person_info
                    if (sample.person_info &&
                        sample.person_info.name &&
                        typeof sample.person_info.name === 'string') {
                        return sample.person_info.name.toLowerCase().includes(personName.toLowerCase());
                    }

                    // Check in person_info_list
                    if (sample.person_info_list &&
                        Array.isArray(sample.person_info_list) &&
                        sample.person_info_list.length > 0) {
                        return sample.person_info_list.some(person =>
                            person &&
                            person.name &&
                            typeof person.name === 'string' &&
                            person.name.toLowerCase().includes(personName.toLowerCase())
                        );
                    }

                    return false;
                });
                filteredTotal = samples.length;
            }

            // Calculate total pages based on filtered total
            const pages = Math.ceil(filteredTotal / limit);

            // Return paginated results using SearchPaginationResponseModel
            return new SearchPaginationResponseModel<ISample>(
                samples.slice(0, limit), // Ensure we don't return more than the limit
                {
                    totalItems: filteredTotal,
                    totalPages: pages > 0 ? pages : 1, // Ensure at least 1 page even if no results
                    pageNum: page,
                    pageSize: limit
                }
            );
        } catch (error) {
            console.error('Error in searchSamples service:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching samples');
        }
    }

    /**
     * Collect sample at facility
     */
    public async collectSampleAtFacility(model: CollectSampleDto, staff_id: string): Promise<ISample[]> {
        const appointment = await this.appointmentService.getAppointmentById(model.appointment_id);
        if (!appointment) {
            throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
        }

        if (appointment.status !== AppointmentStatusEnum.CONFIRMED) {
            throw new HttpException(HttpStatus.BadRequest, 'Appointment must be confirmed before collecting sample');
        }

        // Validate that number of sample types matches number of person info entries
        if (model.type.length !== model.person_info.length) {
            throw new HttpException(HttpStatus.BadRequest, 'Number of sample types must match number of person information entries');
        }

        // Get available kits
        const availableKits = await this.kitService.getAvailableKits();
        if (availableKits.length < model.type.length) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Not enough available kits. Need ${model.type.length} but only ${availableKits.length} available.`
            );
        }

        const samples: ISample[] = [];

        // Create a sample for each type and person info
        for (let i = 0; i < model.type.length; i++) {
            // Get an available kit
            const kit = availableKits[i];

            // Update kit status to ASSIGNED
            await this.kitService.changeKitStatus(kit._id.toString(), KitStatusEnum.ASSIGNED);

            // Validate the collection date is valid before creating the sample
            if (model.collection_date && isNaN(new Date(model.collection_date).getTime())) {
                throw new HttpException(HttpStatus.BadRequest, 'collection_date must be a valid ISO 8601 date string');
            }

            const sampleData: Partial<ISample> = {
                appointment_id: model.appointment_id,
                kit_id: kit._id.toString(),
                type: model.type[i],
                collection_method: CollectionMethodEnum.FACILITY,
                collection_date: model.collection_date ? new Date(model.collection_date) : new Date(),
                status: SampleStatusEnum.PENDING,
                person_info: model.person_info[i] as IPersonInfo,
                created_at: new Date(),
                updated_at: new Date(),
                created_by: staff_id,
                updated_by: staff_id
            };

            const sample = await this.sampleRepository.create(sampleData);
            samples.push(sample);
        }

        // Update appointment status to SAMPLE_COLLECTED
        await this.appointmentService.updateAppointmentStatus(
            model.appointment_id,
            AppointmentStatusEnum.SAMPLE_COLLECTED
        );

        return samples;
    }
} 


================================================
FILE: src/modules/sample/dtos/addSample.dto.ts
================================================
import { IsDate, IsEnum, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested, ArrayMinSize, ArrayMaxSize, IsUrl } from 'class-validator';
import { SampleTypeEnum } from '../sample.enum';
import { Type } from 'class-transformer';

export class PersonInfoDto {
    @IsNotEmpty()
    @IsString()
    name: string = '';

    @IsOptional()
    @IsDate()
    @Type(() => Date)
    dob?: Date;

    @IsOptional()
    @IsString()
    relationship?: string;

    @IsOptional()
    @IsString()
    birth_place?: string;

    @IsOptional()
    @IsString()
    nationality?: string;

    @IsOptional()
    @IsString()
    identity_document?: string;

    @IsOptional()
    @IsString()
    image_url?: string;
}

export class AddSampleDto {
    @IsMongoId()
    appointment_id: string = '';

    @IsMongoId()
    @IsOptional()
    kit_id?: string;

    @IsEnum(SampleTypeEnum, { each: true })
    sample_types: SampleTypeEnum[] = [SampleTypeEnum.SALIVA];

    @IsString()
    @IsOptional()
    notes?: string;

    @IsOptional()
    @ValidateNested()
    @Type(() => PersonInfoDto)
    person_info?: PersonInfoDto;

    @IsOptional()
    @ValidateNested({ each: true })
    @Type(() => PersonInfoDto)
    person_info_list?: PersonInfoDto[];

    @IsOptional()
    @IsString()
    collection_method?: string;
} 


================================================
FILE: src/modules/sample/dtos/addSampleForFacility.dto.ts
================================================



================================================
FILE: src/modules/sample/dtos/addSampleWithMultiplePersonInfo.dto.ts
================================================
import { IsEnum, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested, ArrayMinSize, ArrayMaxSize, IsArray } from 'class-validator';
import { SampleTypeEnum } from '../sample.enum';
import { Type } from 'class-transformer';
import { PersonInfoDto } from './addSample.dto';

export class AddSampleWithMultiplePersonInfoDto {
    @IsMongoId()
    appointment_id: string = '';

    @IsMongoId()
    @IsOptional()
    kit_id?: string;

    @IsArray()
    @IsEnum(SampleTypeEnum, { each: true })
    @ArrayMinSize(2)
    sample_types: SampleTypeEnum[] = [];

    @IsString()
    @IsOptional()
    notes?: string;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PersonInfoDto)
    @ArrayMinSize(2)
    person_info_list: PersonInfoDto[] = [];
} 


================================================
FILE: src/modules/sample/dtos/batchReceiveSamples.dto.ts
================================================
import { IsArray, IsDateString, IsNotEmpty, IsString } from 'class-validator';

export class BatchReceiveSamplesDto {
    @IsArray()
    @IsString({ each: true })
    sample_ids: string[] = [];

    @IsNotEmpty()
    @IsDateString()
    received_date: string = '';
} 


================================================
FILE: src/modules/sample/dtos/batchSubmitSamples.dto.ts
================================================
import { IsArray, IsDateString, IsOptional, IsString } from 'class-validator';

export class BatchSubmitSamplesDto {
    @IsArray()
    @IsString({ each: true })
    sample_ids: string[] = [];

    @IsOptional()
    @IsDateString()
    collection_date?: string;
} 


================================================
FILE: src/modules/sample/dtos/collect-sample.dto.ts
================================================
import { IsArray, IsDateString, IsEnum, IsNotEmpty, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { SampleTypeEnum } from '../sample.enum';

export class PersonInfoDto {
    @IsNotEmpty()
    @IsString()
    name!: string;

    @IsString()
    gender?: string;

    @IsString()
    phone_number?: string;

    @IsDateString()
    dob?: string;

    @IsString()
    relationship?: string;

    @IsString()
    birth_place?: string;

    @IsString()
    nationality?: string;

    @IsString()
    identity_document?: string;
}

export class CollectSampleDto {
    @IsNotEmpty()
    @IsString()
    appointment_id!: string;

    @IsArray()
    @IsEnum(SampleTypeEnum, { each: true })
    type!: SampleTypeEnum[];

    @Type(() => Date)
    collection_date?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PersonInfoDto)
    person_info!: PersonInfoDto[];
} 


================================================
FILE: src/modules/sample/dtos/index.ts
================================================
export * from './addSample.dto';
export * from './submitSample.dto';
export * from './receiveSample.dto';
export * from './addSampleWithMultiplePersonInfo.dto';
export * from './batchSubmitSamples.dto';
export * from './batchReceiveSamples.dto';
export * from './uploadPersonImage.dto'; 


================================================
FILE: src/modules/sample/dtos/receiveSample.dto.ts
================================================
import { IsDateString, IsNotEmpty } from 'class-validator';

export class ReceiveSampleDto {
    @IsNotEmpty({ message: 'Received date is required' })
    @IsDateString({}, { message: 'Received date must be a valid date' })
    received_date: string = '';
} 


================================================
FILE: src/modules/sample/dtos/searchSamples.dto.ts
================================================
import { IsDateString, IsEnum, IsMongoId, IsNumber, IsOptional, IsString, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { SampleStatusEnum, SampleTypeEnum } from '../sample.enum';

export class SearchSamplesDto {
    @IsOptional()
    @IsEnum(SampleStatusEnum, { message: 'Status must be a valid sample status' })
    status?: SampleStatusEnum;

    @IsOptional()
    @IsEnum(SampleTypeEnum, { message: 'Type must be a valid sample type' })
    type?: SampleTypeEnum;

    @IsOptional()
    @IsMongoId({ message: 'Appointment ID must be a valid MongoDB ID' })
    appointmentId?: string;

    @IsOptional()
    @IsString({ message: 'Kit code must be a string' })
    kitCode?: string;

    @IsOptional()
    @IsString({ message: 'Person name must be a string' })
    personName?: string;

    @IsOptional()
    @IsDateString({}, { message: 'Start date must be a valid date string' })
    startDate?: string;

    @IsOptional()
    @IsDateString({}, { message: 'End date must be a valid date string' })
    endDate?: string;

    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Page must be a number' })
    @Min(1, { message: 'Page must be at least 1' })
    page?: number = 1;

    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Limit must be a number' })
    @Min(1, { message: 'Limit must be at least 1' })
    limit?: number = 10;
} 


================================================
FILE: src/modules/sample/dtos/submitSample.dto.ts
================================================
import { IsDateString, IsOptional } from 'class-validator';

export class SubmitSampleDto {
    @IsOptional()
    @IsDateString({}, { message: 'Collection date must be a valid date' })
    collection_date?: string;
} 


================================================
FILE: src/modules/sample/dtos/uploadPersonImage.dto.ts
================================================
import { IsMongoId, IsNotEmpty } from 'class-validator';

export class UploadPersonImageDto {
    @IsNotEmpty()
    @IsMongoId()
    sample_id: string = '';
} 


================================================
FILE: src/modules/sample/swagger/sample.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     PersonInfoDto:
 *       type: object
 *       required:
 *         - name
 *       properties:
 *         name:
 *           type: string
 *           description: Full name of the person
 *           example: "Nguyễn Văn A"
 *         dob:
 *           type: string
 *           format: date-time
 *           description: Date of birth
 *           example: "1978-04-19T00:00:00Z"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "Cha giả định"
 *         birth_place:
 *           type: string
 *           description: Place of birth
 *           example: "Thanh An"
 *         nationality:
 *           type: string
 *           description: Nationality
 *           example: "Hà Lan"
 *         identity_document:
 *           type: string
 *           description: Identity document number (ID card, passport, etc.)
 *           example: "NX2JHP9F9"
 *         image_url:
 *           type: string
 *           description: URL to the person's image
 *           example: "https://dna-test-samples.s3.ap-southeast-1.amazonaws.com/sample/60c72b2f9b1e8b3b4c8d6e27/1234567890.jpg"
 *
 *     UploadPersonImageDto:
 *       type: object
 *       required:
 *         - sample_id
 *       properties:
 *         sample_id:
 *           type: string
 *           description: ID of the sample
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *
 *     SubmitSampleDto:
 *       type: object
 *       properties:
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the sample was collected (optional - if not provided, the existing collection date will be used)
 *           example: "2025-05-28T10:00:00Z"
 *
 *     ReceiveSampleDto:
 *       type: object
 *       required:
 *         - received_date
 *       properties:
 *         received_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the sample was received by the facility
 *           example: "2025-05-29T09:00:00Z"
 *
 *     BatchSubmitSamplesDto:
 *       type: object
 *       required:
 *         - sample_ids
 *       properties:
 *         sample_ids:
 *           type: array
 *           description: Array of sample IDs to submit
 *           items:
 *             type: string
 *           example: ["60c72b2f9b1e8b3b4c8d6e27", "60c72b2f9b1e8b3b4c8d6e28"]
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the samples were collected (optional - if not provided, the existing collection dates will be used)
 *           example: "2025-05-28T10:00:00Z"
 *
 *     BatchReceiveSamplesDto:
 *       type: object
 *       required:
 *         - sample_ids
 *         - received_date
 *       properties:
 *         sample_ids:
 *           type: array
 *           description: Array of sample IDs to receive
 *           items:
 *             type: string
 *           example: ["60c72b2f9b1e8b3b4c8d6e27", "60c72b2f9b1e8b3b4c8d6e28"]
 *         received_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the samples were received by the facility
 *           example: "2025-05-29T09:00:00Z"
 *
 *     SampleResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Sample ID
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e24"
 *             user_id:
 *               type: object
 *               properties:
 *                 _id:
 *                   type: string
 *                   example: "60c72b2f9b1e8b3b4c8d6e23"
 *                 first_name:
 *                   type: string
 *                   example: "John"
 *                 last_name:
 *                   type: string
 *                   example: "Doe"
 *             service_id:
 *               type: object
 *               properties:
 *                 _id:
 *                   type: string
 *                   example: "60c72b2f9b1e8b3b4c8d6e22"
 *                 name:
 *                   type: string
 *                   example: "DNA Paternity Test"
 *         kit_id:
 *           type: object
 *           description: Associated kit
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e26"
 *             code:
 *               type: string
 *               example: "KIT-20250527-001"
 *         type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample
 *           example: "saliva"
 *         collection_method:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Method of collection
 *           example: "self"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *         received_date:
 *           type: string
 *           format: date-time
 *           description: Date when sample was received by the facility
 *           example: "2025-05-29T09:00:00Z"
 *         status:
 *           type: string
 *           enum: [pending, received, testing, completed, invalid]
 *           description: Current sample status
 *           example: "pending"
 *         person_info:
 *           $ref: '#/components/schemas/PersonInfoDto'
 *         person_info_list:
 *           type: array
 *           description: List of person information associated with each sample type
 *           items:
 *             $ref: '#/components/schemas/PersonInfoDto'
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2025-05-27T09:12:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2025-05-27T09:13:00Z"
 *
 *     AddSampleDto:
 *       type: object
 *       required:
 *         - appointment_id
 *         - sample_types
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment to add the sample to
 *           example: "60d0fe4f5311236168a109ca"
 *         kit_id:
 *           type: string
 *           description: ID of the kit to use (optional - if not provided, an available kit will be assigned)
 *           example: "60d0fe4f5311236168a109cb"
 *         sample_types:
 *           type: array
 *           description: Types of samples to add (must provide at least two)
 *           items:
 *             type: string
 *             enum: [saliva, blood, hair, other]
 *           example: ["saliva", "saliva"]
 *         notes:
 *           type: string
 *           description: Additional notes about the sample
 *           example: "Morning sample"
 *         person_info:
 *           $ref: '#/components/schemas/PersonInfoDto'
 *         person_info_list:
 *           type: array
 *           description: List of person information corresponding to each sample type
 *           items:
 *             $ref: '#/components/schemas/PersonInfoDto'
 *
 *     PersonInfo:
 *       type: object
 *       required:
 *         - name
 *       properties:
 *         name:
 *           type: string
 *           description: Full name of the person
 *         gender:
 *           type: string
 *           description: Gender of the person
 *         phone_number:
 *           type: string
 *           description: Phone number of the person
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *         relationship:
 *           type: string
 *           description: Relationship to the patient
 *         birth_place:
 *           type: string
 *           description: Place of birth
 *         nationality:
 *           type: string
 *           description: Nationality
 *         identity_document:
 *           type: string
 *           description: Identity document number
 *
 *     CollectSampleRequest:
 *       type: object
 *       required:
 *         - appointment_id
 *         - type
 *         - collection_date
 *         - person_info
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment
 *         type:
 *           type: array
 *           items:
 *             type: string
 *             enum: [SALIVA, BLOOD, HAIR, OTHER]
 *           description: Types of samples to collect
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date and time of sample collection
 *         person_info:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/PersonInfo'
 *           description: Information for each person providing a sample
 *
 *     CollectSampleResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *           example: true
 *         message:
 *           type: string
 *           example: Samples collected successfully
 *         data:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               _id:
 *                 type: string
 *                 description: Sample ID
 *               appointment_id:
 *                 type: string
 *                 description: ID of the appointment
 *               type:
 *                 type: string
 *                 enum: [SALIVA, BLOOD, HAIR, OTHER]
 *                 description: Type of sample
 *               collection_method:
 *                 type: string
 *                 enum: [FACILITY]
 *                 description: Method of collection
 *               collection_date:
 *                 type: string
 *                 format: date-time
 *                 description: Date and time of collection
 *               status:
 *                 type: string
 *                 enum: [PENDING]
 *                 description: Status of the sample
 *               person_info:
 *                 $ref: '#/components/schemas/PersonInfo'
 *               created_at:
 *                 type: string
 *                 format: date-time
 *                 description: Creation timestamp
 *               updated_at:
 *                 type: string
 *                 format: date-time
 *                 description: Last update timestamp
 */ 


================================================
FILE: src/modules/sample/swagger/sample.swagger.js
================================================
/**
 * @swagger
 * /api/sample/{id}:
 *   get:
 *     tags:
 *       - samples
 *     summary: Get sample by ID (All authenticated users)
 *     description: Retrieve detailed information about a specific sample
 *     operationId: getSampleById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Sample ID
 *         example: "60c72b2f9b1e8b3b4c8d6e27"
 *     responses:
 *       200:
 *         description: Sample details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Invalid sample ID format
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Invalid sample ID"
 *                 error:
 *                   type: string
 *                   example: "Bad Request"
 *                 statusCode:
 *                   type: integer
 *                   example: 400
 *       401:
 *         description: Unauthorized - Authentication required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Unauthorized"
 *                 error:
 *                   type: string
 *                   example: "Unauthorized"
 *                 statusCode:
 *                   type: integer
 *                   example: 401
 *       403:
 *         description: Forbidden - User cannot access this sample
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "You are not authorized to access this sample"
 *                 error:
 *                   type: string
 *                   example: "Forbidden"
 *                 statusCode:
 *                   type: integer
 *                   example: 403
 *       404:
 *         description: Sample not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Sample not found"
 *                 error:
 *                   type: string
 *                   example: "Not Found"
 *                 statusCode:
 *                   type: integer
 *                   example: 404
 */
/**
 * @swagger
 * /api/sample/appointment/{appointmentId}:
 *   get:
 *     tags:
 *       - samples
 *     summary: Get samples by appointment ID (All authenticated users)
 *     description: Retrieve all samples associated with a specific appointment
 *     operationId: getSamplesByAppointmentId
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Samples retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Invalid appointment ID format
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Invalid appointment ID"
 *                 error:
 *                   type: string
 *                   example: "Bad Request"
 *                 statusCode:
 *                   type: integer
 *                   example: 400
 *       401:
 *         description: Unauthorized - Authentication required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Unauthorized"
 *                 error:
 *                   type: string
 *                   example: "Unauthorized"
 *                 statusCode:
 *                   type: integer
 *                   example: 401
 *       404:
 *         description: Appointment not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Appointment not found"
 *                 error:
 *                   type: string
 *                   example: "Not Found"
 *                 statusCode:
 *                   type: integer
 *                   example: 404
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal server error"
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *                 statusCode:
 *                   type: integer
 *                   example: 500
 */

/**
 * @swagger
 * /api/sample/add-to-appointment:
 *   post:
 *     tags:
 *       - samples
 *     summary: Add samples with multiple person information (Customer only or Other Authenticated Users)
 *     description: Add samples to an existing appointment where each sample type corresponds to a specific person_info entry
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - appointment_id
 *               - sample_types
 *               - person_info_list
 *             properties:
 *               appointment_id:
 *                 type: string
 *                 description: ID of the appointment to add samples to
 *                 example: "60d0fe4f5311236168a109ca"
 *               kit_id:
 *                 type: string
 *                 description: ID of the kit to use for the first sample (optional - if not provided, an available kit will be assigned)
 *                 example: "60d0fe4f5311236168a109cb"
 *               sample_types:
 *                 type: array
 *                 description: Types of samples to add (must provide at least two)
 *                 items:
 *                   type: string
 *                   enum: [saliva, blood, hair, other]
 *                 example: ["saliva", "saliva"]
 *               notes:
 *                 type: string
 *                 description: Additional notes about the samples
 *                 example: "Morning samples"
 *               person_info_list:
 *                 type: array
 *                 description: List of person information corresponding to each sample type (must match the length of sample_types)
 *                 items:
 *                   $ref: '#/components/schemas/PersonInfoDto'
 *                 example: [
 *                   {
 *                     "name": "Nguyễn Văn A",
 *                     "dob": "1978-04-19T00:00:00Z",
 *                     "relationship": "Cha giả định",
 *                     "birth_place": "Thanh An",
 *                     "nationality": "Hà Lan",
 *                     "identity_document": "NX2JHP9F9"
 *                   },
 *                   {
 *                     "name": "Nguyễn Văn B",
 *                     "dob": "2010-03-15T00:00:00Z",
 *                     "relationship": "Con giả định",
 *                     "birth_place": "Hà Nội",
 *                     "nationality": "Việt Nam",
 *                     "identity_document": "CH7382HF2"
 *                   }
 *                 ]
 *     responses:
 *       201:
 *         description: Samples added successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Bad request - Invalid input data, not enough available kits, or mismatched sample_types and person_info_list lengths
 *       401:
 *         description: Unauthorized - User not authenticated
 *       403:
 *         description: Forbidden - User not authorized to add samples to this appointment
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/batch-submit:
 *   post:
 *     tags:
 *       - samples
 *     summary: Submit multiple samples at once (Customer only)
 *     description: Customer submits multiple samples in a single request
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/BatchSubmitSamplesDto'
 *     responses:
 *       200:
 *         description: Samples submitted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Bad request - Invalid input data or sample status
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Customer access required or not your samples
 *       404:
 *         description: One or more samples not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/batch-receive:
 *   post:
 *     tags:
 *       - samples
 *     summary: Receive multiple samples at once (Staff only)
 *     description: Staff confirms receipt of multiple samples in a single request
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/BatchReceiveSamplesDto'
 *     responses:
 *       200:
 *         description: Samples received successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Bad request - Invalid input data or sample status
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required
 *       404:
 *         description: One or more samples not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/upload-person-image:
 *   post:
 *     tags:
 *       - samples
 *     summary: Upload a person's image (Customer only)
 *     description: Upload an image for a person associated with a sample
 *     security:
 *       - Bearer: []
 *     consumes:
 *       - multipart/form-data
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - sample_id
 *               - image
 *             properties:
 *               sample_id:
 *                 type: string
 *                 description: ID of the sample
 *                 example: "60c72b2f9b1e8b3b4c8d6e27"
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: Image file to upload (jpg, jpeg, png, gif)
 *     responses:
 *       200:
 *         description: Image uploaded successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     sample:
 *                       $ref: '#/components/schemas/SampleResponse'
 *                     image_url:
 *                       type: string
 *                       description: URL of the uploaded image
 *                       example: "https://dna-test-samples.s3.ap-southeast-1.amazonaws.com/sample/60c72b2f9b1e8b3b4c8d6e27/1234567890.jpg"
 *       400:
 *         description: Bad request - Invalid input data or no file uploaded
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - User not authorized to update this sample
 *       404:
 *         description: Sample not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/testing/ready:
 *   get:
 *     summary: Get samples ready for testing (Lab only)
 *     description: Retrieve samples with RECEIVED status that are ready for laboratory testing. Only accessible by laboratory technicians.
 *     tags:
 *       - samples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of samples ready for testing
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Sample'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         totalItems:
 *                           type: integer
 *                           example: 25
 *                         pageNum:
 *                           type: integer
 *                           example: 1
 *                         pageSize:
 *                           type: integer
 *                           example: 10
 *                         totalPages:
 *                           type: integer
 *                           example: 3
 *       403:
 *         description: Forbidden - Only laboratory technicians can access this endpoint
 *       500:
 *         description: Internal server error
 * 
 * /api/sample/testing/all:
 *   get:
 *     summary: Get all samples with TESTING status (Lab only)
 *     description: Retrieve all samples with TESTING status that are ready for laboratory testing, with pagination. Only accessible by laboratory technicians.
 *     tags:
 *       - samples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of all samples with TESTING status
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Sample'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         totalItems:
 *                           type: integer
 *                           example: 25
 *                         pageNum:
 *                           type: integer
 *                           example: 1
 *                         pageSize:
 *                           type: integer
 *                           example: 10
 *                         totalPages:
 *                           type: integer
 *                           example: 3
 *       403:
 *         description: Forbidden - Only laboratory technicians can access this endpoint
 *       500:
 *         description: Internal server error
 * 
 * /api/sample/search:
 *   get:
 *     summary: Search samples by various criteria (Lab, Staff only)
 *     description: Search for samples using different filters. Accessible by laboratory technicians and staff.
 *     tags:
 *       - samples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [pending, received, testing, completed, invalid]
 *         description: Filter by sample status
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *         description: Filter by sample type
 *       - in: query
 *         name: appointmentId
 *         schema:
 *           type: string
 *         description: Filter by appointment ID
 *       - in: query
 *         name: kitCode
 *         schema:
 *           type: string
 *         description: Filter by kit code
 *       - in: query
 *         name: personName
 *         schema:
 *           type: string
 *         description: Filter by person name
 *       - in: query
 *         name: startDate
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date
 *       - in: query
 *         name: endDate
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of samples matching the search criteria
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Sample'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         totalItems:
 *                           type: integer
 *                           example: 25
 *                         pageNum:
 *                           type: integer
 *                           example: 1
 *                         pageSize:
 *                           type: integer
 *                           example: 10
 *                         totalPages:
 *                           type: integer
 *                           example: 3
 *       403:
 *         description: Forbidden - Only laboratory technicians and staff can access this endpoint
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/collect:
 *   post:
 *     tags: [samples]
 *     summary: Collect sample at facility (Staff only)
 *     description: Staff collects a sample at the medical facility and records the information
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - appointment_id
 *               - type
 *               - person_info
 *             properties:
 *               appointment_id:
 *                 type: string
 *                 description: ID of the appointment
 *                 example: "60d21b4667d0d8992e610c85"
 *               type:
 *                 type: array
 *                 description: Types of samples collected
 *                 items:
 *                   type: string
 *                   enum: [blood, saliva, hair, other]
 *                 example: ["blood", "saliva"]
 *               person_info:
 *                 type: array
 *                 description: Information about the persons from whom samples were collected
 *                 items:
 *                   type: object
 *                   properties:
 *                     name:
 *                       type: string
 *                       description: Full name of the person
 *                       example: "Thích Tâm Phúc"
 *                     dob:
 *                       type: string
 *                       format: date
 *                       description: Date of birth
 *                       example: "1983-03-08"
 *                     relationship:
 *                       type: string
 *                       description: Relationship to the primary patient
 *                       example: "Self"
 *                     gender:
 *                       type: string
 *                       description: Gender of the person
 *                       example: "Male"
 *                     phone_number:
 *                       type: string
 *                       description: Phone number of the person
 *                       example: "0909090909"
 *                     birth_place:
 *                       type: string
 *                       description: Birth place of the person
 *                       example: "Vietnam"
 *                     nationality:
 *                       type: string
 *                       description: Nationality of the person
 *                       example: "Vietnamese"
 *                     identity_document:
 *                       type: string
 *                       description: ID document number
 *                       example: "1234567890"
 *                 example:
 *                   - name: "Thích Tâm Phúc"
 *                     dob: "1983-03-08"
 *                     relationship: "Self"
 *                     gender: "Male"
 *                     phone_number: "0909090909"
 *                     birth_place: "Vietnam"
 *                     nationality: "Vietnamese"
 *                     identity_document: "1234567890"
 *                   - name: "Nguyễn Đan Huy"
 *                     dob: "2003-10-15"
 *                     relationship: "Self"
 *                     gender: "Male"
 *                     phone_number: "0909090909"
 *                     birth_place: "Vietnam"
 *                     nationality: "Vietnamese"
 *                     identity_document: "1234567890"
 *     responses:
 *       201:
 *         description: Sample collected successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Sample collected successfully
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         example: "60d21b4667d0d8992e610c86"
 *                       appointment_id:
 *                         type: string
 *                         example: "60d21b4667d0d8992e610c85"
 *                       type:
 *                         type: string
 *                         example: "BLOOD"
 *                       collection_method:
 *                         type: string
 *                         example: "FACILITY"
 *                       collection_date:
 *                         type: string
 *                         format: date-time
 *                         example: "2023-06-15T10:30:00Z"
 *                       status:
 *                         type: string
 *                         example: "PENDING"
 *                       person_info:
 *                         type: object
 *                         properties:
 *                           name:
 *                             type: string
 *                             example: "John Doe"
 *                           dob:
 *                             type: string
 *                             format: date
 *                             example: "1990-01-15"
 *                           relationship:
 *                             type: string
 *                             example: "Self"
 *       400:
 *         description: Bad request
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: Appointment must be confirmed before collecting sample
 *       401:
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: Staff not authenticated
 *       404:
 *         description: Appointment not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: Appointment not found
 */ 


================================================
FILE: src/modules/sample/swagger/sample.tag.js
================================================
/**
 * @swagger
 * tags:
 *   name: samples
 *   description: Sample management APIs
 */ 


================================================
FILE: src/modules/service/index.ts
================================================
import ServiceSchema from './service.model';
import { IService, ServiceType, SampleMethod } from './service.interface';
import { ServiceTypeEnum, SampleMethodEnum } from './service.enum';
import { ServiceTypes, SampleMethods } from './service.constant';
import ServiceRoute from './service.route';

export { ServiceSchema, IService, ServiceType, SampleMethod, ServiceTypeEnum, SampleMethodEnum, ServiceTypes, SampleMethods, ServiceRoute }; 


================================================
FILE: src/modules/service/service.constant.ts
================================================
import { SampleMethodEnum, ServiceTypeEnum } from './service.enum';

export const ServiceTypes = ['', ServiceTypeEnum.CIVIL, ServiceTypeEnum.ADMINISTRATIVE];
export const SampleMethods = ['', SampleMethodEnum.SELF_COLLECTED, SampleMethodEnum.FACILITY_COLLECTED, SampleMethodEnum.HOME_COLLECTED]; 


================================================
FILE: src/modules/service/service.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import ServiceService from './service.service';
import CreateServiceDto from './dtos/createService.dto';
import { IService } from './service.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class ServiceController {
    private serviceService = new ServiceService();

    public createService = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: CreateServiceDto = req.body;
            const file = req.file;
            const service = await this.serviceService.createService(model, file);
            res.status(HttpStatus.Created).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    public getServices = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getServices(req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IService>>(services));
        } catch (error) {
            next(error);
        }
    }

    public getServiceById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const service = await this.serviceService.getServiceById(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    public getServiceBySlug = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const service = await this.serviceService.getServiceBySlug(req.params.slug);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    public getChildServices = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getChildServices(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<IService[]>(services));
        } catch (error) {
            next(error);
        }
    }

    public updateService = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const file = req.file;
            const service = await this.serviceService.updateService(req.params.id, req.body, file);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service as IService));
        } catch (error) {
            next(error);
        }
    }

    public deleteService = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.serviceService.deleteService(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<string>('Delete service successfully'));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Lấy danh sách dịch vụ dựa trên thông tin cuộc hẹn
     */
    public getServicesByAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getServicesByAppointment(req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IService>>(services));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Đếm số lượng dịch vụ theo loại
     */
    public countServicesByType = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const statistics = await this.serviceService.countServicesByType(req.query);
            res.status(HttpStatus.Success).json(formatResponse(statistics));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Thay đổi trạng thái hoạt động của dịch vụ
     */
    public changeServiceStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const { is_active } = req.body;

            if (is_active === undefined) {
                res.status(HttpStatus.BadRequest).json(
                    formatResponse<string>('is_active field is required')
                );
                return;
            }

            const service = await this.serviceService.changeServiceStatus(id, is_active);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get all services with images
     */
    public getServicesWithImages = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getServicesWithImages();
            res.status(HttpStatus.Success).json(formatResponse<IService[]>(services));
        } catch (error) {
            next(error);
        }
    }
}



================================================
FILE: src/modules/service/service.enum.ts
================================================
export enum ServiceTypeEnum {
    CIVIL = 'civil',
    ADMINISTRATIVE = 'administrative',
}

export enum SampleMethodEnum {
    SELF_COLLECTED = 'self_collected',
    FACILITY_COLLECTED = 'facility_collected',
    HOME_COLLECTED = 'home_collected',
} 


================================================
FILE: src/modules/service/service.interface.ts
================================================
import { Document } from 'mongoose';
import { SampleMethodEnum, ServiceTypeEnum } from './service.enum';

export type ServiceType = ServiceTypeEnum.CIVIL | ServiceTypeEnum.ADMINISTRATIVE;
export type SampleMethod = SampleMethodEnum.SELF_COLLECTED | SampleMethodEnum.FACILITY_COLLECTED | SampleMethodEnum.HOME_COLLECTED;

export interface IService extends Document {
    _id: string;
    name: string;
    slug: string;
    description: string;
    parent_service_id?: string | null;
    type: ServiceType;
    // sample_method: SampleMethod;
    estimated_time: number; // in hours
    price: number;
    image_url?: string;
    is_active: boolean;
    is_deleted: boolean;
    created_at?: Date;
    updated_at?: Date;
    average_rating?: number;
    review_count?: number;
} 


================================================
FILE: src/modules/service/service.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { SampleMethods, ServiceTypes } from './service.constant';
import { IService } from './service.interface';

const ServiceSchemaEntity: Schema<IService> = new Schema({
    name: { type: String, required: true },
    slug: { type: String, required: true, unique: true },
    description: { type: String, required: true },
    parent_service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE },
    type: {
        type: String,
        enum: ServiceTypes,
        required: true
    },
    // sample_method: {
    //     type: String,
    //     enum: SampleMethods,
    //     required: true
    // },
    estimated_time: { type: Number, required: true }, // in hours
    price: { type: Number, required: true },
    image_url: { type: String },
    is_active: { type: Boolean, default: true },
    is_deleted: { type: Boolean, default: false },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
});

const ServiceSchema = mongoose.model<IService & mongoose.Document>(COLLECTION_NAME.SERVICE, ServiceSchemaEntity);
export default ServiceSchema; 


================================================
FILE: src/modules/service/service.repository.ts
================================================
import ServiceSchema from './service.model';
import { IService, SampleMethod, ServiceType } from './service.interface';

export default class ServiceRepository {
    public async createService(data: Partial<IService>): Promise<IService> {
        return ServiceSchema.create(data);
    }

    public async findOne(query: any): Promise<IService | null> {
        return ServiceSchema.findOne(query);
    }

    public async findById(id: string): Promise<IService | null> {
        return ServiceSchema.findById(id).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    // Find service by slug
    public async findBySlug(slug: string): Promise<IService | null> {
        return ServiceSchema.findOne({
            slug,
            is_deleted: false
        }).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    // find by id and populate parent service
    public async findByIdAndPopulateParentService(id: string): Promise<IService | null> {
        return ServiceSchema.findById(id).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    public async findByIdAndUpdate(id: string, update: Partial<IService>, options: any = {}): Promise<IService | null> {
        return ServiceSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return ServiceSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IService[]> {
        return ServiceSchema.find(query).sort(sort).skip(skip).limit(limit).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    public async findAll(query: any): Promise<IService[]> {
        return ServiceSchema.find(query);
    }

    // find child services
    public async findChildServices(query: any): Promise<IService[]> {
        return ServiceSchema.find({
            ...query,
            is_deleted: false,
            is_active: true
        }).populate({
            path: 'parent_service_id',
            select: 'name slug'
        }).select('name description price estimated_time type image_url slug');
    }
}



================================================
FILE: src/modules/service/service.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware, uploadSingleFile } from '../../core/middleware';
import ServiceController from './service.controller';
import CreateServiceDto from './dtos/createService.dto';
import UpdateServiceDto from './dtos/updateService.dto';
import { SampleMethods, ServiceTypes } from './service.constant'
import { UserRoleEnum } from '../user/user.enum';

export default class ServiceRoute implements IRoute {
    public path = API_PATH.SERVICE;
    public router = Router();
    private serviceController = new ServiceController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/service/create -> Create service
        this.router.post(
            API_PATH.CREATE_SERVICE,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            uploadSingleFile('service_image'),
            validationMiddleware(CreateServiceDto),
            this.serviceController.createService);

        // GET: domain:/api/service/search -> Get all services
        this.router.get(
            API_PATH.SEARCH_SERVICE,
            authMiddleWare([], true),
            this.serviceController.getServices);

        // GET: domain:/api/service/statistics -> Đếm số lượng dịch vụ theo loại
        this.router.get(
            `${this.path}/statistics`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.serviceController.countServicesByType
        );

        // GET: domain:/api/service/appointments -> Lấy các dịch vụ dựa trên thông tin cuộc hẹn
        this.router.get(
            `${this.path}/appointments`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF]),
            this.serviceController.getServicesByAppointment
        );

        // GET: domain:/api/service/:id -> Get service by id
        this.router.get(
            API_PATH.GET_SERVICE_BY_ID,
            authMiddleWare([], true),
            this.serviceController.getServiceById);

        // GET: domain:/api/service/slug/:slug -> Get service by slug
        this.router.get(
            `${this.path}/slug/:slug`,
            authMiddleWare([], true),
            this.serviceController.getServiceBySlug);

        // GET: domain:/api/service/:id/child -> Get child services by id
        this.router.get(
            `${this.path}/:id/child`,
            authMiddleWare([], true),
            this.serviceController.getChildServices);

        // PUT: domain:/api/service/:id -> Update service by id
        this.router.put(
            API_PATH.UPDATE_SERVICE,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            uploadSingleFile('service_image'),
            validationMiddleware(UpdateServiceDto),
            this.serviceController.updateService);

        // PATCH: domain:/api/service/:id/status -> Thay đổi trạng thái hoạt động của dịch vụ
        this.router.patch(
            `${this.path}/:id/status`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.serviceController.changeServiceStatus);

        // DELETE: domain:/api/service/:id -> Delete service by id
        this.router.delete(
            API_PATH.DELETE_SERVICE,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.serviceController.deleteService);

        // GET: domain:/api/service/services-with-images -> Get all services with images
        this.router.get(
            `${this.path}/services-with-images`,
            authMiddleWare([], true),
            this.serviceController.getServicesWithImages
        );
    }
}



================================================
FILE: src/modules/service/service.service.ts
================================================
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { IService, SampleMethod, ServiceType } from "./service.interface";
import CreateServiceDto from "./dtos/createService.dto";
import UpdateServiceDto from "./dtos/updateService.dto";
import { isEmptyObject } from "../../core/utils";
import { SampleMethodEnum, ServiceTypeEnum } from "./service.enum";
import AppointmentSchema from '../appointment/appointment.model';
import ServiceRepository from './service.repository';
import { uploadFileToS3 } from "../../core/utils/s3Upload";
import { s3Folders } from "../../core/utils/aws.config";
import ReviewSchema from '../review/review.model';
import { UserRoleEnum } from '../user/user.enum';

export default class ServiceService {
    private appointmentSchema = AppointmentSchema;
    private serviceRepository = new ServiceRepository();

    /**
     * Generate a slug from a string
     * @param name The string to generate a slug from
     * @returns A URL-friendly slug
     */
    /**
     * Generate a slug from a string
     * @param name The string to generate a slug from
     * @returns A URL-friendly slug
     */
    private generateSlug(name: string): string {
        if (!name) return '';

        // First normalize Vietnamese characters
        let slug = name
            .toLowerCase()
            .trim()
            .replace(/[àáạảãâầấậẩẫăằắặẳẵ]/g, 'a')
            .replace(/[èéẹẻẽêềếệểễ]/g, 'e')
            .replace(/[ìíịỉĩ]/g, 'i')
            .replace(/[òóọỏõôồốộổỗơờớợởỡ]/g, 'o')
            .replace(/[ùúụủũưừứựửữ]/g, 'u')
            .replace(/[ỳýỵỷỹ]/g, 'y')
            .replace(/đ/g, 'd');

        // Then handle spaces and special characters
        slug = slug
            .replace(/[^\w\s-]/g, '') // Xóa các ký tự không phải là từ ngoại trừ khoảng trắng và dấu gạch nối
            .replace(/[\s_]+/g, '-') // Thay thế khoảng trắng và dấu gạch dưới bằng dấu gạch nối
            .replace(/-+/g, '-') // Xóa các dấu gạch nối liên tiếp
            .replace(/^-+|-+$/g, ''); // Xóa các dấu gạch nối ở đầu và cuối chuỗi

        return slug;
    }

    /**
     * Ensure a slug is unique by adding a suffix if necessary
     * @param baseSlug The base slug to check
     * @returns A unique slug
     */
    private async ensureUniqueSlug(baseSlug: string): Promise<string> {
        if (!baseSlug) return '';

        let slug = baseSlug;
        let counter = 1;
        let existingService = await this.serviceRepository.findOne({ slug, is_deleted: false });

        // Keep checking and incrementing counter until we find a unique slug
        while (existingService) {
            slug = `${baseSlug}-${counter}`;
            counter++;
            existingService = await this.serviceRepository.findOne({ slug, is_deleted: false });
        }

        return slug;
    }

    public async createService(model: CreateServiceDto, file?: Express.Multer.File): Promise<IService> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        // Convert string values to appropriate types (needed for multipart/form-data)
        if (typeof model.price === 'string') {
            model.price = parseFloat(model.price);
        }

        if (typeof model.estimated_time === 'string') {
            model.estimated_time = parseFloat(model.estimated_time);
        }

        // Handle empty string for parent_service_id
        if (model.parent_service_id === '') {
            model.parent_service_id = null as any;
        }

        // Xác thực tên dịch vụ
        if (!model.name || model.name.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service name is required');
        }

        // Xác thực mô tả
        if (!model.description || model.description.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service description is required');
        }

        // Xác thực giá
        if (isNaN(model.price) || model.price <= 0) {
            throw new HttpException(HttpStatus.BadRequest, 'Service price must be a valid number greater than 0');
        }

        // Xác thực thời gian ước tính
        if (isNaN(model.estimated_time) || model.estimated_time <= 0) {
            throw new HttpException(HttpStatus.BadRequest, 'Estimated time must be a valid number greater than 0');
        }

        // Xác thực loại dịch vụ
        if (!Object.values(ServiceTypeEnum).includes(model.type as ServiceTypeEnum)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid service type');
        }

        // Xác thực parent_service_id
        if (model.parent_service_id && model.parent_service_id.trim() !== '') {
            const parentService = await this.serviceRepository.findByIdAndPopulateParentService(model.parent_service_id);
            if (!parentService) {
                throw new HttpException(HttpStatus.BadRequest, 'Parent service not found');
            }
        }

        // // Xác thực phương thức lấy mẫu
        // if (!Object.values(SampleMethodEnum).includes(model.sample_method as SampleMethodEnum)) {
        //     throw new HttpException(HttpStatus.BadRequest, 'Invalid sample method');
        // }

        // kiểm tra tên dịch vụ có bị trùng không
        const existingService = await this.serviceRepository.findOne({ name: model.name, is_deleted: false });
        if (existingService) {
            throw new HttpException(HttpStatus.Conflict, 'Service with this name already exists');
        }

        // Generate slug if not provided
        if (!model.slug) {
            model.slug = await this.ensureUniqueSlug(this.generateSlug(model.name));
        } else {
            // If slug is provided, ensure it's URL-friendly
            model.slug = this.generateSlug(model.slug);
            // Check if the slug is unique
            model.slug = await this.ensureUniqueSlug(model.slug);
        }

        let newService = {
            ...model,
            is_active: true,
            created_at: new Date(),
            updated_at: new Date(),
        };

        // If there's a file, upload the image (for any service type)
        if (file) {
            try {
                // Create the service first to get the ID
                const createdService = await this.serviceRepository.createService(newService);

                // Upload image to S3
                const imageUrl = await uploadFileToS3(file, createdService._id, s3Folders.personImages);

                // Update service with image URL
                const updatedService = await this.serviceRepository.findByIdAndUpdate(
                    createdService._id,
                    { image_url: imageUrl },
                    { new: true }
                );

                return updatedService || createdService;
            } catch (error) {
                console.error('Error uploading image during service creation:', error);
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload image');
            }
        }

        return this.serviceRepository.createService(newService);
    }

    /**
     * Lấy danh sách dịch vụ với các bộ lọc tùy chọn và phân trang
     */
    public async getServices(queryParams: any = {}, user?: any): Promise<SearchPaginationResponseModel<IService & { average_rating?: number, review_count?: number }>> {
        try {
            const query: any = { is_deleted: false };

            // Xử lý và làm sạch các tham số truy vấn
            const cleanParams = this.processQueryParams(queryParams);

            // Xử lý các tham số phân trang
            const page = cleanParams.pageNum ? parseInt(cleanParams.pageNum) : 1; // trang hiện tại
            const limit = cleanParams.pageSize ? parseInt(cleanParams.pageSize) : 10; // số lượng bản ghi trên mỗi trang
            const skip = (page - 1) * limit; // số bản ghi bị bỏ qua

            // Xử lý sắp xếp
            const sortField = cleanParams.sort_by || 'created_at'; // trường sắp xếp mặc định là created_at
            const sortOrder = cleanParams.sort_order === 'asc' ? 1 : -1; // thứ tự sắp xếp mặc định là tăng dần
            const sortOptions: any = {}; // khởi tạo một đối tượng để lưu trữ các tùy chọn sắp xếp
            sortOptions[sortField] = sortOrder; // thêm tùy chọn sắp xếp vào đối tượng

            // Xử lý các tham số lọc
            if (cleanParams.type) {
                query.type = new RegExp(`^${cleanParams.type}$`, 'i'); // tìm kiếm theo loại dịch vụ với tùy chọn không phân biệt chữ hoa và chữ thường
            }

            // if (cleanParams.sample_method) {
            //     query.sample_method = new RegExp(`^${cleanParams.sample_method}$`, 'i'); // tìm kiếm theo phương thức lấy mẫu với tùy chọn không phân biệt chữ hoa và chữ thường
            // }

            if (cleanParams.is_active !== undefined) {
                query.is_active = cleanParams.is_active;
            }

            if (cleanParams.min_price !== undefined || cleanParams.max_price !== undefined) {
                query.price = {};
                if (cleanParams.min_price !== undefined) {
                    query.price.$gte = cleanParams.min_price; // giá >= min_price
                }
                if (cleanParams.max_price !== undefined) {
                    query.price.$lte = cleanParams.max_price; // giá <= max_price
                }
            }

            // Lọc dữ liệu theo thời gian tạo
            if (cleanParams.start_date || cleanParams.end_date) {
                query.created_at = {};
                if (cleanParams.start_date) {
                    query.created_at.$gte = new Date(cleanParams.start_date); // ngày tạo >= start_date
                }
                if (cleanParams.end_date) {
                    const endDate = new Date(cleanParams.end_date);
                    endDate.setHours(23, 59, 59, 999); // set thời gian cuối ngày là 23:59:59.999
                    query.created_at.$lte = endDate; // ngày tạo <= end_date
                }
            }

            // Tìm kiếm theo từ khóa (nếu có)
            if (cleanParams.keyword) {
                const keyword = cleanParams.keyword.toLowerCase();
                query.$or = [
                    { name: { $regex: keyword, $options: 'i' } }, // tìm kiếm theo tên dịch vụ với tùy chọn không phân biệt chữ hoa và chữ thường
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            // Đếm tổng số bản ghi phù hợp với điều kiện tìm kiếm
            const totalItems = await this.serviceRepository.countDocuments(query);

            // Lấy dữ liệu với phân trang và sắp xếp
            const items = await this.serviceRepository.find(query, sortOptions, skip, limit);

            // For each service, get average_rating and review_count
            const itemsWithStats = await Promise.all(items.map(async (service) => {
                const { average_rating, review_count } = await this.getServiceReviewStats(service._id);
                return { ...service.toObject(), average_rating, review_count };
            }));

            // Tính toán thông tin phân trang
            const totalPages = Math.ceil(totalItems / limit);
            // Trả về kết quả theo định dạng SearchPaginationResponseModel
            return {
                pageData: itemsWithStats,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: page,
                    pageSize: limit,
                }
            };
        } catch (error) {
            console.error('Error in getServices:', error);
            throw error;
        }
    }

    /**
     * Tạo query từ các tham số truyền vào
     */
    private processQueryParams(params: any): {
        type?: string;
        // sample_method?: string;
        is_active?: boolean;
        min_price?: number;
        max_price?: number;
        pageNum?: string;
        pageSize?: string;
        keyword?: string;
        sort_by?: string;
        sort_order?: string;
        start_date?: string;
        end_date?: string;
    } {
        const processedParams: Record<string, any> = {}; // khởi tạo một đối tượng để lưu trữ các tham số đã xử lý

        // Duyệt qua từng key của params
        Object.keys(params).forEach(key => {
            const trimmedKey = key.trim(); // loại bỏ khoảng trắng ở đầu và cuối của key
            const normalizedKey = trimmedKey.replace(/-/g, '_'); // thay thế dấu gạch ngang bằng dấu gạch dưới
            processedParams[normalizedKey] = params[key]; // lưu trữ giá trị của key vào processedParams
        });

        // Xác thực các trường sắp xếp hợp lệ để tránh lỗi injection
        const allowedSortFields = ['name', 'price', 'created_at', 'estimated_time'];
        const sortBy = processedParams.sort_by?.toLowerCase();

        return {
            type: processedParams.type?.toLowerCase(),
            // sample_method: processedParams.sample_method?.toLowerCase(),
            is_active: processedParams.is_active === 'true',
            min_price: processedParams.min_price ? parseFloat(processedParams.min_price) : undefined,
            max_price: processedParams.max_price ? parseFloat(processedParams.max_price) : undefined,
            pageNum: processedParams.pageNum || '1',
            pageSize: processedParams.pageSize || '10',
            keyword: processedParams.keyword,
            sort_by: allowedSortFields.includes(sortBy) ? sortBy : 'created_at',
            sort_order: processedParams.sort_order === 'asc' ? 'asc' : 'desc',
            start_date: processedParams.start_date,
            end_date: processedParams.end_date
        };
    }

    /**
     * Cập nhật dịch vụ
     */
    public async updateService(id: string, model: Partial<UpdateServiceDto>, file?: Express.Multer.File): Promise<IService | undefined> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const existingService = await this.serviceRepository.findById(id);
        if (!existingService) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        // Convert string values to appropriate types (needed for multipart/form-data)
        if (typeof model.price === 'string') {
            model.price = parseFloat(model.price);
        }

        if (typeof model.estimated_time === 'string') {
            model.estimated_time = parseFloat(model.estimated_time);
        }

        // Handle empty string for parent_service_id
        if (model.parent_service_id === '') {
            model.parent_service_id = null as any;
        }

        // Validate name if provided
        if (model.name && model.name.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service name cannot be empty');
        }

        // Validate description if provided
        if (model.description && model.description.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service description cannot be empty');
        }

        // Validate price if provided
        if (model.price !== undefined && (isNaN(model.price) || model.price <= 0)) {
            throw new HttpException(HttpStatus.BadRequest, 'Service price must be a valid number greater than 0');
        }

        // Validate estimated time if provided
        if (model.estimated_time !== undefined && (isNaN(model.estimated_time) || model.estimated_time <= 0)) {
            throw new HttpException(HttpStatus.BadRequest, 'Estimated time must be a valid number greater than 0');
        }

        // Validate service type if provided
        if (model.type && !Object.values(ServiceTypeEnum).includes(model.type as ServiceTypeEnum)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid service type');
        }

        // Validate parent service ID if provided
        if (model.parent_service_id && model.parent_service_id.trim() !== '') {
            const parentService = await this.serviceRepository.findById(model.parent_service_id);
            if (!parentService) {
                throw new HttpException(HttpStatus.BadRequest, 'Parent service not found');
            }
        }

        // // Validate sample method if provided
        // if (model.sample_method && !Object.values(SampleMethodEnum).includes(model.sample_method as SampleMethodEnum)) {
        //     throw new HttpException(HttpStatus.BadRequest, 'Invalid sample method');
        // }

        // Check for name uniqueness if name is being updated
        if (model.name && model.name !== existingService.name) {
            const serviceWithSameName = await this.serviceRepository.findOne({
                name: model.name,
                is_deleted: false,
                _id: { $ne: id } // Exclude the current service
            });
            if (serviceWithSameName) {
                throw new HttpException(HttpStatus.Conflict, 'Service with this name already exists');
            }
        }

        // Update slug if name is changed or slug is provided
        if ((model.name && model.name !== existingService.name) || model.slug) {
            const baseSlug = model.slug ? this.generateSlug(model.slug) : this.generateSlug(model.name || existingService.name);

            // Only check for uniqueness if the slug is different from the current one
            if (baseSlug !== existingService.slug) {
                model.slug = await this.ensureUniqueSlug(baseSlug);
            } else {
                model.slug = baseSlug;
            }
        }

        // Handle file upload if provided
        if (file) {
            try {
                const imageUrl = await uploadFileToS3(file, id, s3Folders.personImages);
                model.image_url = imageUrl;
            } catch (error) {
                console.error('Error uploading image during service update:', error);
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload image');
            }
        }

        const updateData = {
            ...model,
            updated_at: new Date()
        };

        const updatedService = await this.serviceRepository.findByIdAndUpdate(
            id,
            updateData,
            { new: true }
        );

        if (!updatedService) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        return updatedService;
    }

    /**
     * Xóa dịch vụ (soft delete - chỉ vô hiệu hóa)
     */
    public async deleteService(id: string): Promise<IService> {
        const service = await this.serviceRepository.findByIdAndUpdate(
            id,
            { is_deleted: true, is_active: false, updated_at: new Date() },
            { new: true }
        );

        if (!service) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        return service;
    }

    /**
     * Tìm dịch vụ theo ID
     */
    public async getServiceById(id: string): Promise<IService & { average_rating?: number, review_count?: number }> {
        const service = await this.serviceRepository.findById(id);
        if (!service) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }
        // Calculate average rating and review count
        const { average_rating, review_count } = await this.getServiceReviewStats(service._id);
        return { ...service.toObject(), average_rating, review_count };
    }

    /**
     * Tìm kiếm dịch vụ theo loại
     */
    public async getServicesByType(type: ServiceType): Promise<IService[]> {
        return this.serviceRepository.findAll({ type, is_active: true });
    }

    /**
     * Lấy dịch vụ theo phương thức lấy mẫu
     */
    public async getServicesBySampleMethod(sampleMethod: SampleMethod): Promise<IService[]> {
        return this.serviceRepository.findAll({ sample_method: sampleMethod, is_active: true });
    }

    /**
     * Lấy danh sách dịch vụ con của một dịch vụ cha
     */
    public async getChildServices(parentServiceId: string): Promise<IService[]> {
        const parentService = await this.serviceRepository.findChildServices({ parent_service_id: parentServiceId });
        if (!parentService) {
            throw new HttpException(HttpStatus.NotFound, 'Parent service not found');
        }
        return parentService;
    }

    /**
     * Lấy danh sách dịch vụ dựa trên thông tin cuộc hẹn
     */
    public async getServicesByAppointment(queryParams: any = {}): Promise<SearchPaginationResponseModel<IService>> {
        try {
            // Xử lý và làm sạch các tham số truy vấn
            const cleanParams = this.processAppointmentParams(queryParams);

            // Xử lý các tham số phân trang
            const page = cleanParams.pageNum ? parseInt(cleanParams.pageNum) : 1;
            const limit = cleanParams.pageSize ? parseInt(cleanParams.pageSize) : 10;
            const skip = (page - 1) * limit;

            // Tạo query để tìm kiếm các appointment phù hợp
            const appointmentQuery: any = {};

            // Lọc theo trạng thái cuộc hẹn
            if (cleanParams.status) {
                appointmentQuery.status = cleanParams.status;
            }

            // Lọc theo ngày hẹn
            if (cleanParams.start_appointment_date || cleanParams.end_appointment_date) {
                appointmentQuery.appointment_date = {};
                if (cleanParams.start_appointment_date) {
                    appointmentQuery.appointment_date.$gte = new Date(cleanParams.start_appointment_date);
                }
                if (cleanParams.end_appointment_date) {
                    const endDate = new Date(cleanParams.end_appointment_date);
                    endDate.setHours(23, 59, 59, 999);
                    appointmentQuery.appointment_date.$lte = endDate;
                }
            }

            // Lọc theo loại cuộc hẹn (SELF, FACILITY, HOME)
            if (cleanParams.appointment_type) {
                appointmentQuery.type = cleanParams.appointment_type;
            }

            // Lọc theo khách hàng
            if (cleanParams.customer_id) {
                appointmentQuery.user_id = cleanParams.customer_id;
            }

            // Lọc theo nhân viên
            if (cleanParams.staff_id) {
                appointmentQuery.staff_id = cleanParams.staff_id;
            }

            // Lọc theo địa chỉ làm xét nghiệm (nếu là tại nhà)
            if (cleanParams.collection_address) {
                appointmentQuery.collection_address = { $regex: cleanParams.collection_address, $options: 'i' };
            }

            console.log('Appointment query:', appointmentQuery);

            // Tìm các appointment phù hợp và chỉ lấy service_id
            const appointments = await this.appointmentSchema.find(appointmentQuery).select('service_id');
            console.log('Found appointments:', appointments.length);

            // Lấy danh sách các service_id từ các appointment
            const serviceIds = appointments.map(app => app.service_id);

            // Loại bỏ các giá trị trùng lặp và giá trị null/undefined
            const uniqueServiceIds = [...new Set(serviceIds.filter(id => id))];
            console.log('Unique service IDs:', uniqueServiceIds.length);

            // Nếu không có service_id nào, trả về danh sách trống
            if (uniqueServiceIds.length === 0) {
                return {
                    pageData: [],
                    pageInfo: {
                        totalItems: 0,
                        totalPages: 0,
                        pageNum: page,
                        pageSize: limit,
                    }
                };
            }

            // Tạo query để tìm các service tương ứng
            const serviceQuery: any = {
                _id: { $in: uniqueServiceIds },
                is_deleted: false
            };

            // Xử lý lọc bổ sung cho service
            if (cleanParams.is_active !== undefined) {
                serviceQuery.is_active = cleanParams.is_active;
            }

            if (cleanParams.type) {
                serviceQuery.type = cleanParams.type;
            }

            if (cleanParams.sample_method) {
                serviceQuery.sample_method = cleanParams.sample_method;
            }

            if (cleanParams.min_price !== undefined || cleanParams.max_price !== undefined) {
                serviceQuery.price = {};
                if (cleanParams.min_price !== undefined) {
                    serviceQuery.price.$gte = cleanParams.min_price;
                }
                if (cleanParams.max_price !== undefined) {
                    serviceQuery.price.$lte = cleanParams.max_price;
                }
            }

            // Tìm kiếm theo từ khóa trên service (nếu có)
            if (cleanParams.keyword) {
                const keyword = cleanParams.keyword.toLowerCase();
                serviceQuery.$or = [
                    { name: { $regex: keyword, $options: 'i' } },
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            console.log('Service query:', serviceQuery);

            // Đếm tổng số dịch vụ phù hợp
            const totalItems = await this.serviceRepository.countDocuments(serviceQuery);
            console.log('Total matching services:', totalItems);

            // Xử lý sắp xếp
            const sortField = cleanParams.sort_by || 'created_at';
            const sortOrder = cleanParams.sort_order === 'asc' ? 1 : -1;
            const sortOptions: any = {};
            sortOptions[sortField] = sortOrder;

            // Lấy danh sách dịch vụ với phân trang
            const services = await this.serviceRepository.find(serviceQuery, sortOptions, skip, limit);

            console.log('Retrieved services:', services.length);

            // Tính toán thông tin phân trang
            const totalPages = Math.ceil(totalItems / limit);

            // Trả về kết quả
            return {
                pageData: services,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: page,
                    pageSize: limit,
                }
            };
        } catch (error) {
            console.error('Error in getServicesByAppointment:', error);
            throw error;
        }
    }

    /**
     * Xử lý tham số truy vấn cho API service-appointment
     */
    private processAppointmentParams(params: any): {
        status?: string;
        start_appointment_date?: string;
        end_appointment_date?: string;
        appointment_type?: string;
        customer_id?: string;
        staff_id?: string;
        collection_address?: string;
        is_active?: boolean;
        type?: string;
        sample_method?: string;
        min_price?: number;
        max_price?: number;
        pageNum?: string;
        pageSize?: string;
        keyword?: string;
        sort_by?: string;
        sort_order?: string;
    } {
        const processedParams: Record<string, any> = {};

        // Duyệt qua từng key của params
        Object.keys(params).forEach(key => {
            const trimmedKey = key.trim();
            const normalizedKey = trimmedKey.replace(/-/g, '_');
            processedParams[normalizedKey] = params[key];
        });

        // Xác thực các trường sắp xếp hợp lệ
        const allowedSortFields = ['name', 'price', 'created_at', 'estimated_time'];
        const sortBy = processedParams.sort_by?.toLowerCase();

        return {
            status: processedParams.status,
            start_appointment_date: processedParams.start_appointment_date,
            end_appointment_date: processedParams.end_appointment_date,
            appointment_type: processedParams.appointment_type,
            customer_id: processedParams.customer_id,
            staff_id: processedParams.staff_id,
            collection_address: processedParams.collection_address,
            is_active: processedParams.is_active === 'true',
            type: processedParams.type?.toLowerCase(),
            sample_method: processedParams.sample_method?.toLowerCase(),
            min_price: processedParams.min_price ? parseFloat(processedParams.min_price) : undefined,
            max_price: processedParams.max_price ? parseFloat(processedParams.max_price) : undefined,
            pageNum: processedParams.pageNum || '1',
            pageSize: processedParams.pageSize || '10',
            keyword: processedParams.keyword,
            sort_by: allowedSortFields.includes(sortBy) ? sortBy : 'created_at',
            sort_order: processedParams.sort_order === 'asc' ? 'asc' : 'desc',
        };
    }

    /**
     * Đếm số lượng dịch vụ theo loại
     */
    public async countServicesByType(queryParams: any = {}): Promise<{
        total: number;
        byType: Record<string, number>;
        byStatus: Record<string, number>;
        bySampleMethod: Record<string, number>;
    }> {
        try {
            // Xử lý tham số truy vấn
            const cleanParams = this.processQueryParams(queryParams);

            // Xây dựng query cơ bản
            const baseQuery: any = { is_deleted: false };

            // Thêm các điều kiện lọc nếu có
            if (cleanParams.is_active !== undefined) {
                baseQuery.is_active = cleanParams.is_active;
            }

            if (cleanParams.keyword) {
                const keyword = cleanParams.keyword.toLowerCase();
                baseQuery.$or = [
                    { name: { $regex: keyword, $options: 'i' } },
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            // Ghi log query để debug
            console.log('Base query for counting:', baseQuery);

            // Đếm tổng số dịch vụ
            const total = await this.serviceRepository.countDocuments(baseQuery);
            console.log('Total services:', total);

            // Khởi tạo các objects kết quả với giá trị mặc định
            const byType: Record<string, number> = {
                [ServiceTypeEnum.CIVIL]: 0,
                [ServiceTypeEnum.ADMINISTRATIVE]: 0
            };

            const bySampleMethod: Record<string, number> = {
                [SampleMethodEnum.SELF_COLLECTED]: 0,
                [SampleMethodEnum.FACILITY_COLLECTED]: 0,
                [SampleMethodEnum.HOME_COLLECTED]: 0
            };

            const byStatus = {
                active: 0,
                inactive: 0
            };

            // Nếu không có dịch vụ nào, trả về kết quả với các giá trị mặc định
            if (total === 0) {
                return {
                    total: 0,
                    byType,
                    byStatus,
                    bySampleMethod
                };
            }

            // Đếm theo loại dịch vụ
            const typeCountsPromise = Promise.all([
                this.serviceRepository.countDocuments({ ...baseQuery, type: ServiceTypeEnum.CIVIL }),
                this.serviceRepository.countDocuments({ ...baseQuery, type: ServiceTypeEnum.ADMINISTRATIVE })
            ]);

            // Đếm theo trạng thái (luôn đếm cả active và inactive, bất kể giá trị is_active trong query)
            const activeQuery = { ...baseQuery, is_active: true };
            const inactiveQuery = { ...baseQuery, is_active: false };

            // Xóa điều kiện is_active khỏi query để đếm tất cả trạng thái
            if (activeQuery.is_active !== undefined) delete activeQuery.is_active;
            if (inactiveQuery.is_active !== undefined) delete inactiveQuery.is_active;

            const statusCountsPromise = Promise.all([
                this.serviceRepository.countDocuments({ ...activeQuery, is_active: true }),
                this.serviceRepository.countDocuments({ ...inactiveQuery, is_active: false })
            ]);

            // Đếm theo phương thức lấy mẫu
            const sampleMethodCountsPromise = Promise.all([
                this.serviceRepository.countDocuments({ ...baseQuery, sample_method: SampleMethodEnum.SELF_COLLECTED }),
                this.serviceRepository.countDocuments({ ...baseQuery, sample_method: SampleMethodEnum.FACILITY_COLLECTED }),
                this.serviceRepository.countDocuments({ ...baseQuery, sample_method: SampleMethodEnum.HOME_COLLECTED })
            ]);

            // Đợi tất cả các truy vấn hoàn thành
            const [typeCounts, statusCounts, sampleMethodCounts] = await Promise.all([
                typeCountsPromise,
                statusCountsPromise,
                sampleMethodCountsPromise
            ]);

            // Cập nhật kết quả
            byType[ServiceTypeEnum.CIVIL] = typeCounts[0];
            byType[ServiceTypeEnum.ADMINISTRATIVE] = typeCounts[1];

            byStatus.active = statusCounts[0];
            byStatus.inactive = statusCounts[1];

            bySampleMethod[SampleMethodEnum.SELF_COLLECTED] = sampleMethodCounts[0];
            bySampleMethod[SampleMethodEnum.FACILITY_COLLECTED] = sampleMethodCounts[1];
            bySampleMethod[SampleMethodEnum.HOME_COLLECTED] = sampleMethodCounts[2];

            console.log('Count statistics:', {
                total,
                byType,
                byStatus,
                bySampleMethod
            });

            return {
                total,
                byType,
                byStatus,
                bySampleMethod
            };
        } catch (error) {
            console.error('Error in countServicesByType:', error);
            throw error;
        }
    }

    /**
     * Thay đổi trạng thái hoạt động của dịch vụ
     */
    public async changeServiceStatus(id: string, isActive: boolean): Promise<IService> {
        // Kiểm tra dịch vụ có tồn tại không
        const service = await this.serviceRepository.findById(id);
        if (!service) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        // Kiểm tra nếu dịch vụ đã bị xóa
        if (service.is_deleted) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot change status of a deleted service');
        }

        // Nếu trạng thái    không thay đổi, trả về dịch vụ hiện tại
        if (service.is_active === isActive) {
            return service;
        }

        // Cập nhật trạng thái
        const updatedService = await this.serviceRepository.findByIdAndUpdate(
            id,
            {
                is_active: isActive,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedService) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update service status');
        }

        return updatedService;
    }

    /**
     * Get all services with images
     * @returns Array of services with images
     */
    public async getServicesWithImages(): Promise<IService[]> {
        try {
            // Find all services that have an image_url
            const services = await this.serviceRepository.findAll({
                image_url: { $exists: true, $ne: null },
                is_deleted: false,
                is_active: true
            });

            return services;
        } catch (error) {
            console.error('Error getting services with images:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to get services with images');
        }
    }

    /**
     * Get a service by its slug
     * @param slug The slug of the service to retrieve
     * @returns The service with the specified slug
     */
    public async getServiceBySlug(slug: string): Promise<IService & { average_rating?: number, review_count?: number }> {
        const service = await this.serviceRepository.findBySlug(slug);
        if (!service) {
            throw new HttpException(HttpStatus.NotFound, `Service with slug '${slug}' not found`);
        }
        const { average_rating, review_count } = await this.getServiceReviewStats(service._id);
        return { ...service.toObject(), average_rating, review_count };
    }

    private async getServiceReviewStats(serviceId: string) {
        // Find all appointments for this service
        const appointments = await this.appointmentSchema.find({ service_id: serviceId }, '_id');
        const appointmentIds = appointments.map(a => a._id);
        if (appointmentIds.length === 0) return { average_rating: 0, review_count: 0 };
        // Aggregate reviews for these appointments
        const result = await ReviewSchema.aggregate([
            { $match: { appointment_id: { $in: appointmentIds }, is_deleted: { $ne: true } } },
            { $group: { _id: null, average_rating: { $avg: '$rating' }, review_count: { $sum: 1 } } }
        ]);
        if (result.length === 0) return { average_rating: 0, review_count: 0 };
        return { average_rating: result[0].average_rating, review_count: result[0].review_count };
    }
}


================================================
FILE: src/modules/service/dtos/createService.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsOptional, IsString } from "class-validator";
import { IService, SampleMethod, ServiceType } from "../service.interface";
import { Type, Transform } from "class-transformer";

export default class CreateServiceDto {
    constructor(
        name: string,
        description: string,
        parent_service_id: string | null,
        price: number,
        type: ServiceType,
        // sample_method: SampleMethod,
        estimated_time: number,
        image_url?: string,
        slug?: string,
    ) {
        this.name = name;
        this.description = description;
        this.parent_service_id = parent_service_id;
        this.price = price;
        this.type = type;
        // this.sample_method = sample_method;
        this.estimated_time = estimated_time;
        this.image_url = image_url;
        this.slug = slug || '';
    }

    @IsString()
    @IsNotEmpty()
    public name: string;

    @IsString()
    @IsOptional()
    public slug: string;

    @IsString()
    @IsNotEmpty()
    public description: string;

    @IsString()
    @IsOptional()
    public parent_service_id: string | null;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    public price: number;

    @IsString()
    @IsNotEmpty()
    public type: ServiceType;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    public estimated_time: number;

    @IsString()
    @IsOptional()
    public image_url?: string;
}



================================================
FILE: src/modules/service/dtos/updateService.dto.ts
================================================
import { SampleMethod, ServiceType } from "../service.interface";
import { IsString, IsNotEmpty, IsOptional, IsNumber, IsEnum } from "class-validator";
import { ServiceTypeEnum, SampleMethodEnum } from "../service.enum";
import { Type } from "class-transformer";

export default class UpdateServiceDto {
    constructor(
        name: string,
        description: string,
        parent_service_id: string | null,
        price: number,
        type: ServiceType,
        // sample_method: SampleMethod,
        estimated_time: number,
        image_url?: string,
        slug?: string,
    ) {
        this.name = name;
        this.description = description;
        this.parent_service_id = parent_service_id;
        this.price = price;
        this.type = type;
        // this.sample_method = sample_method;
        this.estimated_time = estimated_time;
        this.image_url = image_url;
        this.slug = slug;
    }

    @IsString()
    @IsNotEmpty()
    name: string;

    @IsString()
    @IsOptional()
    slug?: string;

    @IsString()
    @IsNotEmpty()
    description: string;

    @IsString()
    @IsOptional()
    parent_service_id: string | null;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    price: number;

    @IsEnum(ServiceTypeEnum)
    @IsNotEmpty()
    type: ServiceType;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    estimated_time: number;

    @IsString()
    @IsOptional()
    image_url?: string;
}




================================================
FILE: src/modules/service/swagger/service.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateServiceDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - price
 *         - type
 *         - sample_method
 *         - estimated_time
 *       properties:
 *         name:
 *           type: string
 *           description: service name
 *           example: "DNA Test"
 *         slug:
 *           type: string
 *           description: URL-friendly identifier (generated automatically if not provided)
 *           example: "dna-test"
 *         description:
 *           type: string
 *           description: service description
 *           example: "Dịch vụ xét nghiệm ADN để xác định mối quan hệ huyết thống giữa cha/mẹ và con"
 *         parent_service_id:
 *           type: string
 *           description: ID của dịch vụ cha (nếu có)
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         price:
 *           type: number
 *           description: Giá dịch vụ
 *           example: 3500000
 *         type:
 *           type: string
 *           enum: [civil, administrative]
 *           description: Loại dịch vụ
 *           example: "civil"
 *         sample_method:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *           description: sample method
 *           example: "facility_collected"
 *         estimated_time:
 *           type: number
 *           description: estimated time
 *           example: 72
 *         image_url:
 *           type: string
 *           description: URL của hình ảnh dịch vụ
 *           example: "https://wdp392-generate-pdf.s3-ap-southeast-2.amazonaws.com/person-sample-images/123456/image.jpg"
 *
 *     UpdateServiceDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - price
 *         - type
 *         - sample_method
 *         - estimated_time
 *       properties:
 *         name:
 *           type: string
 *           description: Tên dịch vụ
 *           example: "Xét nghiệm ADN xác định huyết thống"
 *         slug:
 *           type: string
 *           description: URL-friendly identifier (updated automatically if not provided)
 *           example: "xet-nghiem-adn-xac-dinh-huyet-thong"
 *         description:
 *           type: string
 *           description: Mô tả chi tiết về dịch vụ
 *           example: "Dịch vụ xét nghiệm ADN để xác định mối quan hệ huyết thống giữa cha/mẹ và con"
 *         parent_service_id:
 *           type: string
 *           description: ID của dịch vụ cha (nếu có)
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         price:
 *           type: number
 *           description: Giá dịch vụ
 *           example: 3500000
 *         type:
 *           type: string
 *           enum: [civil, administrative]
 *           description: Loại dịch vụ
 *           example: "civil"
 *         sample_method:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *           description: Phương thức thu thập mẫu
 *           example: "facility_collected"
 *         estimated_time:
 *           type: number
 *           description: Thời gian ước tính để hoàn thành dịch vụ (tính bằng giờ)
 *           example: 72
 *         image_url:
 *           type: string
 *           description: URL của hình ảnh dịch vụ
 *           example: "https://wdp392-generate-pdf.s3-ap-southeast-2.amazonaws.com/person-sample-images/123456/image.jpg"
 *
 *     ServiceResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: ID dịch vụ
 *           example: "60d5ec9af682fbd12a0f4a3d"
 *         name:
 *           type: string
 *           description: Tên dịch vụ
 *           example: "Xét nghiệm ADN xác định huyết thống"
 *         slug:
 *           type: string
 *           description: URL-friendly identifier for the service
 *           example: "xet-nghiem-adn-xac-dinh-huyet-thong"
 *         description:
 *           type: string
 *           description: Mô tả chi tiết về dịch vụ
 *           example: "Dịch vụ xét nghiệm ADN để xác định mối quan hệ huyết thống giữa cha/mẹ và con"
 *         parent_service_id:
 *           type: string
 *           description: ID của dịch vụ cha (nếu có)
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         price:
 *           type: number
 *           description: Giá dịch vụ
 *           example: 3500000
 *         type:
 *           type: string
 *           enum: [civil, administrative]
 *           description: Loại dịch vụ
 *           example: "civil"
 *         sample_method:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *           description: Phương thức thu thập mẫu
 *           example: "facility_collected"
 *         estimated_time:
 *           type: number
 *           description: Thời gian ước tính để hoàn thành dịch vụ (tính bằng giờ)
 *           example: 72
 *         image_url:
 *           type: string
 *           description: URL của hình ảnh dịch vụ
 *           example: "https://wdp392-generate-pdf.s3-ap-southeast-2.amazonaws.com/person-sample-images/123456/image.jpg"
 *         is_active:
 *           type: boolean
 *           description: Trạng thái hoạt động của dịch vụ
 *           example: true
 *         is_deleted:
 *           type: boolean
 *           description: Trạng thái xóa của dịch vụ
 *           example: false
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Ngày tạo
 *           example: "2023-07-15T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Ngày cập nhật gần nhất
 *           example: "2023-07-16T14:20:00.000Z"
 *
 *     ServicePaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/ServiceResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Tổng số dịch vụ
 *               example: 45
 *             totalPages:
 *               type: integer
 *               description: Tổng số trang
 *               example: 5
 *             pageNum:
 *               type: integer
 *               description: Số trang hiện tại
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Số lượng dịch vụ mỗi trang
 *               example: 10
 *
 *     ServiceStatisticsResponse:
 *       type: object
 *       properties:
 *         total:
 *           type: integer
 *           description: Tổng số dịch vụ
 *           example: 45
 *         byType:
 *           type: object
 *           description: Số lượng dịch vụ theo loại
 *           properties:
 *             civil:
 *               type: integer
 *               example: 30
 *             administrative:
 *               type: integer
 *               example: 15
 *         byStatus:
 *           type: object
 *           description: Số lượng dịch vụ theo trạng thái
 *           properties:
 *             active:
 *               type: integer
 *               example: 40
 *             inactive:
 *               type: integer
 *               example: 5
 *         bySampleMethod:
 *           type: object
 *           description: Số lượng dịch vụ theo phương thức thu thập mẫu
 *           properties:
 *             self_collected:
 *               type: integer
 *               example: 15
 *             facility_collected:
 *               type: integer
 *               example: 20
 *             home_collected:
 *               type: integer
 *               example: 10
 */



================================================
FILE: src/modules/service/swagger/service.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: services
 *   description: Service management
 */

/**
 * @swagger
 * /api/service/create:
 *   post:
 *     tags:
 *       - services
 *     summary: Create a new service (Only Admin, Manager)
 *     description: Create a new DNA testing service in the system. You can upload an image for any service type.
 *     operationId: createService
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: Service name
 *               slug:
 *                 type: string
 *                 description: URL-friendly identifier (generated automatically if not provided)
 *               description:
 *                 type: string
 *                 description: Service description
 *               parent_service_id:
 *                 type: string
 *                 description: ID of parent service (if this is a child service)
 *               price:
 *                 type: number
 *                 description: Service price
 *               type:
 *                 type: string
 *                 enum: [civil, administrative]
 *                 description: Service type
 *               sample_method:
 *                 type: string
 *                 enum: [self_collected, facility_collected, home_collected]
 *                 description: Sample collection method
 *               estimated_time:
 *                 type: number
 *                 description: Estimated time in hours
 *               service_image:
 *                 type: string
 *                 format: binary
 *                 description: Image for the service
 *             required:
 *               - name
 *               - description
 *               - price
 *               - type
 *               - sample_method
 *               - estimated_time
 *     responses:
 *       201:
 *         description: Create service successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/search:
 *   get:
 *     tags:
 *       - services
 *     summary: Search and filter services (All roles)
 *     description: Search services with pagination and filtering by multiple criteria
 *     operationId: getServices
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: Filter by service type (civil, administrative)
 *       - in: query
 *         name: sample_method
 *         schema:
 *           type: string
 *         description: Filter by sample collection method (self_collected, facility_collected, home_collected)
 *       - in: query
 *         name: is_active
 *         schema:
 *           type: boolean
 *         description: Filter by active status
 *       - in: query
 *         name: min_price
 *         schema:
 *           type: number
 *         description: Minimum price
 *       - in: query
 *         name: max_price
 *         schema:
 *           type: number
 *         description: Maximum price
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of services per page
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by name or description
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           default: created_at
 *         description: Sort by field (name, price, created_at, estimated_time)
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           default: desc
 *         description: Sort order (asc, desc)
 *       - in: query
 *         name: start_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by created date (start)
 *       - in: query
 *         name: end_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by created date (end)
 *     responses:
 *       200:
 *         description: List of services with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServicePaginationResponse'
 *       401:   
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/slug/{slug}:
 *   get:
 *     tags:
 *       - services
 *     summary: Get service by slug (All roles)
 *     description: Retrieve detailed information of a service by its slug (URL-friendly identifier)
 *     operationId: getServiceBySlug
 *     parameters:
 *       - in: path
 *         name: slug
 *         required: true
 *         schema:
 *           type: string
 *         description: Service slug
 *     responses:
 *       200:
 *         description: Detailed service information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 */

/**
 * @swagger     
 * /api/service/{id}:
 *   get:
 *     tags:
 *       - services
 *     summary: Get service information by ID (All roles)
 *     description: Retrieve detailed information of a service by ID
 *     operationId: getServiceById
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     responses:
 *       200:
 *         description: Detailed service information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 *
 *   put:
 *     tags:
 *       - services
 *     summary: Update service (Only Admin, Manager)
 *     description: Update service information. You can upload or update an image for any service.
 *     operationId: updateService
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: Service name
 *               slug:
 *                 type: string
 *                 description: URL-friendly identifier (updated automatically if not provided)
 *               description:
 *                 type: string
 *                 description: Service description
 *               parent_service_id:
 *                 type: string
 *                 description: ID of parent service (if this is a child service)
 *               price:
 *                 type: number
 *                 description: Service price
 *               type:
 *                 type: string
 *                 enum: [civil, administrative]
 *                 description: Service type
 *               sample_method:
 *                 type: string
 *                 enum: [self_collected, facility_collected, home_collected]
 *                 description: Sample collection method
 *               estimated_time:
 *                 type: number
 *                 description: Estimated time in hours
 *               service_image:
 *                 type: string
 *                 format: binary
 *                 description: Image for the service
 *             required:
 *               - name
 *               - description
 *               - price
 *               - type
 *               - sample_method
 *               - estimated_time
 *     responses:
 *       200:
 *         description: Update service successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 *
 *   delete:
 *     tags:
 *       - services
 *     summary: Delete service (Only Admin, Manager)
 *     description: Delete service (soft delete)
 *     operationId: deleteService
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     responses:
 *       200:
 *         description: Delete service successfully
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 */

/**
 * @swagger
 * /api/service/{id}/child:
 *   get:
 *     tags:
 *       - services
 *     summary: Get list of child services (All roles)
 *     description: Get all child services of a parent service
 *     operationId: getChildServices
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Parent service ID
 *     responses:
 *       200:
 *         description: List of child services
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/ServiceResponse'
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Parent service not found
 */

/**
 * @swagger
 * /api/service/appointments:
 *   get:
 *     tags:
 *       - services
 *     summary: Get services by appointment criteria (Admin, Manager, Staff)
 *     description: Filter services based on appointment related information
 *     operationId: getServicesByAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *         description: Filter by appointment status
 *       - in: query
 *         name: start_appointment_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by appointment date (start)
 *       - in: query
 *         name: end_appointment_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by appointment date (end)
 *       - in: query
 *         name: appointment_type
 *         schema:
 *           type: string
 *         description: Filter by appointment type (self, facility, home)
 *       - in: query
 *         name: customer_id
 *         schema:
 *           type: string
 *         description: Filter by customer ID
 *       - in: query
 *         name: staff_id
 *         schema:
 *           type: string
 *         description: Filter by staff ID
 *       - in: query
 *         name: collection_address
 *         schema:
 *           type: string
 *         description: Filter by collection address
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Number of services per page
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of services per page
 *     responses:
 *       200:
 *         description: List of services by appointment criteria
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServicePaginationResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/statistics:
 *   get:
 *     tags:
 *       - services
 *     summary: Service statistics (Admin, Manager)
 *     description: Count services by type, status and sample collection method
 *     operationId: countServicesByType
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: is_active
 *         schema:
 *           type: boolean
 *         description: Filter by active status
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by name or description
 *     responses:
 *       200:
 *         description: Service statistics
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceStatisticsResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/{id}/status:
 *   patch:
 *     tags:
 *       - services
 *     summary: Change service status (Admin, Manager)
 *     description: Activate or deactivate a service
 *     operationId: changeServiceStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               is_active:
 *                 type: boolean
 *                 description: New active status
 *             required:
 *               - is_active
 *     responses:
 *       200:
 *         description: Change service status successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       400:
 *         description: Invalid input data or service has been deleted
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 */


================================================
FILE: src/modules/slot/index.ts
================================================
import SlotSchema from './slot.model';
import { ISlot, SlotStatus } from './slot.interface';
import { SlotStatusEnum } from './slot.enum';
import { SlotStatuses } from './slot.constant';
import SlotRoute from './slot.route';

export {
    SlotSchema,
    ISlot,
    SlotStatus,
    SlotStatusEnum,
    SlotStatuses,
    SlotRoute
}; 


================================================
FILE: src/modules/slot/slot.constant.ts
================================================
import { SlotStatusEnum } from './slot.enum';

export const SlotStatuses = [
    '',
    SlotStatusEnum.AVAILABLE,
    SlotStatusEnum.BOOKED,
    SlotStatusEnum.UNAVAILABLE
]; 


================================================
FILE: src/modules/slot/slot.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { UpdateSlotDto } from './dtos/updateSlot.dto';
import SlotService from './slot.service';
import { CreateSlotDto } from './dtos/createSlot.dto';
import { ISlot } from './slot.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { UserRoleEnum } from '../user/user.enum';

export default class SlotController {
    private slotService = new SlotService();

    /**
     * Tạo một slot mới
     */
    public createSlot = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotData: CreateSlotDto = req.body;
            const slot = await this.slotService.createSlot(slotData);
            res.status(HttpStatus.Created).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Tạo nhiều slot cùng lúc theo mẫu
     */
    // public createMultipleSlots = async (req: Request, res: Response, next: NextFunction) => {
    //     try {
    //         const slotsData: CreateMultipleSlotsDto = req.body;
    //         const result = await this.slotService.createMultipleSlots(slotsData);
    //         res.status(HttpStatus.Created).json({
    //             success: true,
    //             data: result
    //         });
    //     } catch (error) {
    //         next(error);
    //     }
    // };

    /**
     * Tìm kiếm slots với các bộ lọc
     */
    public getSlots = async (req: Request, res: Response, next: NextFunction) => {
        try {
            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            const slots = await this.slotService.getSlots(req.query, userRole, userId);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Lấy slot theo ID
     */
    public getSlotById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotId = req.params.id;

            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            // Get requested staff ID if any
            const requestedStaffId = req.query.staff_profile_id as string;

            const slot = await this.slotService.getSlotById(slotId, userRole, userId, requestedStaffId);
            res.status(HttpStatus.Success).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Cập nhật thông tin slot
     */
    public updateSlot = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotId = req.params.id;
            const slotData: UpdateSlotDto = req.body;
            const slot = await this.slotService.updateSlot(slotId, slotData);
            res.status(HttpStatus.Success).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Thay đổi trạng thái slot
     */
    public changeSlotStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotId = req.params.id;
            const { status } = req.body;

            if (!status) {
                throw new HttpException(HttpStatus.BadRequest, 'Status is required');
            }

            const slot = await this.slotService.changeSlotStatus(slotId, status);
            res.status(HttpStatus.Success).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Lấy slots của một nhân viên
     */
    public getSlotsByUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.params.id;

            if (!userId) {
                throw new HttpException(HttpStatus.BadRequest, 'User ID is required');
            }

            // Get requesting user role and ID
            const requestingUserRole = req.user?.role;
            const requestingUserId = req.user?.id;

            const slots = await this.slotService.getSlotsByUser(
                userId,
                req.query,
                requestingUserRole,
                requestingUserId
            );

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Lấy slots theo phòng ban
     */
    public getSlotsByDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const departmentId = req.params.departmentId;
            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            // Staff role is not allowed to filter by staff_profile_ids
            if (userRole === UserRoleEnum.STAFF && req.query.staff_profile_ids) {
                throw new HttpException(HttpStatus.Forbidden, 'Staff role is not allowed to filter by staff_profile_id');
            }

            const slots = await this.slotService.getSlotsByDepartment(departmentId, req.query, userRole, userId);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Lấy slots theo dịch vụ
     */
    // public getSlotsByService = async (req: Request, res: Response, next: NextFunction) => {
    //     try {
    //         const serviceId = req.params.serviceId;
    //         const slots = await this.slotService.getSlotsByService(serviceId, req.query);
    //         res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
    //     } catch (error) {
    //         next(error);
    //     }
    // };


    /**
     * Lấy thống kê performance của phòng ban
     */
    public getDepartmentPerformance = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const departmentId = req.params.departmentId;
            const { date_from, date_to } = req.query;
            const performanceStats = await this.slotService.getDepartmentPerformance(departmentId, { date_from, date_to });
            res.status(HttpStatus.Success).json(formatResponse(performanceStats));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Lấy danh sách slots có sẵn để đặt lịch
     */
    public getAvailableSlots = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { start_date, end_date, type, staff_profile_ids } = req.query;

            if (!start_date) {
                throw new HttpException(HttpStatus.BadRequest, 'start_date is required');
            }

            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            // Staff role is not allowed to filter by staff_profile_ids
            if (userRole === UserRoleEnum.STAFF && staff_profile_ids) {
                throw new HttpException(HttpStatus.Forbidden, 'Staff role is not allowed to filter by staff_profile_id');
            }

            const availableSlots = await this.slotService.getAvailableSlots({
                start_date: start_date as string,
                end_date: end_date as string,
                type: type as string,
                staff_profile_ids: staff_profile_ids as string | string[]
            }, userRole, userId);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(availableSlots));
        } catch (error) {
            next(error);
        }
    };
}


================================================
FILE: src/modules/slot/slot.enum.ts
================================================
export enum SlotStatusEnum {
    AVAILABLE = 'available',
    BOOKED = 'booked',
    UNAVAILABLE = 'unavailable'
} 


================================================
FILE: src/modules/slot/slot.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { SlotStatusEnum } from './slot.enum';

export type SlotStatus =
    SlotStatusEnum.AVAILABLE |
    SlotStatusEnum.BOOKED |
    SlotStatusEnum.UNAVAILABLE;

export interface TimePoint {
    hour: number;
    minute: number;
}

export interface ITimeSlot {
    year: number;
    month: number;
    day: number;
    start_time: TimePoint;
    end_time: TimePoint;
}

export interface ISlot extends Document {
    _id: string | undefined;
    service_id?: string | undefined;
    staff_profile_ids: string[] | undefined;
    appointment_id?: string | undefined;
    appointment_limit: number; //max appointment per slot
    assigned_count?: number; // current count of appointments assigned to this slot
    time_slots?: ITimeSlot[];
    status: SlotStatus | string;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/slot/slot.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { SlotStatuses } from './slot.constant';
import { ISlot } from './slot.interface';
import type { ITimeSlot, TimePoint } from './slot.interface';

const TimePointSchema: Schema<TimePoint> = new Schema({
    hour: { type: Number, required: true },
    minute: { type: Number, required: true }
}, { _id: false });

const TimeSlotSchema: Schema<ITimeSlot> = new Schema({
    year: { type: Number, required: true },
    month: { type: Number, required: true },
    day: { type: Number, required: true },
    start_time: { type: TimePointSchema, required: true },
    end_time: { type: TimePointSchema, required: true }
});

const SlotSchemaEntity: Schema<ISlot> = new Schema({
    staff_profile_ids: { type: [Schema.Types.ObjectId], ref: COLLECTION_NAME.STAFF_PROFILE, required: true },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT },
    appointment_limit: { type: Number, required: true, default: 1 },
    assigned_count: { type: Number, default: 0 },
    time_slots: { type: [TimeSlotSchema], required: true },
    status: {
        type: String,
        enum: SlotStatuses,
        required: true
    },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const SlotSchema = mongoose.model<ISlot & mongoose.Document>(
    COLLECTION_NAME.SLOT,
    SlotSchemaEntity
);

export default SlotSchema; 


================================================
FILE: src/modules/slot/slot.repository.ts
================================================
import SlotSchema from './slot.model';
import { ISlot } from './slot.interface';

export default class SlotRepository {
    public async createSlot(data: Partial<ISlot>): Promise<ISlot> {
        return SlotSchema.create(data);
    }

    public async findOne(query: any): Promise<ISlot | null> {
        return SlotSchema.findOne(query);
    }

    public async findById(id: string): Promise<ISlot | null> {
        return SlotSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<ISlot>, options: any = {}): Promise<ISlot | null> {
        return SlotSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return SlotSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISlot[]> {
        return SlotSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<ISlot[]> {
        return SlotSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISlot[]> {
        return SlotSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate({
                path: 'staff_profile_ids',
                select: 'employee_id job_title _id',
                populate: {
                    path: 'user_id',
                    select: '_id first_name last_name'
                }
            })
    }

    public async findByIdWithPopulate(id: string): Promise<ISlot | null> {
        return SlotSchema.findById(id)
            .populate({
                path: 'staff_profile_ids',
                select: 'employee_id job_title id',
                populate: {
                    path: 'user_id',
                    select: 'first_name last_name id'
                }
            })
    }
}



================================================
FILE: src/modules/slot/slot.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import SlotController from './slot.controller';
import { CreateSlotDto } from './dtos/createSlot.dto';
import { UpdateSlotDto } from './dtos/updateSlot.dto';

export default class SlotRoute implements IRoute {
    public path = API_PATH.SLOT;
    public router = Router();
    private slotController = new SlotController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/slot/create -> Create a single slot
        this.router.post(
            `${API_PATH.CREATE_SLOT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(CreateSlotDto),
            this.slotController.createSlot
        );

        // POST: domain:/api/slot/create-multiple -> Create multiple slots
        // this.router.post(
        //     `${this.path}/create-multiple`,
        //     authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
        //     validationMiddleware(CreateMultipleSlotsDto),
        //     this.slotController.createMultipleSlots
        // );

        // GET: domain:/api/slot/search -> Search slots with filters
        this.router.get(
            `${API_PATH.SEARCH_SLOT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.slotController.getSlots
        );

        // GET: domain:/api/slot/available -> Get available slots for booking
        this.router.get(
            `${API_PATH.AVAILABLE_SLOT}`,
            authMiddleWare([], true),
            this.slotController.getAvailableSlots
        );

        // GET: domain:/api/slot/staff/:staffProfileId -> Get slots by staff
        this.router.get(
            `${API_PATH.GET_SLOT_BY_STAFF}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.slotController.getSlotsByUser
        );

        // GET: domain:/api/slot/department/:departmentId -> Get slots by department
        this.router.get(
            `${API_PATH.GET_SLOT_BY_DEPARTMENT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.slotController.getSlotsByDepartment
        );

        // GET: domain:/api/slot/:id -> Get slot by id
        this.router.get(
            `${API_PATH.GET_SLOT_BY_ID}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.slotController.getSlotById
        );

        // GET: domain:/api/slot/service/:serviceId -> Get slots by service
        // this.router.get(
        //     `${API_PATH.GET_SLOT_BY_SERVICE}`,
        //     authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
        //     this.slotController.getSlotsByService
        // );

        // PUT: domain:/api/slot/:id -> Update slot
        this.router.put(
            `${API_PATH.UPDATE_SLOT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateSlotDto),
            this.slotController.updateSlot
        );

        // PATCH: domain:/api/slot/:id/status -> Change slot status
        this.router.patch(
            `${API_PATH.CHANGE_SLOT_STATUS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.slotController.changeSlotStatus
        );

        // GET: domain:/api/department/:departmentId/statistics -> Get department performance statistics
        this.router.get(
            `${API_PATH.DEPARTMENT_STATISTICS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.slotController.getDepartmentPerformance
        );
    }
}



================================================
FILE: src/modules/slot/slot.service.ts
================================================
import mongoose, { Schema } from "mongoose";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
// import { IError } from "../../core/interfaces";
import { SearchPaginationResponseModel } from "../../core/models";
import SlotSchema from "./slot.model";
import StaffProfileSchema from "../staff_profile/staff_profile.model";
import { StaffStatusEnum } from "../staff_profile/staff_profile.enum";
import { SlotStatusEnum } from "./slot.enum";
import { ISlot } from "./slot.interface";
import { UpdateSlotDto } from "./dtos/updateSlot.dto";
import { CreateSlotDto } from "./dtos/createSlot.dto";
import { UserRoleEnum } from "../user/user.enum";
import ServiceSchema from "../service/service.model";
import { ServiceTypeEnum, SampleMethodEnum } from "../service/service.enum";
import SlotRepository from "./slot.repository";
import UserSchema from "../user/user.model";

export default class SlotService {
    private slotSchema = SlotSchema;
    private staffProfileSchema = StaffProfileSchema;
    private serviceSchema = ServiceSchema;
    private slotRepository = new SlotRepository();
    private userSchema = UserSchema;
    // private errorResults: IError[] = [];

    /**
     * Tạo nhiều slot cùng lúc theo mẫu
     */
    // public async createMultipleSlots(model: CreateMultipleSlotsDto): Promise<{
    //     created: number,
    //     skipped: number
    // }> {
    //     // Kiểm tra staff_profile_id hợp lệ
    //     const staffProfile = await this.staffProfileSchema.findById(model.staff_profile_id);
    //     if (!staffProfile) {
    //         this.errorResults.push({
    //             message: 'Staff profile not found',
    //             field: 'staff_profile_id'
    //         });
    //     }

    //     if (staffProfile && staffProfile.status !== StaffStatusEnum.ACTIVE) {
    //         this.errorResults.push({
    //             message: 'Staff is not active',
    //             field: 'staff_profile_id'
    //         });
    //     }

    //     // Kiểm tra time_slots hợp lệ
    //     for (const timeSlot of model.time_slots) {
    //         const startTime = timeSlot.start_hour * 60 + timeSlot.start_minute; // convert start time to minutes
    //         const endTime = timeSlot.end_hour * 60 + timeSlot.end_minute; // convert end time to minutes

    //         if (endTime <= startTime) {
    //             this.errorResults.push({
    //                 message: `Invalid time slot: ${timeSlot.start_hour}:${timeSlot.start_minute} - ${timeSlot.end_hour}:${timeSlot.end_minute}. End time must be after start time.`,
    //                 field: 'time_slots'
    //             });
    //         }
    //     }

    //     // Tạo danh sách slots dựa trên pattern
    //     const slotTimes: { start: Date, end: Date }[] = []; // create an array of objects with start and end dates

    //     // Tạo slots theo pattern
    //     if (model.pattern === SlotPattern.DAILY) {
    //         // Tạo slot mỗi ngày trong khoảng từ start_date đến end_date
    //         for (let d = new Date(model.start_date); d <= new Date(model.end_date); d.setDate(d.getDate() + 1)) { //loop through each day in the range
    //             for (const time of model.time_slots) { // sử dụng time_slots để tạo slot cho từng ngày
    //                 const startDate = new Date(d); // tạo ngày bắt đầu cho slot
    //                 startDate.setHours(time.start_hour, time.start_minute, 0, 0); // set the start time of the slot

    //                 const endDate = new Date(d); // tạo ngày kết thúc cho slot
    //                 endDate.setHours(time.end_hour, time.end_minute, 0, 0); // set the end time of the slot

    //                 // xử lý time_slots qua đêm
    //                 // Nếu thời gian kết thúc nhỏ hơn thời gian bắt đầu, thêm 1 ngày vào thời gian kết thúc
    //                 if (endDate < startDate) {
    //                     endDate.setDate(endDate.getDate() + 1);
    //                 }

    //                 slotTimes.push({ start: startDate, end: endDate }); // thêm slot vào danh sách
    //             }
    //         }
    //     } else if (model.pattern === SlotPattern.WEEKLY) {
    //         // Tạo slot hàng tuần cho các ngày được chọn
    //         for (let d = new Date(model.start_date); d <= new Date(model.end_date); d.setDate(d.getDate() + 1)) { //loop through each day in the range
    //             // Kiểm tra ngày trong tuần có được chọn không
    //             if (model.days_of_week.includes(d.getDay())) {
    //                 for (const time of model.time_slots) { // sử dụng time_slots để tạo slot cho từng ngày
    //                     const startDate = new Date(d); // tạo ngày bắt đầu cho slot
    //                     startDate.setHours(time.start_hour, time.start_minute, 0, 0); // set the start time of the slot

    //                     const endDate = new Date(d);
    //                     endDate.setHours(time.end_hour, time.end_minute, 0, 0); // set the end time of the slot

    //                     // xử lý time_slots qua đêm
    //                     // Nếu thời gian kết thúc nhỏ hơn thời gian bắt đầu, thêm 1 ngày vào thời gian kết thúc
    //                     if (endDate < startDate) {
    //                         endDate.setDate(endDate.getDate() + 1);
    //                     }

    //                     slotTimes.push({ start: startDate, end: endDate }); // thêm slot vào danh sách
    //                 }
    //             }
    //         }
    //     }

    //     // Kiểm tra trùng lặp và tạo slot
    //     let created = 0;
    //     let skipped = 0;

    //     for (const time of slotTimes) {
    //         // Kiểm tra slot đã tồn tại chưa
    //         const existingSlot = await this.slotSchema.findOne({
    //             staff_profile_id: model.staff_profile_id,
    //             $or: [
    //                 {
    //                     start_time: { $lt: time.end }, // start_time nhỏ hơn end_time
    //                     end_time: { $gt: time.start } // end_time lớn hơn start_time
    //                 }
    //             ]
    //         });

    //         if (existingSlot) { // nếu slot đã tồn tại
    //             skipped++; // tăng số lượng slot bị bỏ qua
    //             continue; // tiếp tục vòng lặp
    //         }

    //         // kiểm tra time_slots, days_of_week có phải là Array không
    //         if (!Array.isArray(model.time_slots) && !Array.isArray(model.days_of_week)) {
    //             this.errorResults.push({
    //                 message: 'time_slots and days_of_week must be an array',
    //                 field: 'time_slots'
    //             });
    //         }

    //         // Tạo slot mới
    //         await this.slotSchema.create({
    //             staff_profile_id: model.staff_profile_id,
    //             service_id: model.service_id,
    //             pattern: model.pattern || SlotPattern.DAILY,
    //             start_time: time.start,
    //             end_time: time.end,
    //             appointment_limit: model.appointment_limit || 1,
    //             days_of_week: model.days_of_week || [],
    //             time_slots: model.time_slots || [],
    //             status: SlotStatusEnum.AVAILABLE,
    //             created_at: new Date(),
    //             updated_at: new Date()
    //         });

    //         created++; // Tăng số lượng slot đã tạo thành công để trả về cho người dùng
    //     }

    //     return { created, skipped }; // trả về số lượng slot đã tạo thành công và số lượng slot bị bỏ qua
    // }

    /**
     * Get slots by department with role-based filtering
     * @param departmentId Department ID
     * @param queryParams Query parameters
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @returns Paginated list of slots for the department
     */
    public async getSlotsByDepartment(
        departmentId: string,
        queryParams: any = {},
        userRole?: string,
        userId?: string
    ): Promise<SearchPaginationResponseModel<ISlot>> {
        if (!mongoose.Types.ObjectId.isValid(departmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Department ID is invalid');
        }

        // Find all staff profiles in the department
        const staffProfiles = await this.staffProfileSchema.find({
            department_id: departmentId,
            status: StaffStatusEnum.ACTIVE
        });

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // For staff users, check if they belong to the requested department
        if (userRole === UserRoleEnum.STAFF && userId) {
            const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });

            if (!staffProfile) {
                return {
                    pageData: [],
                    pageInfo: {
                        totalItems: 0,
                        totalPages: 0,
                        pageNum: 1,
                        pageSize: 10
                    }
                };
            }

            // Check if staff belongs to the requested department
            if (staffProfile.department_id?.toString() !== departmentId) {
                // Staff can only see slots from their own department
                throw new HttpException(HttpStatus.Forbidden, 'You can only view slots from your own department');
            }
        }

        // Add department_id to query params
        const enrichedQueryParams = {
            ...queryParams,
            department_id: departmentId
        };

        // Use the getSlots method with role-based filtering
        return this.getSlots(enrichedQueryParams, userRole, userId);
    }

    /**
     * Cập nhật slot
     */
    public async updateSlot(id: string, model: UpdateSlotDto): Promise<ISlot> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid slot ID');
        }

        const slot = await this.slotRepository.findById(id);
        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        if (!model.time_slots || model.time_slots.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'time_slots are required');
        }

        for (const timeSlot of model.time_slots) {
            // kiểm tra xem time_slots có hợp lệ hay không
            if (!timeSlot.year || !timeSlot.month || !timeSlot.day ||
                !timeSlot.start_time || !timeSlot.end_time ||
                timeSlot.start_time.hour === undefined || timeSlot.start_time.minute === undefined ||
                timeSlot.end_time.hour === undefined || timeSlot.end_time.minute === undefined) {
                throw new HttpException(HttpStatus.BadRequest, 'All time slot fields are required');
            }

            // kiểm tra xem hour và minute có hợp lệ hay không
            if (timeSlot.start_time.hour < 0 || timeSlot.start_time.hour > 23 ||
                timeSlot.end_time.hour < 0 || timeSlot.end_time.hour > 23 ||
                timeSlot.start_time.minute < 0 || timeSlot.start_time.minute > 59 ||
                timeSlot.end_time.minute < 0 || timeSlot.end_time.minute > 59) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid hour or minute values');
            }

            // chuyển đổi sang phút để dễ so sánh
            const startTimeInMinutes = timeSlot.start_time.hour * 60 + timeSlot.start_time.minute;
            const endTimeInMinutes = timeSlot.end_time.hour * 60 + timeSlot.end_time.minute;

            // kiểm tra xem thời gian kết thúc có sau thời gian bắt đầu hay không
            if (endTimeInMinutes <= startTimeInMinutes) {
                throw new HttpException(HttpStatus.BadRequest, 'End time must be after start time');
            }

            // kiểm tra xem ngày có hợp lệ hay không
            const date = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            if (isNaN(date.getTime()) || date.getDate() !== timeSlot.day) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid date');
            }
        }

        // kiểm tra xem staff_profile_ids có hợp lệ hay không
        const staffProfiles = await this.staffProfileSchema.find({
            _id: { $in: model.staff_profile_ids }, // $in is used in array to filter the some of the values
            status: StaffStatusEnum.ACTIVE
        });

        if (staffProfiles.length === 0) {
            throw new HttpException(HttpStatus.NotFound, 'No active staff profiles found');
        }

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // kiểm tra xem slot có bị trùng lặp với slot khác hay không, BỎ QUA NẾU TRÙNG VỚI CHÍNH NÓ
        for (const timeSlot of model.time_slots) {
            const overlappingSlots = await this.slotRepository.findOne({
                _id: { $ne: id }, // không tính chính nó - $ne is not equal to
                staff_profile_ids: { $in: model.staff_profile_ids },
                time_slots: {
                    $elemMatch: { // $elemMatch được sử dụng để tìm kiếm phần tử trong mảng
                        year: timeSlot.year,
                        month: timeSlot.month,
                        day: timeSlot.day,
                        $or: [
                            {
                                // thời gian bắt đầu nằm trong slot hiện tại
                                "start_time.hour": { $lt: timeSlot.end_time.hour }, // start_time.hour < end_time.hour
                                "end_time.hour": { $gt: timeSlot.start_time.hour } // end_time.hour > start_time.hour
                            },
                            {
                                // cùng giờ, kiểm tra phút
                                "start_time.hour": timeSlot.start_time.hour,
                                "start_time.minute": { $lt: timeSlot.end_time.minute }
                            },
                            {
                                // Same hour, check minutes
                                "end_time.hour": timeSlot.end_time.hour,
                                "end_time.minute": { $gt: timeSlot.start_time.minute }
                            }
                        ]
                    }
                }
            });

            // kiểm tra xem slot có bị trùng lặp với slot khác hay không, BỎ QUA NẾU TRÙNG VỚI CHÍNH NÓ
            if (overlappingSlots) {
                throw new HttpException(HttpStatus.Conflict, 'Slot overlaps with an existing slot');
            }
        }

        // kiểm tra xem staff_profile_ids có hợp lệ hay không
        if (model.staff_profile_ids.length !== staffProfileIds.length) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid staff profile IDs');
        }

        // cập nhật slot
        const updatedSlot = await this.slotRepository.findByIdAndUpdate(
            id,
            {
                staff_profile_ids: staffProfileIds,
                time_slots: model.time_slots as any, // ép kiểu sang any để khắc phục lỗi kiểu dữ liệu
                appointment_limit: model.appointment_limit,
                status: model.status,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedSlot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found after update');
        }

        return updatedSlot;
    }

    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }

    /**
     * Tạo một slot mới
     */
    public async createSlot(model: CreateSlotDto): Promise<ISlot> {
        if (!model.time_slots || model.time_slots.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'time_slots are required');
        }

        // Validate time slots
        for (const timeSlot of model.time_slots) {
            // kiểm tra xem tất cả các trường bắt buộc có tồn tại hay không
            if (!timeSlot.year || !timeSlot.month || !timeSlot.day ||
                !timeSlot.start_time || !timeSlot.end_time ||
                timeSlot.start_time.hour === undefined || timeSlot.start_time.minute === undefined ||
                timeSlot.end_time.hour === undefined || timeSlot.end_time.minute === undefined) {
                throw new HttpException(HttpStatus.BadRequest, 'All time slot fields are required');
            }

            // kiểm tra xem hour và minute có hợp lệ hay không
            if (timeSlot.start_time.hour < 0 || timeSlot.start_time.hour > 23 ||
                timeSlot.end_time.hour < 0 || timeSlot.end_time.hour > 23 ||
                timeSlot.start_time.minute < 0 || timeSlot.start_time.minute > 59 ||
                timeSlot.end_time.minute < 0 || timeSlot.end_time.minute > 59) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid hour or minute values');
            }

            // chuyển đổi sang phút để dễ so sánh
            const startTimeInMinutes = timeSlot.start_time.hour * 60 + timeSlot.start_time.minute;
            const endTimeInMinutes = timeSlot.end_time.hour * 60 + timeSlot.end_time.minute;

            // kiểm tra xem thời gian kết thúc có sau thời gian bắt đầu hay không
            if (endTimeInMinutes <= startTimeInMinutes) {
                throw new HttpException(HttpStatus.BadRequest, 'End time must be after start time');
            }

            // kiểm tra xem ngày có hợp lệ hay không
            const date = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            if (isNaN(date.getTime()) || date.getDate() !== timeSlot.day) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid date');
            }
        }

        // kiểm tra xem staff_profile_ids có hợp lệ hay không
        const staffProfiles = await this.staffProfileSchema.find({
            _id: { $in: model.staff_profile_ids || [] },
            status: StaffStatusEnum.ACTIVE
        });

        if (staffProfiles.length === 0) {
            throw new HttpException(HttpStatus.NotFound, 'No active staff profiles found');
        }

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // kiểm tra xem slot có bị trùng lặp với slot khác hay không, BỎ QUA NẾU TRÙNG VỚI CHÍNH NÓ
        for (const timeSlot of model.time_slots) {
            // tạo ngày bắt đầu
            const startDate = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            startDate.setHours(timeSlot.start_time.hour, timeSlot.start_time.minute, 0, 0);

            // tạo ngày kết thúc
            const endDate = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            endDate.setHours(timeSlot.end_time.hour, timeSlot.end_time.minute, 0, 0);

            // kiểm tra xem slot có bị trùng lặp với slot khác hay không, BỎ QUA NẾU TRÙNG VỚI CHÍNH NÓ
            const overlappingSlots = await this.slotSchema.find({
                staff_profile_ids: { $in: staffProfileIds }, // $in is used in array to filter the some of the values
                time_slots: {
                    $elemMatch: { // $elemMatch được sử dụng để tìm kiếm phần tử trong mảng
                        year: timeSlot.year,
                        month: timeSlot.month,
                        day: timeSlot.day,
                        $or: [
                            {
                                // thời gian bắt đầu nằm trong slot hiện tại
                                "start_time.hour": { $lt: timeSlot.end_time.hour }, // start_time.hour < end_time.hour
                                "end_time.hour": { $gt: timeSlot.start_time.hour } // end_time.hour > start_time.hour
                            },
                            {
                                // cùng giờ, kiểm tra phút
                                "start_time.hour": timeSlot.start_time.hour,
                                "start_time.minute": { $lt: timeSlot.end_time.minute } // start_time.minute < end_time.minute
                            },
                            {
                                // cùng giờ, kiểm tra phút
                                "end_time.hour": timeSlot.end_time.hour,
                                "end_time.minute": { $gt: timeSlot.start_time.minute } // end_time.minute > start_time.minute
                            }
                        ]
                    }
                }
            });

            if (overlappingSlots.length > 0) {
                throw new HttpException(HttpStatus.Conflict, 'Slot overlaps with an existing slot');
            }
        }

        // tạo slot mới
        const newSlot = await this.slotSchema.create({
            staff_profile_ids: staffProfileIds,
            time_slots: model.time_slots,
            appointment_limit: model.appointment_limit,
            status: SlotStatusEnum.AVAILABLE,
            created_at: new Date(),
            updated_at: new Date()
        });

        return newSlot;
    }

    /**
     * Get slots with filters
     * @param queryParams Query parameters for filtering
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @returns Paginated list of slots
     */
    public async getSlots(queryParams: any = {}, userRole?: string, userId?: string): Promise<SearchPaginationResponseModel<ISlot>> {
        try {
            const {
                pageNum = 1,
                pageSize = 10,
                staff_profile_ids,
                department_id,
                appointment_id,
                status,
                date_from,
                date_to,
                sort_by = 'start_time',
                sort_order = 1,
            } = queryParams;

            const skip = (pageNum - 1) * pageSize;

            const query: any = {};

            // Lưu trữ staff_profile_ids được yêu cầu để lọc trong phản hồi sau
            let requestedStaffIds: string[] = [];

            // Xử lý lọc staff_profile_ids dựa trên vai trò của người dùng
            if (userRole === UserRoleEnum.STAFF) {
                if (staff_profile_ids) {
                    // Vai trò STAFF không được phép lọc bằng staff_profile_ids
                    throw new HttpException(HttpStatus.Forbidden, 'Staff role is not allowed to filter by staff_profile_id');
                }

                // STAFF chỉ có thể xem slot mà họ được giao
                if (userId) {
                    const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });
                    if (staffProfile) {
                        query.staff_profile_ids = { $in: [staffProfile._id] }; // $in is used in array to filter the some of the values
                        requestedStaffIds = [staffProfile._id.toString()];
                    } else {
                        // Nếu staff profile không được tìm thấy, trả về kết quả trống
                        return {
                            pageData: [],
                            pageInfo: {
                                totalItems: 0,
                                totalPages: 0,
                                pageNum: Number(pageNum),
                                pageSize: Number(pageSize)
                            }
                        };
                    }
                }
            } else if (userRole === UserRoleEnum.ADMIN || userRole === UserRoleEnum.MANAGER) {
                // Admin/Manager có thể lọc bằng staff_profile_ids nếu được cung cấp
                if (staff_profile_ids) {
                    // Chuyển đổi thành mảng nếu đó là ID duy nhất
                    const staffIdsArray: any[] = Array.isArray(staff_profile_ids)
                        ? staff_profile_ids
                        : [staff_profile_ids]; // ép kiểu sang mảng

                    // Chuyển đổi tất cả các ID thành chuỗi để so sánh
                    requestedStaffIds = staffIdsArray.map(id => id.toString());

                    // Sử dụng các giá trị gốc cho truy vấn
                    query.staff_profile_ids = { $in: staffIdsArray };
                }
                // Ngược lại, họ có thể xem tất cả các slot (không áp dụng bất kỳ lọc nào)
            }

            // Lọc theo department_id
            if (department_id) {
                const staffProfiles = await this.staffProfileSchema.find({
                    department_id,
                    status: StaffStatusEnum.ACTIVE
                });
                const staffProfileIds = staffProfiles.map(profile => profile._id.toString());

                // Nếu staff_profile_ids đã được thiết lập, sử dụng $and để kết hợp các bộ lọc
                if (query.staff_profile_ids) {
                    query.$and = [
                        { staff_profile_ids: query.staff_profile_ids },
                        { staff_profile_ids: { $in: staffProfileIds } }
                    ];

                    // Lọc requestedStaffIds để chỉ bao gồm nhân viên từ phòng ban này
                    if (requestedStaffIds.length > 0) {
                        requestedStaffIds = requestedStaffIds.filter(id =>
                            staffProfileIds.includes(id)
                        );
                    } else {
                        requestedStaffIds = staffProfileIds;
                    }

                    delete query.staff_profile_ids; // Xóa bộ lọc gốc vì chúng ta đang sử dụng $and
                } else {
                    query.staff_profile_ids = { $in: staffProfileIds };
                    requestedStaffIds = staffProfileIds;
                }
            }

            if (appointment_id) {
                query.appointment_id = appointment_id;
            }

            if (status) {
                query.status = status;
            }

            // Lọc theo khoảng ngày
            if (date_from || date_to) {
                // Tìm các slot mà bất kỳ thời gian_slot nào nằm trong khoảng ngày
                const dateConditions = [];

                if (date_from) {
                    // Parse date_from in yyyy-mm-dd format
                    let startDate: Date;
                    if (typeof date_from === 'string' && date_from.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const [year, month, day] = date_from.split('-').map(Number);
                        startDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
                    } else {
                        startDate = new Date(date_from);
                    }

                    if (isNaN(startDate.getTime())) {
                        throw new HttpException(HttpStatus.BadRequest, 'Invalid date_from format. Use YYYY-MM-DD format.');
                    }

                    const startYear = startDate.getFullYear();
                    const startMonth = startDate.getMonth() + 1; // JavaScript months are 0-based
                    const startDay = startDate.getDate();

                    dateConditions.push({
                        $or: [
                            { 'time_slots.year': { $gt: startYear } },
                            {
                                'time_slots.year': startYear,
                                'time_slots.month': { $gt: startMonth }
                            },
                            {
                                'time_slots.year': startYear,
                                'time_slots.month': startMonth,
                                'time_slots.day': { $gte: startDay }
                            }
                        ]
                    });
                }

                if (date_to) {
                    // Parse date_to in yyyy-mm-dd format
                    let endDate: Date;
                    if (typeof date_to === 'string' && date_to.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const [year, month, day] = date_to.split('-').map(Number);
                        endDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
                    } else {
                        endDate = new Date(date_to);
                    }

                    if (isNaN(endDate.getTime())) {
                        throw new HttpException(HttpStatus.BadRequest, 'Invalid date_to format. Use YYYY-MM-DD format.');
                    }

                    const endYear = endDate.getFullYear();
                    const endMonth = endDate.getMonth() + 1;
                    const endDay = endDate.getDate();

                    dateConditions.push({
                        $or: [
                            { 'time_slots.year': { $lt: endYear } },
                            {
                                'time_slots.year': endYear,
                                'time_slots.month': { $lt: endMonth }
                            },
                            {
                                'time_slots.year': endYear,
                                'time_slots.month': endMonth,
                                'time_slots.day': { $lte: endDay }
                            }
                        ]
                    });
                }

                // Nếu có điều kiện ngày, sử dụng $and để kết hợp các điều kiện => tạo ra điều kiện ngày
                if (dateConditions.length > 0) {
                    if (query.$and) {
                        query.$and.push({ $and: dateConditions });
                    } else {
                        query.$and = dateConditions;
                    }
                }
            }

            console.log('Slot search query:', JSON.stringify(query, null, 2));

            const totalItems = await this.slotSchema.countDocuments(query);

            const slots = await this.slotSchema
                .find(query)
                .sort({ [sort_by]: sort_order })
                .skip(skip)
                .limit(Number(pageSize))
                .populate({
                    path: 'staff_profile_ids',
                    select: 'employee_id job_title department_id',
                    populate: {
                        path: 'user_id',
                        select: 'first_name last_name email'
                    }
                })
                .populate({
                    path: 'appointment_id',
                    select: 'code status'
                });

            // Xử lý kết quả dựa trên vai trò của người dùng và tham số lọc
            const processedSlots = slots.map(slot => {
                const slotObj = slot.toObject();

                // Nếu lọc theo staff_profile_ids, chỉ hiển thị những nhân viên được yêu cầu trong phản hồi
                if (staff_profile_ids && Array.isArray(slotObj.staff_profile_ids)) {
                    // Lọc staff_profile_ids để chỉ bao gồm những nhân viên được yêu cầu
                    slotObj.staff_profile_ids = slotObj.staff_profile_ids.filter((profile: any) => {
                        return profile._id && requestedStaffIds.includes(profile._id.toString());
                    }) as any;
                }
                // Đối với danh sách xem (không lọc theo staff_profile_id cụ thể), ẩn staff_profile_ids cho vai trò STAFF
                else if (!staff_profile_ids && userRole === UserRoleEnum.STAFF) {
                    slotObj.staff_profile_ids = [];  // Thay thế bằng mảng trống
                }

                return slotObj;
            });

            const totalPages = Math.ceil(totalItems / pageSize);

            return {
                pageData: processedSlots,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: Number(pageNum),
                    pageSize: Number(pageSize)
                }
            };
        } catch (error) {
            console.error('Error in getSlots:', error);
            throw error;
        }
    }

    /**
     * Get slot by ID with role-based access control
     * @param id Slot ID
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @param requestedStaffId Optional specific staff ID to filter in the response
     * @returns Slot with appropriate staff information based on user role
     */
    public async getSlotById(
        id: string,
        userRole?: string,
        userId?: string,
        requestedStaffId?: string
    ): Promise<ISlot> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid slot ID');
        }

        const slot = await this.slotRepository.findByIdWithPopulate(id);

        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        // Process the slot based on user role
        const slotObj = slot.toObject();

        // Nếu yêu cầu một nhân viên cụ thể và người dùng không phải là STAFF hoặc là nhân viên được yêu cầu
        if (requestedStaffId && (userRole !== UserRoleEnum.STAFF ||
            (userId && await this.isUserMatchingStaffId(userId, requestedStaffId)))) {
            // Lọc để chỉ hiển thị thông tin nhân viên được yêu cầu
            if (Array.isArray(slotObj.staff_profile_ids)) {
                slotObj.staff_profile_ids = slotObj.staff_profile_ids.filter((profile: any) => {
                    return profile._id && profile._id.toString() === requestedStaffId;
                });
            }
        }
        // Đối với vai trò STAFF, chỉ hiển thị thông tin của chính họ trong staff_profile_ids
        else if (userRole === UserRoleEnum.STAFF && userId && Array.isArray(slotObj.staff_profile_ids)) {
            const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });

            if (staffProfile) {
                // Kiểm tra xem nhân viên này có được giao slot hay không
                const isAssigned = slotObj.staff_profile_ids.some((profile: any) => {
                    return profile._id && profile._id.toString() === staffProfile._id.toString();
                });

                if (isAssigned) {
                    // Chỉ giữ lại thông tin nhân viên này trong danh sách
                    const staffProfileData = slotObj.staff_profile_ids.find((profile: any) =>
                        profile._id && profile._id.toString() === staffProfile._id.toString()
                    );

                    slotObj.staff_profile_ids = staffProfileData ? [staffProfileData] : [];
                } else {
                    // Nhân viên không được giao slot, ẩn tất cả thông tin nhân viên
                    slotObj.staff_profile_ids = [];
                }
            } else {
                // Staff profile not found, hide all staff info
                slotObj.staff_profile_ids = [];
            }
        }

        return slotObj as ISlot;
    }

    /**
     * Check if the given user ID matches the given staff profile ID
     * @param userId User ID to check
     * @param staffProfileId Staff profile ID to check against
     * @returns True if the user is associated with the staff profile
     */
    private async isUserMatchingStaffId(userId: string, staffProfileId: string): Promise<boolean> {
        if (!mongoose.Types.ObjectId.isValid(staffProfileId)) {
            return false;
        }

        const staffProfile = await this.staffProfileSchema.findById(staffProfileId);
        if (!staffProfile) {
            return false;
        }

        return staffProfile.user_id?.toString() === userId;
    }

    /**
     * Thay đổi trạng thái slot
     */
    public async changeSlotStatus(id: string, status: string): Promise<ISlot> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid slot ID');
        }

        const slot = await this.slotRepository.findById(id);
        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        // Không cho phép thay đổi trạng thái nếu slot đã BOOKED (có trong db) và param status không phải là BOOKED
        if (slot && slot.status === SlotStatusEnum.BOOKED && status !== SlotStatusEnum.BOOKED) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot change status of a booked slot');
        }

        // Chỉ chấp nhận các trạng thái hợp lệ
        if (![SlotStatusEnum.AVAILABLE, SlotStatusEnum.UNAVAILABLE, SlotStatusEnum.BOOKED].includes(status as any)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid status value');
        }

        const updatedSlot = await this.slotSchema.findByIdAndUpdate(
            id,
            {
                status: status,
                updated_at: new Date()
            },
            { new: true }
        ).populate({
            path: 'staff_profile_ids',
            select: 'employee_id job_title',
            populate: {
                path: 'user_id',
                select: 'first_name last_name'
            }
        });

        if (!updatedSlot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        return updatedSlot as ISlot;
    }

    /**
     * Get slots by user (staff) with role-based access control
     * @param userId User ID to get slots for
     * @param queryParams Query parameters
     * @param requestingUserRole Role of the requesting user
     * @param requestingUserId ID of the requesting user
     * @returns Paginated list of slots for the user
     */
    public async getSlotsByUser(
        userId: string,
        queryParams: any = {},
        requestingUserRole?: string,
        requestingUserId?: string
    ): Promise<SearchPaginationResponseModel<ISlot>> {
        if (!mongoose.Types.ObjectId.isValid(userId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid user ID');
        }

        // Find user
        const user = await this.userSchema.findById(userId);

        if (!user) {
            throw new HttpException(HttpStatus.NotFound, 'User not found');
        }

        if (user.status !== true) {
            throw new HttpException(HttpStatus.BadRequest, 'User is not active');
        }

        // Find staff profile
        const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });

        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found for this user');
        }

        // Check permissions - staff can only view their own slots
        if (requestingUserRole === UserRoleEnum.STAFF) {
            if (requestingUserId !== userId) {
                throw new HttpException(HttpStatus.Forbidden, 'As a staff member, you can only view your own slots');
            }
        }

        // Add staff_profile_id to query params
        const enrichedQueryParams = {
            ...queryParams,
            staff_profile_ids: [staffProfile._id.toString()]
        };

        // Use the getSlots method with role override to ensure we see all slots for this staff
        // We pass ADMIN as the role to bypass staff-specific filtering in getSlots
        return this.getSlots(enrichedQueryParams, UserRoleEnum.ADMIN);
    }

    /**
     * Lấy thống kê performance của phòng ban
     */
    public async getDepartmentPerformance(departmentId: string, queryParams: any): Promise<any> {
        if (!mongoose.Types.ObjectId.isValid(departmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid department ID');
        }

        // Lấy tất cả nhân viên thuộc phòng ban và trạng thái ACTIVE
        const staffProfiles = await this.staffProfileSchema.find({
            department_id: departmentId,
            status: StaffStatusEnum.ACTIVE
        });

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // Process query parameters
        const { date_from, date_to } = queryParams;
        const query: any = { staff_profile_ids: { $in: staffProfileIds } };

        // Filter by date range
        if (date_from || date_to) {
            query.start_time = {};
            if (date_from) {
                query.start_time.$gte = new Date(date_from);
            }
            if (date_to) {
                const endDate = new Date(date_to);
                endDate.setHours(23, 59, 59, 999);
                query.start_time.$lte = endDate;
            }
        }

        // Count total slots
        const totalSlots = await this.slotSchema.countDocuments(query);

        // Count booked slots
        const bookedSlots = await this.slotSchema.countDocuments({
            ...query,
            status: SlotStatusEnum.BOOKED
        });

        // Calculate booking rate (số lượng slot đã được đặt / tổng số slot)
        const bookingRate = totalSlots > 0 ? (bookedSlots / totalSlots) * 100 : 0;

        return {
            totalStaff: staffProfiles.length,
            totalSlots,
            bookedSlots,
            bookingRate
        };
    }

    /**
     * Get available slots for booking with role-based filtering
     * @param params Search parameters
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @returns Paginated list of available slots
     */
    public async getAvailableSlots(
        params: {
            start_date: string;
            end_date?: string;
            type?: string;
            staff_profile_ids?: string | string[];
        },
        userRole?: string,
        userId?: string
    ): Promise<SearchPaginationResponseModel<ISlot>> {
        const { start_date, end_date, type, staff_profile_ids } = params;

        // Validate start_date
        if (!start_date) {
            throw new HttpException(HttpStatus.BadRequest, 'start_date is required');
        }

        // Parse start_date in yyyy-mm-dd format
        let startDate: Date;
        if (start_date.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Parse yyyy-mm-dd format
            const [year, month, day] = start_date.split('-').map(Number);
            startDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
        } else {
            startDate = new Date(start_date);
        }

        if (isNaN(startDate.getTime())) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid start_date format. Use YYYY-MM-DD format.');
        }

        // Set default end_date if not provided
        let endDate: Date;
        if (end_date) {
            // Parse end_date in yyyy-mm-dd format if it matches the pattern
            if (end_date.match(/^\d{4}-\d{2}-\d{2}$/)) {
                const [year, month, day] = end_date.split('-').map(Number);
                endDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
            } else {
                endDate = new Date(end_date);
            }

            if (isNaN(endDate.getTime())) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid end_date format. Use YYYY-MM-DD format.');
            }
        } else {
            endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 7); // Default to 7 days from start date
        }

        // Create query with all parameters
        const queryParams: Record<string, any> = {
            status: SlotStatusEnum.AVAILABLE,
            date_from: startDate.toISOString().split('T')[0], // Format as YYYY-MM-DD
            date_to: endDate.toISOString().split('T')[0], // Format as YYYY-MM-DD
            staff_profile_ids: staff_profile_ids
        };

        if (type) {
            // Validate type if provided
            const validTypes = Object.values(SampleMethodEnum);
            if (!validTypes.includes(type as SampleMethodEnum)) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid type. Must be one of: ${validTypes.join(', ')}`);
            }
            queryParams.type = type;
        }

        // Use the getSlots method with role-based filtering
        return this.getSlots(queryParams, userRole, userId);
    }
}


================================================
FILE: src/modules/slot/dtos/createSlot.dto.ts
================================================
import { Type } from "class-transformer";
import { IsNotEmpty, IsNumber, IsString, IsOptional, IsArray, ValidateNested } from "class-validator";
import { ITimeSlot, TimePoint } from "../slot.interface";

export class TimePointDto implements TimePoint {
    constructor(hour: number, minute: number) {
        this.hour = hour;
        this.minute = minute;
    }

    @IsNotEmpty()
    @IsNumber()
    hour: number;

    @IsNotEmpty()
    @IsNumber()
    minute: number;
}

export class TimeSlotDto implements ITimeSlot {
    constructor(
        year: number,
        month: number,
        day: number,
        start_time: TimePointDto,
        end_time: TimePointDto
    ) {
        this.year = year;
        this.month = month;
        this.day = day;
        this.start_time = start_time;
        this.end_time = end_time;
    }

    @IsNotEmpty()
    @IsNumber()
    year: number;

    @IsNotEmpty()
    @IsNumber()
    month: number;

    @IsNotEmpty()
    @IsNumber()
    day: number;

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TimePointDto)
    start_time: TimePointDto;

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TimePointDto)
    end_time: TimePointDto;
}

export class CreateSlotDto {
    constructor(
        staff_profile_ids: string[],
        time_slots: TimeSlotDto[],
        appointment_limit: number
    ) {
        this.staff_profile_ids = staff_profile_ids;
        this.time_slots = time_slots;
        this.appointment_limit = appointment_limit;
    }

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    staff_profile_ids: string[];

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimeSlotDto)
    time_slots: TimeSlotDto[];

    @IsNotEmpty()
    @IsNumber()
    appointment_limit: number;
} 


================================================
FILE: src/modules/slot/dtos/timeSlot.dto.ts
================================================
import { IsNotEmpty, IsNumber } from "class-validator";

export default class TimeSlotDto {
    constructor(
        start_hour: number,
        start_minute: number,
        end_hour: number,
        end_minute: number
    ) {
        this.start_hour = start_hour;
        this.start_minute = start_minute;
        this.end_hour = end_hour;
        this.end_minute = end_minute;
    }

    @IsNotEmpty()
    @IsNumber()
    start_hour: number;

    @IsNotEmpty()
    @IsNumber()
    start_minute: number;

    @IsNotEmpty()
    @IsNumber()
    end_hour: number;

    @IsNotEmpty()
    @IsNumber()
    end_minute: number;
}



================================================
FILE: src/modules/slot/dtos/updateSlot.dto.ts
================================================
import { Type } from "class-transformer";
import { IsEnum, IsNotEmpty, IsOptional, IsNumber, IsString, IsArray, ValidateNested } from "class-validator";
import mongoose, { Schema } from "mongoose";
import { TimePointDto, TimeSlotDto } from "./createSlot.dto";

export class UpdateSlotDto {
    constructor(
        staff_profile_ids: string[],
        time_slots: TimeSlotDto[],
        appointment_limit: number,
        status?: string,
    ) {
        this.staff_profile_ids = staff_profile_ids;
        this.time_slots = time_slots;
        this.appointment_limit = appointment_limit;
        this.status = status;
    }

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    staff_profile_ids: string[];

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimeSlotDto)
    time_slots: TimeSlotDto[];

    @IsNotEmpty()
    @IsNumber()
    appointment_limit: number;

    @IsOptional()
    @IsString()
    status?: string;
}



================================================
FILE: src/modules/slot/swagger/slot.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     TimePoint:
 *       type: object
 *       required:
 *         - hour
 *         - minute
 *       properties:
 *         hour:
 *           type: integer
 *           minimum: 0
 *           maximum: 23
 *           description: Hour (0-23)
 *           example: 9
 *         minute:
 *           type: integer
 *           minimum: 0
 *           maximum: 59
 *           description: Minute (0-59)
 *           example: 30
 *
 *     TimeSlot:
 *       type: object
 *       required:
 *         - year
 *         - month
 *         - day
 *         - start_time
 *         - end_time
 *       properties:
 *         year:
 *           type: integer
 *           description: Year
 *           example: 2025
 *         month:
 *           type: integer
 *           minimum: 1
 *           maximum: 12
 *           description: Month (1-12)
 *           example: 10
 *         day:
 *           type: integer
 *           minimum: 1
 *           maximum: 31
 *           description: Day (1-31)
 *           example: 15
 *         start_time:
 *           $ref: '#/components/schemas/TimePoint'
 *         end_time:
 *           $ref: '#/components/schemas/TimePoint'
 *
 *     CreateSlotDto:
 *       type: object
 *       required:
 *         - staff_profile_ids
 *         - time_slots
 *         - appointment_limit
 *       properties:
 *         staff_profile_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Array of staff profile IDs assigned to this slot
 *           example: ["60d5ec9af682fbd12a0f4a1b"]
 *         time_slots:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/TimeSlot'
 *           description: Array of time slots
 *         appointment_limit:
 *           type: integer
 *           minimum: 1
 *           description: Maximum number of appointments allowed for this slot
 *           example: 1
 *
 *     UpdateSlotDto:
 *       type: object
 *       required:
 *         - staff_profile_ids
 *         - time_slots
 *         - appointment_limit
 *       properties:
 *         staff_profile_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Array of staff profile IDs assigned to this slot
 *           example: ["60d5ec9af682fbd12a0f4a1b"]
 *         time_slots:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/TimeSlot'
 *           description: Array of time slots
 *         appointment_limit:
 *           type: integer
 *           minimum: 1
 *           description: Maximum number of appointments allowed for this slot
 *           example: 1
 *         status:
 *           type: string
 *           enum: [available, booked, unavailable]
 *           description: Slot status
 *           example: "available"
 *
 *     SlotResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Slot ID
 *           example: "60d5ec9af682fbd12a0f4a3d"
 *         staff_profile_ids:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               _id:
 *                 type: string
 *                 example: "60d5ec9af682fbd12a0f4a1b"
 *               employee_id:
 *                 type: string
 *                 example: "EMP-2023-001"
 *               job_title:
 *                 type: string
 *                 example: "Laboratory Technician"
 *               user_id:
 *                 type: object
 *                 properties:
 *                   _id:
 *                     type: string
 *                     example: "60d5ec9af682fbd12a0f4a1a"
 *                   first_name:
 *                     type: string
 *                     example: "John"
 *                   last_name:
 *                     type: string
 *                     example: "Doe"
 *                   email:
 *                     type: string
 *                     example: "john.doe@example.com"
 *         service_id:
 *           type: string
 *           description: Service ID associated with this slot
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         appointment_id:
 *           type: string
 *           description: Associated appointment ID (if booked)
 *           example: "60d5ec9af682fbd12a0f4a4d"
 *         appointment_limit:
 *           type: integer
 *           description: Maximum number of appointments allowed for this slot
 *           example: 1
 *         time_slots:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/TimeSlot'
 *           description: Array of time slots
 *         status:
 *           type: string
 *           enum: [available, booked, unavailable]
 *           description: Slot status
 *           example: "available"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-07-15T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-07-16T14:20:00.000Z"
 *
 *     SlotPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/SlotResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 45
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 5
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     DepartmentPerformanceResponse:
 *       type: object
 *       properties:
 *         totalStaff:
 *           type: integer
 *           description: Total number of active staff in the department
 *           example: 10
 *         totalSlots:
 *           type: integer
 *           description: Total number of slots in the department
 *           example: 120
 *         bookedSlots:
 *           type: integer
 *           description: Number of booked slots in the department
 *           example: 85
 *         bookingRate:
 *           type: number
 *           format: float
 *           description: Booking rate as a percentage (bookedSlots/totalSlots * 100)
 *           example: 70.83
 *
 *     StatusChangeRequest:
 *       type: object
 *       required:
 *         - status
 *       properties:
 *         status:
 *           type: string
 *           enum: [available, booked, unavailable]
 *           description: New slot status
 *           example: "available"
 */



================================================
FILE: src/modules/slot/swagger/slot.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: slots
 *   description: Slot management
 */

/**
 * @swagger
 * /api/slot/create:
 *   post:
 *     tags:
 *       - slots
 *     summary: Create a new slot (Admin, Manager only)
 *     description: Create a new time slot for staff profiles
 *     operationId: createSlot
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateSlotDto'
 *     responses:
 *       201:
 *         description: Slot created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       409:
 *         description: Slot overlaps with an existing slot
 */

/**
 * @swagger
 * /api/slot/search:
 *   get:
 *     tags:
 *       - slots
 *     summary: Search slots with filters (Admin, Manager, Laboratory Technician, Staff only)
 *     description: Search for slots with pagination and filtering by multiple criteria
 *     operationId: getSlots
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: staff_profile_ids
 *         schema:
 *           type: string
 *         description: Filter by staff profile IDs (comma-separated or single value)
 *       - in: query
 *         name: department_id
 *         schema:
 *           type: string
 *         description: Filter by department ID
 *       - in: query
 *         name: appointment_id
 *         schema:
 *           type: string
 *         description: Filter by appointment ID
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, booked, unavailable]
 *         description: Filter by slot status
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           default: start_time
 *         description: Field to sort by
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           default: asc
 *           enum: [asc, desc]
 *         description: "Sort order (asc: ascending, desc: descending)"
 *     responses:
 *       200:
 *         description: List of slots with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/slot/available:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get available slots for booking
 *     description: Retrieve available slots for booking with optional filters
 *     operationId: getAvailableSlots
 *     parameters:
 *       - in: query
 *         name: start_date
 *         schema:
 *           type: string
 *           format: date
 *         required: true
 *         description: Start date to search for available slots
 *       - in: query
 *         name: end_date
 *         schema:
 *           type: string
 *           format: date
 *         description: End date to search for available slots (defaults to 7 days from start_date if not provided)
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *         description: Filter by sample collection method
 *     responses:
 *       200:
 *         description: Available slots with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       400:
 *         description: Invalid input (e.g., missing required parameters)
 */

/**
 * @swagger
 * /api/slot/{id}:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get slot by ID (Admin, Manager, Laboratory Technician, Staff only)
 *     description: Retrieve slot details by ID
 *     operationId: getSlotById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *     responses:
 *       200:
 *         description: Slot details
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid slot ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Slot not found
 *
 *   put:
 *     tags:
 *       - slots
 *     summary: Update slot (Admin, Manager only)
 *     description: Update slot information
 *     operationId: updateSlot
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateSlotDto'
 *     responses:
 *       200:
 *         description: Slot updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Slot not found
 *       409:
 *         description: Slot overlaps with an existing slot
 */

/**
 * @swagger
 * /api/slot/{id}/status:
 *   patch:
 *     tags:
 *       - slots
 *     summary: Change slot status (Admin, Manager only)
 *     description: Change the status of a slot
 *     operationId: changeSlotStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/StatusChangeRequest'
 *     responses:
 *       200:
 *         description: Slot status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid input or cannot change status of a booked slot
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Slot not found
 */

/**
 * @swagger
 * /api/slot/staff/{id}:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get slots by user ID (Admin, Manager, Laboratory Technician, Staff only)
 *     description: Retrieve slots associated with a specific user's staff profile
 *     operationId: getSlotsByUser
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, booked, unavailable]
 *         description: Filter by slot status
 *     responses:
 *       200:
 *         description: List of slots for the user
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       400:
 *         description: Invalid user ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: User not found or staff profile not found for this user
 */

/**
 * @swagger
 * /api/slot/department/{departmentId}:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get slots by department ID (Admin, Manager only)
 *     description: Retrieve slots associated with a specific department
 *     operationId: getSlotsByDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: departmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: staff_profile_ids
 *         schema:
 *           type: string
 *         description: Filter by specific staff profile IDs within department
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, booked, unavailable]
 *         description: Filter by slot status
 *     responses:
 *       200:
 *         description: List of slots for the department
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       400:
 *         description: Invalid department ID
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/department/{departmentId}/statistics:
 *   get:
 *     tags:
 *       - slots
 *       - departments
 *     summary: Get department performance statistics (Admin, Manager only)
 *     description: Retrieve performance statistics for a specific department
 *     operationId: getDepartmentPerformance
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: departmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *     responses:
 *       200:
 *         description: Department performance statistics
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentPerformanceResponse'
 *       400:
 *         description: Invalid department ID
 *       401:
 *         description: Unauthorized
 */



================================================
FILE: src/modules/staff_profile/index.ts
================================================
import StaffProfileSchema from './staff_profile.model';
import { IStaffProfile, StaffStatus, IQualification } from './staff_profile.interface';
import { StaffStatusEnum } from './staff_profile.enum';
import { StaffStatuses } from './staff_profile.constant';
import StaffProfileController from './staff_profile.controller';
import StaffProfileService from './staff_profile.service';
import StaffProfileRoute from './staff_profile.route';

export {
    StaffProfileSchema,
    IStaffProfile,
    StaffStatus,
    IQualification,
    StaffStatusEnum,
    StaffStatuses,
    StaffProfileController,
    StaffProfileService,
    StaffProfileRoute
}; 


================================================
FILE: src/modules/staff_profile/staff_profile.constant.ts
================================================
import { StaffStatusEnum } from './staff_profile.enum';

export const StaffStatuses = [
    '',
    StaffStatusEnum.ACTIVE,
    StaffStatusEnum.ON_LEAVE,
    StaffStatusEnum.TERMINATED
]; 


================================================
FILE: src/modules/staff_profile/staff_profile.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import StaffProfileService from './staff_profile.service';
import CreateStaffProfileDto from './dtos/createStaffProfile.dto';
import UpdateStaffProfileDto from './dtos/updateStaffProfile.dto';
import { IStaffProfile } from './staff_profile.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { HttpException } from '../../core/exceptions';


export default class StaffProfileController {
    private staffProfileService = new StaffProfileService();

    public createStaffProfile = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: CreateStaffProfileDto = req.body;
            const staffProfile = await this.staffProfileService.createStaffProfile(model);
            res.status(HttpStatus.Created).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

    public getStaffProfiles = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const queryParams = req.query;
            const staffProfiles = await this.staffProfileService.getStaffProfiles(queryParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IStaffProfile>>(staffProfiles));
        } catch (error) {
            next(error);
        }
    }

    public getStaffProfilesByDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const queryParams = req.query;
            const staffProfiles = await this.staffProfileService.getStaffProfilesByDepartment(id, queryParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IStaffProfile>>(staffProfiles));
        } catch (error) {
            next(error);
        }
    }

    public getStaffProfileById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const staffProfile = await this.staffProfileService.getStaffProfileById(id);
            res.status(HttpStatus.Success).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

    public updateStaffProfile = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const model: UpdateStaffProfileDto = req.body;
            const staffProfile = await this.staffProfileService.updateStaffProfile(id, model);
            res.status(HttpStatus.Success).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

    public changeStaffStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const { status } = req.body;
            const staffProfile = await this.staffProfileService.changeStaffStatus(id, status);
            res.status(HttpStatus.Success).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

}




================================================
FILE: src/modules/staff_profile/staff_profile.enum.ts
================================================
export enum StaffStatusEnum {
    ACTIVE = 'active',
    ON_LEAVE = 'on_leave',
    TERMINATED = 'terminated'
} 


================================================
FILE: src/modules/staff_profile/staff_profile.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { StaffStatusEnum } from './staff_profile.enum';

export type StaffStatus =
    StaffStatusEnum.ACTIVE |
    StaffStatusEnum.ON_LEAVE |
    StaffStatusEnum.TERMINATED;

export interface IQualification {
    name: string;
    institution: string;
    issue_date: Date;
    expiry_date?: Date;
    description?: string;
}

export interface IStaffProfile extends Document {
    _id: string;
    user_id: string | undefined;
    department_id: string | undefined;
    job_title: string;
    hire_date: Date;
    employee_id: string; //unique
    salary: number;
    status: StaffStatus;
    qualifications: IQualification[];
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/staff_profile/staff_profile.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { StaffStatuses } from './staff_profile.constant';
import { IStaffProfile } from './staff_profile.interface';
import { StaffStatusEnum } from './staff_profile.enum';
const QualificationSchema = new Schema({
    name: { type: String, required: true },
    institution: { type: String, required: true },
    issue_date: { type: Date, required: true },
    expiry_date: { type: Date },
    description: { type: String }
});

const StaffProfileSchemaEntity: Schema<IStaffProfile> = new Schema({
    user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true, unique: true },
    department_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.DEPARTMENT, required: true },
    job_title: { type: String, required: true },
    hire_date: { type: Date, required: true },
    employee_id: { type: String, required: true, unique: true },
    salary: { type: Number, required: true, default: 0 },
    status: {
        type: String,
        enum: StaffStatuses,
        required: true,
        default: StaffStatusEnum.ACTIVE
    },
    qualifications: [QualificationSchema],
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const StaffProfileSchema = mongoose.model<IStaffProfile & mongoose.Document>(
    COLLECTION_NAME.STAFF_PROFILE,
    StaffProfileSchemaEntity
);

export default StaffProfileSchema; 


================================================
FILE: src/modules/staff_profile/staff_profile.repository.ts
================================================
import StaffProfileSchema from './staff_profile.model';
import { IStaffProfile } from './staff_profile.interface';

export default class StaffProfileRepository {
    public async createStaffProfile(data: Partial<IStaffProfile>): Promise<IStaffProfile> {
        return StaffProfileSchema.create(data);
    }

    public async findOne(query: any): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findOne(query);
    }

    public async findById(id: string): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IStaffProfile>, options: any = {}): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return StaffProfileSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IStaffProfile[]> {
        return StaffProfileSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IStaffProfile[]> {
        return StaffProfileSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IStaffProfile[]> {
        return StaffProfileSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email')
            .populate('department_id', 'name');
    }

    public async findByIdWithPopulate(id: string): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findById(id)
            .populate('user_id', 'first_name last_name email')
            .populate('department_id', 'name');
    }
}



================================================
FILE: src/modules/staff_profile/staff_profile.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import StaffProfileController from './staff_profile.controller';
import CreateStaffProfileDto from './dtos/createStaffProfile.dto';
import UpdateStaffProfileDto from './dtos/updateStaffProfile.dto';
import { UserRoleEnum } from '../user/user.enum';


export default class StaffProfileRoute implements IRoute {
    public path = API_PATH.STAFF_PROFILE;
    public router = Router();
    private staffProfileController = new StaffProfileController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain: /api/staff-profile/create -> Create staff profile
        this.router.post(
            `${this.path}/create`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(CreateStaffProfileDto),
            this.staffProfileController.createStaffProfile
        );

        // GET: domain: /api/staff-profile/search -> Get all staff profiles
        this.router.get(
            `${this.path}/search`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.getStaffProfiles
        );

        // GET: domain: /api/staff-profile/department/:id -> Get staff profiles by department id
        this.router.get(
            `${this.path}/department/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.getStaffProfilesByDepartment
        );

        // GET: domain: /api/staff-profile/:id -> Get staff profile by id
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.getStaffProfileById
        );

        // PUT: domain: /api/staff-profile/:id -> Update staff profile
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateStaffProfileDto),
            this.staffProfileController.updateStaffProfile
        );

        // PUT: domain: /api/staff-profile/:id/status -> Change staff status
        this.router.put(
            `${this.path}/:id/status`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.changeStaffStatus
        );

    }
}








================================================
FILE: src/modules/staff_profile/staff_profile.service.ts
================================================
import mongoose, { Schema } from "mongoose";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { IStaffProfile, StaffStatus } from "./staff_profile.interface";
import { StaffStatusEnum } from "./staff_profile.enum";
import { SlotStatusEnum } from "../slot/slot.enum";
import SlotSchema from "../slot/slot.model";
import DepartmentSchema from "../department/department.model";
import UserSchema from "../user/user.model";
import CreateStaffProfileDto from "./dtos/createStaffProfile.dto";
import UpdateStaffProfileDto from "./dtos/updateStaffProfile.dto";
import { isEmptyObject } from "../../core/utils";
import { UserRoleEnum } from "../user/user.enum";
import StaffProfileRepository from './staff_profile.repository';

export default class StaffProfileService {
    private staffProfileRepository = new StaffProfileRepository();
    private departmentSchema = DepartmentSchema;
    private userSchema = UserSchema;
    private slotSchema = SlotSchema;

    /**
     * Tạo hồ sơ nhân viên mới
     */
    public async createStaffProfile(model: CreateStaffProfileDto): Promise<IStaffProfile> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Data is required');
        }

        // Kiểm tra user_id có tồn tại và có role STAFF hoặc LABORATORY TECHNICIAN  
        const user = await this.userSchema.findById(model.user_id);
        if (!user || user.role !== UserRoleEnum.STAFF && user.role !== UserRoleEnum.LABORATORY_TECHNICIAN) {
            throw new HttpException(HttpStatus.BadRequest, 'User does not exist or does not have Staff or Laboratory Technician role');
        }

        // Kiểm tra user đã có hồ sơ nhân viên chưa
        const existingProfile = await this.staffProfileRepository.findOne({ user_id: model.user_id });
        if (existingProfile) {
            throw new HttpException(HttpStatus.Conflict, 'User already has a staff profile');
        }

        // Kiểm tra department_id có tồn tại
        const department = await this.departmentSchema.findById(model.department_id);
        if (!department || department.is_deleted) {
            throw new HttpException(HttpStatus.BadRequest, 'Department does not exist');
        }

        // Tạo employee_id duy nhất
        const employeeId = await this.generateEmployeeId();

        // Tạo hồ sơ nhân viên mới với các giá trị mặc định
        const newProfile = await this.staffProfileRepository.createStaffProfile({
            ...model,
            user_id: model.user_id,
            department_id: model.department_id,
            employee_id: employeeId,
            status: StaffStatusEnum.ACTIVE,
            salary: model.salary || 0,
            qualifications: model.qualifications || [],
            created_at: new Date(),
            updated_at: new Date()
        });

        return newProfile;
    }

    /**
     * Tạo employee_id duy nhất 
     */
    private async generateEmployeeId(): Promise<string> {
        const prefix = 'EMP';
        const currentYear = new Date().getFullYear().toString().substr(-2);

        // Đếm số nhân viên đã tạo trong năm hiện tại
        const count = await this.staffProfileRepository.countDocuments({
            employee_id: { $regex: `^${prefix}${currentYear}` }
        });

        // Format: EMP23001, EMP23002, ...
        let sequenceNumber = (count + 1).toString().padStart(3, '0');
        let employeeId = `${prefix}${currentYear}${sequenceNumber}`;

        // Kiểm tra xem ID đã tồn tại chưa để đảm bảo tính duy nhất
        let existingProfile = await this.staffProfileRepository.findOne({ employee_id: employeeId });
        while (existingProfile) {
            // Nếu ID đã tồn tại, tăng số thứ tự và thử lại
            sequenceNumber = (parseInt(sequenceNumber) + 1).toString().padStart(3, '0');
            employeeId = `${prefix}${currentYear}${sequenceNumber}`;
            existingProfile = await this.staffProfileRepository.findOne({ employee_id: employeeId });
        }

        return employeeId;
    }

    /**
     * Tìm kiếm hồ sơ nhân viên với bộ lọc
     */
    public async getStaffProfiles(queryParams: any = {}): Promise<SearchPaginationResponseModel<IStaffProfile>> {
        try {
            // Xử lý tham số truy vấn
            const {
                pageNum,
                pageSize,
                sort_by,
                sort_order,
                department_id,
                status,
                keyword,
                hire_date_from,
                hire_date_to
            } = this.processQueryParams(queryParams);

            const skip = (pageNum - 1) * pageSize;

            // Xây dựng truy vấn
            const query: any = {};

            // Lọc theo phòng ban
            if (department_id) {
                query.department_id = department_id;
            }

            // Lọc theo trạng thái
            if (status) {
                query.status = status;
            }

            // Lọc theo ngày tuyển dụng
            if (hire_date_from || hire_date_to) { // Nếu có ngày tuyển dụng từ hoặc đến
                query.hire_date = {}; // Khởi tạo đối tượng ngày tuyển dụng
                if (hire_date_from) {
                    query.hire_date.$gte = new Date(hire_date_from); // hire_date >= hire_date_from
                }
                if (hire_date_to) {
                    const endDate = new Date(hire_date_to);
                    endDate.setHours(23, 59, 59, 999); // Đặt giờ, phút, giây, mili giây là 23:59:59.999
                    query.hire_date.$lte = endDate; // hire_date <= hire_date_to
                }
            }

            // Tìm kiếm theo từ khóa
            if (keyword) {
                query.$or = [
                    { employee_id: { $regex: keyword, $options: 'i' } },
                    { job_title: { $regex: keyword, $options: 'i' } },
                ];
            }

            // Đếm tổng số nhân viên
            const totalItems = await this.staffProfileRepository.countDocuments(query);

            // Xử lý sắp xếp
            const sortOptions: any = {};
            sortOptions[sort_by] = sort_order === 'asc' ? 1 : -1;

            // Lấy dữ liệu với phân trang và populate
            const staffProfiles = await this.staffProfileRepository.findWithPopulate(query, sortOptions, skip, pageSize);

            const totalPages = Math.ceil(totalItems / pageSize);

            return {
                pageData: staffProfiles,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum,
                    pageSize
                }
            };
        } catch (error) {
            console.error('Error in getStaffProfiles:', error);
            throw error;
        }
    }

    /**
     * Lấy nhân viên theo phòng ban
     */
    public async getStaffProfilesByDepartment(departmentId: string, queryParams: any = {}): Promise<SearchPaginationResponseModel<IStaffProfile>> {
        // Kiểm tra department_id hợp lệ
        if (!mongoose.Types.ObjectId.isValid(departmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid department ID');
        }

        const department = await this.departmentSchema.findById(departmentId);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'Department does not exist');
        }

        // Thêm department_id vào query params và gọi lại hàm getStaffProfiles
        const newQueryParams = { ...queryParams, department_id: departmentId };
        return this.getStaffProfiles(newQueryParams);
    }

    /**
     * Lấy nhân viên theo id
     */
    public async getStaffProfileById(id: string): Promise<IStaffProfile> {
        const staffProfile = await this.staffProfileRepository.findByIdWithPopulate(id);
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }
        return staffProfile;
    }

    /**
     * Cập nhật hồ sơ nhân viên
     */
    public async updateStaffProfile(id: string, model: UpdateStaffProfileDto): Promise<IStaffProfile> {
        // Kiểm tra hồ sơ tồn tại
        const staffProfile = await this.staffProfileRepository.findById(id);
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        // kiểm tra department_id có tồn tại, nếu không thay đổi thì lấy department_id cũ
        if (model.department_id) {
            const department = await this.departmentSchema.findById(model.department_id);
            if (!department) {
                throw new HttpException(HttpStatus.NotFound, 'Department does not exist');
            }
        }

        // Cập nhật thông tin hồ sơ
        const updatedProfile = await this.staffProfileRepository.findByIdAndUpdate(
            id,
            {
                ...model,
                // user_id: model.user_id,
                department_id: model.department_id,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        return updatedProfile;
    }

    /**
     * Thay đổi trạng thái nhân viên
     */
    public async changeStaffStatus(id: string, status: StaffStatus): Promise<IStaffProfile> {
        // Kiểm tra hồ sơ tồn tại
        const staffProfile = await this.staffProfileRepository.findById(id);
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        // Kiểm tra trạng thái có hợp lệ không
        if (!Object.values(StaffStatusEnum).includes(status)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid status');
        }

        // Nếu chuyển sang TERMINATED, hủy tất cả slot trong tương lai
        if (status === StaffStatusEnum.TERMINATED) {
            const currentDate = new Date();
            await this.slotSchema.updateMany(
                {
                    staff_profile_id: id,
                    start_time: { $gt: currentDate }, // start_time > currentDate
                    status: SlotStatusEnum.AVAILABLE // status = AVAILABLE
                },
                { status: SlotStatusEnum.UNAVAILABLE } // status = UNAVAILABLE
            );
        }

        // Cập nhật trạng thái
        const updatedProfile = await this.staffProfileRepository.findByIdAndUpdate(
            id,
            { status, updated_at: new Date() },
            { new: true }
        );

        if (!updatedProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        return updatedProfile;
    }

    /**
     * Xử lý tham số truy vấn
     */
    private processQueryParams(params: any): {
        pageNum: number;
        pageSize: number;
        sort_by: string;
        sort_order: string;
        department_id?: string;
        status?: string;
        keyword?: string;
        hire_date_from?: string;
        hire_date_to?: string;
    } {
        return {
            pageNum: params.pageNum || 1,
            pageSize: params.pageSize || 10,
            sort_by: params.sort_by || 'created_at',
            sort_order: params.sort_order || 'desc',
            department_id: params.department_id,
            status: params.status,
            keyword: params.keyword,
            hire_date_from: params.hire_date_from,
            hire_date_to: params.hire_date_to
        };
    }

}


================================================
FILE: src/modules/staff_profile/dtos/createStaffProfile.dto.ts
================================================
import { IsArray, IsDate, IsNotEmpty, IsNumber, IsOptional, IsString } from "class-validator";
import { IQualification } from "../staff_profile.interface";
import { Type } from "class-transformer";

export default class CreateStaffProfileDto {
    constructor(
        user_id: string,
        department_id: string,
        job_title: string,
        hire_date: Date,
        salary: number,
        qualifications: IQualification[] = []
    ) {
        this.user_id = user_id;
        this.department_id = department_id;
        this.job_title = job_title;
        this.hire_date = hire_date;
        this.salary = salary;
        this.qualifications = qualifications;
    }

    @IsNotEmpty()
    @IsString()
    public user_id: string;

    @IsNotEmpty()
    @IsString()
    public department_id: string;

    @IsNotEmpty()
    @IsString()
    public job_title: string;

    @IsNotEmpty()
    @IsDate()
    @Type(() => Date)
    public hire_date: Date;

    @IsNotEmpty()
    @IsNumber()
    public salary: number;

    @IsOptional()
    @IsArray()
    public qualifications: IQualification[] = [];

    // Các trường sau sẽ được tạo tự động trong service
    // employee_id: string;
    // status: string;
}



================================================
FILE: src/modules/staff_profile/dtos/updateStaffProfile.dto.ts
================================================
import { IsArray, IsDate, IsNotEmpty, IsNumber, IsOptional, IsString } from "class-validator";
import { IQualification } from "../staff_profile.interface";
import { Type } from "class-transformer";

export default class UpdateStaffProfileDto {
    constructor(
        user_id: string,
        department_id: string,
        job_title: string,
        hire_date: Date,
        salary: number,
        qualifications: IQualification[]
    ) {
        this.user_id = user_id;
        this.department_id = department_id;
        this.job_title = job_title;
        this.hire_date = hire_date;
        this.salary = salary;
        this.qualifications = qualifications;
    }

    @IsOptional()
    @IsString()
    public user_id: string;

    @IsNotEmpty()
    @IsString()
    public department_id: string;

    @IsNotEmpty()
    @IsString()
    public job_title: string;

    @IsNotEmpty()
    @IsDate()
    @Type(() => Date)
    public hire_date: Date;

    @IsNotEmpty()
    @IsNumber()
    public salary: number;

    @IsNotEmpty()
    @IsArray()
    public qualifications: IQualification[];
}



================================================
FILE: src/modules/staff_profile/swagger/staff_profile.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Qualification:
 *       type: object
 *       required:
 *         - name
 *         - institution
 *         - issue_date
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the qualification or certification
 *           example: "Medical Laboratory Technician Certification"
 *         institution:
 *           type: string
 *           description: Institution that issued the qualification
 *           example: "American Medical Technologists"
 *         issue_date:
 *           type: string
 *           format: date
 *           description: Date when the qualification was issued
 *           example: "2020-01-15"
 *         expiry_date:
 *           type: string
 *           format: date
 *           description: Date when the qualification expires (if applicable)
 *           example: "2025-01-15"
 *         description:
 *           type: string
 *           description: Additional details about the qualification
 *           example: "National certification for laboratory technicians"
 *
 *     CreateStaffProfileDto:
 *       type: object
 *       required:
 *         - user_id
 *         - department_id
 *         - job_title
 *         - hire_date
 *         - salary
 *       properties:
 *         user_id:
 *           type: string
 *           description: ID of the user to associate with this staff profile
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         department_id:
 *           type: string
 *           description: ID of the department where the staff works
 *           example: "60d5ec9af682fbd12a0f4b2b"
 *         job_title:
 *           type: string
 *           description: Job title or position of the staff
 *           example: "Laboratory Technician"
 *         hire_date:
 *           type: string
 *           format: date
 *           description: Date when the staff was hired
 *           example: "2023-06-01"
 *         salary:
 *           type: number
 *           description: Monthly salary amount
 *           example: 5000
 *         qualifications:
 *           type: array
 *           description: List of qualifications and certifications
 *           items:
 *             $ref: '#/components/schemas/Qualification'
 *
 *     UpdateStaffProfileDto:
 *       type: object
 *       required:
 *         - department_id
 *         - job_title
 *         - hire_date
 *         - salary
 *         - qualifications
 *       properties:
 *         department_id:
 *           type: string
 *           description: ID of the department where the staff works
 *           example: "60d5ec9af682fbd12a0f4b2b"
 *         job_title:
 *           type: string
 *           description: Job title or position of the staff
 *           example: "Senior Laboratory Technician"
 *         hire_date:
 *           type: string
 *           format: date
 *           description: Date when the staff was hired
 *           example: "2023-06-01"
 *         salary:
 *           type: number
 *           description: Monthly salary amount
 *           example: 5500
 *         qualifications:
 *           type: array
 *           description: List of qualifications and certifications
 *           items:
 *             $ref: '#/components/schemas/Qualification'
 *
 *     StaffProfileResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Staff profile ID
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         user_id:
 *           type: object
 *           description: User information
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4a1a"
 *             first_name:
 *               type: string
 *               example: "John"
 *             last_name:
 *               type: string
 *               example: "Doe"
 *             email:
 *               type: string
 *               example: "john.doe@example.com"
 *         department_id:
 *           type: object
 *           description: Department information
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4b2b"
 *             name:
 *               type: string
 *               example: "Laboratory"
 *         job_title:
 *           type: string
 *           description: Job title or position
 *           example: "Laboratory Technician"
 *         hire_date:
 *           type: string
 *           format: date
 *           description: Date when the staff was hired
 *           example: "2023-06-01"
 *         employee_id:
 *           type: string
 *           description: Unique employee identifier
 *           example: "EMP-2023-001"
 *         salary:
 *           type: number
 *           description: Monthly salary amount
 *           example: 5000
 *         status:
 *           type: string
 *           enum: [active, on_leave, terminated]
 *           description: Current employment status
 *           example: "active"
 *         qualifications:
 *           type: array
 *           description: List of qualifications and certifications
 *           items:
 *             $ref: '#/components/schemas/Qualification'
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date and time when the record was created
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date and time when the record was last updated
 *           example: "2023-07-15T14:20:00.000Z"
 *
 *     StaffProfilePaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/StaffProfileResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of staff profiles
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     StatusChangeRequest:
 *       type: object
 *       required:
 *         - status
 *       properties:
 *         status:
 *           type: string
 *           enum: [active, on_leave, terminated]
 *           description: New staff status
 *           example: "on_leave"
 */



================================================
FILE: src/modules/staff_profile/swagger/staff_profile.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: staff_profiles
 *   description: Staff profile management
 */

/**
 * @swagger
 * /api/staff-profile/create:
 *   post:
 *     tags:
 *       - staff_profiles
 *     summary: Create a new staff profile (Admin, Manager only)
 *     description: Create a new staff profile with user and department association
 *     operationId: createStaffProfile
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateStaffProfileDto'
 *     responses:
 *       201:
 *         description: Staff profile created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       409:
 *         description: User already has a staff profile
 */

/**
 * @swagger
 * /api/staff-profile/search:
 *   get:
 *     tags:
 *       - staff_profiles
 *     summary: Search staff profiles (Admin, Manager only)
 *     description: Search for staff profiles with pagination and filtering
 *     operationId: getStaffProfiles
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: department_id
 *         schema:
 *           type: string
 *         description: Filter by department ID
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [active, on_leave, terminated]
 *         description: Filter by staff status
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by employee ID or job title
 *       - in: query
 *         name: hire_date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by hire date (start)
 *       - in: query
 *         name: hire_date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by hire date (end)
 *     responses:
 *       200:
 *         description: List of staff profiles with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfilePaginationResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/staff-profile/department/{id}:
 *   get:
 *     tags:
 *       - staff_profiles
 *     summary: Get staff profiles by department ID (Admin, Manager only)
 *     description: Retrieve staff profiles associated with a specific department
 *     operationId: getStaffProfilesByDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *     responses:
 *       200:
 *         description: List of staff profiles in the department
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfilePaginationResponse'
 *       400:
 *         description: Invalid department ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Department not found
 */

/**
 * @swagger
 * /api/staff-profile/{id}:
 *   get:
 *     tags:
 *       - staff_profiles
 *     summary: Get staff profile by ID (Admin, Manager only)
 *     description: Retrieve staff profile details by ID
 *     operationId: getStaffProfileById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Staff profile ID
 *     responses:
 *       200:
 *         description: Staff profile details
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid staff profile ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Staff profile not found
 *   
 *   put:
 *     tags:
 *       - staff_profiles
 *     summary: Update staff profile (Admin, Manager only)
 *     description: Update staff profile information
 *     operationId: updateStaffProfile
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Staff profile ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateStaffProfileDto'
 *     responses:
 *       200:
 *         description: Staff profile updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Staff profile not found
 */

/**
 * @swagger
 * /api/staff-profile/{id}/status:
 *   put:
 *     tags:
 *       - staff_profiles
 *     summary: Change staff status (Admin, Manager only)
 *     description: Change the status of a staff profile
 *     operationId: changeStaffStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Staff profile ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/StatusChangeRequest'
 *     responses:
 *       200:
 *         description: Staff status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Staff profile not found
 */



================================================
FILE: src/modules/transaction/index.ts
================================================
import TransactionSchema from './transaction.model';
import { ITransaction } from './transaction.interface';

export {
    TransactionSchema,
    ITransaction
}; 


================================================
FILE: src/modules/transaction/transaction.constant.ts
================================================
import { TransactionStatusEnum } from './transaction.enum';

export const TransactionStatuses = [
    '',
    TransactionStatusEnum.PENDING,
    TransactionStatusEnum.SUCCESS,
    TransactionStatusEnum.FAILED,
    TransactionStatusEnum.CANCELLED
];



================================================
FILE: src/modules/transaction/transaction.enum.ts
================================================
export enum TransactionStatusEnum {
    PENDING = 'pending',
    SUCCESS = 'success',
    FAILED = 'failed',
    CANCELLED = 'cancelled',
    REFUNDED = 'refunded'
}




================================================
FILE: src/modules/transaction/transaction.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { TransactionStatusEnum } from './transaction.enum';
export interface ITransaction extends Document {
    _id: string;
    payment_id: string | undefined;
    staff_id: string | undefined;
    customer_id: string | undefined;
    sample_id: string | undefined;
    receipt_number: string;
    payos_transaction_id?: string;
    payos_payment_status?: TransactionStatusEnum;
    payos_webhook_received_at?: Date;
    payos_payment_status_message?: string;
    payos_payment_status_code?: string;
    payos_payment_status_detail?: string;
    payos_payment_status_time?: Date;
    transaction_date: Date;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/transaction/transaction.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { ITransaction } from './transaction.interface';
import { TransactionStatusEnum } from './transaction.enum';

const TransactionSchemaEntity: Schema<ITransaction> = new Schema({
    payment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.PAYMENT, required: true },
    staff_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    sample_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SAMPLE },
    receipt_number: { type: String, required: true },
    payos_transaction_id: { type: String },
    payos_payment_status: {
        type: String,
        enum: Object.values(TransactionStatusEnum),
        default: TransactionStatusEnum.PENDING
    },
    payos_webhook_received_at: { type: Date },
    payos_payment_status_message: { type: String },
    payos_payment_status_code: { type: String },
    payos_payment_status_detail: { type: String },
    payos_payment_status_time: { type: Date },
    transaction_date: { type: Date, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const TransactionSchema = mongoose.model<ITransaction & mongoose.Document>(
    COLLECTION_NAME.TRANSACTION,
    TransactionSchemaEntity
);

export default TransactionSchema; 


================================================
FILE: src/modules/transaction/swagger/transaction.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Transaction:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a1"
 *         payment_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a2"
 *         staff_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a3"
 *         customer_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a4"
 *         sample_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a5"
 *         receipt_number:
 *           type: string
 *           example: "PAY-12345-123456-abc123"
 *         payos_transaction_id:
 *           type: string
 *           example: "payos_12345"
 *         payos_payment_status:
 *           type: string
 *           enum: [pending, success, failed, cancelled, refunded]
 *           example: "success"
 *         payos_webhook_received_at:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         payos_payment_status_message:
 *           type: string
 *           example: "Payment successful"
 *         payos_payment_status_code:
 *           type: string
 *           example: "00"
 *         payos_payment_status_detail:
 *           type: string
 *           example: "Transaction completed successfully"
 *         payos_payment_status_time:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         transaction_date:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 */ 


================================================
FILE: src/modules/transaction/swagger/transaction.tag.js
================================================
/**
 * @swagger
 * tags:
 *   - name: transaction
 *     description: Transaction management
 */ 


================================================
FILE: src/modules/user/index.ts
================================================
import { UserRoleEnum } from "./user.enum";
import { IUser, UserRole } from "./user.interface";
import UserSchema from "./user.model";
import UserRoute from "./user.route";

export { IUser, UserRole, UserRoleEnum, UserRoute, UserSchema };



================================================
FILE: src/modules/user/user.constant.ts
================================================
import { UserRoleEnum, UserGenderEnum } from './user.enum';

export const UserRoles = ['', UserRoleEnum.ALL, UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN];
export const UserGenders = ['', UserGenderEnum.MALE, UserGenderEnum.FEMALE, UserGenderEnum.OTHER];


================================================
FILE: src/modules/user/user.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { API_PATH } from '../../core/constants';
import { HttpStatus } from '../../core/enums';
import { SearchPaginationResponseModel } from '../../core/models';
import { formatResponse } from '../../core/utils';
import ChangePasswordDto from './dtos/changePassword.dto';
import ChangeRoleDto from './dtos/changeRole.dto';
import ChangeStatusDto from './dtos/changeStatus.dto';
import RegisterDto from './dtos/register.dto';
import SearchPaginationUserDto from './dtos/searchPaginationUser.dto';
import UpdateUserDto from './dtos/updateUser.dto';
import { UserRoleEnum } from './user.enum';
import { IUser } from './user.interface';
import UserService from './user.service';
import ReviewProfileDto from './dtos/reviewProfileDto';
import { HttpException } from '../../core/exceptions';

export default class UserController {
    private userService = new UserService();

    public generateUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model = new RegisterDto(
                '',
                'Tôi là',
                'Admin',
                'admin@gmail.com',
                '123456',
                UserRoleEnum.ADMIN,
                true,
                '0869872830',
                'https://yt3.googleusercontent.com/zlWYSmjS34cnOH94qZYmWEeCkU_DnrFl5G-dCd66i3jqTElMvdwBtsOyMJPpoNXfdpHKPjYrmA=s900-c-k-c0x00ffffff-no-rj',
                new Date(),
                '',
                '',
                true,
                '',
                new Date(),
                0,
                new Date(),
                new Date(),
                false
            );
            const user: IUser = await this.userService.createUser(model, false, false);
            res.status(HttpStatus.Created).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public register = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: RegisterDto = req.body;
            const file = req.file; // Get the uploaded file from multer
            const routerPath = req.route.path;
            const isGoogle = routerPath === API_PATH.USERS_GOOGLE;
            const isRegister = !(routerPath === API_PATH.CREATE_USERS);

            const user: IUser = await this.userService.createUser(model, isGoogle, isRegister, file);
            res.status(HttpStatus.Created).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public getUsers = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: SearchPaginationUserDto = req.body;
            const result: SearchPaginationResponseModel<IUser> = await this.userService.getUsers(model);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IUser>>(result));
        } catch (error) {
            next(error);
        }
    };

    public getUserById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const user: IUser = await this.userService.getUserById(req.params.id, true, req.user);
            res.status(HttpStatus.Success).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public changePassword = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ChangePasswordDto = req.body;
            await this.userService.changePassword(model);
            res.status(HttpStatus.Success).json(formatResponse<string>('Change password successfully'));
        } catch (error) {
            next(error);
        }
    };

    public changeStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ChangeStatusDto = req.body;
            await this.userService.changeStatus(model);
            res.status(HttpStatus.Success).json(formatResponse<string>('Change status successfully'));
        } catch (error) {
            next(error);
        }
    };

    public changeRole = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ChangeRoleDto = req.body;
            await this.userService.changeRole(model);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public reviewProfileAccount = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ReviewProfileDto = req.body;
            await this.userService.reviewProfileAccount(model);
            res.status(HttpStatus.Success).json(formatResponse<string>('Review profile account successfully'));
        } catch (error) {
            next(error);
        }
    };

    public updateUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: UpdateUserDto = req.body;
            const file = req.file; // Get the uploaded file from multer
            const user: IUser = await this.userService.updateUser(req.params.id, model, file);
            res.status(HttpStatus.Success).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public deleteUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.userService.deleteUser(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<string>('Delete user successfully'));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get staff and laboratory technician users
     */
    public getStaffAndLabTechUsers = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;
            if (userRole !== UserRoleEnum.MANAGER && userRole !== UserRoleEnum.ADMIN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only Admin and Managers can view staff and laboratory technician users');
            }

            const users = await this.userService.getStaffAndLabTechUsers();
            res.status(HttpStatus.Success).json(formatResponse<any[]>(users));
        } catch (error) {
            next(error);
        }
    }
}



================================================
FILE: src/modules/user/user.enum.ts
================================================
export enum UserRoleEnum {
    ALL = 'all',
    CUSTOMER = 'customer',
    STAFF = 'staff',
    MANAGER = 'manager',
    LABORATORY_TECHNICIAN = 'laboratory_technician',
    ADMIN = 'admin',
}

export enum UserReviewStatusEnum {
    APPROVE = 'approve',
    REJECT = 'reject',
}

export enum UserGenderEnum {
    MALE = 'male',
    FEMALE = 'female',
    OTHER = 'other'
}




================================================
FILE: src/modules/user/user.interface.ts
================================================
import { Document } from 'mongoose';
import { UserReviewStatusEnum, UserRoleEnum, UserGenderEnum } from './user.enum';

export type UserRole = UserRoleEnum.ADMIN | UserRoleEnum.CUSTOMER | UserRoleEnum.STAFF | UserRoleEnum.MANAGER | UserRoleEnum.ALL | UserRoleEnum.LABORATORY_TECHNICIAN;
export type UserReviewStatus = UserReviewStatusEnum.APPROVE | UserReviewStatusEnum.REJECT;
export type UserGender = UserGenderEnum.MALE | UserGenderEnum.FEMALE | UserGenderEnum.OTHER;

export interface IUser extends Document {
    _id: string;
    first_name: string; // required
    last_name: string; // required
    gender: UserGender; // male, female, other
    email: string; // unique
    phone_number: string; // unique
    password?: string; // required if google_id is null or empty
    dob?: Date; // date of birth
    role: UserRole; // default is "client"
    status: boolean; // active, inactive, suspended
    is_verified?: boolean; // default false
    verification_token?: string; // default empty
    verification_token_expires?: Date; // default new Date()
    token_version: number; // default 0
    google_id?: string; // default empty
    avatar_url?: string; // url
    address?: string; // address

    // bank account info
    balance: number; // default 0
    balance_total: number; // default 0
    withdrawn_amount: number; // default 0
    bank_name: string; // default empty
    bank_account_no: string; // default empty
    bank_account_name: string; // default empty

    created_at?: Date; // default new Date()
    updated_at?: Date; // default new Date()
    is_deleted?: boolean; // flag remove logic when user is deleted, default is false


    // citizen id
    citizen_id?: string;
    citizen_id_url?: string;
    birth_certificate?: string; // giấy khai sinh
    divorce_certificate?: string; // giấy ly hôn

    full_name?: string;
    phone?: string;
    administrative_cases?: any[];
}


================================================
FILE: src/modules/user/user.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { UserRoles, UserGenders } from './user.constant';
import { UserRoleEnum, UserGenderEnum } from './user.enum';
import { IUser } from './user.interface';

const UserSchemaEntity: Schema<IUser> = new Schema({
    email: { type: String, unique: true, index: true, required: true },
    password: { type: String },
    first_name: { type: String, required: true },
    last_name: { type: String, required: true },
    gender: {
        type: String,
        enum: UserGenders,
        default: UserGenderEnum.OTHER
    },
    google_id: { type: String },
    role: {
        type: String,
        enum: UserRoles,
        default: UserRoleEnum.CUSTOMER,
        required: true,
    },
    status: { type: Boolean, default: true },
    phone_number: { type: String, unique: true },
    avatar_url: { type: String },
    dob: { type: Date },
    address: { type: String },

    is_verified: { type: Boolean, default: false },
    verification_token: { type: String },
    verification_token_expires: { type: Date },
    token_version: { type: Number, default: 0 },

    // TODO: change to table
    // transactions: [
    //     {
    //         payout_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.PAYOUT, required: true },
    //         payout_no: { type: String },
    //         payout_amount: { type: Number },
    //         created_at: { type: Date, default: Date.now },
    //     },
    // ],

    balance: { type: Number, default: 0 },
    balance_total: { type: Number, default: 0 },
    withdrawn_amount: { type: Number, default: 0 },
    bank_name: { type: String },
    bank_account_no: { type: String },
    bank_account_name: { type: String },

    // citizen id
    citizen_id: { type: String },
    citizen_id_url: { type: String },
    birth_certificate: { type: String },
    divorce_certificate: { type: String },

    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false },
    administrative_cases: [{ type: String }],
});

// Thêm virtual field vào UserSchema - virtual field là một trường ảo, không được lưu trữ trong database
UserSchemaEntity.virtual('staff_profile', {
    ref: COLLECTION_NAME.STAFF_PROFILE,
    localField: '_id',
    foreignField: 'user_id',
    justOne: true,
});

// Đảm bảo virtuals được bao gồm khi chuyển đổi sang JSON
UserSchemaEntity.set('toJSON', { virtuals: true });
UserSchemaEntity.set('toObject', { virtuals: true });

const UserSchema = mongoose.model<IUser & mongoose.Document>(COLLECTION_NAME.USER, UserSchemaEntity);
export default UserSchema;



================================================
FILE: src/modules/user/user.repository.ts
================================================
import UserSchema from './user.model';
import { IUser } from './user.interface';
// import { SearchPaginationUserDto } from './dtos/searchPaginationUser.dto';

export default class UserRepository {
    public async findUserByEmail(email: string): Promise<IUser | null> {
        return UserSchema.findOne({
            email: { $regex: new RegExp('^' + email + '$', 'i') },
            is_deleted: false,
        });
    }

    public async createUser(user: Partial<IUser>): Promise<IUser> {
        return UserSchema.create(user);
    }

    public async findUserById(userId: string): Promise<IUser | null> {
        return UserSchema.findOne({ _id: userId, is_deleted: false, is_verified: true }).lean();
    }

    public async updateUser(userId: string, updateData: Partial<IUser>): Promise<boolean> {
        const result = await UserSchema.updateOne({ _id: userId }, updateData);
        return result.acknowledged;
    }

    public async deleteUser(userId: string): Promise<boolean> {
        const result = await UserSchema.updateOne({ _id: userId }, { is_deleted: true, updated_at: new Date() });
        return result.acknowledged;
    }

    public async getUsers(query: any, pageNum: number, pageSize: number): Promise<IUser[]> {
        return UserSchema.find(query)
            .sort({ updated_at: -1 })
            .select('-password')
            .skip((pageNum - 1) * pageSize)
            .limit(pageSize)
            .exec();
    }

    public async countUsers(query: any): Promise<number> {
        return UserSchema.find(query).countDocuments().exec();
    }

    public async updatePassword(userId: string, newPassword: string): Promise<boolean> {
        const result = await UserSchema.updateOne(
            { _id: userId },
            { password: newPassword, updated_at: new Date() }
        );
        return result.acknowledged;
    }

    public async updateStatus(userId: string, status: boolean): Promise<boolean> {
        const result = await UserSchema.updateOne(
            { _id: userId },
            { status: status, updated_at: new Date() }
        );
        return result.acknowledged;
    }

    public async updateRole(userId: string, role: string): Promise<boolean> {
        const result = await UserSchema.updateOne(
            { _id: userId },
            { role, updated_at: new Date() }
        );
        return result.acknowledged;
    }

    public async findUserByIdWithStaffProfile(userId: string): Promise<IUser | null> {
        return UserSchema.findOne({ _id: userId, is_deleted: false })
            .populate({
                path: 'staff_profile',
                select: '-__v',
                populate: {
                    path: 'department_id',
                    select: 'name'
                }
            })
            .lean();
    }

    public async getUsersWithStaffProfile(query: any, pageNum: number, pageSize: number): Promise<IUser[]> {
        return UserSchema.find(query)
            .sort({ updated_at: -1 })
            .select('-password')
            .populate({
                path: 'staff_profile',
                select: '-__v',
                populate: {
                    path: 'department_id',
                    select: 'name'
                }
            })
            .skip((pageNum - 1) * pageSize)
            .limit(pageSize)
            .lean();
    }
}


================================================
FILE: src/modules/user/user.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware, uploadSingleFile } from '../../core/middleware';
import ChangePasswordDto from './dtos/changePassword.dto';
import ChangeStatusDto from './dtos/changeStatus.dto';
import RegisterDto from './dtos/register.dto';
import SearchPaginationUserDto from './dtos/searchPaginationUser.dto';
import UpdateUserDto from './dtos/updateUser.dto';
import UserController from './user.controller';
import { UserRoleEnum } from './user.enum';
import ChangeRoleDto from './dtos/changeRole.dto';
import ReviewProfileDto from './dtos/reviewProfileDto';

export default class UserRoute implements IRoute {
    public path = API_PATH.USERS;
    public router = Router();
    public userController = new UserController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST domain:/api/users/generate -> Create admin user default
        this.router.post(API_PATH.GENERATE_USERS, this.userController.generateUser);

        // POST domain:/api/users -> Register normal user
        this.router.post(
            this.path,
            uploadSingleFile('avatar_image', false),
            validationMiddleware(RegisterDto),
            this.userController.register
        );

        // POST domain:/api/users/google -> Register google user
        this.router.post(API_PATH.USERS_GOOGLE, this.userController.register);

        // POST domain:/api/users -> Create normal user
        this.router.post(
            API_PATH.CREATE_USERS,
            authMiddleWare([UserRoleEnum.ADMIN]),
            uploadSingleFile('avatar_image', false),
            validationMiddleware(RegisterDto),
            this.userController.register,
        );

        // POST domain:/api/users/search -> Get all users includes params: keyword, status, role
        this.router.post(
            API_PATH.SEARCH_USERS,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(SearchPaginationUserDto),
            this.userController.getUsers,
        );

        // PUT domain:/api/users/review-profile-account -> Review profile account
        this.router.put(
            API_PATH.REVIEW_PROFILE_ACCOUNT,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(ReviewProfileDto),
            this.userController.reviewProfileAccount,
        );

        // GET: domain:/api/users/staff-lab-tech -> Get staff and laboratory technician users
        this.router.get(
            `${this.path}/staff-lab-tech`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.userController.getStaffAndLabTechUsers
        );

        // GET domain:/api/users/:id -> Get user by id
        this.router.get(`${this.path}/:id`, authMiddleWare([], true), this.userController.getUserById);

        // PUT domain:/api/users/:id -> Update user
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare(),
            uploadSingleFile('avatar_image', false),
            validationMiddleware(UpdateUserDto),
            this.userController.updateUser,
        );

        // POST domain:/api/users/:id -> Delete user logic
        this.router.delete(`${this.path}/:id`, authMiddleWare([UserRoleEnum.ADMIN]), this.userController.deleteUser);

        // PUT domain:/api/users/change-password -> Change password
        this.router.put(
            API_PATH.CHANGE_PASSWORD_USERS,
            authMiddleWare(),
            validationMiddleware(ChangePasswordDto),
            this.userController.changePassword,
        );

        // PUT domain:/api/users/change-status -> Change user status (block/unBlock)
        this.router.put(
            API_PATH.CHANGE_STATUS_USERS,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(ChangeStatusDto),
            this.userController.changeStatus,
        );

        // PUT domain:/api/users/change-role -> Change user role
        this.router.put(
            API_PATH.CHANGE_ROLE_USER,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(ChangeRoleDto),
            this.userController.changeRole,
        );
    }
}



================================================
FILE: src/modules/user/user.service.ts
================================================
import bcryptjs from 'bcryptjs';
import { OAuth2Client } from 'google-auth-library';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IError } from '../../core/interfaces';
import { SearchPaginationResponseModel } from '../../core/models';
import {
    checkValidUrl,
    createTokenVerifiedUser,
    encodePasswordUserNormal,
    isEmptyObject,
    sendMail,
    createVerificationEmailTemplate
} from '../../core/utils';
import { uploadFileToS3, s3Folders } from '../../core/utils/s3Upload';
import ChangePasswordDto from './dtos/changePassword.dto';
import ChangeRoleDto from './dtos/changeRole.dto';
import ChangeStatusDto from './dtos/changeStatus.dto';
import RegisterDto from './dtos/register.dto';
import ReviewProfileDto from './dtos/reviewProfileDto';
import SearchPaginationUserDto from './dtos/searchPaginationUser.dto';
import SearchUserDto from './dtos/searchUser.dto';
import UpdateUserDto from './dtos/updateUser.dto';
import { UserReviewStatusEnum, UserRoleEnum } from './user.enum';
import { IUser } from './user.interface';
import UserSchema from './user.model';
import { StaffProfileSchema, StaffStatusEnum } from '../staff_profile';
// import { SubscriptionSchema } from '../subscription';
import { DataStoredInToken, UserInfoInTokenDefault } from '../auth';
import UserRepository from './user.repository';
import { AdministrativeCaseSchema } from '../administrative_cases/administrative_cases.model';

export default class UserService {
    private userRepository = new UserRepository();
    public userSchema = UserSchema;
    // public subscriptionSchema = SubscriptionSchema;

    public async createUser(
        model: RegisterDto,
        isGoogle = false,
        isRegister = true,
        avatarFile?: Express.Multer.File
    ): Promise<IUser> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        let newUser = {
            ...model,
            role: model.role || UserRoleEnum.CUSTOMER,
            google_id: model.google_id || '',
            phone_number: model.phone_number || '',
            avatar_url: model.avatar_url || '',
            token_version: 0,
        };

        // Handle avatar file upload if provided
        if (avatarFile) {
            try {
                // Upload to S3 and get the URL
                const avatarUrl = await uploadFileToS3(avatarFile, undefined, s3Folders.personImages);
                newUser.avatar_url = avatarUrl;
            } catch (error) {
                console.error('Error uploading avatar to S3:', error);
                throw new HttpException(HttpStatus.BadRequest, 'Failed to upload avatar image');
            }
        } else if (newUser.avatar_url && !checkValidUrl(model.avatar_url)) {
            throw new HttpException(HttpStatus.BadRequest, `The URL '${model.avatar_url}' is not valid`);
        }

        if (isRegister && newUser.role === UserRoleEnum.ADMIN) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `You can only register with the Customer or Staff or Manager role!`,
            );
        }

        // create a new user by google
        if (isGoogle) {
            if (model.google_id) {
                newUser = await this.formatUserByGoogle(model.google_id, newUser);
            } else {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Field google_id via IdToken is empty, please send google_id!',
                );
            }
        }

        // check email duplicates
        const existingUserByEmail = await this.userRepository.findUserByEmail(newUser.email);
        if (existingUserByEmail) {
            throw new HttpException(HttpStatus.BadRequest, `Your email: '${newUser.email}' already exists!`);
        }

        // create a new user normal
        if (!isGoogle && model.password) {
            // handle encode password
            newUser.password = await encodePasswordUserNormal(model.password);
        }

        // send mail with token
        if (!newUser.is_verified && newUser.role !== UserRoleEnum.ADMIN) {
            let subject: string = 'Verify your email address';
            let content: string = `Hello, ${newUser.first_name} ${newUser.last_name}.`;
            let htmlContent: string = '';

            // for customer, manager, staff
            if (newUser.role === UserRoleEnum.CUSTOMER || newUser.role === UserRoleEnum.MANAGER || newUser.role === UserRoleEnum.STAFF || newUser.role === UserRoleEnum.LABORATORY_TECHNICIAN) {
                // create token verification
                const tokenData = createTokenVerifiedUser();
                newUser.verification_token = tokenData.verification_token;
                newUser.verification_token_expires = tokenData.verification_token_expires;
                const domain = process.env.DOMAIN_FE;
                const verificationLink = `${domain}/verify-email/${tokenData.verification_token}`;
                content = `${content}\nPlease click the following link to verify your email address:\n${verificationLink}`;

                // Generate HTML template for email
                const userName = `${newUser.first_name} ${newUser.last_name}`;
                htmlContent = createVerificationEmailTemplate(userName, verificationLink);
            }

            const sendMailResult = await sendMail({
                toMail: newUser.email,
                subject: subject,
                content: content,
                html: htmlContent
            });

            if (!sendMailResult) {
                throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${newUser.email}`);
            }
        }

        const createdUser: IUser = await this.userRepository.createUser(newUser as IUser);
        if (!createdUser) {
            throw new HttpException(HttpStatus.Accepted, `Create item failed!`);
        }
        const resultUser: IUser = createdUser.toObject(); // convert to plain object
        delete resultUser.password;
        return resultUser;
    }

    public async getUsers(model: SearchPaginationUserDto): Promise<SearchPaginationResponseModel<IUser>> {
        const searchCondition = { ...new SearchUserDto(), ...model.searchCondition };
        const { keyword, role, is_verified, status, is_deleted } = searchCondition;
        const { pageNum, pageSize } = model.pageInfo;

        let query: any = {
            role: { $ne: UserRoleEnum.ADMIN },
            is_deleted: is_deleted
        };

        if (keyword) {
            const keywordValue = keyword.toLowerCase().trim();
            query.$or = [
                { email: { $regex: keywordValue, $options: 'i' } },
                { first_name: { $regex: keywordValue, $options: 'i' } },
                { last_name: { $regex: keywordValue, $options: 'i' } },
            ];
        }

        // Handle role filtering with array support
        if (role && Array.isArray(role) && role.length > 0) {
            // Filter out 'all' role if present
            const filteredRoles = role.filter(r => r !== UserRoleEnum.ALL);

            // Only apply role filter if there are specific roles to filter by
            if (filteredRoles.length > 0) {
                query.role = { $in: filteredRoles };
            }
        }

        if (is_verified !== '') {
            query.is_verified = is_verified;
        }

        if (status !== undefined) {
            query.status = status;
        }

        const resultQuery = await this.userRepository.getUsersWithStaffProfile(query, pageNum, pageSize);
        const rowCount = await this.userRepository.countUsers(query);

        const result = new SearchPaginationResponseModel<IUser>();
        result.pageInfo.pageNum = pageNum;
        result.pageInfo.pageSize = pageSize;
        if (rowCount > 0) {
            result.pageData = resultQuery;
            result.pageInfo.totalItems = rowCount;
            result.pageInfo.totalPages = Math.ceil(rowCount / pageSize);
        }

        return result;
    }

    public async getUserById(
        userId: string,
        is_deletedPassword = true,
        userData: DataStoredInToken = UserInfoInTokenDefault,
    ): Promise<IUser & { administrative_cases?: any[] }> {
        const user = await this.userRepository.findUserByIdWithStaffProfile(userId);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Item is not exists.`);
        }

        if (user.role === UserRoleEnum.MANAGER || user.role === UserRoleEnum.STAFF) {
            user.is_verified = true;
        }

        if (is_deletedPassword) {
            delete user.password;
        }
        // Lấy các administrative cases mà user là applicant_id
        const administrative_cases = await AdministrativeCaseSchema.find({ applicant_id: userId });
        user.administrative_cases = administrative_cases;
        return user;
    }

    public async updateUser(
        userId: string,
        model: UpdateUserDto,
        avatarFile?: Express.Multer.File
    ): Promise<IUser> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        // check user exits
        const item = await this.getUserById(userId);

        const errorResults: IError[] = [];

        if (model.dob) {
            const dobDate = new Date(model.dob);
            if (isNaN(dobDate.getTime())) {
                errorResults.push({
                    message: 'Please provide value with date type!',
                    field: 'dob',
                });
            }
        }

        // check valid
        if (errorResults.length) {
            throw new HttpException(HttpStatus.BadRequest, '', errorResults);
        }

        // Handle avatar file upload if provided
        let avatarUrl = model.avatar_url || item.avatar_url;
        if (avatarFile) {
            try {
                // Upload to S3 and get the URL
                avatarUrl = await uploadFileToS3(avatarFile, undefined, s3Folders.personImages);
            } catch (error) {
                console.error('Error uploading avatar to S3:', error);
                throw new HttpException(HttpStatus.BadRequest, 'Failed to upload avatar image');
            }
        } else if (model.avatar_url && !checkValidUrl(model.avatar_url)) {
            throw new HttpException(HttpStatus.BadRequest, `The URL '${model.avatar_url}' is not valid`);
        }

        const updateData = {
            first_name: model.first_name,
            last_name: model.last_name,
            phone_number: model.phone_number || item.phone_number,
            avatar_url: avatarUrl,
            dob: model.dob || item.dob,
            address: model.address || item.address,
            gender: model.gender || item.gender,
            updated_at: new Date(),
        };

        const updateUserId = await this.userRepository.updateUser(userId, updateData as Partial<IUser>);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Update user info failed!');
        }

        const updateUser = await this.getUserById(userId);
        return updateUser;
    }

    public async changePassword(model: ChangePasswordDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.getUserById(userId, false);

        if (!user.password) {
            throw new HttpException(HttpStatus.BadRequest, `User created by google cannot change password.`);
        }

        // check old_password
        if (model.old_password) {
            const isMatchPassword = await bcryptjs.compare(model.old_password, user.password!);
            if (!isMatchPassword) {
                throw new HttpException(HttpStatus.BadRequest, `Your old password is not valid!`);
            }
        }

        // compare new_password vs old_password
        if (model.new_password === model.old_password) {
            throw new HttpException(HttpStatus.BadRequest, `New password and old password must not be the same!`);
        }

        // handle encode password
        const newPassword = await encodePasswordUserNormal(model.new_password);
        const updatePasswordUser = await this.userRepository.updatePassword(userId, newPassword);

        if (!updatePasswordUser) throw new HttpException(HttpStatus.BadRequest, 'Change password failed!');

        return true;
    }

    public async changeStatus(model: ChangeStatusDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.getUserById(userId);

        // check change status
        if (user.status === model.status) {
            throw new HttpException(HttpStatus.BadRequest, `User status is already ${model.status}`);
        }

        const updateUserId = await this.userRepository.updateStatus(userId, model.status);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Update user status failed!');
        }

        return true;
    }

    public async changeRole(model: ChangeRoleDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.getUserById(userId);

        // check change role
        if (user.role === model.role) {
            throw new HttpException(HttpStatus.BadRequest, `User role is already ${model.role}`);
        }

        const updateUserId = await this.userRepository.updateRole(userId, model.role);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Update user status failed!');
        }

        return true;
    }

    public async reviewProfileAccount(model: ReviewProfileDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.userRepository.findUserById(userId);

        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, 'User is not manager or staff or not exist or already verified!');
        }

        if (model.status === UserReviewStatusEnum.REJECT && !model.comment) {
            throw new HttpException(HttpStatus.BadRequest, 'Please enter reason reject profile manager or staff!');
        }

        // create token verification
        const tokenData = createTokenVerifiedUser();
        const domain = process.env.DOMAIN_FE;

        let subject: string = '';
        let content: string = `Hello, ${user.first_name} ${user.last_name}.`;

        if (model.status === UserReviewStatusEnum.APPROVE) {
            user.verification_token = tokenData.verification_token;
            user.verification_token_expires = tokenData.verification_token_expires;
            user.updated_at = new Date();
            subject = 'Register manager or staff success and verify your email address';
            content = `${content}\nYour manager or staff registration profile has been approved by admin.\nPlease click the following link to verify your email address:\n${domain}/verify-email/${tokenData.verification_token}`;
        } else {
            subject = 'Register manager or staff is rejected';
            content = `${content}\nYour manager or staff registration profile has been reject by admin.\nReason: '${model.comment}'.\nIf you have any questions please send email for admin!`;
        }

        const sendMailResult = await sendMail({
            toMail: user.email,
            subject,
            content,
        });

        if (!sendMailResult) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${user.email}`);
        }

        const updateUserId = await user.save();
        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async deleteUser(userId: string): Promise<boolean> {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Item is not exists.`);
        }

        const updateUserId = await this.userRepository.deleteUser(userId);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Delete item failed!');
        }

        return true;
    }

    // get user info from google by idToken, after get user info, format user info to RegisterDto
    private async formatUserByGoogle(google_id: string, newUser: RegisterDto): Promise<RegisterDto> {
        const client = new OAuth2Client();
        // check google_id is valid
        const ticket = await client.verifyIdToken({
            idToken: google_id,
        });
        // get user info from ticket
        const payload = ticket.getPayload();
        // If payload already exists, format user info to RegisterDto
        if (payload) {
            // newUser.last_name = newUser.first_name = payload.name!;
            newUser.first_name = payload.given_name!;
            newUser.last_name = payload.family_name!;
            newUser.email = payload.email!;
            newUser.avatar_url = payload.picture!;
            newUser.google_id = payload.sub!;
        }
        return newUser;
    }

    /**
     * Get staff and laboratory technician users
     */
    public async getStaffAndLabTechUsers(): Promise<any[]> {
        try {
            // Get users with STAFF or LABORATORY_TECHNICIAN role
            const users = await UserSchema.find({
                role: { $in: [UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN] },
                is_deleted: { $ne: true } // Exclude deleted users
            }).select('_id first_name last_name email phone_number role').lean();

            if (!users || users.length === 0) {
                return [];
            }

            // Get staff profiles for these users
            const userIds = users.map(user => user._id);
            const staffProfiles = await StaffProfileSchema.find({
                user_id: { $in: userIds },
                status: StaffStatusEnum.ACTIVE
            }).lean().select('user_id status department');

            // Combine user and profile information
            const usersWithProfiles = users.map(user => {
                const profile = staffProfiles.find(p =>
                    p.user_id &&
                    user._id &&
                    p.user_id.toString() === user._id.toString()
                );

                return {
                    _id: user._id,
                    first_name: user.first_name,
                    last_name: user.last_name,
                    email: user.email,
                    phone_number: user.phone_number,
                    role: user.role,
                    staff_profile: profile ? {
                        status: profile.status,
                        department: profile.department_id
                    } : null
                };
            });

            return usersWithProfiles;
        } catch (error) {
            console.error('Error in getStaffAndLabTechUsers:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff and laboratory technician users');
        }
    }
}



================================================
FILE: src/modules/user/dtos/changePassword.dto.ts
================================================
import { IsNotEmpty, MinLength } from "class-validator";

export default class ChangePasswordDto {
    constructor(user_id: string, old_password: string, new_password: string) {
        this.user_id = user_id;
        this.old_password = old_password;
        this.new_password = new_password;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsNotEmpty()
    @MinLength(6)
    public old_password: string;

    @IsNotEmpty()
    @MinLength(6)
    public new_password: string;
}



================================================
FILE: src/modules/user/dtos/changeRole.dto.ts
================================================
import { IsIn, IsNotEmpty } from "class-validator";
import { UserRoles } from "../user.constant";
import { UserRole } from "../user.interface";

export default class ChangeRoleDto {
    constructor(user_id: string, role: UserRole) {
        this.user_id = user_id;
        this.role = role;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsIn(UserRoles)
    public role: UserRole;
}



================================================
FILE: src/modules/user/dtos/changeStatus.dto.ts
================================================
import { IsBoolean, IsNotEmpty } from 'class-validator';

export default class ChangeStatusDto {
    constructor(user_id: string, status: boolean) {
        this.user_id = user_id;
        this.status = status;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsNotEmpty()
    @IsBoolean()
    public status: boolean;
}



================================================
FILE: src/modules/user/dtos/register.dto.ts
================================================
import { IsBoolean, IsDate, IsEmail, IsIn, IsNotEmpty, IsOptional, IsString, MinLength } from 'class-validator';
import { Type } from 'class-transformer';
import { UserRoles } from '../user.constant';
import { UserRole } from '../user.interface';
import { UserRoleEnum } from './../user.enum';

export default class RegisterDto {
    constructor(
        google_id: string = '',
        first_name: string,
        last_name: string,
        email: string,
        password: string,
        role: UserRole = UserRoleEnum.CUSTOMER,
        status: boolean = true,
        phone_number: string = '',
        avatar_url: string = '',
        dob: Date = new Date(),
        address: string = '',
        gender: string = '',

        is_verified: boolean = false,
        verification_token: string = '',
        verification_token_expires: Date = new Date(),
        token_version: number = 0,

        created_at: Date = new Date(),
        updated_at: Date = new Date(),
        is_deleted: boolean = false,
    ) {
        this.google_id = google_id;
        this.first_name = first_name;
        this.last_name = last_name;
        this.email = email;
        this.password = password;
        this.role = role;
        this.status = status;
        this.phone_number = phone_number;
        this.avatar_url = avatar_url;
        this.dob = dob;
        this.address = address;
        this.gender = gender;
        this.is_verified = is_verified;
        this.verification_token = verification_token;
        this.verification_token_expires = verification_token_expires;
        this.token_version = token_version;
        this.created_at = created_at;
        this.updated_at = updated_at;
        this.is_deleted = is_deleted;
    }

    public google_id: string;

    @IsNotEmpty()
    public first_name: string;

    @IsNotEmpty()
    public last_name: string;

    @IsNotEmpty()
    @IsEmail()
    public email: string;

    @IsNotEmpty()
    @MinLength(6)
    public password: string;

    @IsIn(UserRoles)
    @IsOptional()
    public role: UserRole;

    @IsBoolean()
    public status: boolean;

    @IsNotEmpty()
    public phone_number: string;

    @IsOptional()
    public avatar_url: string;

    @IsDate()
    @Type(() => Date)
    @IsOptional()
    public dob: Date;

    @IsString()
    @IsOptional()
    public address: string;

    @IsString()
    @IsOptional()
    public gender: string

    public is_verified: boolean;
    public verification_token: string;
    public verification_token_expires: Date;
    public token_version: number;

    @IsDate()
    public created_at: Date;

    @IsDate()
    public updated_at: Date;

    @IsBoolean()
    public is_deleted: boolean;
}



================================================
FILE: src/modules/user/dtos/reviewProfileDto.ts
================================================
import { IsIn, IsNotEmpty } from 'class-validator';
import { UserReviewStatusEnum } from '../user.enum';
import { UserReviewStatus } from '../user.interface';

export default class ReviewProfileDto {
    constructor(user_id: string, status: UserReviewStatus, comment: string) {
        this.user_id = user_id;
        this.status = status;
        this.comment = comment;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsIn([UserReviewStatusEnum.APPROVE, UserReviewStatusEnum.REJECT])
    public status: UserReviewStatus;

    public comment: string;
}



================================================
FILE: src/modules/user/dtos/searchPaginationUser.dto.ts
================================================
import { Type } from 'class-transformer';
import { SearchPaginationRequestModel } from '../../../core/models';
import { PaginationRequestModel } from '../../../core/models/pagination.model';
import SearchUserDto from './searchUser.dto';

export default class SearchPaginationUserDto extends SearchPaginationRequestModel<SearchUserDto> {
    constructor(pageInfo: PaginationRequestModel, searchCondition: SearchUserDto) {
        super(pageInfo, searchCondition);
    }

    @Type(() => SearchUserDto)
    public searchCondition!: SearchUserDto;
}



================================================
FILE: src/modules/user/dtos/searchUser.dto.ts
================================================
import { IsBoolean, IsIn, IsString, IsArray } from 'class-validator';
import { UserRoles } from '../user.constant';
import { UserRole } from '../user.interface';
import { UserRoleEnum } from '../user.enum';

export default class SearchUserDto {
    constructor(
        keyword: string = '',
        role: UserRole[] | string[] = [],
        status: boolean = true,
        is_verified: boolean | string = '',
        is_deleted: boolean = false,
    ) {
        this.keyword = keyword;
        this.role = role;
        this.status = status;
        this.is_verified = is_verified;
        this.is_deleted = is_deleted;
    }

    @IsString()
    public keyword: string;

    @IsArray()
    public role: UserRole[] | string[];

    public is_verified: boolean | string;

    @IsBoolean()
    public status: boolean;

    @IsBoolean()
    public is_deleted: boolean;
}



================================================
FILE: src/modules/user/dtos/updateUser.dto.ts
================================================
import { IsDate, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { Type } from 'class-transformer';

export default class UpdateUserDto {
    constructor(
        first_name: string,
        last_name: string,
        phone_number: string,
        avatar_url: string,
        dob: Date | string,
        address: string,
        gender: string
    ) {
        this.first_name = first_name;
        this.last_name = last_name;
        this.phone_number = phone_number;
        this.avatar_url = avatar_url;
        this.dob = dob;
        this.address = address;
        this.gender = gender;
    }

    @IsNotEmpty()
    public first_name: string;

    @IsNotEmpty()
    public last_name: string;

    @IsString()
    public phone_number: string;

    @IsString()
    public avatar_url: string;

    @IsDate()
    @Type(() => Date)
    public dob: Date | string;

    @IsString()
    @IsOptional()
    public address: string;

    @IsString()
    @IsOptional()
    public gender: string;
}



================================================
FILE: src/modules/user/swagger/user.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     UserResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         first_name:
 *           type: string
 *           description: User's first name
 *           example: "John"
 *         last_name:
 *           type: string
 *           description: User's last name
 *           example: "Doe"
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *           example: "john.doe@example.com"
 *         google_id:
 *           type: string
 *           description: Google ID (if applicable)
 *           example: ""
 *         role:
 *           type: string
 *           enum: [admin, manager, staff, customer, laboratory_technician]
 *           description: User role
 *           example: "customer"
 *         status:
 *           type: boolean
 *           description: User account status (true = active, false = inactive)
 *           example: true
 *         phone_number:
 *           type: string
 *           description: User's phone number
 *           example: "+84912345678"
 *         avatar_url:
 *           type: string
 *           description: URL to user's avatar
 *           example: "https://example.com/avatars/user123.jpg"
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *           example: "1990-01-15"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: User's gender
 *           example: "male"
 *         address:
 *           type: string
 *           description: User's address
 *           example: "123 Main Street, City, Country"
 *         is_verified:
 *           type: boolean
 *           description: Email verification status
 *           example: true
 *         balance:
 *           type: number
 *           description: Current account balance
 *           example: 1000
 *         balance_total:
 *           type: number
 *           description: Total account balance
 *           example: 5000
 *         withdrawn_amount:
 *           type: number
 *           description: Total withdrawn amount
 *           example: 4000
 *         bank_name:
 *           type: string
 *           description: Bank name
 *           example: "Example Bank"
 *         bank_account_no:
 *           type: string
 *           description: Bank account number
 *           example: "1234567890"
 *         bank_account_name:
 *           type: string
 *           description: Bank account name
 *           example: "John Doe"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Account creation date
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Account last update date
 *           example: "2023-07-15T14:20:00.000Z"
 *
 *     RegisterDto:
 *       type: object
 *       required:
 *         - first_name
 *         - last_name
 *         - email
 *         - password
 *         - phone_number
 *       properties:
 *         google_id:
 *           type: string
 *           description: Google ID (optional)
 *           example: ""
 *         first_name:
 *           type: string
 *           description: User's first name
 *           example: "John"
 *         last_name:
 *           type: string
 *           description: User's last name
 *           example: "Doe"
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *           example: "john.doe@example.com"
 *         password:
 *           type: string
 *           minLength: 6
 *           description: User's password (minimum 6 characters)
 *           example: "password123"
 *         role:
 *           type: string
 *           enum: [customer, manager, staff, admin, laboratory_technician]
 *           description: User role (defaults to customer if not specified)
 *           example: "customer"
 *         phone_number:
 *           type: string
 *           description: User's phone number
 *           example: "+84912345678"
 *         avatar_url:
 *           type: string
 *           description: URL to user's avatar
 *           example: "https://example.com/avatars/user123.jpg"
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *           example: "1990-01-15"
 *         address:
 *           type: string
 *           description: User's address
 *           example: "123 Main Street, City, Country"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: User's gender
 *           example: "male"
 *
 *     UpdateUserDto:
 *       type: object
 *       required:
 *         - first_name
 *         - last_name
 *       properties:
 *         first_name:
 *           type: string
 *           description: User's first name
 *           example: "John"
 *         last_name:
 *           type: string
 *           description: User's last name
 *           example: "Doe"
 *         phone_number:
 *           type: string
 *           description: User's phone number
 *           example: "+84912345678"
 *         avatar_url:
 *           type: string
 *           description: URL to user's avatar
 *           example: "https://example.com/avatars/user123.jpg"
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *           example: "1990-01-15"
 *         address:
 *           type: string
 *           description: User's address
 *           example: "123 Main Street, City, Country"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: User's gender
 *           example: "male"
 *
 *     ChangePasswordDto:
 *       type: object
 *       required:
 *         - user_id
 *         - old_password
 *         - new_password
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         old_password:
 *           type: string
 *           description: Current password
 *           minLength: 6
 *           example: "oldPassword123"
 *         new_password:
 *           type: string
 *           description: New password
 *           minLength: 6
 *           example: "newPassword456"
 *
 *     ChangeStatusDto:
 *       type: object
 *       required:
 *         - user_id
 *         - status
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         status:
 *           type: boolean
 *           description: New status (true=active, false=inactive)
 *           example: true
 *
 *     ChangeRoleDto:
 *       type: object
 *       required:
 *         - user_id
 *         - role
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         role:
 *           type: string
 *           enum: [admin, manager, staff, customer, laboratory_technician]
 *           description: New user role
 *           example: "staff"
 *
 *     ReviewProfileDto:
 *       type: object
 *       required:
 *         - user_id
 *         - is_approved
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         is_approved:
 *           type: boolean
 *           description: Approval status
 *           example: true
 *         notes:
 *           type: string
 *           description: Review notes
 *           example: "Profile information verified and approved"
 *
 *     SearchUserDto:
 *       type: object
 *       properties:
 *         keyword:
 *           type: string
 *           description: Search keyword (email, first name, last name)
 *           example: "john"
 *         role:
 *           type: array
 *           description: Filter by multiple roles
 *           items:
 *             type: string
 *             enum: ["", all, admin, manager, staff, customer, laboratory_technician]
 *           example: ["customer", "staff"]
 *         is_verified:
 *           type: boolean
 *           description: Filter by verification status
 *           example: true
 *         status:
 *           type: boolean
 *           description: Filter by user status
 *           example: true
 *         is_deleted:
 *           type: boolean
 *           description: Include deleted users
 *           example: false
 *
 *     PaginationRequestModel:
 *       type: object
 *       properties:
 *         pageNum:
 *           type: integer
 *           minimum: 1
 *           description: Page number (starting from 1)
 *           default: 1
 *           example: 1
 *         pageSize:
 *           type: integer
 *           minimum: 1
 *           description: Number of items per page
 *           default: 10
 *           example: 10
 *
 *     SearchPaginationUserDto:
 *       type: object
 *       properties:
 *         pageInfo:
 *           $ref: '#/components/schemas/PaginationRequestModel'
 *         searchCondition:
 *           $ref: '#/components/schemas/SearchUserDto'
 *
 *     SearchPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/UserResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 */ 


================================================
FILE: src/modules/user/swagger/user.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: users
 *   description: User management APIs
 */

/**
 * @swagger
 * /api/users:
 *   post:
 *     summary: Register new user
 *     description: Register a new user account with email and password, with optional avatar upload
 *     tags: [users]
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - first_name
 *               - last_name
 *               - email
 *               - password
 *               - phone_number
 *             properties:
 *               first_name:
 *                 type: string
 *                 example: "John"
 *               last_name:
 *                 type: string
 *                 example: "Doe"
 *               email:
 *                 type: string
 *                 format: email
 *                 example: "john.doe@example.com"
 *               password:
 *                 type: string
 *                 format: password
 *                 example: "password123"
 *               role:
 *                 type: string
 *                 enum: [customer, manager, staff, laboratory_technician]
 *                 example: "customer"
 *               phone_number:
 *                 type: string
 *                 example: "+84912345678"
 *               avatar_image:
 *                 type: string
 *                 format: binary
 *                 description: User's avatar image (jpg, jpeg, png, gif) - optional
 *               avatar_url:
 *                 type: string
 *                 description: URL to avatar (can be provided directly or uploaded via avatar_image field)
 *                 example: "https://example.com/avatars/user123.jpg"
 *               dob:
 *                 type: string
 *                 format: date
 *                 example: "1990-01-15"
 *               address:
 *                 type: string
 *                 example: "123 Main Street, City, Country"
 *               gender:
 *                 type: string
 *                 enum: [male, female, other]
 *                 example: "male"
 *     responses:
 *       201:
 *         description: User registered successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input or email already in use
 *       409:
 *         description: User with this email already exists
 */

/**
 * @swagger
 * /api/users/google:
 *   post:
 *     summary: Register with Google
 *     description: Register a new user with Google account or login if account exists
 *     tags: [users]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - google_id
 *             properties:
 *               google_id:
 *                 type: string
 *                 description: Google account ID
 *     responses:
 *       201:
 *         description: User registered successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       200:
 *         description: User logged in successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input
 */

/**
 * @swagger
 * /api/users/create:
 *   post:
 *     summary: Create user (Admin only)
 *     description: Create a new user with specified role (Admin only), with optional avatar upload
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - first_name
 *               - last_name
 *               - email
 *               - password
 *               - phone_number
 *             properties:
 *               first_name:
 *                 type: string
 *                 example: "John"
 *               last_name:
 *                 type: string
 *                 example: "Doe"
 *               email:
 *                 type: string
 *                 format: email
 *                 example: "john.doe@example.com"
 *               password:
 *                 type: string
 *                 format: password
 *                 example: "password123"
 *               role:
 *                 type: string
 *                 enum: [customer, manager, staff, admin, laboratory_technician]
 *                 example: "customer"
 *               phone_number:
 *                 type: string
 *                 example: "+84912345678"
 *               avatar_image:
 *                 type: string
 *                 format: binary
 *                 description: User's avatar image (jpg, jpeg, png, gif) - optional
 *               avatar_url:
 *                 type: string
 *                 description: URL to avatar (can be provided directly or uploaded via avatar_image field)
 *                 example: "https://example.com/avatars/user123.jpg"
 *               dob:
 *                 type: string
 *                 format: date
 *                 example: "1990-01-15"
 *               address:
 *                 type: string
 *                 example: "123 Main Street, City, Country"
 *               gender:
 *                 type: string
 *                 enum: [male, female, other]
 *                 example: "male"
 *     responses:
 *       201:
 *         description: User created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input or email already in use
 *       401:
 *         description: Unauthorized - Admin access required
 *       409:
 *         description: User with this email already exists
 */

/**
 * @swagger
 * /api/users/search:
 *   post:
 *     summary: Search users (Admin only)
 *     description: Search for users with pagination and filtering options
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/SearchPaginationUserDto'
 *     responses:
 *       200:
 *         description: Search results with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SearchPaginationResponse'
 *       400:
 *         description: Invalid input parameters
 *       401:
 *         description: Unauthorized - Admin access required
 */

/**
 * @swagger
 * /api/users/{id}:
 *   get:
 *     summary: Get user by ID
 *     description: Get user information by ID (own profile or Admin access)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     responses:
 *       200:
 *         description: User information retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Cannot access other user's profile
 *       404:
 *         description: User not found
 *
 *   put:
 *     summary: Update user profile
 *     description: Update user profile information (own profile or Admin access), with optional avatar upload
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - first_name
 *               - last_name
 *             properties:
 *               first_name:
 *                 type: string
 *                 example: "John"
 *               last_name:
 *                 type: string
 *                 example: "Doe"
 *               phone_number:
 *                 type: string
 *                 example: "+84912345678"
 *               avatar_image:
 *                 type: string
 *                 format: binary
 *                 description: User's avatar image (jpg, jpeg, png, gif) - optional
 *               avatar_url:
 *                 type: string
 *                 description: URL to avatar (can be provided directly or uploaded via avatar_image field)
 *                 example: "https://example.com/avatars/user123.jpg"
 *               dob:
 *                 type: string
 *                 format: date
 *                 example: "1990-01-15"
 *               address:
 *                 type: string
 *                 example: "123 Main Street, City, Country"
 *               gender:
 *                 type: string
 *                 enum: [male, female, other]
 *                 example: "male"
 *     responses:
 *       200:
 *         description: User profile updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Cannot update other user's profile
 *       404:
 *         description: User not found
 *
 *   delete:
 *     summary: Delete user (Admin only)
 *     description: Delete user by ID (soft delete - Admin only)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     responses:
 *       200:
 *         description: User deleted successfully
 *       400:
 *         description: Invalid ID format
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/change-password:
 *   put:
 *     summary: Change password
 *     description: Change user password (requires old password verification)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangePasswordDto'
 *     responses:
 *       200:
 *         description: Password changed successfully
 *       400:
 *         description: Invalid input or incorrect old password
 *       401:
 *         description: Unauthorized - Authentication required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/change-status:
 *   put:
 *     summary: Change user status (Admin only)
 *     description: Enable or disable a user account (Admin only)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangeStatusDto'
 *     responses:
 *       200:
 *         description: User status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/change-role:
 *   put:
 *     summary: Change user role (Admin only)
 *     description: Change the role of a user account (Admin only)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangeRoleDto'
 *     responses:
 *       200:
 *         description: User role changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/staff-lab-tech:
 *   get:
 *     tags: [users]
 *     summary: Get staff and laboratory technician users (Admin and Manager only)
 *     description: Retrieve list of all staff and laboratory technician users with their profiles
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Users retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: User ID
 *                       first_name:
 *                         type: string
 *                         description: User's first name
 *                       last_name:
 *                         type: string
 *                         description: User's last name
 *                       email:
 *                         type: string
 *                         description: User's email
 *                       phone_number:
 *                         type: string
 *                         description: User's phone number
 *                       role:
 *                         type: string
 *                         enum: [STAFF, LABORATORY_TECHNICIAN]
 *                         description: User's role
 *                       staff_profile:
 *                         type: object
 *                         properties:
 *                           status:
 *                             type: string
 *                             enum: [ACTIVE, INACTIVE]
 *                             description: Staff profile status
 *                           department:
 *                             type: string
 *                             description: Department ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       500:
 *         description: Internal server error
 */


================================================
FILE: src/types/express.d.ts
================================================
import 'express';

declare global {
    namespace Express {
        namespace Multer {
            interface File {
                fieldname: string;
                originalname: string;
                encoding: string;
                mimetype: string;
                size: number;
                destination: string;
                filename: string;
                path: string;
                buffer: Buffer;
            }
        }

        interface Request {
            file?: Multer.File;
            files?: Multer.File[] | { [fieldname: string]: Multer.File[] };
        }
    }
} 


================================================
FILE: src/types/express/index.d.ts
================================================
declare namespace Express {
    interface Request {
        user: {
            id: string;
            role: UserRole;
            version: number;
        };
    }
}



================================================
FILE: .cursor/README.md
================================================
# Cursor IDE Rules for RestAPI Project

This directory contains custom rules and settings for the Cursor IDE that help enforce coding standards, best practices, and detect potential issues in the codebase.

## Rule Sets

The rules are organized into the following categories:

### 1. TypeScript ESLint Rules (`rules/eslint-typescript.json`)
- Basic TypeScript linting rules
- Type safety enforcement
- Interface naming conventions
- Function return type requirements

### 2. Module Structure Rules (`rules/module-structure.json`) 
- Enforces proper naming conventions for services, controllers, and models
- Prevents importing from internal module folders
- Prevents circular dependencies
- Enforces module export patterns

### 3. Code Style Rules (`rules/code-style.json`)
- Consistent indentation (4 spaces)
- Trailing semicolons
- No trailing whitespace
- Single quotes preference
- Import spacing and organization
- Line length limits (240 characters)

### 4. Security Rules (`rules/security.json`)
- Detects hardcoded secrets
- Identifies potential SQL injection vulnerabilities
- Flags insecure JWT implementations
- Ensures proper input validation
- Detects security issues with CORS and cookies

### 5. Performance Rules (`rules/performance.json`)
- Avoids nested promises
- Encourages use of `.lean()` for read-only Mongoose operations
- Detects unnecessary async/await usage
- Identifies inefficient database queries
- Warns about potentially large responses without pagination

## Usage

The rules are automatically loaded by Cursor IDE when opening the project. The main configuration file `.cursor/rules.json` references all the rule sets and provides global settings.

## Settings

Custom editor settings are defined in `.cursor/settings.json` which configures:

- Format on save
- Tab size (4 spaces)
- Maximum line length (240 characters)
- TypeScript preferences
- File associations

## Customization

To modify these rules:

1. Edit the specific rule file in the `.cursor/rules/` directory
2. Adjust severity levels as needed (error, warning, info)
3. Add or remove rules based on project requirements

For more information on Cursor IDE custom rules, refer to the [Cursor Documentation](mdc:https:/cursor.sh/docs). 


================================================
FILE: .cursor/rules.json
================================================
{
    "name": "RestAPI Project Rules",
    "description": "A comprehensive set of rules for the Node.js Express MongoDB TypeScript project",
    "rulesets": [
        "rules/eslint-typescript.json",
        "rules/module-structure.json",
        "rules/code-style.json",
        "rules/security.json",
        "rules/performance.json"
    ],
    "settings": {
        "enabledByDefault": true,
        "ignorePatterns": [
            "node_modules/**",
            "dist/**",
            "**/*.test.ts",
            "**/*.spec.ts"
        ]
    }
}


================================================
FILE: .cursor/settings.json
================================================
{
    "editor": {
        "formatOnSave": true,
        "tabSize": 4,
        "insertSpaces": true,
        "detectIndentation": true,
        "rulers": [
            240
        ],
        "wordWrap": "off",
        "trimTrailingWhitespace": true,
        "insertFinalNewline": true
    },
    "typescript": {
        "suggest.completeFunctionCalls": true,
        "preferences.importModuleSpecifier": "relative",
        "preferences.quoteStyle": "single",
        "updateImportsOnFileMove.enabled": "always",
        "suggest.autoImports": true
    },
    "linting": {
        "enable": true,
        "mode": "background"
    },
    "files": {
        "exclude": {
            "**/.git": true,
            "**/node_modules": true,
            "**/dist": true,
            "**/.DS_Store": true
        },
        "associations": {
            "*.route.ts": "typescript",
            "*.controller.ts": "typescript",
            "*.service.ts": "typescript",
            "*.model.ts": "typescript",
            "*.middleware.ts": "typescript",
            "*.dto.ts": "typescript"
        }
    },
    "cursor": {
        "rules": {
            "enableCustomRules": true,
            "rulesFile": ".cursor/rules.json"
        }
    }
}


================================================
FILE: .cursor/rules/code-style.json
================================================
{
    "name": "Code Style Rules",
    "description": "Code style and formatting rules for the project",
    "language": "typescript",
    "rules": [
        {
            "name": "consistent-indentation",
            "description": "Use 4 spaces for indentation",
            "severity": "warning",
            "pattern": "^(\\t+)",
            "message": "Use 4 spaces instead of tabs for indentation"
        },
        {
            "name": "trailing-semicolon",
            "description": "Always use semicolons",
            "severity": "warning",
            "pattern": "\\}\\s*$|\\w\\s*$",
            "message": "Missing semicolon at the end of statement"
        },
        {
            "name": "trailing-whitespace",
            "description": "No trailing whitespace",
            "severity": "warning",
            "pattern": "[ \\t]+$",
            "message": "Remove trailing whitespace"
        },
        {
            "name": "single-quotes",
            "description": "Use single quotes instead of double quotes",
            "severity": "warning",
            "pattern": "\"(?!\\{)(?!\\.\\*)(?!\\\\')(?!\\$\\{)(?!\\\\\")(?:\\\\[^']|[^\\\\\"])*\"",
            "message": "Use single quotes instead of double quotes"
        },
        {
            "name": "import-spacing",
            "description": "Group imports with newlines between different types",
            "severity": "warning",
            "pattern": "import.*from.*\\nimport",
            "message": "Group imports with newlines between different types"
        },
        {
            "name": "max-line-length",
            "description": "Maximum line length should be 240 characters",
            "severity": "warning",
            "pattern": "^.{241,}$",
            "message": "Line is too long (>240 characters)"
        },
        {
            "name": "no-multiple-empty-lines",
            "description": "No more than 2 consecutive empty lines",
            "severity": "warning",
            "pattern": "\\n\\s*\\n\\s*\\n\\s*\\n",
            "message": "Too many consecutive empty lines"
        }
    ]
}


================================================
FILE: .cursor/rules/dna-testing.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
# DNA Testing Service API Documentation

This project implements a RESTful API for a Bloodline DNA Testing Service using Node.js, Express, MongoDB, and TypeScript. The API provides endpoints for user authentication, test management, laboratory processing, and result reporting.

## Key Features

- **User Authentication**: Complete authentication system with email/password and Google OAuth
- **Test Ordering**: API endpoints for ordering various types of DNA tests
- **Sample Collection**: Tracking of sample collection kits and status
- **Laboratory Processing**: Backend integration with lab processes 
- **Result Reporting**: Secure delivery of test results to authorized users
- **Admin Dashboard**: Administrative interfaces for managing tests and users

## API Structure

The API follows a modular architecture with clear separation of concerns:
- **Auth Module**: User registration, login, verification
- **Tests Module**: Test ordering, status tracking
- **Samples Module**: Sample collection, tracking
- **Results Module**: Test results and reporting
- **Admin Module**: Administrative functions

## Documentation

API documentation is available through Swagger UI at the `/api-docs` endpoint.

## Security Features

- JWT authentication
- Role-based access control
- Input validation
- Data encryption
- Secure password storage





================================================
FILE: .cursor/rules/eslint-typescript.json
================================================
{
    "name": "TypeScript ESLint Rules",
    "description": "ESLint rules for TypeScript files in the project",
    "language": "typescript",
    "rules": [
        {
            "name": "no-explicit-any",
            "description": "Disallow usage of the any type",
            "severity": "error",
            "pattern": "any(?!where|thing|one|more|\\w)"
        },
        {
            "name": "no-console",
            "description": "Disallow console.log statements",
            "severity": "warning",
            "pattern": "console\\.(log|info|warn|error)\\("
        },
        {
            "name": "interface-naming",
            "description": "Interface names must start with 'I' and use PascalCase",
            "severity": "error",
            "pattern": "interface\\s+(?!I[A-Z])[A-Za-z]+"
        },
        {
            "name": "explicit-function-return-type",
            "description": "Functions should have explicit return types",
            "severity": "warning",
            "pattern": "function\\s+[a-zA-Z0-9_]+\\s*\\([^\\)]*\\)\\s*\\{"
        },
        {
            "name": "require-await",
            "description": "Async functions should use await",
            "severity": "warning",
            "pattern": "async\\s+function[^{]*\\{(?!\\s*[^}]*await)[^}]*\\}"
        },
        {
            "name": "model-naming",
            "description": "Model variables should use PascalCase",
            "severity": "warning",
            "pattern": "const\\s+([a-z][a-zA-Z0-9_]*(Model|Schema))\\s*="
        },
        {
            "name": "no-unused-imports",
            "description": "Detect unused imports",
            "severity": "warning",
            "pattern": "import\\s+\\{[^\\}]*\\}\\s+from\\s+['\"][^'\"]+['\"];"
        }
    ]
}


================================================
FILE: .cursor/rules/module-structure.json
================================================
{
    "name": "Module Structure Rules",
    "description": "Rules to enforce module structure and organization patterns",
    "language": "typescript",
    "rules": [
        {
            "name": "service-class-naming",
            "description": "Service classes should follow the [Name]Service pattern",
            "severity": "warning",
            "pattern": "class\\s+(?!.*Service)[A-Z][A-Za-z0-9_]*\\s+(?:implements|extends).*\\{",
            "filePattern": "src/modules/.*/services/.*\\.ts"
        },
        {
            "name": "controller-class-naming",
            "description": "Controller classes should follow the [Name]Controller pattern",
            "severity": "warning",
            "pattern": "class\\s+(?!.*Controller)[A-Z][A-Za-z0-9_]*\\s+(?:implements|extends).*\\{",
            "filePattern": "src/modules/.*/controllers/.*\\.ts"
        },
        {
            "name": "model-class-naming",
            "description": "Model schema should follow the [Name]Schema pattern",
            "severity": "warning",
            "pattern": "const\\s+(?!.*Schema)[a-zA-Z0-9_]*\\s*=\\s*new\\s+mongoose\\.Schema",
            "filePattern": "src/modules/.*/models/.*\\.ts"
        },
        {
            "name": "internal-module-import",
            "description": "Do not import from internal module folders",
            "severity": "error",
            "pattern": "import\\s+.*from\\s+['\"]modules/.*/internal/[^'\"]+['\"]"
        },
        {
            "name": "circular-imports-prevention",
            "description": "Prevent circular dependencies in routes",
            "severity": "error",
            "pattern": "import\\s+.*from\\s+['\"]\\.\\./(controllers|services)/[^'\"]+['\"]",
            "filePattern": "src/modules/.*/routes/.*\\.ts"
        },
        {
            "name": "module-export-pattern",
            "description": "Modules should have a proper export pattern",
            "severity": "warning",
            "pattern": "export\\s+default\\s+router",
            "filePattern": "src/modules/.*/routes/.*\\.ts"
        }
    ]
}


================================================
FILE: .cursor/rules/performance.json
================================================
{
    "name": "Performance Rules",
    "description": "Rules for identifying performance issues in the codebase",
    "language": "typescript",
    "rules": [
        {
            "name": "nested-promises",
            "description": "Avoid nesting promises, use async/await or chain them",
            "severity": "warning",
            "pattern": "\\.(then|catch)\\([^)]*\\)\\.(then|catch)"
        },
        {
            "name": "mongoose-lean",
            "description": "Use .lean() for read-only operations with Mongoose",
            "severity": "warning",
            "pattern": "\\.(find|findOne|findById)\\([^)]*\\)(?!\\.lean\\(\\))",
            "excludePattern": "\\.(populate|exec|sort|limit|skip)"
        },
        {
            "name": "unused-async-await",
            "description": "Unnecessary async/await usage",
            "severity": "warning",
            "pattern": "async\\s+[^(]*\\([^)]*\\)\\s*{[^}]*return\\s+[^;]*;[^}]*}"
        },
        {
            "name": "array-foreach",
            "description": "Consider using for...of instead of forEach for better performance",
            "severity": "info",
            "pattern": "\\.forEach\\("
        },
        {
            "name": "heavy-computation-in-loop",
            "description": "Avoid heavy computations inside loops",
            "severity": "warning",
            "pattern": "(for|while)\\s*\\([^)]*\\)\\s*\\{[^}]*\\.(map|filter|reduce|find|some|every)\\("
        },
        {
            "name": "inefficient-db-query",
            "description": "Potentially inefficient database query",
            "severity": "warning",
            "pattern": "\\.(find|findOne)\\(\\{\\s*\\$or:\\s*\\["
        },
        {
            "name": "large-response",
            "description": "Returning potentially large responses without pagination",
            "severity": "warning",
            "pattern": "res\\.(?:json|send)\\([^)]*\\.find\\([^)]*\\)(?!\\.limit)",
            "filePattern": "src/modules/.*/controllers/.*\\.ts"
        }
    ]
}


================================================
FILE: .cursor/rules/security.json
================================================
{
    "name": "Security Rules",
    "description": "Rules for identifying security issues in the codebase",
    "language": "typescript",
    "rules": [
        {
            "name": "hardcoded-secrets",
            "description": "No hardcoded secrets or credentials",
            "severity": "error",
            "pattern": "(password|secret|key|token|auth)\\s*[:=]\\s*['\"][^'\"]+['\"]",
            "excludePattern": "process\\.env\\."
        },
        {
            "name": "sql-injection",
            "description": "Potential SQL injection vulnerability",
            "severity": "error",
            "pattern": "(?:exec|execute|query|where)\\(`[^`]*\\$\\{(?!.*\\?\\s*\\[).*\\}`\\)"
        },
        {
            "name": "insecure-jwt",
            "description": "Insecure JWT implementation",
            "severity": "error",
            "pattern": "jwt\\.sign\\(.*,\\s*['\"][^'\"]+['\"]\\s*,\\s*\\{\\s*expiresIn"
        },
        {
            "name": "missing-input-validation",
            "description": "Missing input validation for user data",
            "severity": "warning",
            "pattern": "req\\.body\\.[a-zA-Z0-9_]+",
            "filePattern": "src/modules/.*/controllers/.*\\.ts",
            "excludePattern": "validate|check|sanitize|escape"
        },
        {
            "name": "cors-all-origins",
            "description": "CORS configured to allow all origins",
            "severity": "warning",
            "pattern": "cors\\(\\{\\s*origin:\\s*['\"]\\*['\"]"
        },
        {
            "name": "insecure-cookies",
            "description": "Cookies without secure or httpOnly flags",
            "severity": "warning",
            "pattern": "\\.cookie\\(['\"][^'\"]+['\"]\\s*,\\s*[^,]+\\s*,\\s*\\{(?!.*secure: true)(?!.*httpOnly: true)"
        },
        {
            "name": "eval-usage",
            "description": "Using eval which can lead to code injection",
            "severity": "error",
            "pattern": "eval\\([^)]*\\)"
        }
    ]
}


================================================
FILE: .husky/pre-commit
================================================
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged 
