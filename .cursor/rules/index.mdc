---
description: 
globs: 
alwaysApply: true
---
Repository: server-craftsman/wdp392-restapi-with-nodejs-express-mongodb
Files analyzed: 407

Estimated tokens: 393.6k

Directory structure:
â””â”€â”€ server-craftsman-wdp392-restapi-with-nodejs-express-mongodb/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ Dockerfile
    â”œâ”€â”€ fly.toml
    â”œâ”€â”€ package.json
    â”œâ”€â”€ pnpm-lock.yaml
    â”œâ”€â”€ README-VERCEL-OPTIMIZATION.md
    â”œâ”€â”€ render.yaml
    â”œâ”€â”€ swagger.yaml
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ vercel.json
    â”œâ”€â”€ web.config
    â”œâ”€â”€ webpack.config.js
    â”œâ”€â”€ .eslintrc
    â”œâ”€â”€ .lintstagedrc
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ assets/
    â”‚   â””â”€â”€ fonts/
    â”‚       â”œâ”€â”€ NotoSans-Bold.ttf
    â”‚       â”œâ”€â”€ NotoSans-BoldItalic.ttf
    â”‚       â”œâ”€â”€ NotoSans-Italic.ttf
    â”‚       â”œâ”€â”€ NotoSans-Regular.ttf
    â”‚       â””â”€â”€ Noto_Sans/
    â”‚           â”œâ”€â”€ NotoSans-Italic-VariableFont_wdth,wght.ttf
    â”‚           â”œâ”€â”€ NotoSans-VariableFont_wdth,wght.ttf
    â”‚           â”œâ”€â”€ OFL.txt
    â”‚           â”œâ”€â”€ README.txt
    â”‚           â””â”€â”€ static/
    â”‚               â”œâ”€â”€ NotoSans-Black.ttf
    â”‚               â”œâ”€â”€ NotoSans-BlackItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans-Bold.ttf
    â”‚               â”œâ”€â”€ NotoSans-BoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans-ExtraBold.ttf
    â”‚               â”œâ”€â”€ NotoSans-ExtraBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans-ExtraLight.ttf
    â”‚               â”œâ”€â”€ NotoSans-ExtraLightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans-Italic.ttf
    â”‚               â”œâ”€â”€ NotoSans-Light.ttf
    â”‚               â”œâ”€â”€ NotoSans-LightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans-Medium.ttf
    â”‚               â”œâ”€â”€ NotoSans-MediumItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans-Regular.ttf
    â”‚               â”œâ”€â”€ NotoSans-SemiBold.ttf
    â”‚               â”œâ”€â”€ NotoSans-SemiBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans-Thin.ttf
    â”‚               â”œâ”€â”€ NotoSans-ThinItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-Black.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-BlackItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-Bold.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-BoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-ExtraBold.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-ExtraBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-ExtraLight.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-ExtraLightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-Italic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-Light.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-LightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-Medium.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-MediumItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-Regular.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-SemiBold.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-SemiBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-Thin.ttf
    â”‚               â”œâ”€â”€ NotoSans_Condensed-ThinItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-Black.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-BlackItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-Bold.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-BoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-ExtraBold.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-ExtraBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-ExtraLight.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-ExtraLightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-Italic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-Light.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-LightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-Medium.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-MediumItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-Regular.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-SemiBold.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-SemiBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-Thin.ttf
    â”‚               â”œâ”€â”€ NotoSans_ExtraCondensed-ThinItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-Black.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-BlackItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-Bold.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-BoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-ExtraBold.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-ExtraBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-ExtraLight.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-ExtraLightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-Italic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-Light.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-LightItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-Medium.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-MediumItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-Regular.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-SemiBold.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-SemiBoldItalic.ttf
    â”‚               â”œâ”€â”€ NotoSans_SemiCondensed-Thin.ttf
    â”‚               â””â”€â”€ NotoSans_SemiCondensed-ThinItalic.ttf
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ app.ts
    â”‚   â”œâ”€â”€ server.ts
    â”‚   â”œâ”€â”€ swagger.ts
    â”‚   â”œâ”€â”€ .eslintrc.js
    â”‚   â”œâ”€â”€ core/
    â”‚   â”‚   â”œâ”€â”€ constants/
    â”‚   â”‚   â”‚   â”œâ”€â”€ collection.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ common.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ date.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ path.constant.ts
    â”‚   â”‚   â”‚   â””â”€â”€ prefix.constant.ts
    â”‚   â”‚   â”œâ”€â”€ enums/
    â”‚   â”‚   â”‚   â”œâ”€â”€ http.enum.ts
    â”‚   â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ exceptions/
    â”‚   â”‚   â”‚   â”œâ”€â”€ http.exception.ts
    â”‚   â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ interfaces/
    â”‚   â”‚   â”‚   â”œâ”€â”€ error.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ mail.interface.ts
    â”‚   â”‚   â”‚   â””â”€â”€ routes.interface.ts
    â”‚   â”‚   â”œâ”€â”€ middleware/
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.middleware.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ cache.middleware.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ error.middleware.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ upload.middleware.ts
    â”‚   â”‚   â”‚   â””â”€â”€ validation.middleware.ts
    â”‚   â”‚   â”œâ”€â”€ models/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ pagination.model.ts
    â”‚   â”‚   â”‚   â””â”€â”€ searchPagination.model.ts
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚       â”œâ”€â”€ aws.config.ts
    â”‚   â”‚       â”œâ”€â”€ helpers.ts
    â”‚   â”‚       â”œâ”€â”€ index.ts
    â”‚   â”‚       â”œâ”€â”€ logger.ts
    â”‚   â”‚       â”œâ”€â”€ password.ts
    â”‚   â”‚       â”œâ”€â”€ performance.ts
    â”‚   â”‚       â”œâ”€â”€ query.ts
    â”‚   â”‚       â”œâ”€â”€ s3Upload.ts
    â”‚   â”‚       â”œâ”€â”€ sendMail.ts
    â”‚   â”‚       â”œâ”€â”€ service.ts
    â”‚   â”‚       â”œâ”€â”€ token.ts
    â”‚   â”‚       â”œâ”€â”€ validateEnv.ts
    â”‚   â”‚       â””â”€â”€ validation.ts
    â”‚   â”œâ”€â”€ modules/
    â”‚   â”‚   â”œâ”€â”€ administrative_cases/
    â”‚   â”‚   â”‚   â”œâ”€â”€ administrative_cases.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ administrative_cases.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ administrative_cases.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ administrative_cases.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ administrative_cases.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ administrative_cases.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ commonAdminCases.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â””â”€â”€ swagger.js
    â”‚   â”‚   â”œâ”€â”€ appointment/
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assign-staff.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ confirm-appointment.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createAppointment.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ search-appointment.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ appointment.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ appointment.swagger.js
    â”‚   â”‚   â”œâ”€â”€ appointment_log/
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ appointment_log.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ createAppointmentLog.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ appointment_log.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ appointment_log.swagger.js
    â”‚   â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ emai.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ login.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ loginGoogle.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ verifiedToken.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ auth.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ auth.swagger.js
    â”‚   â”‚   â”œâ”€â”€ blog/
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ blog.dto.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ log/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ log.controller.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ log.interface.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ log.model.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ log.repository.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ log.route.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ log.service.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ log.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ log.swagger.js
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â””â”€â”€ blog.swagger.js
    â”‚   â”‚   â”œâ”€â”€ blog_category/
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog_category.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog_category.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog_category.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog_category.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog_category.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ blog_category.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ blog_category.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â””â”€â”€ blog_category.swagger.js
    â”‚   â”‚   â”œâ”€â”€ department/
    â”‚   â”‚   â”‚   â”œâ”€â”€ department.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ department.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ department.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ department.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ department.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ department.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createDepartment.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateDepartment.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ department.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ department.swagger.js
    â”‚   â”‚   â”œâ”€â”€ docs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ docs.route.ts
    â”‚   â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ index/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ view/
    â”‚   â”‚   â”‚       â””â”€â”€ index.ejs
    â”‚   â”‚   â”œâ”€â”€ kit/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ kit.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assignKit.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createKit.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ returnKit.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ searchKit.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateKit.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ kit.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ kit.swagger.js
    â”‚   â”‚   â”œâ”€â”€ payment/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.util.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createAppointmentPayment.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createPayosPayment.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createSamplePayment.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ createWebhook.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ payment-webhook.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ payment.schema.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ payment.swagger.js
    â”‚   â”‚   â”‚       â””â”€â”€ payment.tag.js
    â”‚   â”‚   â”œâ”€â”€ refund/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ refund.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ refund.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ refund.interface.ts
    â”‚   â”‚   â”‚   â””â”€â”€ refund.model.ts
    â”‚   â”‚   â”œâ”€â”€ registration_form/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ registration_form.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ registration_form.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ registration_form.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ registration_form.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ registration_form.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ registration_form.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createRegistrationForm.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateRegistrationForm.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ registrationForm.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ registrationForm.swagger.js
    â”‚   â”‚   â”œâ”€â”€ result/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ result.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createResult.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ startTesting.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateResult.dto.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ reportGenerator.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ swagger/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ result.schema.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ result.swagger.js
    â”‚   â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚   â”‚       â””â”€â”€ pdfGenerator.util.ts
    â”‚   â”‚   â”œâ”€â”€ review/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ review.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ review.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ review.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ review.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ review.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ review.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createReview.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateReview.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ review.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ review.swagger.js
    â”‚   â”‚   â”œâ”€â”€ sample/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ sample.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ addSample.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ addSampleForFacility.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ addSampleWithMultiplePersonInfo.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batchReceiveSamples.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batchSubmitSamples.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ collect-sample.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ receiveSample.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ searchSamples.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ submitSample.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ uploadPersonImage.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ sample.schema.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ sample.swagger.js
    â”‚   â”‚   â”‚       â””â”€â”€ sample.tag.js
    â”‚   â”‚   â”œâ”€â”€ service/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ service.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createService.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateService.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ service.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ service.swagger.js
    â”‚   â”‚   â”œâ”€â”€ slot/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ slot.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createSlot.dto.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ timeSlot.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateSlot.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ slot.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ slot.swagger.js
    â”‚   â”‚   â”œâ”€â”€ staff_profile/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.controller.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.model.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.repository.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ staff_profile.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createStaffProfile.dto.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ updateStaffProfile.dto.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ staff_profile.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ staff_profile.swagger.js
    â”‚   â”‚   â”œâ”€â”€ transaction/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ transaction.constant.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ transaction.enum.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ transaction.interface.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ transaction.model.ts
    â”‚   â”‚   â”‚   â””â”€â”€ swagger/
    â”‚   â”‚   â”‚       â”œâ”€â”€ transaction.schema.js
    â”‚   â”‚   â”‚       â””â”€â”€ transaction.tag.js
    â”‚   â”‚   â””â”€â”€ user/
    â”‚   â”‚       â”œâ”€â”€ index.ts
    â”‚   â”‚       â”œâ”€â”€ user.constant.ts
    â”‚   â”‚       â”œâ”€â”€ user.controller.ts
    â”‚   â”‚       â”œâ”€â”€ user.enum.ts
    â”‚   â”‚       â”œâ”€â”€ user.interface.ts
    â”‚   â”‚       â”œâ”€â”€ user.model.ts
    â”‚   â”‚       â”œâ”€â”€ user.repository.ts
    â”‚   â”‚       â”œâ”€â”€ user.route.ts
    â”‚   â”‚       â”œâ”€â”€ user.service.ts
    â”‚   â”‚       â”œâ”€â”€ dtos/
    â”‚   â”‚       â”‚   â”œâ”€â”€ changePassword.dto.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ changeRole.dto.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ changeStatus.dto.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ register.dto.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ reviewProfileDto.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ searchPaginationUser.dto.ts
    â”‚   â”‚       â”‚   â”œâ”€â”€ searchUser.dto.ts
    â”‚   â”‚       â”‚   â””â”€â”€ updateUser.dto.ts
    â”‚   â”‚       â””â”€â”€ swagger/
    â”‚   â”‚           â”œâ”€â”€ user.schema.js
    â”‚   â”‚           â””â”€â”€ user.swagger.js
    â”‚   â””â”€â”€ types/
    â”‚       â”œâ”€â”€ express.d.ts
    â”‚       â””â”€â”€ express/
    â”‚           â””â”€â”€ index.d.ts
    â”œâ”€â”€ .cursor/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ rules.json
    â”‚   â”œâ”€â”€ settings.json
    â”‚   â””â”€â”€ rules/
    â”‚       â”œâ”€â”€ code-style.json
    â”‚       â”œâ”€â”€ dna-testing.mdc
    â”‚       â”œâ”€â”€ eslint-typescript.json
    â”‚       â”œâ”€â”€ module-structure.json
    â”‚       â”œâ”€â”€ performance.json
    â”‚       â””â”€â”€ security.json
    â””â”€â”€ .husky/
        â””â”€â”€ pre-commit


================================================
FILE: README.md
================================================
# Node.js API Starter with TypeScript, PNPM, MongoDB

![Node.js](mdc:https:/img.shields.io/badge/Node.js-20.x-brightgreen?logo=node.js)
![PNPM](mdc:https:/img.shields.io/badge/PNPM-10.x-orange?logo=pnpm)
![TypeScript](mdc:https:/img.shields.io/badge/TypeScript-Enabled-blue?logo=typescript)
![MongoDB](mdc:https:/img.shields.io/badge/MongoDB-Connected-success?logo=mongodb)

---

## Requirements

- `node --version`: **v20.18.1**
- `npm --version`: **10.8.2**
- `pnpm --version`: **10.10.0**

---

## Installation

1. **Install Node.js, NPM and PNPM** if not already:
    ```bash
    # Node & npm
    https://nodejs.org/

    # pnpm
    npm install -g pnpm
    ```

2. **Create a `.env` file** in the project root with the following fields:

    ```env
    - NODE_ENV: development
    - JWT_TOKEN_SECRET: set the secret token as you like
    - PORT: set the port as you like (should be 8080)
    - MONGODB_URI: get the mongoDB uri of the link to your account
    - EMAIL_USER: set email for admin
    - EMAIL_PASSWORD: set email_password for admin
    - DOMAIN_FE: domain default send mail
    ```

---

## Running the Project

```bash
# Install dependencies
pnpm install

# Run development server
pnpm run dev
```

> Or if using npm:

```bash
npm install
npm run dev
```

The backend API runs on:

- `http://localhost:8080/`
- (Optional) Frontend or client: `http://localhost:3000/`

---

## ðŸ“š References

- [Morgan middleware (Logging)](mdc:https:/expressjs.com/en/resources/middleware/morgan.html)
- [TypeScript Configuration](mdc:https:/www.typescriptlang.org/tsconfig)
- [Winston Logger](mdc:https:/github.com/winstonjs/winston)

---

## Code Quality Tools

### ESLint Rules

This project uses ESLint to enforce code quality and maintain consistent coding standards. The rules are specifically configured for the `src` directory with special configurations for different module types.

To run the linter:
```bash
npm run lint        # Check for linting errors
npm run lint:fix    # Fix linting errors automatically
```

### Key Linting Rules

- **TypeScript Safety**: Strict type checking with no `any` type allowed
- **Module Structure**: Enforced import ordering and module boundaries
- **Naming Conventions**: 
  - Interfaces must start with `I` and use PascalCase
  - Models must follow PascalCase
  - Type aliases must use PascalCase
- **Code Organization**: Different rules for controllers, services, routes, and models

### Prettier

Code formatting is handled by Prettier. To format your code:
```bash
npm run format       # Format all TypeScript files
npm run format:check # Check formatting without changing files
```

### Pre-commit Hooks

This project uses Husky and lint-staged to run linters and formatters before each commit, ensuring that only quality code is committed to the repository.

### Â© 2025 Báº£n quyá»n thuá»™c vá» Nguyá»…n Äan Huy | [fb/danhuyspm](mdc:https:/facebook.com/danhuyspm)


================================================
FILE: Dockerfile
================================================
# Build stage
FROM node:20-alpine AS builder

# Install pnpm globally
RUN npm install -g pnpm@10.10.0

# Set working directory
WORKDIR /app

# Copy package.json and pnpm-lock.yaml
COPY package.json pnpm-lock.yaml ./

# Install dependencies
RUN pnpm install --frozen-lockfile

# Copy source code
COPY . .

# Build the application
RUN pnpm run build

# Production stage
FROM node:20-alpine AS production

# Install pnpm globally
RUN npm install -g pnpm@10.10.0

# Create app directory
WORKDIR /app

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Copy package.json and pnpm-lock.yaml
COPY package.json pnpm-lock.yaml ./

# Install only production dependencies
RUN pnpm install --frozen-lockfile --prod

# Copy built application from builder stage
COPY --from=builder /app/dist ./dist

# Copy necessary static files
COPY --from=builder /app/swagger.yaml ./
COPY --from=builder /app/assets ./assets
COPY --from=builder /app/src/modules/index/view ./src/modules/index/view

# Create public directory for images
RUN mkdir -p public/images

# Change ownership to nodejs user
RUN chown -R nodejs:nodejs /app
USER nodejs

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:8080/api-docs', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# Start the application
CMD ["pnpm", "start"] 


================================================
FILE: fly.toml
================================================
# fly.toml app configuration file generated for restapi-bloodline-dna on 2024-12-19T10:00:00.000Z
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.

app = 'wdp392-restapi-with-nodejs-express-mongodb'
primary_region = 'sin'  # Singapore region for better performance in Asia

[build]

[deploy]
  release_command = 'echo "Deployment starting..."'

[env]
  NODE_ENV = 'production'
  WEBSITES_PORT = '8080'

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 1
  processes = ['app']

  [[http_service.checks]]
    grace_period = '10s'
    interval = '30s'
    method = 'GET'
    timeout = '5s'
    path = '/api-docs'

[vm]
  cpu_kind = 'shared'
  cpus = 1
  memory_mb = 512

[[vm.http_service.concurrency]]
  hard_limit = 25
  soft_limit = 20
  type = 'connections'

[metrics]
  port = 9091
  path = '/metrics'

# Enable process restart on failure
[processes]
  app = 'pnpm start'

# Machine restart policy
[restart]
  policy = 'on-failure'


================================================
FILE: package.json
================================================
{
  "name": "restApi-with-nodejs-express-mongodb",
  "version": "2.0.0",
  "description": "",
  "main": "src/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "postinstall": "npm run build",
    "lint": "eslint --ext .ts src/",
    "lint:fix": "eslint --ext .ts src/ --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "lint-staged": "lint-staged"
  },
  "keywords": [],
  "author": "Nguyen Dan Huy",
  "license": "ISC",
  "packageManager": "pnpm@10.10.0",
  "dependencies": {
    "@aws-sdk/client-s3": "^3.821.0",
    "@aws-sdk/s3-request-presigner": "^3.821.0",
    "@payos/node": "^1.0.10",
    "aws-sdk": "^2.1692.0",
    "axios": "^1.9.0",
    "bcryptjs": "^3.0.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "compression": "^1.8.0",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.5.0",
    "ejs": "^3.1.10",
    "envalid": "^8.0.0",
    "express": "^5.1.0",
    "google-auth-library": "^9.15.1",
    "helmet": "^8.1.0",
    "hpp": "^0.2.3",
    "jsonwebtoken": "^9.0.2",
    "moment": "^2.30.1",
    "mongoose": "^8.14.3",
    "morgan": "^1.10.0",
    "multer": "^2.0.0",
    "nodemailer": "^7.0.3",
    "path": "^0.12.7",
    "pdfkit": "^0.14.0",
    "reflect-metadata": "^0.2.2",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-dist": "^5.21.0",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^11.1.0",
    "winston": "^3.17.0",
    "yamljs": "^0.3.0"
  },
  "devDependencies": {
    "@types/aws-sdk": "^2.7.4",
    "@types/bcryptjs": "^3.0.0",
    "@types/compression": "^1.8.0",
    "@types/cors": "^2.8.18",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/hpp": "^0.2.6",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.12",
    "@types/node": "^22.15.18",
    "@types/nodemailer": "^6.4.17",
    "@types/pdfkit": "^0.13.9",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/yamljs": "^0.2.34",
    "eslint": "^9.26.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-import": "^2.31.0",
    "husky": "^9.1.7",
    "lint-staged": "^16.0.0",
    "prettier": "^3.5.3",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3"
  }
}


================================================
FILE: pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      '@aws-sdk/client-s3':
        specifier: ^3.821.0
        version: 3.821.0
      '@aws-sdk/s3-request-presigner':
        specifier: ^3.821.0
        version: 3.821.0
      '@payos/node':
        specifier: ^1.0.10
        version: 1.0.10
      aws-sdk:
        specifier: ^2.1692.0
        version: 2.1692.0
      axios:
        specifier: ^1.9.0
        version: 1.9.0
      bcryptjs:
        specifier: ^3.0.2
        version: 3.0.2
      class-transformer:
        specifier: ^0.5.1
        version: 0.5.1
      class-validator:
        specifier: ^0.14.2
        version: 0.14.2
      compression:
        specifier: ^1.8.0
        version: 1.8.0
      cors:
        specifier: ^2.8.5
        version: 2.8.5
      date-fns:
        specifier: ^4.1.0
        version: 4.1.0
      dotenv:
        specifier: ^16.5.0
        version: 16.5.0
      ejs:
        specifier: ^3.1.10
        version: 3.1.10
      envalid:
        specifier: ^8.0.0
        version: 8.0.0
      express:
        specifier: ^5.1.0
        version: 5.1.0
      google-auth-library:
        specifier: ^9.15.1
        version: 9.15.1
      helmet:
        specifier: ^8.1.0
        version: 8.1.0
      hpp:
        specifier: ^0.2.3
        version: 0.2.3
      jsonwebtoken:
        specifier: ^9.0.2
        version: 9.0.2
      moment:
        specifier: ^2.30.1
        version: 2.30.1
      mongoose:
        specifier: ^8.14.3
        version: 8.14.3
      morgan:
        specifier: ^1.10.0
        version: 1.10.0
      multer:
        specifier: ^2.0.0
        version: 2.0.0
      nodemailer:
        specifier: ^7.0.3
        version: 7.0.3
      path:
        specifier: ^0.12.7
        version: 0.12.7
      pdfkit:
        specifier: ^0.14.0
        version: 0.14.0
      reflect-metadata:
        specifier: ^0.2.2
        version: 0.2.2
      swagger-jsdoc:
        specifier: ^6.2.8
        version: 6.2.8(openapi-types@12.1.3)
      swagger-ui-dist:
        specifier: ^5.21.0
        version: 5.21.0
      swagger-ui-express:
        specifier: ^5.0.1
        version: 5.0.1(express@5.1.0)
      uuid:
        specifier: ^11.1.0
        version: 11.1.0
      winston:
        specifier: ^3.17.0
        version: 3.17.0
      yamljs:
        specifier: ^0.3.0
        version: 0.3.0
    devDependencies:
      '@types/aws-sdk':
        specifier: ^2.7.4
        version: 2.7.4
      '@types/bcryptjs':
        specifier: ^3.0.0
        version: 3.0.0
      '@types/compression':
        specifier: ^1.8.0
        version: 1.8.0
      '@types/cors':
        specifier: ^2.8.18
        version: 2.8.18
      '@types/dotenv':
        specifier: ^8.2.3
        version: 8.2.3
      '@types/express':
        specifier: ^5.0.1
        version: 5.0.1
      '@types/hpp':
        specifier: ^0.2.6
        version: 0.2.6
      '@types/jsonwebtoken':
        specifier: ^9.0.9
        version: 9.0.9
      '@types/morgan':
        specifier: ^1.9.9
        version: 1.9.9
      '@types/multer':
        specifier: ^1.4.12
        version: 1.4.12
      '@types/node':
        specifier: ^22.15.18
        version: 22.15.18
      '@types/nodemailer':
        specifier: ^6.4.17
        version: 6.4.17
      '@types/pdfkit':
        specifier: ^0.13.9
        version: 0.13.9
      '@types/swagger-jsdoc':
        specifier: ^6.0.4
        version: 6.0.4
      '@types/swagger-ui-express':
        specifier: ^4.1.8
        version: 4.1.8
      '@types/yamljs':
        specifier: ^0.2.34
        version: 0.2.34
      eslint:
        specifier: ^9.26.0
        version: 9.26.0
      eslint-config-prettier:
        specifier: ^10.1.5
        version: 10.1.5(eslint@9.26.0)
      eslint-plugin-import:
        specifier: ^2.31.0
        version: 2.31.0(eslint@9.26.0)
      husky:
        specifier: ^9.1.7
        version: 9.1.7
      lint-staged:
        specifier: ^16.0.0
        version: 16.0.0
      prettier:
        specifier: ^3.5.3
        version: 3.5.3
      ts-node-dev:
        specifier: ^2.0.0
        version: 2.0.0(@types/node@22.15.18)(typescript@5.8.3)
      typescript:
        specifier: ^5.8.3
        version: 5.8.3

packages:

  '@apidevtools/json-schema-ref-parser@9.1.2':
    resolution: {integrity: sha512-r1w81DpR+KyRWd3f+rk6TNqMgedmAxZP5v5KWlXQWlgMUUtyEJch0DKEci1SorPMiSeM8XPl7MZ3miJ60JIpQg==}

  '@apidevtools/openapi-schemas@2.1.0':
    resolution: {integrity: sha512-Zc1AlqrJlX3SlpupFGpiLi2EbteyP7fXmUOGup6/DnkRgjP9bgMM/ag+n91rsv0U1Gpz0H3VILA/o3bW7Ua6BQ==}
    engines: {node: '>=10'}

  '@apidevtools/swagger-methods@3.0.2':
    resolution: {integrity: sha512-QAkD5kK2b1WfjDS/UQn/qQkbwF31uqRjPTrsCs5ZG9BQGAkjwvqGFjjPqAuzac/IYzpPtRzjCP1WrTuAIjMrXg==}

  '@apidevtools/swagger-parser@10.0.3':
    resolution: {integrity: sha512-sNiLY51vZOmSPFZA5TF35KZ2HbgYklQnTSDnkghamzLb3EkNtcQnrBQEj5AOCxHpTtXpqMCRM1CrmV2rG6nw4g==}
    peerDependencies:
      openapi-types: '>=7'

  '@aws-crypto/crc32@5.2.0':
    resolution: {integrity: sha512-nLbCWqQNgUiwwtFsen1AdzAtvuLRsQS8rYgMuxCrdKf9kOssamGLuPwyTY9wyYblNr9+1XM8v6zoDTPPSIeANg==}
    engines: {node: '>=16.0.0'}

  '@aws-crypto/crc32c@5.2.0':
    resolution: {integrity: sha512-+iWb8qaHLYKrNvGRbiYRHSdKRWhto5XlZUEBwDjYNf+ly5SVYG6zEoYIdxvf5R3zyeP16w4PLBn3rH1xc74Rag==}

  '@aws-crypto/sha1-browser@5.2.0':
    resolution: {integrity: sha512-OH6lveCFfcDjX4dbAvCFSYUjJZjDr/3XJ3xHtjn3Oj5b9RjojQo8npoLeA/bNwkOkrSQ0wgrHzXk4tDRxGKJeg==}

  '@aws-crypto/sha256-browser@5.2.0':
    resolution: {integrity: sha512-AXfN/lGotSQwu6HNcEsIASo7kWXZ5HYWvfOmSNKDsEqC4OashTp8alTmaz+F7TC2L083SFv5RdB+qU3Vs1kZqw==}

  '@aws-crypto/sha256-js@5.2.0':
    resolution: {integrity: sha512-FFQQyu7edu4ufvIZ+OadFpHHOt+eSTBaYaki44c+akjg7qZg9oOQeLlk77F6tSYqjDAFClrHJk9tMf0HdVyOvA==}
    engines: {node: '>=16.0.0'}

  '@aws-crypto/supports-web-crypto@5.2.0':
    resolution: {integrity: sha512-iAvUotm021kM33eCdNfwIN//F77/IADDSs58i+MDaOqFrVjZo9bAal0NK7HurRuWLLpF1iLX7gbWrjHjeo+YFg==}

  '@aws-crypto/util@5.2.0':
    resolution: {integrity: sha512-4RkU9EsI6ZpBve5fseQlGNUWKMa1RLPQ1dnjnQoe07ldfIzcsGb5hC5W0Dm7u423KWzawlrpbjXBrXCEv9zazQ==}

  '@aws-sdk/client-s3@3.821.0':
    resolution: {integrity: sha512-enlFiONQD+oCaV+C6hMsAJvyQRT3wZmCtXXq7qjxX8BiLgXsHQ9HHS+Nhoq08Ya6mtd1Y1qHOOYpnD8yyUzTMQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/client-sso@3.821.0':
    resolution: {integrity: sha512-aDEBZUKUd/+Tvudi0d9KQlqt2OW2P27LATZX0jkNC8yVk4145bAPS04EYoqdKLuyUn/U33DibEOgKUpxZB12jQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/core@3.821.0':
    resolution: {integrity: sha512-8eB3wKbmfciQFmxFq7hAjy7mXdUs7vBOR5SwT0ZtQBg0Txc18Lc9tMViqqdO6/KU7OukA6ib2IAVSjIJJEN7FQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-env@3.821.0':
    resolution: {integrity: sha512-C+s/A72pd7CXwEsJj9+Uq9T726iIfIF18hGRY8o82xcIEfOyakiPnlisku8zZOaAu+jm0CihbbYN4NyYNQ+HZQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-http@3.821.0':
    resolution: {integrity: sha512-gIRzTLnAsRfRSNarCag7G7rhcHagz4x5nNTWRihQs5cwTOghEExDy7Tj5m4TEkv3dcTAsNn+l4tnR4nZXo6R+Q==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-ini@3.821.0':
    resolution: {integrity: sha512-VRTrmsca8kBHtY1tTek1ce+XkK/H0fzodBKcilM/qXjTyumMHPAzVAxKZfSvGC+28/pXyQzhOEyxZfw7giCiWA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-node@3.821.0':
    resolution: {integrity: sha512-oBgbcgOXWMgknAfhIdTeHSSVIv+k2LXN9oTbxu1r++o4WWBWrEQ8mHU0Zo9dfr7Uaoqi3pezYZznsBkXnMLEOg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-process@3.821.0':
    resolution: {integrity: sha512-e18ucfqKB3ICNj5RP/FEdvUfhVK6E9MALOsl8pKP13mwegug46p/1BsZWACD5n+Zf9ViiiHxIO7td03zQixfwA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-sso@3.821.0':
    resolution: {integrity: sha512-Dt+pheBLom4O/egO4L75/72k9C1qtUOLl0F0h6lmqZe4Mvhz+wDtjoO/MdGC/P1q0kcIX/bBKr0NQ3cIvAH8pA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/credential-provider-web-identity@3.821.0':
    resolution: {integrity: sha512-FF5wnRJkxSQaCVVvWNv53K1MhTMgH8d+O+MHTbkv51gVIgVATrtfFQMKBLcEAxzXrgAliIO3LiNv+1TqqBZ+BA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-bucket-endpoint@3.821.0':
    resolution: {integrity: sha512-cebgeytKlWOgGczLo3BPvNY9XlzAzGZQANSysgJ2/8PSldmUpXRIF+GKPXDVhXeInWYHIfB8zZi3RqrPoXcNYQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-expect-continue@3.821.0':
    resolution: {integrity: sha512-zAOoSZKe1njOrtynvK6ZORU57YGv5I7KP4+rwOvUN3ZhJbQ7QPf8gKtFUCYAPRMegaXCKF/ADPtDZBAmM+zZ9g==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-flexible-checksums@3.821.0':
    resolution: {integrity: sha512-C56sBHXq1fEsLfIAup+w/7SKtb6d8Mb3YBec94r2ludVn1s3ypYWRovFE/6VhUzvwUbTQaxfrA2ewy5GQ1/DJQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-host-header@3.821.0':
    resolution: {integrity: sha512-xSMR+sopSeWGx5/4pAGhhfMvGBHioVBbqGvDs6pG64xfNwM5vq5s5v6D04e2i+uSTj4qGa71dLUs5I0UzAK3sw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-location-constraint@3.821.0':
    resolution: {integrity: sha512-sKrm80k0t3R0on8aA/WhWFoMaAl4yvdk+riotmMElLUpcMcRXAd1+600uFVrxJqZdbrKQ0mjX0PjT68DlkYXLg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-logger@3.821.0':
    resolution: {integrity: sha512-0cvI0ipf2tGx7fXYEEN5fBeZDz2RnHyb9xftSgUsEq7NBxjV0yTZfLJw6Za5rjE6snC80dRN8+bTNR1tuG89zA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-recursion-detection@3.821.0':
    resolution: {integrity: sha512-efmaifbhBoqKG3bAoEfDdcM8hn1psF+4qa7ykWuYmfmah59JBeqHLfz5W9m9JoTwoKPkFcVLWZxnyZzAnVBOIg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-sdk-s3@3.821.0':
    resolution: {integrity: sha512-D469De1d4NtcCTVHzUL2Q0tGvPFr7mk2j4+oCYpVyd5awSSOyl8Adkxse8qayZj9ROmuMlsoU5VhBvcc9Hoo2w==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-ssec@3.821.0':
    resolution: {integrity: sha512-YYi1Hhr2AYiU/24cQc8HIB+SWbQo6FBkMYojVuz/zgrtkFmALxENGF/21OPg7f/QWd+eadZJRxCjmRwh5F2Cxg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/middleware-user-agent@3.821.0':
    resolution: {integrity: sha512-rw8q3TxygMg3VrofN04QyWVCCyGwz3bVthYmBZZseENPWG3Krz1OCKcyqjkTcAxMQlEywOske+GIiOasGKnJ3w==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/nested-clients@3.821.0':
    resolution: {integrity: sha512-2IuHcUsWw44ftSEDYU4dvktTEqgyDvkOcfpoGC/UmT4Qo6TVCP3U5tWEGpNK9nN+7nLvekruxxG/jaMt5/oWVw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/region-config-resolver@3.821.0':
    resolution: {integrity: sha512-t8og+lRCIIy5nlId0bScNpCkif8sc0LhmtaKsbm0ZPm3sCa/WhCbSZibjbZ28FNjVCV+p0D9RYZx0VDDbtWyjw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/s3-request-presigner@3.821.0':
    resolution: {integrity: sha512-VLM0pWQxEBf80uKirU4B1hQz3ZYX5OaPFrRSciUkkKYdqPFrnjQ7NyIQRjF1MVmXwsKgBxJVWl+p0BKcsHR+rQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/signature-v4-multi-region@3.821.0':
    resolution: {integrity: sha512-UjfyVR/PB/TP9qe1x6tv7qLlD8/0eiSLDkkBUgBmddkkX0l17oy9c2SJINuV3jy1fbx6KORZ6gyvRZ2nb8dtMw==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/token-providers@3.821.0':
    resolution: {integrity: sha512-qJ7wgKhdxGbPg718zWXbCYKDuSWZNU3TSw64hPRW6FtbZrIyZxObpiTKC6DKwfsVoZZhHEoP/imGykN1OdOTJA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/types@3.821.0':
    resolution: {integrity: sha512-Znroqdai1a90TlxGaJ+FK1lwC0fHpo97Xjsp5UKGR5JODYm7f9+/fF17ebO1KdoBr/Rm0UIFiF5VmI8ts9F1eA==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-arn-parser@3.804.0':
    resolution: {integrity: sha512-wmBJqn1DRXnZu3b4EkE6CWnoWMo1ZMvlfkqU5zPz67xx1GMaXlDCchFvKAXMjk4jn/L1O3tKnoFDNsoLV1kgNQ==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-endpoints@3.821.0':
    resolution: {integrity: sha512-Uknt/zUZnLE76zaAAPEayOeF5/4IZ2puTFXvcSCWHsi9m3tqbb9UozlnlVqvCZLCRWfQryZQoG2W4XSS3qgk5A==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-format-url@3.821.0':
    resolution: {integrity: sha512-h+xqmPToxDrZ0a7rxE1a8Oh4zpWfZe9oiQUphGtfiGFA6j75UiURH5J3MmGHa/G4t15I3iLLbYtUXxvb1i7evg==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-locate-window@3.804.0':
    resolution: {integrity: sha512-zVoRfpmBVPodYlnMjgVjfGoEZagyRF5IPn3Uo6ZvOZp24chnW/FRstH7ESDHDDRga4z3V+ElUQHKpFDXWyBW5A==}
    engines: {node: '>=18.0.0'}

  '@aws-sdk/util-user-agent-browser@3.821.0':
    resolution: {integrity: sha512-irWZHyM0Jr1xhC+38OuZ7JB6OXMLPZlj48thElpsO1ZSLRkLZx5+I7VV6k3sp2yZ7BYbKz/G2ojSv4wdm7XTLw==}

  '@aws-sdk/util-user-agent-node@3.821.0':
    resolution: {integrity: sha512-YwMXc9EvuzJgnLBTyiQly2juPujXwDgcMHB0iSN92tHe7Dd1jJ1feBmTgdClaaqCeHFUaFpw+3JU/ZUJ6LjR+A==}
    engines: {node: '>=18.0.0'}
    peerDependencies:
      aws-crt: '>=1.0.0'
    peerDependenciesMeta:
      aws-crt:
        optional: true

  '@aws-sdk/xml-builder@3.821.0':
    resolution: {integrity: sha512-DIIotRnefVL6DiaHtO6/21DhJ4JZnnIwdNbpwiAhdt/AVbttcE4yw925gsjur0OGv5BTYXQXU3YnANBYnZjuQA==}
    engines: {node: '>=18.0.0'}

  '@colors/colors@1.6.0':
    resolution: {integrity: sha512-Ir+AOibqzrIsL6ajt3Rz3LskB7OiMVHqltZmspbW/TJuTVuyOMirVqAkjfY6JISiLHgyNqicAC8AyHHGzNd/dA==}
    engines: {node: '>=0.1.90'}

  '@cspotcode/source-map-support@0.8.1':
    resolution: {integrity: sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==}
    engines: {node: '>=12'}

  '@dabh/diagnostics@2.0.3':
    resolution: {integrity: sha512-hrlQOIi7hAfzsMqlGSFyVucrx38O+j6wiGOf//H2ecvIEqYN4ADBSS2iLMh5UFyDunCNniUIPk/q3riFv45xRA==}

  '@eslint-community/eslint-utils@4.7.0':
    resolution: {integrity: sha512-dyybb3AcajC7uha6CvhdVRJqaKyn7w2YKqKyAN37NKYgZT36w+iRb0Dymmc5qEJ549c/S31cMMSFd75bteCpCw==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
    peerDependencies:
      eslint: ^6.0.0 || ^7.0.0 || >=8.0.0

  '@eslint-community/regexpp@4.12.1':
    resolution: {integrity: sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==}
    engines: {node: ^12.0.0 || ^14.0.0 || >=16.0.0}

  '@eslint/config-array@0.20.0':
    resolution: {integrity: sha512-fxlS1kkIjx8+vy2SjuCB94q3htSNrufYTXubwiBFeaQHbH6Ipi43gFJq2zCMt6PHhImH3Xmr0NksKDvchWlpQQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/config-helpers@0.2.2':
    resolution: {integrity: sha512-+GPzk8PlG0sPpzdU5ZvIRMPidzAnZDl/s9L+y13iodqvb8leL53bTannOrQ/Im7UkpsmFU5Ily5U60LWixnmLg==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/core@0.13.0':
    resolution: {integrity: sha512-yfkgDw1KR66rkT5A8ci4irzDysN7FRpq3ttJolR88OqQikAWqwA8j5VZyas+vjyBNFIJ7MfybJ9plMILI2UrCw==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/eslintrc@3.3.1':
    resolution: {integrity: sha512-gtF186CXhIl1p4pJNGZw8Yc6RlshoePRvE0X91oPGb3vZ8pM3qOS9W9NGPat9LziaBV7XrJWGylNQXkGcnM3IQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/js@9.26.0':
    resolution: {integrity: sha512-I9XlJawFdSMvWjDt6wksMCrgns5ggLNfFwFvnShsleWruvXM514Qxk8V246efTw+eo9JABvVz+u3q2RiAowKxQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/object-schema@2.1.6':
    resolution: {integrity: sha512-RBMg5FRL0I0gs51M/guSAj5/e14VQ4tpZnQNWwuDT66P14I43ItmPfIZRhO9fUVIPOAQXU47atlywZ/czoqFPA==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@eslint/plugin-kit@0.2.8':
    resolution: {integrity: sha512-ZAoA40rNMPwSm+AeHpCq8STiNAwzWLJuP8Xv4CHIc9wv/PSuExjMrmjfYNj682vW0OOiZ1HKxzvjQr9XZIisQA==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  '@humanfs/core@0.19.1':
    resolution: {integrity: sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==}
    engines: {node: '>=18.18.0'}

  '@humanfs/node@0.16.6':
    resolution: {integrity: sha512-YuI2ZHQL78Q5HbhDiBA1X4LmYdXCKCMQIfw0pw7piHJwyREFebJUvrQN4cMssyES6x+vfUbx1CIpaQUKYdQZOw==}
    engines: {node: '>=18.18.0'}

  '@humanwhocodes/module-importer@1.0.1':
    resolution: {integrity: sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==}
    engines: {node: '>=12.22'}

  '@humanwhocodes/retry@0.3.1':
    resolution: {integrity: sha512-JBxkERygn7Bv/GbN5Rv8Ul6LVknS+5Bp6RgDC/O8gEBU/yeH5Ui5C/OlWrTb6qct7LjjfT6Re2NxB0ln0yYybA==}
    engines: {node: '>=18.18'}

  '@humanwhocodes/retry@0.4.3':
    resolution: {integrity: sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==}
    engines: {node: '>=18.18'}

  '@jridgewell/resolve-uri@3.1.2':
    resolution: {integrity: sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/sourcemap-codec@1.5.0':
    resolution: {integrity: sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==}

  '@jridgewell/trace-mapping@0.3.9':
    resolution: {integrity: sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==}

  '@jsdevtools/ono@7.1.3':
    resolution: {integrity: sha512-4JQNk+3mVzK3xh2rqd6RB4J46qUR19azEHBneZyTZM+c456qOrbbM/5xcR8huNCCcbVt7+UmizG6GuUvPvKUYg==}

  '@modelcontextprotocol/sdk@1.11.2':
    resolution: {integrity: sha512-H9vwztj5OAqHg9GockCQC06k1natgcxWQSRpQcPJf6i5+MWBzfKkRtxGbjQf0X2ihii0ffLZCRGbYV2f2bjNCQ==}
    engines: {node: '>=18'}

  '@mongodb-js/saslprep@1.2.2':
    resolution: {integrity: sha512-EB0O3SCSNRUFk66iRCpI+cXzIjdswfCs7F6nOC3RAGJ7xr5YhaicvsRwJ9eyzYvYRlCSDUO/c7g4yNulxKC1WA==}

  '@payos/node@1.0.10':
    resolution: {integrity: sha512-dY+WHd6pLa558a1G8yv6oKfVe5QLTNyYnQBaSQtwvMAm/p0faKAnfXt04LNIwO9/4buas4ES+sDxc1bfX/mVbQ==}

  '@rtsao/scc@1.1.0':
    resolution: {integrity: sha512-zt6OdqaDoOnJ1ZYsCYGt9YmWzDXl4vQdKTyJev62gFhRGKdx7mcT54V9KIjg+d2wi9EXsPvAPKe7i7WjfVWB8g==}

  '@scarf/scarf@1.4.0':
    resolution: {integrity: sha512-xxeapPiUXdZAE3che6f3xogoJPeZgig6omHEy1rIY5WVsB3H2BHNnZH+gHG6x91SCWyQCzWGsuL2Hh3ClO5/qQ==}

  '@smithy/abort-controller@4.0.4':
    resolution: {integrity: sha512-gJnEjZMvigPDQWHrW3oPrFhQtkrgqBkyjj3pCIdF3A5M6vsZODG93KNlfJprv6bp4245bdT32fsHK4kkH3KYDA==}
    engines: {node: '>=18.0.0'}

  '@smithy/chunked-blob-reader-native@4.0.0':
    resolution: {integrity: sha512-R9wM2yPmfEMsUmlMlIgSzOyICs0x9uu7UTHoccMyt7BWw8shcGM8HqB355+BZCPBcySvbTYMs62EgEQkNxz2ig==}
    engines: {node: '>=18.0.0'}

  '@smithy/chunked-blob-reader@5.0.0':
    resolution: {integrity: sha512-+sKqDBQqb036hh4NPaUiEkYFkTUGYzRsn3EuFhyfQfMy6oGHEUJDurLP9Ufb5dasr/XiAmPNMr6wa9afjQB+Gw==}
    engines: {node: '>=18.0.0'}

  '@smithy/config-resolver@4.1.4':
    resolution: {integrity: sha512-prmU+rDddxHOH0oNcwemL+SwnzcG65sBF2yXRO7aeXIn/xTlq2pX7JLVbkBnVLowHLg4/OL4+jBmv9hVrVGS+w==}
    engines: {node: '>=18.0.0'}

  '@smithy/core@3.5.1':
    resolution: {integrity: sha512-xSw7bZEFKwOKrm/iv8e2BLt2ur98YZdrRD6nII8ditQeUsY2Q1JmIQ0rpILOhaLKYxxG2ivnoOpokzr9qLyDWA==}
    engines: {node: '>=18.0.0'}

  '@smithy/credential-provider-imds@4.0.6':
    resolution: {integrity: sha512-hKMWcANhUiNbCJouYkZ9V3+/Qf9pteR1dnwgdyzR09R4ODEYx8BbUysHwRSyex4rZ9zapddZhLFTnT4ZijR4pw==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-codec@4.0.4':
    resolution: {integrity: sha512-7XoWfZqWb/QoR/rAU4VSi0mWnO2vu9/ltS6JZ5ZSZv0eovLVfDfu0/AX4ub33RsJTOth3TiFWSHS5YdztvFnig==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-browser@4.0.4':
    resolution: {integrity: sha512-3fb/9SYaYqbpy/z/H3yIi0bYKyAa89y6xPmIqwr2vQiUT2St+avRt8UKwsWt9fEdEasc5d/V+QjrviRaX1JRFA==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-config-resolver@4.1.2':
    resolution: {integrity: sha512-JGtambizrWP50xHgbzZI04IWU7LdI0nh/wGbqH3sJesYToMi2j/DcoElqyOcqEIG/D4tNyxgRuaqBXWE3zOFhQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-node@4.0.4':
    resolution: {integrity: sha512-RD6UwNZ5zISpOWPuhVgRz60GkSIp0dy1fuZmj4RYmqLVRtejFqQ16WmfYDdoSoAjlp1LX+FnZo+/hkdmyyGZ1w==}
    engines: {node: '>=18.0.0'}

  '@smithy/eventstream-serde-universal@4.0.4':
    resolution: {integrity: sha512-UeJpOmLGhq1SLox79QWw/0n2PFX+oPRE1ZyRMxPIaFEfCqWaqpB7BU9C8kpPOGEhLF7AwEqfFbtwNxGy4ReENA==}
    engines: {node: '>=18.0.0'}

  '@smithy/fetch-http-handler@5.0.4':
    resolution: {integrity: sha512-AMtBR5pHppYMVD7z7G+OlHHAcgAN7v0kVKEpHuTO4Gb199Gowh0taYi9oDStFeUhetkeP55JLSVlTW1n9rFtUw==}
    engines: {node: '>=18.0.0'}

  '@smithy/hash-blob-browser@4.0.4':
    resolution: {integrity: sha512-WszRiACJiQV3QG6XMV44i5YWlkrlsM5Yxgz4jvsksuu7LDXA6wAtypfPajtNTadzpJy3KyJPoWehYpmZGKUFIQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/hash-node@4.0.4':
    resolution: {integrity: sha512-qnbTPUhCVnCgBp4z4BUJUhOEkVwxiEi1cyFM+Zj6o+aY8OFGxUQleKWq8ltgp3dujuhXojIvJWdoqpm6dVO3lQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/hash-stream-node@4.0.4':
    resolution: {integrity: sha512-wHo0d8GXyVmpmMh/qOR0R7Y46/G1y6OR8U+bSTB4ppEzRxd1xVAQ9xOE9hOc0bSjhz0ujCPAbfNLkLrpa6cevg==}
    engines: {node: '>=18.0.0'}

  '@smithy/invalid-dependency@4.0.4':
    resolution: {integrity: sha512-bNYMi7WKTJHu0gn26wg8OscncTt1t2b8KcsZxvOv56XA6cyXtOAAAaNP7+m45xfppXfOatXF3Sb1MNsLUgVLTw==}
    engines: {node: '>=18.0.0'}

  '@smithy/is-array-buffer@2.2.0':
    resolution: {integrity: sha512-GGP3O9QFD24uGeAXYUjwSTXARoqpZykHadOmA8G5vfJPK0/DC67qa//0qvqrJzL1xc8WQWX7/yc7fwudjPHPhA==}
    engines: {node: '>=14.0.0'}

  '@smithy/is-array-buffer@4.0.0':
    resolution: {integrity: sha512-saYhF8ZZNoJDTvJBEWgeBccCg+yvp1CX+ed12yORU3NilJScfc6gfch2oVb4QgxZrGUx3/ZJlb+c/dJbyupxlw==}
    engines: {node: '>=18.0.0'}

  '@smithy/md5-js@4.0.4':
    resolution: {integrity: sha512-uGLBVqcOwrLvGh/v/jw423yWHq/ofUGK1W31M2TNspLQbUV1Va0F5kTxtirkoHawODAZcjXTSGi7JwbnPcDPJg==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-content-length@4.0.4':
    resolution: {integrity: sha512-F7gDyfI2BB1Kc+4M6rpuOLne5LOcEknH1n6UQB69qv+HucXBR1rkzXBnQTB2q46sFy1PM/zuSJOB532yc8bg3w==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-endpoint@4.1.9':
    resolution: {integrity: sha512-AjDgX4UjORLltD/LZCBQTwjQqEfyrx/GeDTHcYLzIgf87pIT70tMWnN87NQpJru1K4ITirY2htSOxNECZJCBOg==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-retry@4.1.10':
    resolution: {integrity: sha512-RyhcA3sZIIvAo6r48b2Nx2qfg0OnyohlaV0fw415xrQyx5HQ2bvHl9vs/WBiDXIP49mCfws5wX4308c9Pi/isw==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-serde@4.0.8':
    resolution: {integrity: sha512-iSSl7HJoJaGyMIoNn2B7czghOVwJ9nD7TMvLhMWeSB5vt0TnEYyRRqPJu/TqW76WScaNvYYB8nRoiBHR9S1Ddw==}
    engines: {node: '>=18.0.0'}

  '@smithy/middleware-stack@4.0.4':
    resolution: {integrity: sha512-kagK5ggDrBUCCzI93ft6DjteNSfY8Ulr83UtySog/h09lTIOAJ/xUSObutanlPT0nhoHAkpmW9V5K8oPyLh+QA==}
    engines: {node: '>=18.0.0'}

  '@smithy/node-config-provider@4.1.3':
    resolution: {integrity: sha512-HGHQr2s59qaU1lrVH6MbLlmOBxadtzTsoO4c+bF5asdgVik3I8o7JIOzoeqWc5MjVa+vD36/LWE0iXKpNqooRw==}
    engines: {node: '>=18.0.0'}

  '@smithy/node-http-handler@4.0.6':
    resolution: {integrity: sha512-NqbmSz7AW2rvw4kXhKGrYTiJVDHnMsFnX4i+/FzcZAfbOBauPYs2ekuECkSbtqaxETLLTu9Rl/ex6+I2BKErPA==}
    engines: {node: '>=18.0.0'}

  '@smithy/property-provider@4.0.4':
    resolution: {integrity: sha512-qHJ2sSgu4FqF4U/5UUp4DhXNmdTrgmoAai6oQiM+c5RZ/sbDwJ12qxB1M6FnP+Tn/ggkPZf9ccn4jqKSINaquw==}
    engines: {node: '>=18.0.0'}

  '@smithy/protocol-http@5.1.2':
    resolution: {integrity: sha512-rOG5cNLBXovxIrICSBm95dLqzfvxjEmuZx4KK3hWwPFHGdW3lxY0fZNXfv2zebfRO7sJZ5pKJYHScsqopeIWtQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/querystring-builder@4.0.4':
    resolution: {integrity: sha512-SwREZcDnEYoh9tLNgMbpop+UTGq44Hl9tdj3rf+yeLcfH7+J8OXEBaMc2kDxtyRHu8BhSg9ADEx0gFHvpJgU8w==}
    engines: {node: '>=18.0.0'}

  '@smithy/querystring-parser@4.0.4':
    resolution: {integrity: sha512-6yZf53i/qB8gRHH/l2ZwUG5xgkPgQF15/KxH0DdXMDHjesA9MeZje/853ifkSY0x4m5S+dfDZ+c4x439PF0M2w==}
    engines: {node: '>=18.0.0'}

  '@smithy/service-error-classification@4.0.5':
    resolution: {integrity: sha512-LvcfhrnCBvCmTee81pRlh1F39yTS/+kYleVeLCwNtkY8wtGg8V/ca9rbZZvYIl8OjlMtL6KIjaiL/lgVqHD2nA==}
    engines: {node: '>=18.0.0'}

  '@smithy/shared-ini-file-loader@4.0.4':
    resolution: {integrity: sha512-63X0260LoFBjrHifPDs+nM9tV0VMkOTl4JRMYNuKh/f5PauSjowTfvF3LogfkWdcPoxsA9UjqEOgjeYIbhb7Nw==}
    engines: {node: '>=18.0.0'}

  '@smithy/signature-v4@5.1.2':
    resolution: {integrity: sha512-d3+U/VpX7a60seHziWnVZOHuEgJlclufjkS6zhXvxcJgkJq4UWdH5eOBLzHRMx6gXjsdT9h6lfpmLzbrdupHgQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/smithy-client@4.4.1':
    resolution: {integrity: sha512-XPbcHRfd0iwx8dY5XCBCGyI7uweMW0oezYezxXcG8ANgvZ5YPuC6Ylh+n0bTHpdU3SCMZOnhzgVklYz+p3fIhw==}
    engines: {node: '>=18.0.0'}

  '@smithy/types@4.3.1':
    resolution: {integrity: sha512-UqKOQBL2x6+HWl3P+3QqFD4ncKq0I8Nuz9QItGv5WuKuMHuuwlhvqcZCoXGfc+P1QmfJE7VieykoYYmrOoFJxA==}
    engines: {node: '>=18.0.0'}

  '@smithy/url-parser@4.0.4':
    resolution: {integrity: sha512-eMkc144MuN7B0TDA4U2fKs+BqczVbk3W+qIvcoCY6D1JY3hnAdCuhCZODC+GAeaxj0p6Jroz4+XMUn3PCxQQeQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-base64@4.0.0':
    resolution: {integrity: sha512-CvHfCmO2mchox9kjrtzoHkWHxjHZzaFojLc8quxXY7WAAMAg43nuxwv95tATVgQFNDwd4M9S1qFzj40Ul41Kmg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-body-length-browser@4.0.0':
    resolution: {integrity: sha512-sNi3DL0/k64/LO3A256M+m3CDdG6V7WKWHdAiBBMUN8S3hK3aMPhwnPik2A/a2ONN+9doY9UxaLfgqsIRg69QA==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-body-length-node@4.0.0':
    resolution: {integrity: sha512-q0iDP3VsZzqJyje8xJWEJCNIu3lktUGVoSy1KB0UWym2CL1siV3artm+u1DFYTLejpsrdGyCSWBdGNjJzfDPjg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-buffer-from@2.2.0':
    resolution: {integrity: sha512-IJdWBbTcMQ6DA0gdNhh/BwrLkDR+ADW5Kr1aZmd4k3DIF6ezMV4R2NIAmT08wQJ3yUK82thHWmC/TnK/wpMMIA==}
    engines: {node: '>=14.0.0'}

  '@smithy/util-buffer-from@4.0.0':
    resolution: {integrity: sha512-9TOQ7781sZvddgO8nxueKi3+yGvkY35kotA0Y6BWRajAv8jjmigQ1sBwz0UX47pQMYXJPahSKEKYFgt+rXdcug==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-config-provider@4.0.0':
    resolution: {integrity: sha512-L1RBVzLyfE8OXH+1hsJ8p+acNUSirQnWQ6/EgpchV88G6zGBTDPdXiiExei6Z1wR2RxYvxY/XLw6AMNCCt8H3w==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-defaults-mode-browser@4.0.17':
    resolution: {integrity: sha512-HXq5181qnXmIwB7VrwqwP8rsJybHMoYuJnNoXy4PROs2pfSI4sWDMASF2i+7Lo+u64Y6xowhegcdxczowgJtZg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-defaults-mode-node@4.0.17':
    resolution: {integrity: sha512-RfU2A5LjFhEHw4Nwl1GZNitK4AUWu5jGtigAUDoQtfDUvYHpQxcuLw2QGAdKDtKRflIiHSZ8wXBDR36H9R2Ang==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-endpoints@3.0.6':
    resolution: {integrity: sha512-YARl3tFL3WgPuLzljRUnrS2ngLiUtkwhQtj8PAL13XZSyUiNLQxwG3fBBq3QXFqGFUXepIN73pINp3y8c2nBmA==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-hex-encoding@4.0.0':
    resolution: {integrity: sha512-Yk5mLhHtfIgW2W2WQZWSg5kuMZCVbvhFmC7rV4IO2QqnZdbEFPmQnCcGMAX2z/8Qj3B9hYYNjZOhWym+RwhePw==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-middleware@4.0.4':
    resolution: {integrity: sha512-9MLKmkBmf4PRb0ONJikCbCwORACcil6gUWojwARCClT7RmLzF04hUR4WdRprIXal7XVyrddadYNfp2eF3nrvtQ==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-retry@4.0.5':
    resolution: {integrity: sha512-V7MSjVDTlEt/plmOFBn1762Dyu5uqMrV2Pl2X0dYk4XvWfdWJNe9Bs5Bzb56wkCuiWjSfClVMGcsuKrGj7S/yg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-stream@4.2.2':
    resolution: {integrity: sha512-aI+GLi7MJoVxg24/3J1ipwLoYzgkB4kUfogZfnslcYlynj3xsQ0e7vk4TnTro9hhsS5PvX1mwmkRqqHQjwcU7w==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-uri-escape@4.0.0':
    resolution: {integrity: sha512-77yfbCbQMtgtTylO9itEAdpPXSog3ZxMe09AEhm0dU0NLTalV70ghDZFR+Nfi1C60jnJoh/Re4090/DuZh2Omg==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-utf8@2.3.0':
    resolution: {integrity: sha512-R8Rdn8Hy72KKcebgLiv8jQcQkXoLMOGGv5uI1/k0l+snqkOzQ1R0ChUBCxWMlBsFMekWjq0wRudIweFs7sKT5A==}
    engines: {node: '>=14.0.0'}

  '@smithy/util-utf8@4.0.0':
    resolution: {integrity: sha512-b+zebfKCfRdgNJDknHCob3O7FpeYQN6ZG6YLExMcasDHsCXlsXCEuiPZeLnJLpwa5dvPetGlnGCiMHuLwGvFow==}
    engines: {node: '>=18.0.0'}

  '@smithy/util-waiter@4.0.5':
    resolution: {integrity: sha512-4QvC49HTteI1gfemu0I1syWovJgPvGn7CVUoN9ZFkdvr/cCFkrEL7qNCdx/2eICqDWEGnnr68oMdSIPCLAriSQ==}
    engines: {node: '>=18.0.0'}

  '@swc/helpers@0.3.17':
    resolution: {integrity: sha512-tb7Iu+oZ+zWJZ3HJqwx8oNwSDIU440hmVMDPhpACWQWnrZHK99Bxs70gT1L2dnr5Hg50ZRWEFkQCAnOVVV0z1Q==}

  '@tsconfig/node10@1.0.11':
    resolution: {integrity: sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==}

  '@tsconfig/node12@1.0.11':
    resolution: {integrity: sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==}

  '@tsconfig/node14@1.0.3':
    resolution: {integrity: sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==}

  '@tsconfig/node16@1.0.4':
    resolution: {integrity: sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==}

  '@types/aws-sdk@2.7.4':
    resolution: {integrity: sha512-BdGaQDSow2hYmHbn7RV/Lg9rvh/JBD6gFRKAeCh3eqjc2eAjaz5m+cjuX1lpaWOisMeb0ep8sZBhtOLHHZ8qAA==}
    deprecated: This is a stub types definition. aws-sdk provides its own type definitions, so you do not need this installed.

  '@types/bcryptjs@3.0.0':
    resolution: {integrity: sha512-WRZOuCuaz8UcZZE4R5HXTco2goQSI2XxjGY3hbM/xDvwmqFWd4ivooImsMx65OKM6CtNKbnZ5YL+YwAwK7c1dg==}
    deprecated: This is a stub types definition. bcryptjs provides its own type definitions, so you do not need this installed.

  '@types/body-parser@1.19.5':
    resolution: {integrity: sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==}

  '@types/compression@1.8.0':
    resolution: {integrity: sha512-g4vmPIwbTii9dX1HVioHbOolubEaf4re4vDxuzpKrzz9uI7uarBExi9begX0cXyIB85jXZ5X2A/v8rsHZxSAPw==}

  '@types/connect@3.4.38':
    resolution: {integrity: sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==}

  '@types/cors@2.8.18':
    resolution: {integrity: sha512-nX3d0sxJW41CqQvfOzVG1NCTXfFDrDWIghCZncpHeWlVFd81zxB/DLhg7avFg6eHLCRX7ckBmoIIcqa++upvJA==}

  '@types/dotenv@8.2.3':
    resolution: {integrity: sha512-g2FXjlDX/cYuc5CiQvyU/6kkbP1JtmGzh0obW50zD7OKeILVL0NSpPWLXVfqoAGQjom2/SLLx9zHq0KXvD6mbw==}
    deprecated: This is a stub types definition. dotenv provides its own type definitions, so you do not need this installed.

  '@types/estree@1.0.7':
    resolution: {integrity: sha512-w28IoSUCJpidD/TGviZwwMJckNESJZXFu7NBZ5YJ4mEUnNraUn9Pm8HSZm/jDF1pDWYKspWE7oVphigUPRakIQ==}

  '@types/express-serve-static-core@5.0.6':
    resolution: {integrity: sha512-3xhRnjJPkULekpSzgtoNYYcTWgEZkp4myc+Saevii5JPnHNvHMRlBSHDbs7Bh1iPPoVTERHEZXyhyLbMEsExsA==}

  '@types/express@5.0.1':
    resolution: {integrity: sha512-UZUw8vjpWFXuDnjFTh7/5c2TWDlQqeXHi6hcN7F2XSVT5P+WmUnnbFS3KA6Jnc6IsEqI2qCVu2bK0R0J4A8ZQQ==}

  '@types/hpp@0.2.6':
    resolution: {integrity: sha512-6gn1RuHA1/XFCVCqCkSV+AWy07YwtGg4re4SHhLMoiARTg9XlrbYMtVR+Uvws0VlERXzzcA+1UYvxEV6O+sgPg==}

  '@types/http-errors@2.0.4':
    resolution: {integrity: sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==}

  '@types/json-schema@7.0.15':
    resolution: {integrity: sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==}

  '@types/json5@0.0.29':
    resolution: {integrity: sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==}

  '@types/jsonwebtoken@9.0.9':
    resolution: {integrity: sha512-uoe+GxEuHbvy12OUQct2X9JenKM3qAscquYymuQN4fMWG9DBQtykrQEFcAbVACF7qaLw9BePSodUL0kquqBJpQ==}

  '@types/mime@1.3.5':
    resolution: {integrity: sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==}

  '@types/morgan@1.9.9':
    resolution: {integrity: sha512-iRYSDKVaC6FkGSpEVVIvrRGw0DfJMiQzIn3qr2G5B3C//AWkulhXgaBd7tS9/J79GWSYMTHGs7PfI5b3Y8m+RQ==}

  '@types/ms@2.1.0':
    resolution: {integrity: sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==}

  '@types/multer@1.4.12':
    resolution: {integrity: sha512-pQ2hoqvXiJt2FP9WQVLPRO+AmiIm/ZYkavPlIQnx282u4ZrVdztx0pkh3jjpQt0Kz+YI0YhSG264y08UJKoUQg==}

  '@types/node@22.15.18':
    resolution: {integrity: sha512-v1DKRfUdyW+jJhZNEI1PYy29S2YRxMV5AOO/x/SjKmW0acCIOqmbj6Haf9eHAhsPmrhlHSxEhv/1WszcLWV4cg==}

  '@types/nodemailer@6.4.17':
    resolution: {integrity: sha512-I9CCaIp6DTldEg7vyUTZi8+9Vo0hi1/T8gv3C89yk1rSAAzoKQ8H8ki/jBYJSFoH/BisgLP8tkZMlQ91CIquww==}

  '@types/pdfkit@0.13.9':
    resolution: {integrity: sha512-RDG8Yb1zT7I01FfpwK7nMSA433XWpblMqSCtA5vJlSyavWZb303HUYPCel6JTiDDFqwGLvtAnYbH8N/e0Cb89g==}

  '@types/qs@6.9.18':
    resolution: {integrity: sha512-kK7dgTYDyGqS+e2Q4aK9X3D7q234CIZ1Bv0q/7Z5IwRDoADNU81xXJK/YVyLbLTZCoIwUoDoffFeF+p/eIklAA==}

  '@types/range-parser@1.2.7':
    resolution: {integrity: sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==}

  '@types/send@0.17.4':
    resolution: {integrity: sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==}

  '@types/serve-static@1.15.7':
    resolution: {integrity: sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==}

  '@types/strip-bom@3.0.0':
    resolution: {integrity: sha512-xevGOReSYGM7g/kUBZzPqCrR/KYAo+F0yiPc85WFTJa0MSLtyFTVTU6cJu/aV4mid7IffDIWqo69THF2o4JiEQ==}

  '@types/strip-json-comments@0.0.30':
    resolution: {integrity: sha512-7NQmHra/JILCd1QqpSzl8+mJRc8ZHz3uDm8YV1Ks9IhK0epEiTw8aIErbvH9PI+6XbqhyIQy3462nEsn7UVzjQ==}

  '@types/swagger-jsdoc@6.0.4':
    resolution: {integrity: sha512-W+Xw5epcOZrF/AooUM/PccNMSAFOKWZA5dasNyMujTwsBkU74njSJBpvCCJhHAJ95XRMzQrrW844Btu0uoetwQ==}

  '@types/swagger-ui-express@4.1.8':
    resolution: {integrity: sha512-AhZV8/EIreHFmBV5wAs0gzJUNq9JbbSXgJLQubCC0jtIo6prnI9MIRRxnU4MZX9RB9yXxF1V4R7jtLl/Wcj31g==}

  '@types/triple-beam@1.3.5':
    resolution: {integrity: sha512-6WaYesThRMCl19iryMYP7/x2OVgCtbIVflDGFpWnb9irXI3UjYE4AzmYuiUKY1AJstGijoY+MgUszMgRxIYTYw==}

  '@types/validator@13.15.0':
    resolution: {integrity: sha512-nh7nrWhLr6CBq9ldtw0wx+z9wKnnv/uTVLA9g/3/TcOYxbpOSZE+MhKPmWqU+K0NvThjhv12uD8MuqijB0WzEA==}

  '@types/webidl-conversions@7.0.3':
    resolution: {integrity: sha512-CiJJvcRtIgzadHCYXw7dqEnMNRjhGZlYK05Mj9OyktqV8uVT8fD2BFOB7S1uwBE3Kj2Z+4UyPmFw/Ixgw/LAlA==}

  '@types/whatwg-url@11.0.5':
    resolution: {integrity: sha512-coYR071JRaHa+xoEvvYqvnIHaVqaYrLPbsufM9BF63HkwI5Lgmy2QR8Q5K/lYDYo5AK82wOvSOS0UsLTpTG7uQ==}

  '@types/yamljs@0.2.34':
    resolution: {integrity: sha512-gJvfRlv9ErxdOv7ux7UsJVePtX54NAvQyd8ncoiFqK8G5aeHIfQfGH2fbruvjAQ9657HwAaO54waS+Dsk2QTUQ==}

  accepts@2.0.0:
    resolution: {integrity: sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==}
    engines: {node: '>= 0.6'}

  acorn-jsx@5.3.2:
    resolution: {integrity: sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==}
    peerDependencies:
      acorn: ^6.0.0 || ^7.0.0 || ^8.0.0

  acorn-walk@8.3.4:
    resolution: {integrity: sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==}
    engines: {node: '>=0.4.0'}

  acorn@8.14.1:
    resolution: {integrity: sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==}
    engines: {node: '>=0.4.0'}
    hasBin: true

  agent-base@7.1.3:
    resolution: {integrity: sha512-jRR5wdylq8CkOe6hei19GGZnxM6rBGwFl3Bg0YItGDimvjGtAvdZk4Pu6Cl4u4Igsws4a1fd1Vq3ezrhn4KmFw==}
    engines: {node: '>= 14'}

  ajv@6.12.6:
    resolution: {integrity: sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==}

  ansi-escapes@7.0.0:
    resolution: {integrity: sha512-GdYO7a61mR0fOlAsvC9/rIHf7L96sBc6dEWzeOu+KAea5bZyQRPIpojrVoI4AXGJS/ycu/fBTdLrUkA4ODrvjw==}
    engines: {node: '>=18'}

  ansi-regex@6.1.0:
    resolution: {integrity: sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==}
    engines: {node: '>=12'}

  ansi-styles@4.3.0:
    resolution: {integrity: sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==}
    engines: {node: '>=8'}

  ansi-styles@6.2.1:
    resolution: {integrity: sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==}
    engines: {node: '>=12'}

  anymatch@3.1.3:
    resolution: {integrity: sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==}
    engines: {node: '>= 8'}

  append-field@1.0.0:
    resolution: {integrity: sha512-klpgFSWLW1ZEs8svjfb7g4qWY0YS5imI82dTg+QahUvJ8YqAY0P10Uk8tTyh9ZGuYEZEMaeJYCF5BFuX552hsw==}

  arg@4.1.3:
    resolution: {integrity: sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==}

  argparse@1.0.10:
    resolution: {integrity: sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==}

  argparse@2.0.1:
    resolution: {integrity: sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==}

  array-buffer-byte-length@1.0.2:
    resolution: {integrity: sha512-LHE+8BuR7RYGDKvnrmcuSq3tDcKv9OFEXQt/HpbZhY7V6h0zlUXutnAD82GiFx9rdieCMjkvtcsPqBwgUl1Iiw==}
    engines: {node: '>= 0.4'}

  array-includes@3.1.8:
    resolution: {integrity: sha512-itaWrbYbqpGXkGhZPGUulwnhVf5Hpy1xiCFsGqyIGglbBxmG5vSjxQen3/WGOjPpNEv1RtBLKxbmVXm8HpJStQ==}
    engines: {node: '>= 0.4'}

  array.prototype.findlastindex@1.2.6:
    resolution: {integrity: sha512-F/TKATkzseUExPlfvmwQKGITM3DGTK+vkAsCZoDc5daVygbJBnjEUCbgkAvVFsgfXfX4YIqZ/27G3k3tdXrTxQ==}
    engines: {node: '>= 0.4'}

  array.prototype.flat@1.3.3:
    resolution: {integrity: sha512-rwG/ja1neyLqCuGZ5YYrznA62D4mZXg0i1cIskIUKSiqF3Cje9/wXAls9B9s1Wa2fomMsIv8czB8jZcPmxCXFg==}
    engines: {node: '>= 0.4'}

  array.prototype.flatmap@1.3.3:
    resolution: {integrity: sha512-Y7Wt51eKJSyi80hFrJCePGGNo5ktJCslFuboqJsbf57CCPcm5zztluPlc4/aD8sWsKvlwatezpV4U1efk8kpjg==}
    engines: {node: '>= 0.4'}

  arraybuffer.prototype.slice@1.0.4:
    resolution: {integrity: sha512-BNoCY6SXXPQ7gF2opIP4GBE+Xw7U+pHMYKuzjgCN3GwiaIR09UUeKfheyIry77QtrCBlC0KK0q5/TER/tYh3PQ==}
    engines: {node: '>= 0.4'}

  async-function@1.0.0:
    resolution: {integrity: sha512-hsU18Ae8CDTR6Kgu9DYf0EbCr/a5iGL0rytQDobUcdpYOKokk8LEjVphnXkDkgpi0wYVsqrXuP0bZxJaTqdgoA==}
    engines: {node: '>= 0.4'}

  async@3.2.6:
    resolution: {integrity: sha512-htCUDlxyyCLMgaM3xXg0C0LW2xqfuQ6p05pCEIsXuyQ+a1koYKTuBMzRNwmybfLgvJDMd0r1LTn4+E0Ti6C2AA==}

  asynckit@0.4.0:
    resolution: {integrity: sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==}

  available-typed-arrays@1.0.7:
    resolution: {integrity: sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==}
    engines: {node: '>= 0.4'}

  aws-sdk@2.1692.0:
    resolution: {integrity: sha512-x511uiJ/57FIsbgUe5csJ13k3uzu25uWQE+XqfBis/sB0SFoiElJWXRkgEAUh0U6n40eT3ay5Ue4oPkRMu1LYw==}
    engines: {node: '>= 10.0.0'}

  axios@1.9.0:
    resolution: {integrity: sha512-re4CqKTJaURpzbLHtIi6XpDv20/CnpXOtjRY5/CU32L8gU8ek9UIivcfvSWvmKEngmVbrUtPpdDwWDWL7DNHvg==}

  balanced-match@1.0.2:
    resolution: {integrity: sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==}

  base64-js@0.0.8:
    resolution: {integrity: sha512-3XSA2cR/h/73EzlXXdU6YNycmYI7+kicTxks4eJg2g39biHR84slg2+des+p7iHYhbRg/udIS4TD53WabcOUkw==}
    engines: {node: '>= 0.4'}

  base64-js@1.5.1:
    resolution: {integrity: sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==}

  basic-auth@2.0.1:
    resolution: {integrity: sha512-NF+epuEdnUYVlGuhaxbbq+dvJttwLnGY+YixlXlME5KpQ5W3CnXA5cVTneY3SPbPDRkcjMbifrwmFYcClgOZeg==}
    engines: {node: '>= 0.8'}

  bcryptjs@3.0.2:
    resolution: {integrity: sha512-k38b3XOZKv60C4E2hVsXTolJWfkGRMbILBIe2IBITXciy5bOsTKot5kDrf3ZfufQtQOUN5mXceUEpU1rTl9Uog==}
    hasBin: true

  bignumber.js@9.3.0:
    resolution: {integrity: sha512-EM7aMFTXbptt/wZdMlBv2t8IViwQL+h6SLHosp8Yf0dqJMTnY6iL32opnAB6kAdL0SZPuvcAzFr31o0c/R3/RA==}

  binary-extensions@2.3.0:
    resolution: {integrity: sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==}
    engines: {node: '>=8'}

  body-parser@2.2.0:
    resolution: {integrity: sha512-02qvAaxv8tp7fBa/mw1ga98OGm+eCbqzJOKoRt70sLmfEEi+jyBYVTDGfCL/k06/4EMk/z01gCe7HoCH/f2LTg==}
    engines: {node: '>=18'}

  bowser@2.11.0:
    resolution: {integrity: sha512-AlcaJBi/pqqJBIQ8U9Mcpc9i8Aqxn88Skv5d+xBX006BY5u8N3mGLHa5Lgppa7L/HfwgwLgZ6NYs+Ag6uUmJRA==}

  brace-expansion@1.1.11:
    resolution: {integrity: sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==}

  brace-expansion@2.0.1:
    resolution: {integrity: sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==}

  braces@3.0.3:
    resolution: {integrity: sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==}
    engines: {node: '>=8'}

  brotli@1.3.3:
    resolution: {integrity: sha512-oTKjJdShmDuGW94SyyaoQvAjf30dZaHnjJ8uAF+u2/vGJkJbJPJAT1gDiOJP5v1Zb6f9KEyW/1HpuaWIXtGHPg==}

  bson@6.10.3:
    resolution: {integrity: sha512-MTxGsqgYTwfshYWTRdmZRC+M7FnG1b4y7RO7p2k3X24Wq0yv1m77Wsj0BzlPzd/IowgESfsruQCUToa7vbOpPQ==}
    engines: {node: '>=16.20.1'}

  buffer-equal-constant-time@1.0.1:
    resolution: {integrity: sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==}

  buffer-from@1.1.2:
    resolution: {integrity: sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==}

  buffer@4.9.2:
    resolution: {integrity: sha512-xq+q3SRMOxGivLhBNaUdC64hDTQwejJ+H0T/NB1XMtTVEwNTrfFF3gAxiyW0Bu/xWEGhjVKgUcMhCrUy2+uCWg==}

  busboy@1.6.0:
    resolution: {integrity: sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==}
    engines: {node: '>=10.16.0'}

  bytes@3.1.2:
    resolution: {integrity: sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==}
    engines: {node: '>= 0.8'}

  call-bind-apply-helpers@1.0.2:
    resolution: {integrity: sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==}
    engines: {node: '>= 0.4'}

  call-bind@1.0.8:
    resolution: {integrity: sha512-oKlSFMcMwpUg2ednkhQ454wfWiU/ul3CkJe/PEHcTKuiX6RpbehUiFMXu13HalGZxfUwCQzZG747YXBn1im9ww==}
    engines: {node: '>= 0.4'}

  call-bound@1.0.4:
    resolution: {integrity: sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==}
    engines: {node: '>= 0.4'}

  call-me-maybe@1.0.2:
    resolution: {integrity: sha512-HpX65o1Hnr9HH25ojC1YGs7HCQLq0GCOibSaWER0eNpgJ/Z1MZv2mTc7+xh6WOPxbRVcmgbv4hGU+uSQ/2xFZQ==}

  callsites@3.1.0:
    resolution: {integrity: sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==}
    engines: {node: '>=6'}

  chalk@4.1.2:
    resolution: {integrity: sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==}
    engines: {node: '>=10'}

  chalk@5.4.1:
    resolution: {integrity: sha512-zgVZuo2WcZgfUEmsn6eO3kINexW8RAE4maiQ8QNs8CtpPCSyMiYsULR3HQYkm3w8FIA3SberyMJMSldGsW+U3w==}
    engines: {node: ^12.17.0 || ^14.13 || >=16.0.0}

  chokidar@3.6.0:
    resolution: {integrity: sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==}
    engines: {node: '>= 8.10.0'}

  class-transformer@0.5.1:
    resolution: {integrity: sha512-SQa1Ws6hUbfC98vKGxZH3KFY0Y1lm5Zm0SY8XX9zbK7FJCyVEac3ATW0RIpwzW+oOfmHE5PMPufDG9hCfoEOMw==}

  class-validator@0.14.2:
    resolution: {integrity: sha512-3kMVRF2io8N8pY1IFIXlho9r8IPUUIfHe2hYVtiebvAzU2XeQFXTv+XI4WX+TnXmtwXMDcjngcpkiPM0O9PvLw==}

  cli-cursor@5.0.0:
    resolution: {integrity: sha512-aCj4O5wKyszjMmDT4tZj93kxyydN/K5zPWSCe6/0AV/AA1pqe5ZBIw0a2ZfPQV7lL5/yb5HsUreJ6UFAF1tEQw==}
    engines: {node: '>=18'}

  cli-truncate@4.0.0:
    resolution: {integrity: sha512-nPdaFdQ0h/GEigbPClz11D0v/ZJEwxmeVZGeMo3Z5StPtUTkA9o1lD6QwoirYiSDzbcwn2XcjwmCp68W1IS4TA==}
    engines: {node: '>=18'}

  clone@2.1.2:
    resolution: {integrity: sha512-3Pe/CF1Nn94hyhIYpjtiLhdCoEoz0DqQ+988E9gmeEdQZlojxnOb74wctFyuwWQHzqyf9X7C7MG8juUpqBJT8w==}
    engines: {node: '>=0.8'}

  color-convert@1.9.3:
    resolution: {integrity: sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==}

  color-convert@2.0.1:
    resolution: {integrity: sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==}
    engines: {node: '>=7.0.0'}

  color-name@1.1.3:
    resolution: {integrity: sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==}

  color-name@1.1.4:
    resolution: {integrity: sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==}

  color-string@1.9.1:
    resolution: {integrity: sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==}

  color@3.2.1:
    resolution: {integrity: sha512-aBl7dZI9ENN6fUGC7mWpMTPNHmWUSNan9tuWN6ahh5ZLNk9baLJOnSMlrQkHcrfFgz2/RigjUVAjdx36VcemKA==}

  colorette@2.0.20:
    resolution: {integrity: sha512-IfEDxwoWIjkeXL1eXcDiow4UbKjhLdq6/EuSVR9GMN7KVH3r9gQ83e73hsz1Nd1T3ijd5xv1wcWRYO+D6kCI2w==}

  colorspace@1.1.4:
    resolution: {integrity: sha512-BgvKJiuVu1igBUF2kEjRCZXol6wiiGbY5ipL/oVPwm0BL9sIpMIzM8IK7vwuxIIzOXMV3Ey5w+vxhm0rR/TN8w==}

  combined-stream@1.0.8:
    resolution: {integrity: sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==}
    engines: {node: '>= 0.8'}

  commander@13.1.0:
    resolution: {integrity: sha512-/rFeCpNJQbhSZjGVwO9RFV3xPqbnERS8MmIQzCtD/zl6gpJuV/bMLuN92oG3F7d8oDEHHRrujSXNUr8fpjntKw==}
    engines: {node: '>=18'}

  commander@6.2.0:
    resolution: {integrity: sha512-zP4jEKbe8SHzKJYQmq8Y9gYjtO/POJLgIdKgV7B9qNmABVFVc+ctqSX6iXh4mCpJfRBOabiZ2YKPg8ciDw6C+Q==}
    engines: {node: '>= 6'}

  commander@9.5.0:
    resolution: {integrity: sha512-KRs7WVDKg86PWiuAqhDrAQnTXZKraVcCc6vFdL14qrZ/DcWwuRo7VoiYXalXO7S5GKpqYiVEwCbgFDfxNHKJBQ==}
    engines: {node: ^12.20.0 || >=14}

  compressible@2.0.18:
    resolution: {integrity: sha512-AF3r7P5dWxL8MxyITRMlORQNaOA2IkAFaTr4k7BUumjPtRpGDTZpl0Pb1XCO6JeDCBdp126Cgs9sMxqSjgYyRg==}
    engines: {node: '>= 0.6'}

  compression@1.8.0:
    resolution: {integrity: sha512-k6WLKfunuqCYD3t6AsuPGvQWaKwuLLh2/xHNcX4qE+vIfDNXpSqnrhwA7O53R7WVQUnt8dVAIW+YHr7xTgOgGA==}
    engines: {node: '>= 0.8.0'}

  concat-map@0.0.1:
    resolution: {integrity: sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==}

  concat-stream@1.6.2:
    resolution: {integrity: sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==}
    engines: {'0': node >= 0.8}

  content-disposition@1.0.0:
    resolution: {integrity: sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==}
    engines: {node: '>= 0.6'}

  content-type@1.0.5:
    resolution: {integrity: sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==}
    engines: {node: '>= 0.6'}

  cookie-signature@1.2.2:
    resolution: {integrity: sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==}
    engines: {node: '>=6.6.0'}

  cookie@0.7.2:
    resolution: {integrity: sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==}
    engines: {node: '>= 0.6'}

  core-util-is@1.0.3:
    resolution: {integrity: sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==}

  cors@2.8.5:
    resolution: {integrity: sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==}
    engines: {node: '>= 0.10'}

  create-require@1.1.1:
    resolution: {integrity: sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==}

  cross-spawn@7.0.6:
    resolution: {integrity: sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==}
    engines: {node: '>= 8'}

  crypto-js@4.2.0:
    resolution: {integrity: sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q==}

  crypto@1.0.1:
    resolution: {integrity: sha512-VxBKmeNcqQdiUQUW2Tzq0t377b54N2bMtXO/qiLa+6eRRmmC4qT3D4OnTGoT/U6O9aklQ/jTwbOtRMTTY8G0Ig==}
    deprecated: This package is no longer supported. It's now a built-in Node module. If you've depended on crypto, you should switch to the one that's built-in.

  data-view-buffer@1.0.2:
    resolution: {integrity: sha512-EmKO5V3OLXh1rtK2wgXRansaK1/mtVdTUEiEI0W8RkvgT05kfxaH29PliLnpLP73yYO6142Q72QNa8Wx/A5CqQ==}
    engines: {node: '>= 0.4'}

  data-view-byte-length@1.0.2:
    resolution: {integrity: sha512-tuhGbE6CfTM9+5ANGf+oQb72Ky/0+s3xKUpHvShfiz2RxMFgFPjsXuRLBVMtvMs15awe45SRb83D6wH4ew6wlQ==}
    engines: {node: '>= 0.4'}

  data-view-byte-offset@1.0.1:
    resolution: {integrity: sha512-BS8PfmtDGnrgYdOonGZQdLZslWIeCGFP9tpan0hi1Co2Zr2NKADsvGYA8XxuG/4UWgJ6Cjtv+YJnB6MM69QGlQ==}
    engines: {node: '>= 0.4'}

  date-fns@4.1.0:
    resolution: {integrity: sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==}

  debug@2.6.9:
    resolution: {integrity: sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  debug@3.2.7:
    resolution: {integrity: sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  debug@4.4.1:
    resolution: {integrity: sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  deep-equal@2.2.3:
    resolution: {integrity: sha512-ZIwpnevOurS8bpT4192sqAowWM76JDKSHYzMLty3BZGSswgq6pBaH3DhCSW5xVAZICZyKdOBPjwww5wfgT/6PA==}
    engines: {node: '>= 0.4'}

  deep-is@0.1.4:
    resolution: {integrity: sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==}

  define-data-property@1.1.4:
    resolution: {integrity: sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==}
    engines: {node: '>= 0.4'}

  define-properties@1.2.1:
    resolution: {integrity: sha512-8QmQKqEASLd5nx0U1B1okLElbUuuttJ/AnYmRXbbbGDWh6uS208EjD4Xqq/I9wK7u0v6O08XhTWnt5XtEbR6Dg==}
    engines: {node: '>= 0.4'}

  delayed-stream@1.0.0:
    resolution: {integrity: sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==}
    engines: {node: '>=0.4.0'}

  depd@2.0.0:
    resolution: {integrity: sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==}
    engines: {node: '>= 0.8'}

  dfa@1.2.0:
    resolution: {integrity: sha512-ED3jP8saaweFTjeGX8HQPjeC1YYyZs98jGNZx6IiBvxW7JG5v492kamAQB3m2wop07CvU/RQmzcKr6bgcC5D/Q==}

  diff@4.0.2:
    resolution: {integrity: sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==}
    engines: {node: '>=0.3.1'}

  doctrine@2.1.0:
    resolution: {integrity: sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==}
    engines: {node: '>=0.10.0'}

  doctrine@3.0.0:
    resolution: {integrity: sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==}
    engines: {node: '>=6.0.0'}

  dotenv@16.5.0:
    resolution: {integrity: sha512-m/C+AwOAr9/W1UOIZUo232ejMNnJAJtYQjUbHoNTBNTJSvqzzDh7vnrei3o3r3m9blf6ZoDkvcw0VmozNRFJxg==}
    engines: {node: '>=12'}

  dunder-proto@1.0.1:
    resolution: {integrity: sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==}
    engines: {node: '>= 0.4'}

  dynamic-dedupe@0.3.0:
    resolution: {integrity: sha512-ssuANeD+z97meYOqd50e04Ze5qp4bPqo8cCkI4TRjZkzAUgIDTrXV1R8QCdINpiI+hw14+rYazvTRdQrz0/rFQ==}

  ecdsa-sig-formatter@1.0.11:
    resolution: {integrity: sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==}

  ee-first@1.1.1:
    resolution: {integrity: sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==}

  ejs@3.1.10:
    resolution: {integrity: sha512-UeJmFfOrAQS8OJWPZ4qtgHyWExa088/MtK5UEyoJGFH67cDEXkZSviOiKRCZ4Xij0zxI3JECgYs3oKx+AizQBA==}
    engines: {node: '>=0.10.0'}
    hasBin: true

  emoji-regex@10.4.0:
    resolution: {integrity: sha512-EC+0oUMY1Rqm4O6LLrgjtYDvcVYTy7chDnM4Q7030tP4Kwj3u/pR6gP9ygnp2CJMK5Gq+9Q2oqmrFJAz01DXjw==}

  enabled@2.0.0:
    resolution: {integrity: sha512-AKrN98kuwOzMIdAizXGI86UFBoo26CL21UM763y1h/GMSJ4/OHU9k2YlsmBpyScFo/wbLzWQJBMCW4+IO3/+OQ==}

  encodeurl@2.0.0:
    resolution: {integrity: sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==}
    engines: {node: '>= 0.8'}

  envalid@8.0.0:
    resolution: {integrity: sha512-PGeYJnJB5naN0ME6SH8nFcDj9HVbLpYIfg1p5lAyM9T4cH2lwtu2fLbozC/bq+HUUOIFxhX/LP0/GmlqPHT4tQ==}
    engines: {node: '>=8.12'}

  environment@1.1.0:
    resolution: {integrity: sha512-xUtoPkMggbz0MPyPiIWr1Kp4aeWJjDZ6SMvURhimjdZgsRuDplF5/s9hcgGhyXMhs+6vpnuoiZ2kFiu3FMnS8Q==}
    engines: {node: '>=18'}

  es-abstract@1.23.9:
    resolution: {integrity: sha512-py07lI0wjxAC/DcfK1S6G7iANonniZwTISvdPzk9hzeH0IZIshbuuFxLIU96OyF89Yb9hiqWn8M/bY83KY5vzA==}
    engines: {node: '>= 0.4'}

  es-define-property@1.0.1:
    resolution: {integrity: sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==}
    engines: {node: '>= 0.4'}

  es-errors@1.3.0:
    resolution: {integrity: sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==}
    engines: {node: '>= 0.4'}

  es-get-iterator@1.1.3:
    resolution: {integrity: sha512-sPZmqHBe6JIiTfN5q2pEi//TwxmAFHwj/XEuYjTuse78i8KxaqMTTzxPoFKuzRpDpTJ+0NAbpfenkmH2rePtuw==}

  es-object-atoms@1.1.1:
    resolution: {integrity: sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==}
    engines: {node: '>= 0.4'}

  es-set-tostringtag@2.1.0:
    resolution: {integrity: sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==}
    engines: {node: '>= 0.4'}

  es-shim-unscopables@1.1.0:
    resolution: {integrity: sha512-d9T8ucsEhh8Bi1woXCf+TIKDIROLG5WCkxg8geBCbvk22kzwC5G2OnXVMO6FUsvQlgUUXQ2itephWDLqDzbeCw==}
    engines: {node: '>= 0.4'}

  es-to-primitive@1.3.0:
    resolution: {integrity: sha512-w+5mJ3GuFL+NjVtJlvydShqE1eN3h3PbI7/5LAsYJP/2qtuMXjfL2LpHSRqo4b4eSF5K/DH1JXKUAHSB2UW50g==}
    engines: {node: '>= 0.4'}

  escape-html@1.0.3:
    resolution: {integrity: sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==}

  escape-string-regexp@4.0.0:
    resolution: {integrity: sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==}
    engines: {node: '>=10'}

  eslint-config-prettier@10.1.5:
    resolution: {integrity: sha512-zc1UmCpNltmVY34vuLRV61r1K27sWuX39E+uyUnY8xS2Bex88VV9cugG+UZbRSRGtGyFboj+D8JODyme1plMpw==}
    hasBin: true
    peerDependencies:
      eslint: '>=7.0.0'

  eslint-import-resolver-node@0.3.9:
    resolution: {integrity: sha512-WFj2isz22JahUv+B788TlO3N6zL3nNJGU8CcZbPZvVEkBPaJdCV4vy5wyghty5ROFbCRnm132v8BScu5/1BQ8g==}

  eslint-module-utils@2.12.0:
    resolution: {integrity: sha512-wALZ0HFoytlyh/1+4wuZ9FJCD/leWHQzzrxJ8+rebyReSLk7LApMyd3WJaLVoN+D5+WIdJyDK1c6JnE65V4Zyg==}
    engines: {node: '>=4'}
    peerDependencies:
      '@typescript-eslint/parser': '*'
      eslint: '*'
      eslint-import-resolver-node: '*'
      eslint-import-resolver-typescript: '*'
      eslint-import-resolver-webpack: '*'
    peerDependenciesMeta:
      '@typescript-eslint/parser':
        optional: true
      eslint:
        optional: true
      eslint-import-resolver-node:
        optional: true
      eslint-import-resolver-typescript:
        optional: true
      eslint-import-resolver-webpack:
        optional: true

  eslint-plugin-import@2.31.0:
    resolution: {integrity: sha512-ixmkI62Rbc2/w8Vfxyh1jQRTdRTF52VxwRVHl/ykPAmqG+Nb7/kNn+byLP0LxPgI7zWA16Jt82SybJInmMia3A==}
    engines: {node: '>=4'}
    peerDependencies:
      '@typescript-eslint/parser': '*'
      eslint: ^2 || ^3 || ^4 || ^5 || ^6 || ^7.2.0 || ^8 || ^9
    peerDependenciesMeta:
      '@typescript-eslint/parser':
        optional: true

  eslint-scope@8.3.0:
    resolution: {integrity: sha512-pUNxi75F8MJ/GdeKtVLSbYg4ZI34J6C0C7sbL4YOp2exGwen7ZsuBqKzUhXd0qMQ362yET3z+uPwKeg/0C2XCQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  eslint-visitor-keys@3.4.3:
    resolution: {integrity: sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  eslint-visitor-keys@4.2.0:
    resolution: {integrity: sha512-UyLnSehNt62FFhSwjZlHmeokpRK59rcz29j+F1/aDgbkbRTk7wIc9XzdoasMUbRNKDM0qQt/+BJ4BrpFeABemw==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  eslint@9.26.0:
    resolution: {integrity: sha512-Hx0MOjPh6uK9oq9nVsATZKE/Wlbai7KFjfCuw9UHaguDW3x+HF0O5nIi3ud39TWgrTjTO5nHxmL3R1eANinWHQ==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}
    hasBin: true
    peerDependencies:
      jiti: '*'
    peerDependenciesMeta:
      jiti:
        optional: true

  espree@10.3.0:
    resolution: {integrity: sha512-0QYC8b24HWY8zjRnDTL6RiHfDbAWn63qb4LMj1Z4b076A4une81+z03Kg7l7mn/48PUTqoLptSXez8oknU8Clg==}
    engines: {node: ^18.18.0 || ^20.9.0 || >=21.1.0}

  esquery@1.6.0:
    resolution: {integrity: sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==}
    engines: {node: '>=0.10'}

  esrecurse@4.3.0:
    resolution: {integrity: sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==}
    engines: {node: '>=4.0'}

  estraverse@5.3.0:
    resolution: {integrity: sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==}
    engines: {node: '>=4.0'}

  esutils@2.0.3:
    resolution: {integrity: sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==}
    engines: {node: '>=0.10.0'}

  etag@1.8.1:
    resolution: {integrity: sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==}
    engines: {node: '>= 0.6'}

  eventemitter3@5.0.1:
    resolution: {integrity: sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==}

  events@1.1.1:
    resolution: {integrity: sha512-kEcvvCBByWXGnZy6JUlgAp2gBIUjfCAV6P6TgT1/aaQKcmuAEC4OZTV1I4EWQLz2gxZw76atuVyvHhTxvi0Flw==}
    engines: {node: '>=0.4.x'}

  eventsource-parser@3.0.1:
    resolution: {integrity: sha512-VARTJ9CYeuQYb0pZEPbzi740OWFgpHe7AYJ2WFZVnUDUQp5Dk2yJUgF36YsZ81cOyxT0QxmXD2EQpapAouzWVA==}
    engines: {node: '>=18.0.0'}

  eventsource@3.0.7:
    resolution: {integrity: sha512-CRT1WTyuQoD771GW56XEZFQ/ZoSfWid1alKGDYMmkt2yl8UXrVR4pspqWNEcqKvVIzg6PAltWjxcSSPrboA4iA==}
    engines: {node: '>=18.0.0'}

  express-rate-limit@7.5.0:
    resolution: {integrity: sha512-eB5zbQh5h+VenMPM3fh+nw1YExi5nMr6HUCR62ELSP11huvxm/Uir1H1QEyTkk5QX6A58pX6NmaTMceKZ0Eodg==}
    engines: {node: '>= 16'}
    peerDependencies:
      express: ^4.11 || 5 || ^5.0.0-beta.1

  express@5.1.0:
    resolution: {integrity: sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==}
    engines: {node: '>= 18'}

  extend@3.0.2:
    resolution: {integrity: sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==}

  fast-deep-equal@3.1.3:
    resolution: {integrity: sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==}

  fast-json-stable-stringify@2.1.0:
    resolution: {integrity: sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==}

  fast-levenshtein@2.0.6:
    resolution: {integrity: sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==}

  fast-xml-parser@4.4.1:
    resolution: {integrity: sha512-xkjOecfnKGkSsOwtZ5Pz7Us/T6mrbPQrq0nh+aCO5V9nk5NLWmasAHumTKjiPJPWANe+kAZ84Jc8ooJkzZ88Sw==}
    hasBin: true

  fecha@4.2.3:
    resolution: {integrity: sha512-OP2IUU6HeYKJi3i0z4A19kHMQoLVs4Hc+DPqqxI2h/DPZHTm/vjsfC6P0b4jCMy14XizLBqvndQ+UilD7707Jw==}

  file-entry-cache@8.0.0:
    resolution: {integrity: sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==}
    engines: {node: '>=16.0.0'}

  filelist@1.0.4:
    resolution: {integrity: sha512-w1cEuf3S+DrLCQL7ET6kz+gmlJdbq9J7yXCSjK/OZCPA+qEN1WyF4ZAf0YYJa4/shHJra2t/d/r8SV4Ji+x+8Q==}

  fill-range@7.1.1:
    resolution: {integrity: sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==}
    engines: {node: '>=8'}

  finalhandler@2.1.0:
    resolution: {integrity: sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==}
    engines: {node: '>= 0.8'}

  find-up@5.0.0:
    resolution: {integrity: sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==}
    engines: {node: '>=10'}

  flat-cache@4.0.1:
    resolution: {integrity: sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==}
    engines: {node: '>=16'}

  flatted@3.3.3:
    resolution: {integrity: sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==}

  fn.name@1.1.0:
    resolution: {integrity: sha512-GRnmB5gPyJpAhTQdSZTSp9uaPSvl09KoYcMQtsB9rQoOmzs9dH6ffeccH+Z+cv6P68Hu5bC6JjRh4Ah/mHSNRw==}

  follow-redirects@1.15.9:
    resolution: {integrity: sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ==}
    engines: {node: '>=4.0'}
    peerDependencies:
      debug: '*'
    peerDependenciesMeta:
      debug:
        optional: true

  fontkit@1.9.0:
    resolution: {integrity: sha512-HkW/8Lrk8jl18kzQHvAw9aTHe1cqsyx5sDnxncx652+CIfhawokEPkeM3BoIC+z/Xv7a0yMr0f3pRRwhGH455g==}

  for-each@0.3.5:
    resolution: {integrity: sha512-dKx12eRCVIzqCxFGplyFKJMPvLEWgmNtUrpTiJIR5u97zEhRG8ySrtboPHZXx7daLxQVrl643cTzbab2tkQjxg==}
    engines: {node: '>= 0.4'}

  form-data@4.0.2:
    resolution: {integrity: sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==}
    engines: {node: '>= 6'}

  forwarded@0.2.0:
    resolution: {integrity: sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==}
    engines: {node: '>= 0.6'}

  fresh@2.0.0:
    resolution: {integrity: sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==}
    engines: {node: '>= 0.8'}

  fs.realpath@1.0.0:
    resolution: {integrity: sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  function-bind@1.1.2:
    resolution: {integrity: sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==}

  function.prototype.name@1.1.8:
    resolution: {integrity: sha512-e5iwyodOHhbMr/yNrc7fDYG4qlbIvI5gajyzPnb5TCwyhjApznQh1BMFou9b30SevY43gCJKXycoCBjMbsuW0Q==}
    engines: {node: '>= 0.4'}

  functions-have-names@1.2.3:
    resolution: {integrity: sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==}

  gaxios@6.7.1:
    resolution: {integrity: sha512-LDODD4TMYx7XXdpwxAVRAIAuB0bzv0s+ywFonY46k126qzQHT9ygyoa9tncmOiQmmDrik65UYsEkv3lbfqQ3yQ==}
    engines: {node: '>=14'}

  gcp-metadata@6.1.1:
    resolution: {integrity: sha512-a4tiq7E0/5fTjxPAaH4jpjkSv/uCaU2p5KC6HVGrvl0cDjA8iBZv4vv1gyzlmK0ZUKqwpOyQMKzZQe3lTit77A==}
    engines: {node: '>=14'}

  get-east-asian-width@1.3.0:
    resolution: {integrity: sha512-vpeMIQKxczTD/0s2CdEWHcb0eeJe6TFjxb+J5xgX7hScxqrGuyjmv4c1D4A/gelKfyox0gJJwIHF+fLjeaM8kQ==}
    engines: {node: '>=18'}

  get-intrinsic@1.3.0:
    resolution: {integrity: sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==}
    engines: {node: '>= 0.4'}

  get-proto@1.0.1:
    resolution: {integrity: sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==}
    engines: {node: '>= 0.4'}

  get-symbol-description@1.1.0:
    resolution: {integrity: sha512-w9UMqWwJxHNOvoNzSJ2oPF5wvYcvP7jUvYzhp67yEhTi17ZDBBC1z9pTdGuzjD+EFIqLSYRweZjqfiPzQ06Ebg==}
    engines: {node: '>= 0.4'}

  glob-parent@5.1.2:
    resolution: {integrity: sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==}
    engines: {node: '>= 6'}

  glob-parent@6.0.2:
    resolution: {integrity: sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==}
    engines: {node: '>=10.13.0'}

  glob@7.1.6:
    resolution: {integrity: sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==}
    deprecated: Glob versions prior to v9 are no longer supported

  glob@7.2.3:
    resolution: {integrity: sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==}
    deprecated: Glob versions prior to v9 are no longer supported

  globals@14.0.0:
    resolution: {integrity: sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==}
    engines: {node: '>=18'}

  globalthis@1.0.4:
    resolution: {integrity: sha512-DpLKbNU4WylpxJykQujfCcwYWiV/Jhm50Goo0wrVILAv5jOr9d+H+UR3PhSCD2rCCEIg0uc+G+muBTwD54JhDQ==}
    engines: {node: '>= 0.4'}

  google-auth-library@9.15.1:
    resolution: {integrity: sha512-Jb6Z0+nvECVz+2lzSMt9u98UsoakXxA2HGHMCxh+so3n90XgYWkq5dur19JAJV7ONiJY22yBTyJB1TSkvPq9Ng==}
    engines: {node: '>=14'}

  google-logging-utils@0.0.2:
    resolution: {integrity: sha512-NEgUnEcBiP5HrPzufUkBzJOD/Sxsco3rLNo1F1TNf7ieU8ryUzBhqba8r756CjLX7rn3fHl6iLEwPYuqpoKgQQ==}
    engines: {node: '>=14'}

  gopd@1.2.0:
    resolution: {integrity: sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==}
    engines: {node: '>= 0.4'}

  gtoken@7.1.0:
    resolution: {integrity: sha512-pCcEwRi+TKpMlxAQObHDQ56KawURgyAf6jtIY046fJ5tIv3zDe/LEIubckAO8fj6JnAxLdmWkUfNyulQ2iKdEw==}
    engines: {node: '>=14.0.0'}

  has-bigints@1.1.0:
    resolution: {integrity: sha512-R3pbpkcIqv2Pm3dUwgjclDRVmWpTJW2DcMzcIhEXEx1oh/CEMObMm3KLmRJOdvhM7o4uQBnwr8pzRK2sJWIqfg==}
    engines: {node: '>= 0.4'}

  has-flag@4.0.0:
    resolution: {integrity: sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==}
    engines: {node: '>=8'}

  has-property-descriptors@1.0.2:
    resolution: {integrity: sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==}

  has-proto@1.2.0:
    resolution: {integrity: sha512-KIL7eQPfHQRC8+XluaIw7BHUwwqL19bQn4hzNgdr+1wXoU0KKj6rufu47lhY7KbJR2C6T6+PfyN0Ea7wkSS+qQ==}
    engines: {node: '>= 0.4'}

  has-symbols@1.1.0:
    resolution: {integrity: sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==}
    engines: {node: '>= 0.4'}

  has-tostringtag@1.0.2:
    resolution: {integrity: sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==}
    engines: {node: '>= 0.4'}

  hasown@2.0.2:
    resolution: {integrity: sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==}
    engines: {node: '>= 0.4'}

  helmet@8.1.0:
    resolution: {integrity: sha512-jOiHyAZsmnr8LqoPGmCjYAaiuWwjAPLgY8ZX2XrmHawt99/u1y6RgrZMTeoPfpUbV96HOalYgz1qzkRbw54Pmg==}
    engines: {node: '>=18.0.0'}

  hpp@0.2.3:
    resolution: {integrity: sha512-4zDZypjQcxK/8pfFNR7jaON7zEUpXZxz4viyFmqjb3kWNWAHsLEUmWXcdn25c5l76ISvnD6hbOGO97cXUI3Ryw==}
    engines: {node: '>=0.10.0'}

  http-errors@2.0.0:
    resolution: {integrity: sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==}
    engines: {node: '>= 0.8'}

  https-proxy-agent@7.0.6:
    resolution: {integrity: sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==}
    engines: {node: '>= 14'}

  husky@9.1.7:
    resolution: {integrity: sha512-5gs5ytaNjBrh5Ow3zrvdUUY+0VxIuWVL4i9irt6friV+BqdCfmV11CQTWMiBYWHbXhco+J1kHfTOUkePhCDvMA==}
    engines: {node: '>=18'}
    hasBin: true

  iconv-lite@0.6.3:
    resolution: {integrity: sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==}
    engines: {node: '>=0.10.0'}

  ieee754@1.1.13:
    resolution: {integrity: sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg==}

  ignore@5.3.2:
    resolution: {integrity: sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==}
    engines: {node: '>= 4'}

  import-fresh@3.3.1:
    resolution: {integrity: sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==}
    engines: {node: '>=6'}

  imurmurhash@0.1.4:
    resolution: {integrity: sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==}
    engines: {node: '>=0.8.19'}

  inflight@1.0.6:
    resolution: {integrity: sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==}
    deprecated: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.

  inherits@2.0.3:
    resolution: {integrity: sha512-x00IRNXNy63jwGkJmzPigoySHbaqpNuzKbBOmzK+g2OdZpQ9w+sxCN+VSB3ja7IAge2OP2qpfxTjeNcyjmW1uw==}

  inherits@2.0.4:
    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}

  internal-slot@1.1.0:
    resolution: {integrity: sha512-4gd7VpWNQNB4UKKCFFVcp1AVv+FMOgs9NKzjHKusc8jTMhd5eL1NqQqOpE0KzMds804/yHlglp3uxgluOqAPLw==}
    engines: {node: '>= 0.4'}

  ipaddr.js@1.9.1:
    resolution: {integrity: sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==}
    engines: {node: '>= 0.10'}

  is-arguments@1.2.0:
    resolution: {integrity: sha512-7bVbi0huj/wrIAOzb8U1aszg9kdi3KN/CyU19CTI7tAoZYEZoL9yCDXpbXN+uPsuWnP02cyug1gleqq+TU+YCA==}
    engines: {node: '>= 0.4'}

  is-array-buffer@3.0.5:
    resolution: {integrity: sha512-DDfANUiiG2wC1qawP66qlTugJeL5HyzMpfr8lLK+jMQirGzNod0B12cFB/9q838Ru27sBwfw78/rdoU7RERz6A==}
    engines: {node: '>= 0.4'}

  is-arrayish@0.3.2:
    resolution: {integrity: sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ==}

  is-async-function@2.1.1:
    resolution: {integrity: sha512-9dgM/cZBnNvjzaMYHVoxxfPj2QXt22Ev7SuuPrs+xav0ukGB0S6d4ydZdEiM48kLx5kDV+QBPrpVnFyefL8kkQ==}
    engines: {node: '>= 0.4'}

  is-bigint@1.1.0:
    resolution: {integrity: sha512-n4ZT37wG78iz03xPRKJrHTdZbe3IicyucEtdRsV5yglwc3GyUfbAfpSeD0FJ41NbUNSt5wbhqfp1fS+BgnvDFQ==}
    engines: {node: '>= 0.4'}

  is-binary-path@2.1.0:
    resolution: {integrity: sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==}
    engines: {node: '>=8'}

  is-boolean-object@1.2.2:
    resolution: {integrity: sha512-wa56o2/ElJMYqjCjGkXri7it5FbebW5usLw/nPmCMs5DeZ7eziSYZhSmPRn0txqeW4LnAmQQU7FgqLpsEFKM4A==}
    engines: {node: '>= 0.4'}

  is-callable@1.2.7:
    resolution: {integrity: sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==}
    engines: {node: '>= 0.4'}

  is-core-module@2.16.1:
    resolution: {integrity: sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==}
    engines: {node: '>= 0.4'}

  is-data-view@1.0.2:
    resolution: {integrity: sha512-RKtWF8pGmS87i2D6gqQu/l7EYRlVdfzemCJN/P3UOs//x1QE7mfhvzHIApBTRf7axvT6DMGwSwBXYCT0nfB9xw==}
    engines: {node: '>= 0.4'}

  is-date-object@1.1.0:
    resolution: {integrity: sha512-PwwhEakHVKTdRNVOw+/Gyh0+MzlCl4R6qKvkhuvLtPMggI1WAHt9sOwZxQLSGpUaDnrdyDsomoRgNnCfKNSXXg==}
    engines: {node: '>= 0.4'}

  is-extglob@2.1.1:
    resolution: {integrity: sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==}
    engines: {node: '>=0.10.0'}

  is-finalizationregistry@1.1.1:
    resolution: {integrity: sha512-1pC6N8qWJbWoPtEjgcL2xyhQOP491EQjeUo3qTKcmV8YSDDJrOepfG8pcC7h/QgnQHYSv0mJ3Z/ZWxmatVrysg==}
    engines: {node: '>= 0.4'}

  is-fullwidth-code-point@4.0.0:
    resolution: {integrity: sha512-O4L094N2/dZ7xqVdrXhh9r1KODPJpFms8B5sGdJLPy664AgvXsreZUyCQQNItZRDlYug4xStLjNp/sz3HvBowQ==}
    engines: {node: '>=12'}

  is-fullwidth-code-point@5.0.0:
    resolution: {integrity: sha512-OVa3u9kkBbw7b8Xw5F9P+D/T9X+Z4+JruYVNapTjPYZYUznQ5YfWeFkOj606XYYW8yugTfC8Pj0hYqvi4ryAhA==}
    engines: {node: '>=18'}

  is-generator-function@1.1.0:
    resolution: {integrity: sha512-nPUB5km40q9e8UfN/Zc24eLlzdSf9OfKByBw9CIdw4H1giPMeA0OIJvbchsCu4npfI2QcMVBsGEBHKZ7wLTWmQ==}
    engines: {node: '>= 0.4'}

  is-glob@4.0.3:
    resolution: {integrity: sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==}
    engines: {node: '>=0.10.0'}

  is-map@2.0.3:
    resolution: {integrity: sha512-1Qed0/Hr2m+YqxnM09CjA2d/i6YZNfF6R2oRAOj36eUdS6qIV/huPJNSEpKbupewFs+ZsJlxsjjPbc0/afW6Lw==}
    engines: {node: '>= 0.4'}

  is-number-object@1.1.1:
    resolution: {integrity: sha512-lZhclumE1G6VYD8VHe35wFaIif+CTy5SJIi5+3y4psDgWu4wPDoBhF8NxUOinEc7pHgiTsT6MaBb92rKhhD+Xw==}
    engines: {node: '>= 0.4'}

  is-number@7.0.0:
    resolution: {integrity: sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==}
    engines: {node: '>=0.12.0'}

  is-promise@4.0.0:
    resolution: {integrity: sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==}

  is-regex@1.2.1:
    resolution: {integrity: sha512-MjYsKHO5O7mCsmRGxWcLWheFqN9DJ/2TmngvjKXihe6efViPqc274+Fx/4fYj/r03+ESvBdTXK0V6tA3rgez1g==}
    engines: {node: '>= 0.4'}

  is-set@2.0.3:
    resolution: {integrity: sha512-iPAjerrse27/ygGLxw+EBR9agv9Y6uLeYVJMu+QNCoouJ1/1ri0mGrcWpfCqFZuzzx3WjtwxG098X+n4OuRkPg==}
    engines: {node: '>= 0.4'}

  is-shared-array-buffer@1.0.4:
    resolution: {integrity: sha512-ISWac8drv4ZGfwKl5slpHG9OwPNty4jOWPRIhBpxOoD+hqITiwuipOQ2bNthAzwA3B4fIjO4Nln74N0S9byq8A==}
    engines: {node: '>= 0.4'}

  is-stream@2.0.1:
    resolution: {integrity: sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==}
    engines: {node: '>=8'}

  is-string@1.1.1:
    resolution: {integrity: sha512-BtEeSsoaQjlSPBemMQIrY1MY0uM6vnS1g5fmufYOtnxLGUZM2178PKbhsk7Ffv58IX+ZtcvoGwccYsh0PglkAA==}
    engines: {node: '>= 0.4'}

  is-symbol@1.1.1:
    resolution: {integrity: sha512-9gGx6GTtCQM73BgmHQXfDmLtfjjTUDSyoxTCbp5WtoixAhfgsDirWIcVQ/IHpvI5Vgd5i/J5F7B9cN/WlVbC/w==}
    engines: {node: '>= 0.4'}

  is-typed-array@1.1.15:
    resolution: {integrity: sha512-p3EcsicXjit7SaskXHs1hA91QxgTw46Fv6EFKKGS5DRFLD8yKnohjF3hxoju94b/OcMZoQukzpPpBE9uLVKzgQ==}
    engines: {node: '>= 0.4'}

  is-weakmap@2.0.2:
    resolution: {integrity: sha512-K5pXYOm9wqY1RgjpL3YTkF39tni1XajUIkawTLUo9EZEVUFga5gSQJF8nNS7ZwJQ02y+1YCNYcMh+HIf1ZqE+w==}
    engines: {node: '>= 0.4'}

  is-weakref@1.1.1:
    resolution: {integrity: sha512-6i9mGWSlqzNMEqpCp93KwRS1uUOodk2OJ6b+sq7ZPDSy2WuI5NFIxp/254TytR8ftefexkWn5xNiHUNpPOfSew==}
    engines: {node: '>= 0.4'}

  is-weakset@2.0.4:
    resolution: {integrity: sha512-mfcwb6IzQyOKTs84CQMrOwW4gQcaTOAWJ0zzJCl2WSPDrWk/OzDaImWFH3djXhb24g4eudZfLRozAvPGw4d9hQ==}
    engines: {node: '>= 0.4'}

  isarray@1.0.0:
    resolution: {integrity: sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==}

  isarray@2.0.5:
    resolution: {integrity: sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==}

  isexe@2.0.0:
    resolution: {integrity: sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==}

  jake@10.9.2:
    resolution: {integrity: sha512-2P4SQ0HrLQ+fw6llpLnOaGAvN2Zu6778SJMrCUwns4fOoG9ayrTiZk3VV8sCPkVZF8ab0zksVpS8FDY5pRCNBA==}
    engines: {node: '>=10'}
    hasBin: true

  jmespath@0.16.0:
    resolution: {integrity: sha512-9FzQjJ7MATs1tSpnco1K6ayiYE3figslrXA72G2HQ/n76RzvYlofyi5QM+iX4YRs/pu3yzxlVQSST23+dMDknw==}
    engines: {node: '>= 0.6.0'}

  js-yaml@4.1.0:
    resolution: {integrity: sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==}
    hasBin: true

  json-bigint@1.0.0:
    resolution: {integrity: sha512-SiPv/8VpZuWbvLSMtTDU8hEfrZWg/mH/nV/b4o0CYbSxu1UIQPLdwKOCIyLQX+VIPO5vrLX3i8qtqFyhdPSUSQ==}

  json-buffer@3.0.1:
    resolution: {integrity: sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==}

  json-schema-traverse@0.4.1:
    resolution: {integrity: sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==}

  json-stable-stringify-without-jsonify@1.0.1:
    resolution: {integrity: sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==}

  json5@1.0.2:
    resolution: {integrity: sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==}
    hasBin: true

  jsonwebtoken@9.0.2:
    resolution: {integrity: sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==}
    engines: {node: '>=12', npm: '>=6'}

  jwa@1.4.2:
    resolution: {integrity: sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==}

  jwa@2.0.1:
    resolution: {integrity: sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==}

  jws@3.2.2:
    resolution: {integrity: sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==}

  jws@4.0.0:
    resolution: {integrity: sha512-KDncfTmOZoOMTFG4mBlG0qUIOlc03fmzH+ru6RgYVZhPkyiy/92Owlt/8UEN+a4TXR1FQetfIpJE8ApdvdVxTg==}

  kareem@2.6.3:
    resolution: {integrity: sha512-C3iHfuGUXK2u8/ipq9LfjFfXFxAZMQJJq7vLS45r3D9Y2xQ/m4S8zaR4zMLFWh9AsNPXmcFfUDhTEO8UIC/V6Q==}
    engines: {node: '>=12.0.0'}

  keyv@4.5.4:
    resolution: {integrity: sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==}

  kuler@2.0.0:
    resolution: {integrity: sha512-Xq9nH7KlWZmXAtodXDDRE7vs6DU1gTU8zYDHDiWLSip45Egwq3plLHzPn27NgvzL2r1LMPC1vdqh98sQxtqj4A==}

  levn@0.4.1:
    resolution: {integrity: sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==}
    engines: {node: '>= 0.8.0'}

  libphonenumber-js@1.12.8:
    resolution: {integrity: sha512-f1KakiQJa9tdc7w1phC2ST+DyxWimy9c3g3yeF+84QtEanJr2K77wAmBPP22riU05xldniHsvXuflnLZ4oysqA==}

  lilconfig@3.1.3:
    resolution: {integrity: sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==}
    engines: {node: '>=14'}

  linebreak@1.1.0:
    resolution: {integrity: sha512-MHp03UImeVhB7XZtjd0E4n6+3xr5Dq/9xI/5FptGk5FrbDR3zagPa2DS6U8ks/3HjbKWG9Q1M2ufOzxV2qLYSQ==}

  lint-staged@16.0.0:
    resolution: {integrity: sha512-sUCprePs6/rbx4vKC60Hez6X10HPkpDJaGcy3D1NdwR7g1RcNkWL8q9mJMreOqmHBTs+1sNFp+wOiX9fr+hoOQ==}
    engines: {node: '>=20.18'}
    hasBin: true

  listr2@8.3.3:
    resolution: {integrity: sha512-LWzX2KsqcB1wqQ4AHgYb4RsDXauQiqhjLk+6hjbaeHG4zpjjVAB6wC/gz6X0l+Du1cN3pUB5ZlrvTbhGSNnUQQ==}
    engines: {node: '>=18.0.0'}

  locate-path@6.0.0:
    resolution: {integrity: sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==}
    engines: {node: '>=10'}

  lodash.get@4.4.2:
    resolution: {integrity: sha512-z+Uw/vLuy6gQe8cfaFWD7p0wVv8fJl3mbzXh33RS+0oW2wvUqiRXiQ69gLWSLpgB5/6sU+r6BlQR0MBILadqTQ==}
    deprecated: This package is deprecated. Use the optional chaining (?.) operator instead.

  lodash.includes@4.3.0:
    resolution: {integrity: sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==}

  lodash.isboolean@3.0.3:
    resolution: {integrity: sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==}

  lodash.isequal@4.5.0:
    resolution: {integrity: sha512-pDo3lu8Jhfjqls6GkMgpahsF9kCyayhgykjyLMNFTKWrpVdAQtYyB4muAMWozBB4ig/dtWAmsMxLEI8wuz+DYQ==}
    deprecated: This package is deprecated. Use require('node:util').isDeepStrictEqual instead.

  lodash.isinteger@4.0.4:
    resolution: {integrity: sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==}

  lodash.isnumber@3.0.3:
    resolution: {integrity: sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==}

  lodash.isplainobject@4.0.6:
    resolution: {integrity: sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==}

  lodash.isstring@4.0.1:
    resolution: {integrity: sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==}

  lodash.merge@4.6.2:
    resolution: {integrity: sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==}

  lodash.mergewith@4.6.2:
    resolution: {integrity: sha512-GK3g5RPZWTRSeLSpgP8Xhra+pnjBC56q9FZYe1d5RN3TJ35dbkGy3YqBSMbyCrlbi+CM9Z3Jk5yTL7RCsqboyQ==}

  lodash.once@4.1.1:
    resolution: {integrity: sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==}

  lodash@4.17.21:
    resolution: {integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==}

  log-update@6.1.0:
    resolution: {integrity: sha512-9ie8ItPR6tjY5uYJh8K/Zrv/RMZ5VOlOWvtZdEHYSTFKZfIBPQa9tOAEeAWhd+AnIneLJ22w5fjOYtoutpWq5w==}
    engines: {node: '>=18'}

  logform@2.7.0:
    resolution: {integrity: sha512-TFYA4jnP7PVbmlBIfhlSe+WKxs9dklXMTEGcBCIvLhE/Tn3H6Gk1norupVW7m5Cnd4bLcr08AytbyV/xj7f/kQ==}
    engines: {node: '>= 12.0.0'}

  make-error@1.3.6:
    resolution: {integrity: sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==}

  math-intrinsics@1.1.0:
    resolution: {integrity: sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==}
    engines: {node: '>= 0.4'}

  media-typer@0.3.0:
    resolution: {integrity: sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==}
    engines: {node: '>= 0.6'}

  media-typer@1.1.0:
    resolution: {integrity: sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==}
    engines: {node: '>= 0.8'}

  memory-pager@1.5.0:
    resolution: {integrity: sha512-ZS4Bp4r/Zoeq6+NLJpP+0Zzm0pR8whtGPf1XExKLJBAczGMnSi3It14OiNCStjQjM6NU1okjQGSxgEZN8eBYKg==}

  merge-descriptors@2.0.0:
    resolution: {integrity: sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==}
    engines: {node: '>=18'}

  micromatch@4.0.8:
    resolution: {integrity: sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==}
    engines: {node: '>=8.6'}

  mime-db@1.52.0:
    resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
    engines: {node: '>= 0.6'}

  mime-db@1.54.0:
    resolution: {integrity: sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==}
    engines: {node: '>= 0.6'}

  mime-types@2.1.35:
    resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}
    engines: {node: '>= 0.6'}

  mime-types@3.0.1:
    resolution: {integrity: sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==}
    engines: {node: '>= 0.6'}

  mimic-function@5.0.1:
    resolution: {integrity: sha512-VP79XUPxV2CigYP3jWwAUFSku2aKqBH7uTAapFWCBqutsbmDo96KY5o8uh6U+/YSIn5OxJnXp73beVkpqMIGhA==}
    engines: {node: '>=18'}

  minimatch@3.1.2:
    resolution: {integrity: sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==}

  minimatch@5.1.6:
    resolution: {integrity: sha512-lKwV/1brpG6mBUFHtb7NUmtABCb2WZZmm2wNiOA5hAb8VdCS4B3dtMWyvcoViccwAW/COERjXLt0zP1zXUN26g==}
    engines: {node: '>=10'}

  minimist@1.2.8:
    resolution: {integrity: sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==}

  mkdirp@0.5.6:
    resolution: {integrity: sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==}
    hasBin: true

  mkdirp@1.0.4:
    resolution: {integrity: sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==}
    engines: {node: '>=10'}
    hasBin: true

  moment@2.30.1:
    resolution: {integrity: sha512-uEmtNhbDOrWPFS+hdjFCBfy9f2YoyzRpwcl+DqpC6taX21FzsTLQVbMV/W7PzNSX6x/bhC1zA3c2UQ5NzH6how==}

  mongodb-connection-string-url@3.0.2:
    resolution: {integrity: sha512-rMO7CGo/9BFwyZABcKAWL8UJwH/Kc2x0g72uhDWzG48URRax5TCIcJ7Rc3RZqffZzO/Gwff/jyKwCU9TN8gehA==}

  mongodb@6.16.0:
    resolution: {integrity: sha512-D1PNcdT0y4Grhou5Zi/qgipZOYeWrhLEpk33n3nm6LGtz61jvO88WlrWCK/bigMjpnOdAUKKQwsGIl0NtWMyYw==}
    engines: {node: '>=16.20.1'}
    peerDependencies:
      '@aws-sdk/credential-providers': ^3.188.0
      '@mongodb-js/zstd': ^1.1.0 || ^2.0.0
      gcp-metadata: ^5.2.0
      kerberos: ^2.0.1
      mongodb-client-encryption: '>=6.0.0 <7'
      snappy: ^7.2.2
      socks: ^2.7.1
    peerDependenciesMeta:
      '@aws-sdk/credential-providers':
        optional: true
      '@mongodb-js/zstd':
        optional: true
      gcp-metadata:
        optional: true
      kerberos:
        optional: true
      mongodb-client-encryption:
        optional: true
      snappy:
        optional: true
      socks:
        optional: true

  mongoose@8.14.3:
    resolution: {integrity: sha512-BiIQK4mZiStUgnNep1YJMMYTiC4K893+Dj/Sr3lvxXutqy4+yZMVhlHq60xRH3r/l6eXkQXO3tXJnVOE5g592Q==}
    engines: {node: '>=16.20.1'}

  morgan@1.10.0:
    resolution: {integrity: sha512-AbegBVI4sh6El+1gNwvD5YIck7nSA36weD7xvIxG4in80j/UoK8AEGaWnnz8v1GxonMCltmlNs5ZKbGvl9b1XQ==}
    engines: {node: '>= 0.8.0'}

  mpath@0.9.0:
    resolution: {integrity: sha512-ikJRQTk8hw5DEoFVxHG1Gn9T/xcjtdnOKIU1JTmGjZZlg9LST2mBLmcX3/ICIbgJydT2GOc15RnNy5mHmzfSew==}
    engines: {node: '>=4.0.0'}

  mquery@5.0.0:
    resolution: {integrity: sha512-iQMncpmEK8R8ncT8HJGsGc9Dsp8xcgYMVSbs5jgnm1lFHTZqMJTUWTDx1LBO8+mK3tPNZWFLBghQEIOULSTHZg==}
    engines: {node: '>=14.0.0'}

  ms@2.0.0:
    resolution: {integrity: sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==}

  ms@2.1.3:
    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}

  multer@2.0.0:
    resolution: {integrity: sha512-bS8rPZurbAuHGAnApbM9d4h1wSoYqrOqkE+6a64KLMK9yWU7gJXBDDVklKQ3TPi9DRb85cRs6yXaC0+cjxRtRg==}
    engines: {node: '>= 10.16.0'}

  nano-spawn@1.0.1:
    resolution: {integrity: sha512-BfcvzBlUTxSDWfT+oH7vd6CbUV+rThLLHCIym/QO6GGLBsyVXleZs00fto2i2jzC/wPiBYk5jyOmpXWg4YopiA==}
    engines: {node: '>=20.18'}

  natural-compare@1.4.0:
    resolution: {integrity: sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==}

  negotiator@0.6.4:
    resolution: {integrity: sha512-myRT3DiWPHqho5PrJaIRyaMv2kgYf0mUVgBNOYMuCH5Ki1yEiQaf/ZJuQ62nvpc44wL5WDbTX7yGJi1Neevw8w==}
    engines: {node: '>= 0.6'}

  negotiator@1.0.0:
    resolution: {integrity: sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==}
    engines: {node: '>= 0.6'}

  node-fetch@2.7.0:
    resolution: {integrity: sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==}
    engines: {node: 4.x || >=6.0.0}
    peerDependencies:
      encoding: ^0.1.0
    peerDependenciesMeta:
      encoding:
        optional: true

  nodemailer@7.0.3:
    resolution: {integrity: sha512-Ajq6Sz1x7cIK3pN6KesGTah+1gnwMnx5gKl3piQlQQE/PwyJ4Mbc8is2psWYxK3RJTVeqsDaCv8ZzXLCDHMTZw==}
    engines: {node: '>=6.0.0'}

  normalize-path@3.0.0:
    resolution: {integrity: sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==}
    engines: {node: '>=0.10.0'}

  object-assign@4.1.1:
    resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
    engines: {node: '>=0.10.0'}

  object-inspect@1.13.4:
    resolution: {integrity: sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==}
    engines: {node: '>= 0.4'}

  object-is@1.1.6:
    resolution: {integrity: sha512-F8cZ+KfGlSGi09lJT7/Nd6KJZ9ygtvYC0/UYYLI9nmQKLMnydpB9yvbv9K1uSkEu7FU9vYPmVwLg328tX+ot3Q==}
    engines: {node: '>= 0.4'}

  object-keys@1.1.1:
    resolution: {integrity: sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==}
    engines: {node: '>= 0.4'}

  object.assign@4.1.7:
    resolution: {integrity: sha512-nK28WOo+QIjBkDduTINE4JkF/UJJKyf2EJxvJKfblDpyg0Q+pkOHNTL0Qwy6NP6FhE/EnzV73BxxqcJaXY9anw==}
    engines: {node: '>= 0.4'}

  object.fromentries@2.0.8:
    resolution: {integrity: sha512-k6E21FzySsSK5a21KRADBd/NGneRegFO5pLHfdQLpRDETUNJueLXs3WCzyQ3tFRDYgbq3KHGXfTbi2bs8WQ6rQ==}
    engines: {node: '>= 0.4'}

  object.groupby@1.0.3:
    resolution: {integrity: sha512-+Lhy3TQTuzXI5hevh8sBGqbmurHbbIjAi0Z4S63nthVLmLxfbj4T54a4CfZrXIrt9iP4mVAPYMo/v99taj3wjQ==}
    engines: {node: '>= 0.4'}

  object.values@1.2.1:
    resolution: {integrity: sha512-gXah6aZrcUxjWg2zR2MwouP2eHlCBzdV4pygudehaKXSGW4v2AsRQUK+lwwXhii6KFZcunEnmSUoYp5CXibxtA==}
    engines: {node: '>= 0.4'}

  on-finished@2.3.0:
    resolution: {integrity: sha512-ikqdkGAAyf/X/gPhXGvfgAytDZtDbr+bkNUJ0N9h5MI/dmdgCs3l6hoHrcUv41sRKew3jIwrp4qQDXiK99Utww==}
    engines: {node: '>= 0.8'}

  on-finished@2.4.1:
    resolution: {integrity: sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==}
    engines: {node: '>= 0.8'}

  on-headers@1.0.2:
    resolution: {integrity: sha512-pZAE+FJLoyITytdqK0U5s+FIpjN0JP3OzFi/u8Rx+EV5/W+JTWGXG8xFzevE7AjBfDqHv/8vL8qQsIhHnqRkrA==}
    engines: {node: '>= 0.8'}

  once@1.4.0:
    resolution: {integrity: sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==}

  one-time@1.0.0:
    resolution: {integrity: sha512-5DXOiRKwuSEcQ/l0kGCF6Q3jcADFv5tSmRaJck/OqkVFcOzutB134KRSfF0xDrL39MNnqxbHBbUUcjZIhTgb2g==}

  onetime@7.0.0:
    resolution: {integrity: sha512-VXJjc87FScF88uafS3JllDgvAm+c/Slfz06lorj2uAY34rlUu0Nt+v8wreiImcrgAjjIHp1rXpTDlLOGw29WwQ==}
    engines: {node: '>=18'}

  openapi-types@12.1.3:
    resolution: {integrity: sha512-N4YtSYJqghVu4iek2ZUvcN/0aqH1kRDuNqzcycDxhOUpg7GdvLa2F3DgS6yBNhInhv2r/6I0Flkn7CqL8+nIcw==}

  optionator@0.9.4:
    resolution: {integrity: sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==}
    engines: {node: '>= 0.8.0'}

  own-keys@1.0.1:
    resolution: {integrity: sha512-qFOyK5PjiWZd+QQIh+1jhdb9LpxTF0qs7Pm8o5QHYZ0M3vKqSqzsZaEB6oWlxZ+q2sJBMI/Ktgd2N5ZwQoRHfg==}
    engines: {node: '>= 0.4'}

  p-limit@3.1.0:
    resolution: {integrity: sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==}
    engines: {node: '>=10'}

  p-locate@5.0.0:
    resolution: {integrity: sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==}
    engines: {node: '>=10'}

  pako@0.2.9:
    resolution: {integrity: sha512-NUcwaKxUxWrZLpDG+z/xZaCgQITkA/Dv4V/T6bw7VON6l1Xz/VnrBqrYjZQ12TamKHzITTfOEIYUj48y2KXImA==}

  parent-module@1.0.1:
    resolution: {integrity: sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==}
    engines: {node: '>=6'}

  parseurl@1.3.3:
    resolution: {integrity: sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==}
    engines: {node: '>= 0.8'}

  path-exists@4.0.0:
    resolution: {integrity: sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==}
    engines: {node: '>=8'}

  path-is-absolute@1.0.1:
    resolution: {integrity: sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==}
    engines: {node: '>=0.10.0'}

  path-key@3.1.1:
    resolution: {integrity: sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==}
    engines: {node: '>=8'}

  path-parse@1.0.7:
    resolution: {integrity: sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==}

  path-to-regexp@8.2.0:
    resolution: {integrity: sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==}
    engines: {node: '>=16'}

  path@0.12.7:
    resolution: {integrity: sha512-aXXC6s+1w7otVF9UletFkFcDsJeO7lSZBPUQhtb5O0xJe8LtYhj/GxldoL09bBj9+ZmE2hNoHqQSFMN5fikh4Q==}

  pdfkit@0.14.0:
    resolution: {integrity: sha512-Hnor8/78jhHm6ONrxWhrqOwAVALlBnFyWOF8sstBZMiqHZgZ5A6RU+Q3yahhw82plxpT7LOfH3b3qcOX6rzMQg==}

  picomatch@2.3.1:
    resolution: {integrity: sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==}
    engines: {node: '>=8.6'}

  pidtree@0.6.0:
    resolution: {integrity: sha512-eG2dWTVw5bzqGRztnHExczNxt5VGsE6OwTeCG3fdUf9KBsZzO3R5OIIIzWR+iZA0NtZ+RDVdaoE2dK1cn6jH4g==}
    engines: {node: '>=0.10'}
    hasBin: true

  pkce-challenge@5.0.0:
    resolution: {integrity: sha512-ueGLflrrnvwB3xuo/uGob5pd5FN7l0MsLf0Z87o/UQmRtwjvfylfc9MurIxRAWywCYTgrvpXBcqjV4OfCYGCIQ==}
    engines: {node: '>=16.20.0'}

  png-js@1.0.0:
    resolution: {integrity: sha512-k+YsbhpA9e+EFfKjTCH3VW6aoKlyNYI6NYdTfDL4CIvFnvsuO84ttonmZE7rc+v23SLTH8XX+5w/Ak9v0xGY4g==}

  possible-typed-array-names@1.1.0:
    resolution: {integrity: sha512-/+5VFTchJDoVj3bhoqi6UeymcD00DAwb1nJwamzPvHEszJ4FpF6SNNbUbOS8yI56qHzdV8eK0qEfOSiodkTdxg==}
    engines: {node: '>= 0.4'}

  prelude-ls@1.2.1:
    resolution: {integrity: sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==}
    engines: {node: '>= 0.8.0'}

  prettier@3.5.3:
    resolution: {integrity: sha512-QQtaxnoDJeAkDvDKWCLiwIXkTgRhwYDEQCghU9Z6q03iyek/rxRh/2lC3HB7P8sWT2xC/y5JDctPLBIGzHKbhw==}
    engines: {node: '>=14'}
    hasBin: true

  process-nextick-args@2.0.1:
    resolution: {integrity: sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag==}

  process@0.11.10:
    resolution: {integrity: sha512-cdGef/drWFoydD1JsMzuFf8100nZl+GT+yacc2bEced5f9Rjk4z+WtFUTBu9PhOi9j/jfmBPu0mMEY4wIdAF8A==}
    engines: {node: '>= 0.6.0'}

  proxy-addr@2.0.7:
    resolution: {integrity: sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==}
    engines: {node: '>= 0.10'}

  proxy-from-env@1.1.0:
    resolution: {integrity: sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==}

  punycode@1.3.2:
    resolution: {integrity: sha512-RofWgt/7fL5wP1Y7fxE7/EmTLzQVnB0ycyibJ0OOHIlJqTNzglYFxVwETOcIoJqJmpDXJ9xImDv+Fq34F/d4Dw==}

  punycode@2.3.1:
    resolution: {integrity: sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==}
    engines: {node: '>=6'}

  qs@6.14.0:
    resolution: {integrity: sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==}
    engines: {node: '>=0.6'}

  querystring@0.2.0:
    resolution: {integrity: sha512-X/xY82scca2tau62i9mDyU9K+I+djTMUsvwf7xnUX5GLvVzgJybOJf4Y6o9Zx3oJK/LSXg5tTZBjwzqVPaPO2g==}
    engines: {node: '>=0.4.x'}
    deprecated: The querystring API is considered Legacy. new code should use the URLSearchParams API instead.

  range-parser@1.2.1:
    resolution: {integrity: sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==}
    engines: {node: '>= 0.6'}

  raw-body@3.0.0:
    resolution: {integrity: sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==}
    engines: {node: '>= 0.8'}

  readable-stream@2.3.8:
    resolution: {integrity: sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==}

  readable-stream@3.6.2:
    resolution: {integrity: sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==}
    engines: {node: '>= 6'}

  readdirp@3.6.0:
    resolution: {integrity: sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==}
    engines: {node: '>=8.10.0'}

  reflect-metadata@0.2.2:
    resolution: {integrity: sha512-urBwgfrvVP/eAyXx4hluJivBKzuEbSQs9rKWCrCkbSxNv8mxPcUZKeuoF3Uy4mJl3Lwprp6yy5/39VWigZ4K6Q==}

  reflect.getprototypeof@1.0.10:
    resolution: {integrity: sha512-00o4I+DVrefhv+nX0ulyi3biSHCPDe+yLv5o/p6d/UVlirijB8E16FtfwSAi4g3tcqrQ4lRAqQSoFEZJehYEcw==}
    engines: {node: '>= 0.4'}

  regexp.prototype.flags@1.5.4:
    resolution: {integrity: sha512-dYqgNSZbDwkaJ2ceRd9ojCGjBq+mOm9LmtXnAnEGyHhN/5R7iDW2TRw3h+o/jCFxus3P2LfWIIiwowAjANm7IA==}
    engines: {node: '>= 0.4'}

  resolve-from@4.0.0:
    resolution: {integrity: sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==}
    engines: {node: '>=4'}

  resolve@1.22.10:
    resolution: {integrity: sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==}
    engines: {node: '>= 0.4'}
    hasBin: true

  restore-cursor@5.1.0:
    resolution: {integrity: sha512-oMA2dcrw6u0YfxJQXm342bFKX/E4sG9rbTzO9ptUcR/e8A33cHuvStiYOwH7fszkZlZ1z/ta9AAoPk2F4qIOHA==}
    engines: {node: '>=18'}

  restructure@2.0.1:
    resolution: {integrity: sha512-e0dOpjm5DseomnXx2M5lpdZ5zoHqF1+bqdMJUohoYVVQa7cBdnk7fdmeI6byNWP/kiME72EeTiSypTCVnpLiDg==}

  rfdc@1.4.1:
    resolution: {integrity: sha512-q1b3N5QkRUWUl7iyylaaj3kOpIT0N2i9MqIEQXP73GVsN9cw3fdx8X63cEmWhJGi2PPCF23Ijp7ktmd39rawIA==}

  rimraf@2.7.1:
    resolution: {integrity: sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==}
    deprecated: Rimraf versions prior to v4 are no longer supported
    hasBin: true

  router@2.2.0:
    resolution: {integrity: sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==}
    engines: {node: '>= 18'}

  safe-array-concat@1.1.3:
    resolution: {integrity: sha512-AURm5f0jYEOydBj7VQlVvDrjeFgthDdEF5H1dP+6mNpoXOMo1quQqJ4wvJDyRZ9+pO3kGWoOdmV08cSv2aJV6Q==}
    engines: {node: '>=0.4'}

  safe-buffer@5.1.2:
    resolution: {integrity: sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==}

  safe-buffer@5.2.1:
    resolution: {integrity: sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==}

  safe-push-apply@1.0.0:
    resolution: {integrity: sha512-iKE9w/Z7xCzUMIZqdBsp6pEQvwuEebH4vdpjcDWnyzaI6yl6O9FHvVpmGelvEHNsoY6wGblkxR6Zty/h00WiSA==}
    engines: {node: '>= 0.4'}

  safe-regex-test@1.1.0:
    resolution: {integrity: sha512-x/+Cz4YrimQxQccJf5mKEbIa1NzeCRNI5Ecl/ekmlYaampdNLPalVyIcCZNNH3MvmqBugV5TMYZXv0ljslUlaw==}
    engines: {node: '>= 0.4'}

  safe-stable-stringify@2.5.0:
    resolution: {integrity: sha512-b3rppTKm9T+PsVCBEOUR46GWI7fdOs00VKZ1+9c1EWDaDMvjQc6tUwuFyIprgGgTcWoVHSKrU8H31ZHA2e0RHA==}
    engines: {node: '>=10'}

  safer-buffer@2.1.2:
    resolution: {integrity: sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==}

  sax@1.2.1:
    resolution: {integrity: sha512-8I2a3LovHTOpm7NV5yOyO8IHqgVsfK4+UuySrXU8YXkSRX7k6hCV9b3HrkKCr3nMpgj+0bmocaJJWpvp1oc7ZA==}

  semver@6.3.1:
    resolution: {integrity: sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==}
    hasBin: true

  semver@7.7.2:
    resolution: {integrity: sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==}
    engines: {node: '>=10'}
    hasBin: true

  send@1.2.0:
    resolution: {integrity: sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==}
    engines: {node: '>= 18'}

  serve-static@2.2.0:
    resolution: {integrity: sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==}
    engines: {node: '>= 18'}

  set-function-length@1.2.2:
    resolution: {integrity: sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==}
    engines: {node: '>= 0.4'}

  set-function-name@2.0.2:
    resolution: {integrity: sha512-7PGFlmtwsEADb0WYyvCMa1t+yke6daIG4Wirafur5kcf+MhUnPms1UeR0CKQdTZD81yESwMHbtn+TR+dMviakQ==}
    engines: {node: '>= 0.4'}

  set-proto@1.0.0:
    resolution: {integrity: sha512-RJRdvCo6IAnPdsvP/7m6bsQqNnn1FCBX5ZNtFL98MmFF/4xAIJTIg1YbHW5DC2W5SKZanrC6i4HsJqlajw/dZw==}
    engines: {node: '>= 0.4'}

  setprototypeof@1.2.0:
    resolution: {integrity: sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==}

  shebang-command@2.0.0:
    resolution: {integrity: sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==}
    engines: {node: '>=8'}

  shebang-regex@3.0.0:
    resolution: {integrity: sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==}
    engines: {node: '>=8'}

  side-channel-list@1.0.0:
    resolution: {integrity: sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==}
    engines: {node: '>= 0.4'}

  side-channel-map@1.0.1:
    resolution: {integrity: sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==}
    engines: {node: '>= 0.4'}

  side-channel-weakmap@1.0.2:
    resolution: {integrity: sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==}
    engines: {node: '>= 0.4'}

  side-channel@1.1.0:
    resolution: {integrity: sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==}
    engines: {node: '>= 0.4'}

  sift@17.1.3:
    resolution: {integrity: sha512-Rtlj66/b0ICeFzYTuNvX/EF1igRbbnGSvEyT79McoZa/DeGhMyC5pWKOEsZKnpkqtSeovd5FL/bjHWC3CIIvCQ==}

  signal-exit@4.1.0:
    resolution: {integrity: sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==}
    engines: {node: '>=14'}

  simple-swizzle@0.2.2:
    resolution: {integrity: sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==}

  slice-ansi@5.0.0:
    resolution: {integrity: sha512-FC+lgizVPfie0kkhqUScwRu1O/lF6NOgJmlCgK+/LYxDCTk8sGelYaHDhFcDN+Sn3Cv+3VSa4Byeo+IMCzpMgQ==}
    engines: {node: '>=12'}

  slice-ansi@7.1.0:
    resolution: {integrity: sha512-bSiSngZ/jWeX93BqeIAbImyTbEihizcwNjFoRUIY/T1wWQsfsm2Vw1agPKylXvQTU7iASGdHhyqRlqQzfz+Htg==}
    engines: {node: '>=18'}

  source-map-support@0.5.21:
    resolution: {integrity: sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==}

  source-map@0.6.1:
    resolution: {integrity: sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==}
    engines: {node: '>=0.10.0'}

  sparse-bitfield@3.0.3:
    resolution: {integrity: sha512-kvzhi7vqKTfkh0PZU+2D2PIllw2ymqJKujUcyPMd9Y75Nv4nPbGJZXNhxsgdQab2BmlDct1YnfQCguEvHr7VsQ==}

  sprintf-js@1.0.3:
    resolution: {integrity: sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==}

  stack-trace@0.0.10:
    resolution: {integrity: sha512-KGzahc7puUKkzyMt+IqAep+TVNbKP+k2Lmwhub39m1AsTSkaDutx56aDCo+HLDzf/D26BIHTJWNiTG1KAJiQCg==}

  statuses@2.0.1:
    resolution: {integrity: sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==}
    engines: {node: '>= 0.8'}

  stop-iteration-iterator@1.1.0:
    resolution: {integrity: sha512-eLoXW/DHyl62zxY4SCaIgnRhuMr6ri4juEYARS8E6sCEqzKpOiE521Ucofdx+KnDZl5xmvGYaaKCk5FEOxJCoQ==}
    engines: {node: '>= 0.4'}

  streamsearch@1.1.0:
    resolution: {integrity: sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==}
    engines: {node: '>=10.0.0'}

  string-argv@0.3.2:
    resolution: {integrity: sha512-aqD2Q0144Z+/RqG52NeHEkZauTAUWJO8c6yTftGJKO3Tja5tUgIfmIl6kExvhtxSDP7fXB6DvzkfMpCd/F3G+Q==}
    engines: {node: '>=0.6.19'}

  string-width@7.2.0:
    resolution: {integrity: sha512-tsaTIkKW9b4N+AEj+SVA+WhJzV7/zMhcSu78mLKWSk7cXMOSHsBKFWUs0fWwq8QyK3MgJBQRX6Gbi4kYbdvGkQ==}
    engines: {node: '>=18'}

  string.prototype.trim@1.2.10:
    resolution: {integrity: sha512-Rs66F0P/1kedk5lyYyH9uBzuiI/kNRmwJAR9quK6VOtIpZ2G+hMZd+HQbbv25MgCA6gEffoMZYxlTod4WcdrKA==}
    engines: {node: '>= 0.4'}

  string.prototype.trimend@1.0.9:
    resolution: {integrity: sha512-G7Ok5C6E/j4SGfyLCloXTrngQIQU3PWtXGst3yM7Bea9FRURf1S42ZHlZZtsNque2FN2PoUhfZXYLNWwEr4dLQ==}
    engines: {node: '>= 0.4'}

  string.prototype.trimstart@1.0.8:
    resolution: {integrity: sha512-UXSH262CSZY1tfu3G3Secr6uGLCFVPMhIqHjlgCUtCCcgihYc/xKs9djMTMUOb2j1mVSeU8EU6NWc/iQKU6Gfg==}
    engines: {node: '>= 0.4'}

  string_decoder@1.1.1:
    resolution: {integrity: sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==}

  string_decoder@1.3.0:
    resolution: {integrity: sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==}

  strip-ansi@7.1.0:
    resolution: {integrity: sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==}
    engines: {node: '>=12'}

  strip-bom@3.0.0:
    resolution: {integrity: sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==}
    engines: {node: '>=4'}

  strip-json-comments@2.0.1:
    resolution: {integrity: sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==}
    engines: {node: '>=0.10.0'}

  strip-json-comments@3.1.1:
    resolution: {integrity: sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==}
    engines: {node: '>=8'}

  strnum@1.1.2:
    resolution: {integrity: sha512-vrN+B7DBIoTTZjnPNewwhx6cBA/H+IS7rfW68n7XxC1y7uoiGQBxaKzqucGUgavX15dJgiGztLJ8vxuEzwqBdA==}

  supports-color@7.2.0:
    resolution: {integrity: sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==}
    engines: {node: '>=8'}

  supports-preserve-symlinks-flag@1.0.0:
    resolution: {integrity: sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==}
    engines: {node: '>= 0.4'}

  swagger-jsdoc@6.2.8:
    resolution: {integrity: sha512-VPvil1+JRpmJ55CgAtn8DIcpBs0bL5L3q5bVQvF4tAW/k/9JYSj7dCpaYCAv5rufe0vcCbBRQXGvzpkWjvLklQ==}
    engines: {node: '>=12.0.0'}
    hasBin: true

  swagger-parser@10.0.3:
    resolution: {integrity: sha512-nF7oMeL4KypldrQhac8RyHerJeGPD1p2xDh900GPvc+Nk7nWP6jX2FcC7WmkinMoAmoO774+AFXcWsW8gMWEIg==}
    engines: {node: '>=10'}

  swagger-ui-dist@5.21.0:
    resolution: {integrity: sha512-E0K3AB6HvQd8yQNSMR7eE5bk+323AUxjtCz/4ZNKiahOlPhPJxqn3UPIGs00cyY/dhrTDJ61L7C/a8u6zhGrZg==}

  swagger-ui-express@5.0.1:
    resolution: {integrity: sha512-SrNU3RiBGTLLmFU8GIJdOdanJTl4TOmT27tt3bWWHppqYmAZ6IDuEuBvMU6nZq0zLEe6b/1rACXCgLZqO6ZfrA==}
    engines: {node: '>= v0.10.32'}
    peerDependencies:
      express: '>=4.0.0 || >=5.0.0-beta'

  text-hex@1.0.0:
    resolution: {integrity: sha512-uuVGNWzgJ4yhRaNSiubPY7OjISw4sw4E5Uv0wbjp+OzcbmVU/rsT8ujgcXJhn9ypzsgr5vlzpPqP+MBBKcGvbg==}

  tiny-inflate@1.0.3:
    resolution: {integrity: sha512-pkY1fj1cKHb2seWDy0B16HeWyczlJA9/WW3u3c4z/NiWDsO3DOU5D7nhTLE9CF0yXv/QZFY7sEJmj24dK+Rrqw==}

  to-regex-range@5.0.1:
    resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
    engines: {node: '>=8.0'}

  toidentifier@1.0.1:
    resolution: {integrity: sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==}
    engines: {node: '>=0.6'}

  tr46@0.0.3:
    resolution: {integrity: sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==}

  tr46@5.1.1:
    resolution: {integrity: sha512-hdF5ZgjTqgAntKkklYw0R03MG2x/bSzTtkxmIRw/sTNV8YXsCJ1tfLAX23lhxhHJlEf3CRCOCGGWw3vI3GaSPw==}
    engines: {node: '>=18'}

  tree-kill@1.2.2:
    resolution: {integrity: sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==}
    hasBin: true

  triple-beam@1.4.1:
    resolution: {integrity: sha512-aZbgViZrg1QNcG+LULa7nhZpJTZSLm/mXnHXnbAbjmN5aSa0y7V+wvv6+4WaBtpISJzThKy+PIPxc1Nq1EJ9mg==}
    engines: {node: '>= 14.0.0'}

  ts-node-dev@2.0.0:
    resolution: {integrity: sha512-ywMrhCfH6M75yftYvrvNarLEY+SUXtUvU8/0Z6llrHQVBx12GiFk5sStF8UdfE/yfzk9IAq7O5EEbTQsxlBI8w==}
    engines: {node: '>=0.8.0'}
    hasBin: true
    peerDependencies:
      node-notifier: '*'
      typescript: '*'
    peerDependenciesMeta:
      node-notifier:
        optional: true

  ts-node@10.9.2:
    resolution: {integrity: sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==}
    hasBin: true
    peerDependencies:
      '@swc/core': '>=1.2.50'
      '@swc/wasm': '>=1.2.50'
      '@types/node': '*'
      typescript: '>=2.7'
    peerDependenciesMeta:
      '@swc/core':
        optional: true
      '@swc/wasm':
        optional: true

  tsconfig-paths@3.15.0:
    resolution: {integrity: sha512-2Ac2RgzDe/cn48GvOe3M+o82pEFewD3UPbyoUHHdKasHwJKjds4fLXWf/Ux5kATBKN20oaFGu+jbElp1pos0mg==}

  tsconfig@7.0.0:
    resolution: {integrity: sha512-vZXmzPrL+EmC4T/4rVlT2jNVMWCi/O4DIiSj3UHg1OE5kCKbk4mfrXc6dZksLgRM/TZlKnousKH9bbTazUWRRw==}

  tslib@2.6.2:
    resolution: {integrity: sha512-AEYxH93jGFPn/a2iVAwW87VuUIkR1FVUKB77NwMF7nBTDkDrrT/Hpt/IrCJ0QXhW27jTBDcf5ZY7w6RiqTMw2Q==}

  type-check@0.4.0:
    resolution: {integrity: sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==}
    engines: {node: '>= 0.8.0'}

  type-is@1.6.18:
    resolution: {integrity: sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==}
    engines: {node: '>= 0.6'}

  type-is@2.0.1:
    resolution: {integrity: sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==}
    engines: {node: '>= 0.6'}

  typed-array-buffer@1.0.3:
    resolution: {integrity: sha512-nAYYwfY3qnzX30IkA6AQZjVbtK6duGontcQm1WSG1MD94YLqK0515GNApXkoxKOWMusVssAHWLh9SeaoefYFGw==}
    engines: {node: '>= 0.4'}

  typed-array-byte-length@1.0.3:
    resolution: {integrity: sha512-BaXgOuIxz8n8pIq3e7Atg/7s+DpiYrxn4vdot3w9KbnBhcRQq6o3xemQdIfynqSeXeDrF32x+WvfzmOjPiY9lg==}
    engines: {node: '>= 0.4'}

  typed-array-byte-offset@1.0.4:
    resolution: {integrity: sha512-bTlAFB/FBYMcuX81gbL4OcpH5PmlFHqlCCpAl8AlEzMz5k53oNDvN8p1PNOWLEmI2x4orp3raOFB51tv9X+MFQ==}
    engines: {node: '>= 0.4'}

  typed-array-length@1.0.7:
    resolution: {integrity: sha512-3KS2b+kL7fsuk/eJZ7EQdnEmQoaho/r6KUef7hxvltNA5DR8NAUM+8wJMbJyZ4G9/7i3v5zPBIMN5aybAh2/Jg==}
    engines: {node: '>= 0.4'}

  typedarray@0.0.6:
    resolution: {integrity: sha512-/aCDEGatGvZ2BIk+HmLf4ifCJFwvKFNb9/JeZPMulfgFracn9QFcAf5GO8B/mweUjSoblS5In0cWhqpfs/5PQA==}

  typescript@5.8.3:
    resolution: {integrity: sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  unbox-primitive@1.1.0:
    resolution: {integrity: sha512-nWJ91DjeOkej/TA8pXQ3myruKpKEYgqvpw9lz4OPHj/NWFNluYrjbz9j01CJ8yKQd2g4jFoOkINCTW2I5LEEyw==}
    engines: {node: '>= 0.4'}

  undici-types@6.21.0:
    resolution: {integrity: sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==}

  unicode-properties@1.4.1:
    resolution: {integrity: sha512-CLjCCLQ6UuMxWnbIylkisbRj31qxHPAurvena/0iwSVbQ2G1VY5/HjV0IRabOEbDHlzZlRdCrD4NhB0JtU40Pg==}

  unicode-trie@2.0.0:
    resolution: {integrity: sha512-x7bc76x0bm4prf1VLg79uhAzKw8DVboClSN5VxJuQ+LKDOVEW9CdH+VY7SP+vX7xCYQqzzgQpFqz15zeLvAtZQ==}

  unpipe@1.0.0:
    resolution: {integrity: sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==}
    engines: {node: '>= 0.8'}

  uri-js@4.4.1:
    resolution: {integrity: sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==}

  url@0.10.3:
    resolution: {integrity: sha512-hzSUW2q06EqL1gKM/a+obYHLIO6ct2hwPuviqTTOcfFVc61UbfJ2Q32+uGL/HCPxKqrdGB5QUwIe7UqlDgwsOQ==}

  util-deprecate@1.0.2:
    resolution: {integrity: sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==}

  util@0.10.4:
    resolution: {integrity: sha512-0Pm9hTQ3se5ll1XihRic3FDIku70C+iHUdT/W926rSgHV5QgXsYbKZN8MSC3tJtSkhuROzvsQjAaFENRXr+19A==}

  util@0.12.5:
    resolution: {integrity: sha512-kZf/K6hEIrWHI6XqOFUiiMa+79wE/D8Q+NCNAWclkyg3b4d2k7s0QGepNjiABc+aR3N1PAyHL7p6UcLY6LmrnA==}

  uuid@11.1.0:
    resolution: {integrity: sha512-0/A9rDy9P7cJ+8w1c9WD9V//9Wj15Ce2MPz8Ri6032usz+NfePxx5AcN3bN+r6ZL6jEo066/yNYB3tn4pQEx+A==}
    hasBin: true

  uuid@8.0.0:
    resolution: {integrity: sha512-jOXGuXZAWdsTH7eZLtyXMqUb9EcWMGZNbL9YcGBJl4MH4nrxHmZJhEHvyLFrkxo+28uLb/NYRcStH48fnD0Vzw==}
    hasBin: true

  uuid@9.0.1:
    resolution: {integrity: sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==}
    hasBin: true

  v8-compile-cache-lib@3.0.1:
    resolution: {integrity: sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==}

  validator@13.15.0:
    resolution: {integrity: sha512-36B2ryl4+oL5QxZ3AzD0t5SsMNGvTtQHpjgFO5tbNxfXbMFkY822ktCDe1MnlqV3301QQI9SLHDNJokDI+Z9pA==}
    engines: {node: '>= 0.10'}

  vary@1.1.2:
    resolution: {integrity: sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==}
    engines: {node: '>= 0.8'}

  webidl-conversions@3.0.1:
    resolution: {integrity: sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==}

  webidl-conversions@7.0.0:
    resolution: {integrity: sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==}
    engines: {node: '>=12'}

  whatwg-url@14.2.0:
    resolution: {integrity: sha512-De72GdQZzNTUBBChsXueQUnPKDkg/5A5zp7pFDuQAj5UFoENpiACU0wlCvzpAGnTkj++ihpKwKyYewn/XNUbKw==}
    engines: {node: '>=18'}

  whatwg-url@5.0.0:
    resolution: {integrity: sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==}

  which-boxed-primitive@1.1.1:
    resolution: {integrity: sha512-TbX3mj8n0odCBFVlY8AxkqcHASw3L60jIuF8jFP78az3C2YhmGvqbHBpAjTRH2/xqYunrJ9g1jSyjCjpoWzIAA==}
    engines: {node: '>= 0.4'}

  which-builtin-type@1.2.1:
    resolution: {integrity: sha512-6iBczoX+kDQ7a3+YJBnh3T+KZRxM/iYNPXicqk66/Qfm1b93iu+yOImkg0zHbj5LNOcNv1TEADiZ0xa34B4q6Q==}
    engines: {node: '>= 0.4'}

  which-collection@1.0.2:
    resolution: {integrity: sha512-K4jVyjnBdgvc86Y6BkaLZEN933SwYOuBFkdmBu9ZfkcAbdVbpITnDmjvZ/aQjRXQrv5EPkTnD1s39GiiqbngCw==}
    engines: {node: '>= 0.4'}

  which-typed-array@1.1.19:
    resolution: {integrity: sha512-rEvr90Bck4WZt9HHFC4DJMsjvu7x+r6bImz0/BrbWb7A2djJ8hnZMrWnHo9F8ssv0OMErasDhftrfROTyqSDrw==}
    engines: {node: '>= 0.4'}

  which@2.0.2:
    resolution: {integrity: sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==}
    engines: {node: '>= 8'}
    hasBin: true

  winston-transport@4.9.0:
    resolution: {integrity: sha512-8drMJ4rkgaPo1Me4zD/3WLfI/zPdA9o2IipKODunnGDcuqbHwjsbB79ylv04LCGGzU0xQ6vTznOMpQGaLhhm6A==}
    engines: {node: '>= 12.0.0'}

  winston@3.17.0:
    resolution: {integrity: sha512-DLiFIXYC5fMPxaRg832S6F5mJYvePtmO5G9v9IgUFPhXm9/GkXarH/TUrBAVzhTCzAj9anE/+GjrgXp/54nOgw==}
    engines: {node: '>= 12.0.0'}

  word-wrap@1.2.5:
    resolution: {integrity: sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==}
    engines: {node: '>=0.10.0'}

  wrap-ansi@9.0.0:
    resolution: {integrity: sha512-G8ura3S+3Z2G+mkgNRq8dqaFZAuxfsxpBB8OCTGRTCtp+l/v9nbFNmCUP1BZMts3G1142MsZfn6eeUKrr4PD1Q==}
    engines: {node: '>=18'}

  wrappy@1.0.2:
    resolution: {integrity: sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==}

  xml2js@0.6.2:
    resolution: {integrity: sha512-T4rieHaC1EXcES0Kxxj4JWgaUQHDk+qwHcYOCFHfiwKz7tOVPLq7Hjq9dM1WCMhylqMEfP7hMcOIChvotiZegA==}
    engines: {node: '>=4.0.0'}

  xmlbuilder@11.0.1:
    resolution: {integrity: sha512-fDlsI/kFEx7gLvbecc0/ohLG50fugQp8ryHzMTuW9vSa1GJ0XYWKnhsUx7oie3G98+r56aTQIUB4kht42R3JvA==}
    engines: {node: '>=4.0'}

  xtend@4.0.2:
    resolution: {integrity: sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ==}
    engines: {node: '>=0.4'}

  yaml@2.0.0-1:
    resolution: {integrity: sha512-W7h5dEhywMKenDJh2iX/LABkbFnBxasD27oyXWDS/feDsxiw0dD5ncXdYXgkvAsXIY2MpW/ZKkr9IU30DBdMNQ==}
    engines: {node: '>= 6'}

  yaml@2.7.1:
    resolution: {integrity: sha512-10ULxpnOCQXxJvBgxsn9ptjq6uviG/htZKk9veJGhlqn3w/DxQ631zFF+nlQXLwmImeS5amR2dl2U8sg6U9jsQ==}
    engines: {node: '>= 14'}
    hasBin: true

  yamljs@0.3.0:
    resolution: {integrity: sha512-C/FsVVhht4iPQYXOInoxUM/1ELSf9EsgKH34FofQOp6hwCPrW4vG4w5++TED3xRUo8gD7l0P1J1dLlDYzODsTQ==}
    hasBin: true

  yn@3.1.1:
    resolution: {integrity: sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==}
    engines: {node: '>=6'}

  yocto-queue@0.1.0:
    resolution: {integrity: sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==}
    engines: {node: '>=10'}

  z-schema@5.0.5:
    resolution: {integrity: sha512-D7eujBWkLa3p2sIpJA0d1pr7es+a7m0vFAnZLlCEKq/Ij2k0MLi9Br2UPxoxdYystm5K1yeBGzub0FlYUEWj2Q==}
    engines: {node: '>=8.0.0'}
    hasBin: true

  zod-to-json-schema@3.24.5:
    resolution: {integrity: sha512-/AuWwMP+YqiPbsJx5D6TfgRTc4kTLjsh5SOcd4bLsfUg2RcEXrFMJl1DGgdHy2aCfsIA/cr/1JM0xcB2GZji8g==}
    peerDependencies:
      zod: ^3.24.1

  zod@3.24.4:
    resolution: {integrity: sha512-OdqJE9UDRPwWsrHjLN2F8bPxvwJBK22EHLWtanu0LSYr5YqzsaaW3RMgmjwr8Rypg5k+meEJdSPXJZXE/yqOMg==}

snapshots:

  '@apidevtools/json-schema-ref-parser@9.1.2':
    dependencies:
      '@jsdevtools/ono': 7.1.3
      '@types/json-schema': 7.0.15
      call-me-maybe: 1.0.2
      js-yaml: 4.1.0

  '@apidevtools/openapi-schemas@2.1.0': {}

  '@apidevtools/swagger-methods@3.0.2': {}

  '@apidevtools/swagger-parser@10.0.3(openapi-types@12.1.3)':
    dependencies:
      '@apidevtools/json-schema-ref-parser': 9.1.2
      '@apidevtools/openapi-schemas': 2.1.0
      '@apidevtools/swagger-methods': 3.0.2
      '@jsdevtools/ono': 7.1.3
      call-me-maybe: 1.0.2
      openapi-types: 12.1.3
      z-schema: 5.0.5

  '@aws-crypto/crc32@5.2.0':
    dependencies:
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      tslib: 2.6.2

  '@aws-crypto/crc32c@5.2.0':
    dependencies:
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      tslib: 2.6.2

  '@aws-crypto/sha1-browser@5.2.0':
    dependencies:
      '@aws-crypto/supports-web-crypto': 5.2.0
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-locate-window': 3.804.0
      '@smithy/util-utf8': 2.3.0
      tslib: 2.6.2

  '@aws-crypto/sha256-browser@5.2.0':
    dependencies:
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-crypto/supports-web-crypto': 5.2.0
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-locate-window': 3.804.0
      '@smithy/util-utf8': 2.3.0
      tslib: 2.6.2

  '@aws-crypto/sha256-js@5.2.0':
    dependencies:
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/types': 3.821.0
      tslib: 2.6.2

  '@aws-crypto/supports-web-crypto@5.2.0':
    dependencies:
      tslib: 2.6.2

  '@aws-crypto/util@5.2.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/util-utf8': 2.3.0
      tslib: 2.6.2

  '@aws-sdk/client-s3@3.821.0':
    dependencies:
      '@aws-crypto/sha1-browser': 5.2.0
      '@aws-crypto/sha256-browser': 5.2.0
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/credential-provider-node': 3.821.0
      '@aws-sdk/middleware-bucket-endpoint': 3.821.0
      '@aws-sdk/middleware-expect-continue': 3.821.0
      '@aws-sdk/middleware-flexible-checksums': 3.821.0
      '@aws-sdk/middleware-host-header': 3.821.0
      '@aws-sdk/middleware-location-constraint': 3.821.0
      '@aws-sdk/middleware-logger': 3.821.0
      '@aws-sdk/middleware-recursion-detection': 3.821.0
      '@aws-sdk/middleware-sdk-s3': 3.821.0
      '@aws-sdk/middleware-ssec': 3.821.0
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/region-config-resolver': 3.821.0
      '@aws-sdk/signature-v4-multi-region': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@aws-sdk/util-user-agent-browser': 3.821.0
      '@aws-sdk/util-user-agent-node': 3.821.0
      '@aws-sdk/xml-builder': 3.821.0
      '@smithy/config-resolver': 4.1.4
      '@smithy/core': 3.5.1
      '@smithy/eventstream-serde-browser': 4.0.4
      '@smithy/eventstream-serde-config-resolver': 4.1.2
      '@smithy/eventstream-serde-node': 4.0.4
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/hash-blob-browser': 4.0.4
      '@smithy/hash-node': 4.0.4
      '@smithy/hash-stream-node': 4.0.4
      '@smithy/invalid-dependency': 4.0.4
      '@smithy/md5-js': 4.0.4
      '@smithy/middleware-content-length': 4.0.4
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-retry': 4.1.10
      '@smithy/middleware-serde': 4.0.8
      '@smithy/middleware-stack': 4.0.4
      '@smithy/node-config-provider': 4.1.3
      '@smithy/node-http-handler': 4.0.6
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-body-length-node': 4.0.0
      '@smithy/util-defaults-mode-browser': 4.0.17
      '@smithy/util-defaults-mode-node': 4.0.17
      '@smithy/util-endpoints': 3.0.6
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      '@smithy/util-waiter': 4.0.5
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/client-sso@3.821.0':
    dependencies:
      '@aws-crypto/sha256-browser': 5.2.0
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/middleware-host-header': 3.821.0
      '@aws-sdk/middleware-logger': 3.821.0
      '@aws-sdk/middleware-recursion-detection': 3.821.0
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/region-config-resolver': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@aws-sdk/util-user-agent-browser': 3.821.0
      '@aws-sdk/util-user-agent-node': 3.821.0
      '@smithy/config-resolver': 4.1.4
      '@smithy/core': 3.5.1
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/hash-node': 4.0.4
      '@smithy/invalid-dependency': 4.0.4
      '@smithy/middleware-content-length': 4.0.4
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-retry': 4.1.10
      '@smithy/middleware-serde': 4.0.8
      '@smithy/middleware-stack': 4.0.4
      '@smithy/node-config-provider': 4.1.3
      '@smithy/node-http-handler': 4.0.6
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-body-length-node': 4.0.0
      '@smithy/util-defaults-mode-browser': 4.0.17
      '@smithy/util-defaults-mode-node': 4.0.17
      '@smithy/util-endpoints': 3.0.6
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/core@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/core': 3.5.1
      '@smithy/node-config-provider': 4.1.3
      '@smithy/property-provider': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/signature-v4': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-middleware': 4.0.4
      fast-xml-parser: 4.4.1
      tslib: 2.6.2

  '@aws-sdk/credential-provider-env@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/credential-provider-http@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/node-http-handler': 4.0.6
      '@smithy/property-provider': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-stream': 4.2.2
      tslib: 2.6.2

  '@aws-sdk/credential-provider-ini@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/credential-provider-env': 3.821.0
      '@aws-sdk/credential-provider-http': 3.821.0
      '@aws-sdk/credential-provider-process': 3.821.0
      '@aws-sdk/credential-provider-sso': 3.821.0
      '@aws-sdk/credential-provider-web-identity': 3.821.0
      '@aws-sdk/nested-clients': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/credential-provider-imds': 4.0.6
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/credential-provider-node@3.821.0':
    dependencies:
      '@aws-sdk/credential-provider-env': 3.821.0
      '@aws-sdk/credential-provider-http': 3.821.0
      '@aws-sdk/credential-provider-ini': 3.821.0
      '@aws-sdk/credential-provider-process': 3.821.0
      '@aws-sdk/credential-provider-sso': 3.821.0
      '@aws-sdk/credential-provider-web-identity': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/credential-provider-imds': 4.0.6
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/credential-provider-process@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/credential-provider-sso@3.821.0':
    dependencies:
      '@aws-sdk/client-sso': 3.821.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/token-providers': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/credential-provider-web-identity@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/nested-clients': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/middleware-bucket-endpoint@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-arn-parser': 3.804.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      tslib: 2.6.2

  '@aws-sdk/middleware-expect-continue@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-flexible-checksums@3.821.0':
    dependencies:
      '@aws-crypto/crc32': 5.2.0
      '@aws-crypto/crc32c': 5.2.0
      '@aws-crypto/util': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/is-array-buffer': 4.0.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@aws-sdk/middleware-host-header@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-location-constraint@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-logger@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-recursion-detection@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-sdk-s3@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-arn-parser': 3.804.0
      '@smithy/core': 3.5.1
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/signature-v4': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@aws-sdk/middleware-ssec@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/middleware-user-agent@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@smithy/core': 3.5.1
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/nested-clients@3.821.0':
    dependencies:
      '@aws-crypto/sha256-browser': 5.2.0
      '@aws-crypto/sha256-js': 5.2.0
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/middleware-host-header': 3.821.0
      '@aws-sdk/middleware-logger': 3.821.0
      '@aws-sdk/middleware-recursion-detection': 3.821.0
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/region-config-resolver': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-endpoints': 3.821.0
      '@aws-sdk/util-user-agent-browser': 3.821.0
      '@aws-sdk/util-user-agent-node': 3.821.0
      '@smithy/config-resolver': 4.1.4
      '@smithy/core': 3.5.1
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/hash-node': 4.0.4
      '@smithy/invalid-dependency': 4.0.4
      '@smithy/middleware-content-length': 4.0.4
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-retry': 4.1.10
      '@smithy/middleware-serde': 4.0.8
      '@smithy/middleware-stack': 4.0.4
      '@smithy/node-config-provider': 4.1.3
      '@smithy/node-http-handler': 4.0.6
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-body-length-node': 4.0.0
      '@smithy/util-defaults-mode-browser': 4.0.17
      '@smithy/util-defaults-mode-node': 4.0.17
      '@smithy/util-endpoints': 3.0.6
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/region-config-resolver@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      '@smithy/util-middleware': 4.0.4
      tslib: 2.6.2

  '@aws-sdk/s3-request-presigner@3.821.0':
    dependencies:
      '@aws-sdk/signature-v4-multi-region': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@aws-sdk/util-format-url': 3.821.0
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/protocol-http': 5.1.2
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/signature-v4-multi-region@3.821.0':
    dependencies:
      '@aws-sdk/middleware-sdk-s3': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/signature-v4': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/token-providers@3.821.0':
    dependencies:
      '@aws-sdk/core': 3.821.0
      '@aws-sdk/nested-clients': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2
    transitivePeerDependencies:
      - aws-crt

  '@aws-sdk/types@3.821.0':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/util-arn-parser@3.804.0':
    dependencies:
      tslib: 2.6.2

  '@aws-sdk/util-endpoints@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      '@smithy/util-endpoints': 3.0.6
      tslib: 2.6.2

  '@aws-sdk/util-format-url@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/querystring-builder': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/util-locate-window@3.804.0':
    dependencies:
      tslib: 2.6.2

  '@aws-sdk/util-user-agent-browser@3.821.0':
    dependencies:
      '@aws-sdk/types': 3.821.0
      '@smithy/types': 4.3.1
      bowser: 2.11.0
      tslib: 2.6.2

  '@aws-sdk/util-user-agent-node@3.821.0':
    dependencies:
      '@aws-sdk/middleware-user-agent': 3.821.0
      '@aws-sdk/types': 3.821.0
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@aws-sdk/xml-builder@3.821.0':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@colors/colors@1.6.0': {}

  '@cspotcode/source-map-support@0.8.1':
    dependencies:
      '@jridgewell/trace-mapping': 0.3.9

  '@dabh/diagnostics@2.0.3':
    dependencies:
      colorspace: 1.1.4
      enabled: 2.0.0
      kuler: 2.0.0

  '@eslint-community/eslint-utils@4.7.0(eslint@9.26.0)':
    dependencies:
      eslint: 9.26.0
      eslint-visitor-keys: 3.4.3

  '@eslint-community/regexpp@4.12.1': {}

  '@eslint/config-array@0.20.0':
    dependencies:
      '@eslint/object-schema': 2.1.6
      debug: 4.4.1
      minimatch: 3.1.2
    transitivePeerDependencies:
      - supports-color

  '@eslint/config-helpers@0.2.2': {}

  '@eslint/core@0.13.0':
    dependencies:
      '@types/json-schema': 7.0.15

  '@eslint/eslintrc@3.3.1':
    dependencies:
      ajv: 6.12.6
      debug: 4.4.1
      espree: 10.3.0
      globals: 14.0.0
      ignore: 5.3.2
      import-fresh: 3.3.1
      js-yaml: 4.1.0
      minimatch: 3.1.2
      strip-json-comments: 3.1.1
    transitivePeerDependencies:
      - supports-color

  '@eslint/js@9.26.0': {}

  '@eslint/object-schema@2.1.6': {}

  '@eslint/plugin-kit@0.2.8':
    dependencies:
      '@eslint/core': 0.13.0
      levn: 0.4.1

  '@humanfs/core@0.19.1': {}

  '@humanfs/node@0.16.6':
    dependencies:
      '@humanfs/core': 0.19.1
      '@humanwhocodes/retry': 0.3.1

  '@humanwhocodes/module-importer@1.0.1': {}

  '@humanwhocodes/retry@0.3.1': {}

  '@humanwhocodes/retry@0.4.3': {}

  '@jridgewell/resolve-uri@3.1.2': {}

  '@jridgewell/sourcemap-codec@1.5.0': {}

  '@jridgewell/trace-mapping@0.3.9':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.2
      '@jridgewell/sourcemap-codec': 1.5.0

  '@jsdevtools/ono@7.1.3': {}

  '@modelcontextprotocol/sdk@1.11.2':
    dependencies:
      content-type: 1.0.5
      cors: 2.8.5
      cross-spawn: 7.0.6
      eventsource: 3.0.7
      express: 5.1.0
      express-rate-limit: 7.5.0(express@5.1.0)
      pkce-challenge: 5.0.0
      raw-body: 3.0.0
      zod: 3.24.4
      zod-to-json-schema: 3.24.5(zod@3.24.4)
    transitivePeerDependencies:
      - supports-color

  '@mongodb-js/saslprep@1.2.2':
    dependencies:
      sparse-bitfield: 3.0.3

  '@payos/node@1.0.10':
    dependencies:
      axios: 1.9.0
      crypto: 1.0.1
    transitivePeerDependencies:
      - debug

  '@rtsao/scc@1.1.0': {}

  '@scarf/scarf@1.4.0': {}

  '@smithy/abort-controller@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/chunked-blob-reader-native@4.0.0':
    dependencies:
      '@smithy/util-base64': 4.0.0
      tslib: 2.6.2

  '@smithy/chunked-blob-reader@5.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/config-resolver@4.1.4':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      '@smithy/util-config-provider': 4.0.0
      '@smithy/util-middleware': 4.0.4
      tslib: 2.6.2

  '@smithy/core@3.5.1':
    dependencies:
      '@smithy/middleware-serde': 4.0.8
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-base64': 4.0.0
      '@smithy/util-body-length-browser': 4.0.0
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-stream': 4.2.2
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/credential-provider-imds@4.0.6':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/property-provider': 4.0.4
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      tslib: 2.6.2

  '@smithy/eventstream-codec@4.0.4':
    dependencies:
      '@aws-crypto/crc32': 5.2.0
      '@smithy/types': 4.3.1
      '@smithy/util-hex-encoding': 4.0.0
      tslib: 2.6.2

  '@smithy/eventstream-serde-browser@4.0.4':
    dependencies:
      '@smithy/eventstream-serde-universal': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/eventstream-serde-config-resolver@4.1.2':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/eventstream-serde-node@4.0.4':
    dependencies:
      '@smithy/eventstream-serde-universal': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/eventstream-serde-universal@4.0.4':
    dependencies:
      '@smithy/eventstream-codec': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/fetch-http-handler@5.0.4':
    dependencies:
      '@smithy/protocol-http': 5.1.2
      '@smithy/querystring-builder': 4.0.4
      '@smithy/types': 4.3.1
      '@smithy/util-base64': 4.0.0
      tslib: 2.6.2

  '@smithy/hash-blob-browser@4.0.4':
    dependencies:
      '@smithy/chunked-blob-reader': 5.0.0
      '@smithy/chunked-blob-reader-native': 4.0.0
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/hash-node@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-buffer-from': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/hash-stream-node@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/invalid-dependency@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/is-array-buffer@2.2.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/is-array-buffer@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/md5-js@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/middleware-content-length@4.0.4':
    dependencies:
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/middleware-endpoint@4.1.9':
    dependencies:
      '@smithy/core': 3.5.1
      '@smithy/middleware-serde': 4.0.8
      '@smithy/node-config-provider': 4.1.3
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      '@smithy/url-parser': 4.0.4
      '@smithy/util-middleware': 4.0.4
      tslib: 2.6.2

  '@smithy/middleware-retry@4.1.10':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/protocol-http': 5.1.2
      '@smithy/service-error-classification': 4.0.5
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-retry': 4.0.5
      tslib: 2.6.2
      uuid: 9.0.1

  '@smithy/middleware-serde@4.0.8':
    dependencies:
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/middleware-stack@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/node-config-provider@4.1.3':
    dependencies:
      '@smithy/property-provider': 4.0.4
      '@smithy/shared-ini-file-loader': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/node-http-handler@4.0.6':
    dependencies:
      '@smithy/abort-controller': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/querystring-builder': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/property-provider@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/protocol-http@5.1.2':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/querystring-builder@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      '@smithy/util-uri-escape': 4.0.0
      tslib: 2.6.2

  '@smithy/querystring-parser@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/service-error-classification@4.0.5':
    dependencies:
      '@smithy/types': 4.3.1

  '@smithy/shared-ini-file-loader@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/signature-v4@5.1.2':
    dependencies:
      '@smithy/is-array-buffer': 4.0.0
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-hex-encoding': 4.0.0
      '@smithy/util-middleware': 4.0.4
      '@smithy/util-uri-escape': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/smithy-client@4.4.1':
    dependencies:
      '@smithy/core': 3.5.1
      '@smithy/middleware-endpoint': 4.1.9
      '@smithy/middleware-stack': 4.0.4
      '@smithy/protocol-http': 5.1.2
      '@smithy/types': 4.3.1
      '@smithy/util-stream': 4.2.2
      tslib: 2.6.2

  '@smithy/types@4.3.1':
    dependencies:
      tslib: 2.6.2

  '@smithy/url-parser@4.0.4':
    dependencies:
      '@smithy/querystring-parser': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-base64@4.0.0':
    dependencies:
      '@smithy/util-buffer-from': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/util-body-length-browser@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-body-length-node@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-buffer-from@2.2.0':
    dependencies:
      '@smithy/is-array-buffer': 2.2.0
      tslib: 2.6.2

  '@smithy/util-buffer-from@4.0.0':
    dependencies:
      '@smithy/is-array-buffer': 4.0.0
      tslib: 2.6.2

  '@smithy/util-config-provider@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-defaults-mode-browser@4.0.17':
    dependencies:
      '@smithy/property-provider': 4.0.4
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      bowser: 2.11.0
      tslib: 2.6.2

  '@smithy/util-defaults-mode-node@4.0.17':
    dependencies:
      '@smithy/config-resolver': 4.1.4
      '@smithy/credential-provider-imds': 4.0.6
      '@smithy/node-config-provider': 4.1.3
      '@smithy/property-provider': 4.0.4
      '@smithy/smithy-client': 4.4.1
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-endpoints@3.0.6':
    dependencies:
      '@smithy/node-config-provider': 4.1.3
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-hex-encoding@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-middleware@4.0.4':
    dependencies:
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-retry@4.0.5':
    dependencies:
      '@smithy/service-error-classification': 4.0.5
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@smithy/util-stream@4.2.2':
    dependencies:
      '@smithy/fetch-http-handler': 5.0.4
      '@smithy/node-http-handler': 4.0.6
      '@smithy/types': 4.3.1
      '@smithy/util-base64': 4.0.0
      '@smithy/util-buffer-from': 4.0.0
      '@smithy/util-hex-encoding': 4.0.0
      '@smithy/util-utf8': 4.0.0
      tslib: 2.6.2

  '@smithy/util-uri-escape@4.0.0':
    dependencies:
      tslib: 2.6.2

  '@smithy/util-utf8@2.3.0':
    dependencies:
      '@smithy/util-buffer-from': 2.2.0
      tslib: 2.6.2

  '@smithy/util-utf8@4.0.0':
    dependencies:
      '@smithy/util-buffer-from': 4.0.0
      tslib: 2.6.2

  '@smithy/util-waiter@4.0.5':
    dependencies:
      '@smithy/abort-controller': 4.0.4
      '@smithy/types': 4.3.1
      tslib: 2.6.2

  '@swc/helpers@0.3.17':
    dependencies:
      tslib: 2.6.2

  '@tsconfig/node10@1.0.11': {}

  '@tsconfig/node12@1.0.11': {}

  '@tsconfig/node14@1.0.3': {}

  '@tsconfig/node16@1.0.4': {}

  '@types/aws-sdk@2.7.4':
    dependencies:
      aws-sdk: 2.1692.0

  '@types/bcryptjs@3.0.0':
    dependencies:
      bcryptjs: 3.0.2

  '@types/body-parser@1.19.5':
    dependencies:
      '@types/connect': 3.4.38
      '@types/node': 22.15.18

  '@types/compression@1.8.0':
    dependencies:
      '@types/express': 5.0.1
      '@types/node': 22.15.18

  '@types/connect@3.4.38':
    dependencies:
      '@types/node': 22.15.18

  '@types/cors@2.8.18':
    dependencies:
      '@types/node': 22.15.18

  '@types/dotenv@8.2.3':
    dependencies:
      dotenv: 16.5.0

  '@types/estree@1.0.7': {}

  '@types/express-serve-static-core@5.0.6':
    dependencies:
      '@types/node': 22.15.18
      '@types/qs': 6.9.18
      '@types/range-parser': 1.2.7
      '@types/send': 0.17.4

  '@types/express@5.0.1':
    dependencies:
      '@types/body-parser': 1.19.5
      '@types/express-serve-static-core': 5.0.6
      '@types/serve-static': 1.15.7

  '@types/hpp@0.2.6':
    dependencies:
      '@types/express': 5.0.1

  '@types/http-errors@2.0.4': {}

  '@types/json-schema@7.0.15': {}

  '@types/json5@0.0.29': {}

  '@types/jsonwebtoken@9.0.9':
    dependencies:
      '@types/ms': 2.1.0
      '@types/node': 22.15.18

  '@types/mime@1.3.5': {}

  '@types/morgan@1.9.9':
    dependencies:
      '@types/node': 22.15.18

  '@types/ms@2.1.0': {}

  '@types/multer@1.4.12':
    dependencies:
      '@types/express': 5.0.1

  '@types/node@22.15.18':
    dependencies:
      undici-types: 6.21.0

  '@types/nodemailer@6.4.17':
    dependencies:
      '@types/node': 22.15.18

  '@types/pdfkit@0.13.9':
    dependencies:
      '@types/node': 22.15.18

  '@types/qs@6.9.18': {}

  '@types/range-parser@1.2.7': {}

  '@types/send@0.17.4':
    dependencies:
      '@types/mime': 1.3.5
      '@types/node': 22.15.18

  '@types/serve-static@1.15.7':
    dependencies:
      '@types/http-errors': 2.0.4
      '@types/node': 22.15.18
      '@types/send': 0.17.4

  '@types/strip-bom@3.0.0': {}

  '@types/strip-json-comments@0.0.30': {}

  '@types/swagger-jsdoc@6.0.4': {}

  '@types/swagger-ui-express@4.1.8':
    dependencies:
      '@types/express': 5.0.1
      '@types/serve-static': 1.15.7

  '@types/triple-beam@1.3.5': {}

  '@types/validator@13.15.0': {}

  '@types/webidl-conversions@7.0.3': {}

  '@types/whatwg-url@11.0.5':
    dependencies:
      '@types/webidl-conversions': 7.0.3

  '@types/yamljs@0.2.34': {}

  accepts@2.0.0:
    dependencies:
      mime-types: 3.0.1
      negotiator: 1.0.0

  acorn-jsx@5.3.2(acorn@8.14.1):
    dependencies:
      acorn: 8.14.1

  acorn-walk@8.3.4:
    dependencies:
      acorn: 8.14.1

  acorn@8.14.1: {}

  agent-base@7.1.3: {}

  ajv@6.12.6:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-json-stable-stringify: 2.1.0
      json-schema-traverse: 0.4.1
      uri-js: 4.4.1

  ansi-escapes@7.0.0:
    dependencies:
      environment: 1.1.0

  ansi-regex@6.1.0: {}

  ansi-styles@4.3.0:
    dependencies:
      color-convert: 2.0.1

  ansi-styles@6.2.1: {}

  anymatch@3.1.3:
    dependencies:
      normalize-path: 3.0.0
      picomatch: 2.3.1

  append-field@1.0.0: {}

  arg@4.1.3: {}

  argparse@1.0.10:
    dependencies:
      sprintf-js: 1.0.3

  argparse@2.0.1: {}

  array-buffer-byte-length@1.0.2:
    dependencies:
      call-bound: 1.0.4
      is-array-buffer: 3.0.5

  array-includes@3.1.8:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-object-atoms: 1.1.1
      get-intrinsic: 1.3.0
      is-string: 1.1.1

  array.prototype.findlastindex@1.2.6:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      es-shim-unscopables: 1.1.0

  array.prototype.flat@1.3.3:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-shim-unscopables: 1.1.0

  array.prototype.flatmap@1.3.3:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-shim-unscopables: 1.1.0

  arraybuffer.prototype.slice@1.0.4:
    dependencies:
      array-buffer-byte-length: 1.0.2
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      is-array-buffer: 3.0.5

  async-function@1.0.0: {}

  async@3.2.6: {}

  asynckit@0.4.0: {}

  available-typed-arrays@1.0.7:
    dependencies:
      possible-typed-array-names: 1.1.0

  aws-sdk@2.1692.0:
    dependencies:
      buffer: 4.9.2
      events: 1.1.1
      ieee754: 1.1.13
      jmespath: 0.16.0
      querystring: 0.2.0
      sax: 1.2.1
      url: 0.10.3
      util: 0.12.5
      uuid: 8.0.0
      xml2js: 0.6.2

  axios@1.9.0:
    dependencies:
      follow-redirects: 1.15.9
      form-data: 4.0.2
      proxy-from-env: 1.1.0
    transitivePeerDependencies:
      - debug

  balanced-match@1.0.2: {}

  base64-js@0.0.8: {}

  base64-js@1.5.1: {}

  basic-auth@2.0.1:
    dependencies:
      safe-buffer: 5.1.2

  bcryptjs@3.0.2: {}

  bignumber.js@9.3.0: {}

  binary-extensions@2.3.0: {}

  body-parser@2.2.0:
    dependencies:
      bytes: 3.1.2
      content-type: 1.0.5
      debug: 4.4.1
      http-errors: 2.0.0
      iconv-lite: 0.6.3
      on-finished: 2.4.1
      qs: 6.14.0
      raw-body: 3.0.0
      type-is: 2.0.1
    transitivePeerDependencies:
      - supports-color

  bowser@2.11.0: {}

  brace-expansion@1.1.11:
    dependencies:
      balanced-match: 1.0.2
      concat-map: 0.0.1

  brace-expansion@2.0.1:
    dependencies:
      balanced-match: 1.0.2

  braces@3.0.3:
    dependencies:
      fill-range: 7.1.1

  brotli@1.3.3:
    dependencies:
      base64-js: 1.5.1

  bson@6.10.3: {}

  buffer-equal-constant-time@1.0.1: {}

  buffer-from@1.1.2: {}

  buffer@4.9.2:
    dependencies:
      base64-js: 1.5.1
      ieee754: 1.1.13
      isarray: 1.0.0

  busboy@1.6.0:
    dependencies:
      streamsearch: 1.1.0

  bytes@3.1.2: {}

  call-bind-apply-helpers@1.0.2:
    dependencies:
      es-errors: 1.3.0
      function-bind: 1.1.2

  call-bind@1.0.8:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      get-intrinsic: 1.3.0
      set-function-length: 1.2.2

  call-bound@1.0.4:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      get-intrinsic: 1.3.0

  call-me-maybe@1.0.2: {}

  callsites@3.1.0: {}

  chalk@4.1.2:
    dependencies:
      ansi-styles: 4.3.0
      supports-color: 7.2.0

  chalk@5.4.1: {}

  chokidar@3.6.0:
    dependencies:
      anymatch: 3.1.3
      braces: 3.0.3
      glob-parent: 5.1.2
      is-binary-path: 2.1.0
      is-glob: 4.0.3
      normalize-path: 3.0.0
      readdirp: 3.6.0
    optionalDependencies:
      fsevents: 2.3.3

  class-transformer@0.5.1: {}

  class-validator@0.14.2:
    dependencies:
      '@types/validator': 13.15.0
      libphonenumber-js: 1.12.8
      validator: 13.15.0

  cli-cursor@5.0.0:
    dependencies:
      restore-cursor: 5.1.0

  cli-truncate@4.0.0:
    dependencies:
      slice-ansi: 5.0.0
      string-width: 7.2.0

  clone@2.1.2: {}

  color-convert@1.9.3:
    dependencies:
      color-name: 1.1.3

  color-convert@2.0.1:
    dependencies:
      color-name: 1.1.4

  color-name@1.1.3: {}

  color-name@1.1.4: {}

  color-string@1.9.1:
    dependencies:
      color-name: 1.1.4
      simple-swizzle: 0.2.2

  color@3.2.1:
    dependencies:
      color-convert: 1.9.3
      color-string: 1.9.1

  colorette@2.0.20: {}

  colorspace@1.1.4:
    dependencies:
      color: 3.2.1
      text-hex: 1.0.0

  combined-stream@1.0.8:
    dependencies:
      delayed-stream: 1.0.0

  commander@13.1.0: {}

  commander@6.2.0: {}

  commander@9.5.0:
    optional: true

  compressible@2.0.18:
    dependencies:
      mime-db: 1.54.0

  compression@1.8.0:
    dependencies:
      bytes: 3.1.2
      compressible: 2.0.18
      debug: 2.6.9
      negotiator: 0.6.4
      on-headers: 1.0.2
      safe-buffer: 5.2.1
      vary: 1.1.2
    transitivePeerDependencies:
      - supports-color

  concat-map@0.0.1: {}

  concat-stream@1.6.2:
    dependencies:
      buffer-from: 1.1.2
      inherits: 2.0.4
      readable-stream: 2.3.8
      typedarray: 0.0.6

  content-disposition@1.0.0:
    dependencies:
      safe-buffer: 5.2.1

  content-type@1.0.5: {}

  cookie-signature@1.2.2: {}

  cookie@0.7.2: {}

  core-util-is@1.0.3: {}

  cors@2.8.5:
    dependencies:
      object-assign: 4.1.1
      vary: 1.1.2

  create-require@1.1.1: {}

  cross-spawn@7.0.6:
    dependencies:
      path-key: 3.1.1
      shebang-command: 2.0.0
      which: 2.0.2

  crypto-js@4.2.0: {}

  crypto@1.0.1: {}

  data-view-buffer@1.0.2:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-data-view: 1.0.2

  data-view-byte-length@1.0.2:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-data-view: 1.0.2

  data-view-byte-offset@1.0.1:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-data-view: 1.0.2

  date-fns@4.1.0: {}

  debug@2.6.9:
    dependencies:
      ms: 2.0.0

  debug@3.2.7:
    dependencies:
      ms: 2.1.3

  debug@4.4.1:
    dependencies:
      ms: 2.1.3

  deep-equal@2.2.3:
    dependencies:
      array-buffer-byte-length: 1.0.2
      call-bind: 1.0.8
      es-get-iterator: 1.1.3
      get-intrinsic: 1.3.0
      is-arguments: 1.2.0
      is-array-buffer: 3.0.5
      is-date-object: 1.1.0
      is-regex: 1.2.1
      is-shared-array-buffer: 1.0.4
      isarray: 2.0.5
      object-is: 1.1.6
      object-keys: 1.1.1
      object.assign: 4.1.7
      regexp.prototype.flags: 1.5.4
      side-channel: 1.1.0
      which-boxed-primitive: 1.1.1
      which-collection: 1.0.2
      which-typed-array: 1.1.19

  deep-is@0.1.4: {}

  define-data-property@1.1.4:
    dependencies:
      es-define-property: 1.0.1
      es-errors: 1.3.0
      gopd: 1.2.0

  define-properties@1.2.1:
    dependencies:
      define-data-property: 1.1.4
      has-property-descriptors: 1.0.2
      object-keys: 1.1.1

  delayed-stream@1.0.0: {}

  depd@2.0.0: {}

  dfa@1.2.0: {}

  diff@4.0.2: {}

  doctrine@2.1.0:
    dependencies:
      esutils: 2.0.3

  doctrine@3.0.0:
    dependencies:
      esutils: 2.0.3

  dotenv@16.5.0: {}

  dunder-proto@1.0.1:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-errors: 1.3.0
      gopd: 1.2.0

  dynamic-dedupe@0.3.0:
    dependencies:
      xtend: 4.0.2

  ecdsa-sig-formatter@1.0.11:
    dependencies:
      safe-buffer: 5.2.1

  ee-first@1.1.1: {}

  ejs@3.1.10:
    dependencies:
      jake: 10.9.2

  emoji-regex@10.4.0: {}

  enabled@2.0.0: {}

  encodeurl@2.0.0: {}

  envalid@8.0.0:
    dependencies:
      tslib: 2.6.2

  environment@1.1.0: {}

  es-abstract@1.23.9:
    dependencies:
      array-buffer-byte-length: 1.0.2
      arraybuffer.prototype.slice: 1.0.4
      available-typed-arrays: 1.0.7
      call-bind: 1.0.8
      call-bound: 1.0.4
      data-view-buffer: 1.0.2
      data-view-byte-length: 1.0.2
      data-view-byte-offset: 1.0.1
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      es-set-tostringtag: 2.1.0
      es-to-primitive: 1.3.0
      function.prototype.name: 1.1.8
      get-intrinsic: 1.3.0
      get-proto: 1.0.1
      get-symbol-description: 1.1.0
      globalthis: 1.0.4
      gopd: 1.2.0
      has-property-descriptors: 1.0.2
      has-proto: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      internal-slot: 1.1.0
      is-array-buffer: 3.0.5
      is-callable: 1.2.7
      is-data-view: 1.0.2
      is-regex: 1.2.1
      is-shared-array-buffer: 1.0.4
      is-string: 1.1.1
      is-typed-array: 1.1.15
      is-weakref: 1.1.1
      math-intrinsics: 1.1.0
      object-inspect: 1.13.4
      object-keys: 1.1.1
      object.assign: 4.1.7
      own-keys: 1.0.1
      regexp.prototype.flags: 1.5.4
      safe-array-concat: 1.1.3
      safe-push-apply: 1.0.0
      safe-regex-test: 1.1.0
      set-proto: 1.0.0
      string.prototype.trim: 1.2.10
      string.prototype.trimend: 1.0.9
      string.prototype.trimstart: 1.0.8
      typed-array-buffer: 1.0.3
      typed-array-byte-length: 1.0.3
      typed-array-byte-offset: 1.0.4
      typed-array-length: 1.0.7
      unbox-primitive: 1.1.0
      which-typed-array: 1.1.19

  es-define-property@1.0.1: {}

  es-errors@1.3.0: {}

  es-get-iterator@1.1.3:
    dependencies:
      call-bind: 1.0.8
      get-intrinsic: 1.3.0
      has-symbols: 1.1.0
      is-arguments: 1.2.0
      is-map: 2.0.3
      is-set: 2.0.3
      is-string: 1.1.1
      isarray: 2.0.5
      stop-iteration-iterator: 1.1.0

  es-object-atoms@1.1.1:
    dependencies:
      es-errors: 1.3.0

  es-set-tostringtag@2.1.0:
    dependencies:
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      has-tostringtag: 1.0.2
      hasown: 2.0.2

  es-shim-unscopables@1.1.0:
    dependencies:
      hasown: 2.0.2

  es-to-primitive@1.3.0:
    dependencies:
      is-callable: 1.2.7
      is-date-object: 1.1.0
      is-symbol: 1.1.1

  escape-html@1.0.3: {}

  escape-string-regexp@4.0.0: {}

  eslint-config-prettier@10.1.5(eslint@9.26.0):
    dependencies:
      eslint: 9.26.0

  eslint-import-resolver-node@0.3.9:
    dependencies:
      debug: 3.2.7
      is-core-module: 2.16.1
      resolve: 1.22.10
    transitivePeerDependencies:
      - supports-color

  eslint-module-utils@2.12.0(eslint-import-resolver-node@0.3.9)(eslint@9.26.0):
    dependencies:
      debug: 3.2.7
    optionalDependencies:
      eslint: 9.26.0
      eslint-import-resolver-node: 0.3.9
    transitivePeerDependencies:
      - supports-color

  eslint-plugin-import@2.31.0(eslint@9.26.0):
    dependencies:
      '@rtsao/scc': 1.1.0
      array-includes: 3.1.8
      array.prototype.findlastindex: 1.2.6
      array.prototype.flat: 1.3.3
      array.prototype.flatmap: 1.3.3
      debug: 3.2.7
      doctrine: 2.1.0
      eslint: 9.26.0
      eslint-import-resolver-node: 0.3.9
      eslint-module-utils: 2.12.0(eslint-import-resolver-node@0.3.9)(eslint@9.26.0)
      hasown: 2.0.2
      is-core-module: 2.16.1
      is-glob: 4.0.3
      minimatch: 3.1.2
      object.fromentries: 2.0.8
      object.groupby: 1.0.3
      object.values: 1.2.1
      semver: 6.3.1
      string.prototype.trimend: 1.0.9
      tsconfig-paths: 3.15.0
    transitivePeerDependencies:
      - eslint-import-resolver-typescript
      - eslint-import-resolver-webpack
      - supports-color

  eslint-scope@8.3.0:
    dependencies:
      esrecurse: 4.3.0
      estraverse: 5.3.0

  eslint-visitor-keys@3.4.3: {}

  eslint-visitor-keys@4.2.0: {}

  eslint@9.26.0:
    dependencies:
      '@eslint-community/eslint-utils': 4.7.0(eslint@9.26.0)
      '@eslint-community/regexpp': 4.12.1
      '@eslint/config-array': 0.20.0
      '@eslint/config-helpers': 0.2.2
      '@eslint/core': 0.13.0
      '@eslint/eslintrc': 3.3.1
      '@eslint/js': 9.26.0
      '@eslint/plugin-kit': 0.2.8
      '@humanfs/node': 0.16.6
      '@humanwhocodes/module-importer': 1.0.1
      '@humanwhocodes/retry': 0.4.3
      '@modelcontextprotocol/sdk': 1.11.2
      '@types/estree': 1.0.7
      '@types/json-schema': 7.0.15
      ajv: 6.12.6
      chalk: 4.1.2
      cross-spawn: 7.0.6
      debug: 4.4.1
      escape-string-regexp: 4.0.0
      eslint-scope: 8.3.0
      eslint-visitor-keys: 4.2.0
      espree: 10.3.0
      esquery: 1.6.0
      esutils: 2.0.3
      fast-deep-equal: 3.1.3
      file-entry-cache: 8.0.0
      find-up: 5.0.0
      glob-parent: 6.0.2
      ignore: 5.3.2
      imurmurhash: 0.1.4
      is-glob: 4.0.3
      json-stable-stringify-without-jsonify: 1.0.1
      lodash.merge: 4.6.2
      minimatch: 3.1.2
      natural-compare: 1.4.0
      optionator: 0.9.4
      zod: 3.24.4
    transitivePeerDependencies:
      - supports-color

  espree@10.3.0:
    dependencies:
      acorn: 8.14.1
      acorn-jsx: 5.3.2(acorn@8.14.1)
      eslint-visitor-keys: 4.2.0

  esquery@1.6.0:
    dependencies:
      estraverse: 5.3.0

  esrecurse@4.3.0:
    dependencies:
      estraverse: 5.3.0

  estraverse@5.3.0: {}

  esutils@2.0.3: {}

  etag@1.8.1: {}

  eventemitter3@5.0.1: {}

  events@1.1.1: {}

  eventsource-parser@3.0.1: {}

  eventsource@3.0.7:
    dependencies:
      eventsource-parser: 3.0.1

  express-rate-limit@7.5.0(express@5.1.0):
    dependencies:
      express: 5.1.0

  express@5.1.0:
    dependencies:
      accepts: 2.0.0
      body-parser: 2.2.0
      content-disposition: 1.0.0
      content-type: 1.0.5
      cookie: 0.7.2
      cookie-signature: 1.2.2
      debug: 4.4.1
      encodeurl: 2.0.0
      escape-html: 1.0.3
      etag: 1.8.1
      finalhandler: 2.1.0
      fresh: 2.0.0
      http-errors: 2.0.0
      merge-descriptors: 2.0.0
      mime-types: 3.0.1
      on-finished: 2.4.1
      once: 1.4.0
      parseurl: 1.3.3
      proxy-addr: 2.0.7
      qs: 6.14.0
      range-parser: 1.2.1
      router: 2.2.0
      send: 1.2.0
      serve-static: 2.2.0
      statuses: 2.0.1
      type-is: 2.0.1
      vary: 1.1.2
    transitivePeerDependencies:
      - supports-color

  extend@3.0.2: {}

  fast-deep-equal@3.1.3: {}

  fast-json-stable-stringify@2.1.0: {}

  fast-levenshtein@2.0.6: {}

  fast-xml-parser@4.4.1:
    dependencies:
      strnum: 1.1.2

  fecha@4.2.3: {}

  file-entry-cache@8.0.0:
    dependencies:
      flat-cache: 4.0.1

  filelist@1.0.4:
    dependencies:
      minimatch: 5.1.6

  fill-range@7.1.1:
    dependencies:
      to-regex-range: 5.0.1

  finalhandler@2.1.0:
    dependencies:
      debug: 4.4.1
      encodeurl: 2.0.0
      escape-html: 1.0.3
      on-finished: 2.4.1
      parseurl: 1.3.3
      statuses: 2.0.1
    transitivePeerDependencies:
      - supports-color

  find-up@5.0.0:
    dependencies:
      locate-path: 6.0.0
      path-exists: 4.0.0

  flat-cache@4.0.1:
    dependencies:
      flatted: 3.3.3
      keyv: 4.5.4

  flatted@3.3.3: {}

  fn.name@1.1.0: {}

  follow-redirects@1.15.9: {}

  fontkit@1.9.0:
    dependencies:
      '@swc/helpers': 0.3.17
      brotli: 1.3.3
      clone: 2.1.2
      deep-equal: 2.2.3
      dfa: 1.2.0
      restructure: 2.0.1
      tiny-inflate: 1.0.3
      unicode-properties: 1.4.1
      unicode-trie: 2.0.0

  for-each@0.3.5:
    dependencies:
      is-callable: 1.2.7

  form-data@4.0.2:
    dependencies:
      asynckit: 0.4.0
      combined-stream: 1.0.8
      es-set-tostringtag: 2.1.0
      mime-types: 2.1.35

  forwarded@0.2.0: {}

  fresh@2.0.0: {}

  fs.realpath@1.0.0: {}

  fsevents@2.3.3:
    optional: true

  function-bind@1.1.2: {}

  function.prototype.name@1.1.8:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      functions-have-names: 1.2.3
      hasown: 2.0.2
      is-callable: 1.2.7

  functions-have-names@1.2.3: {}

  gaxios@6.7.1:
    dependencies:
      extend: 3.0.2
      https-proxy-agent: 7.0.6
      is-stream: 2.0.1
      node-fetch: 2.7.0
      uuid: 9.0.1
    transitivePeerDependencies:
      - encoding
      - supports-color

  gcp-metadata@6.1.1:
    dependencies:
      gaxios: 6.7.1
      google-logging-utils: 0.0.2
      json-bigint: 1.0.0
    transitivePeerDependencies:
      - encoding
      - supports-color

  get-east-asian-width@1.3.0: {}

  get-intrinsic@1.3.0:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      function-bind: 1.1.2
      get-proto: 1.0.1
      gopd: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      math-intrinsics: 1.1.0

  get-proto@1.0.1:
    dependencies:
      dunder-proto: 1.0.1
      es-object-atoms: 1.1.1

  get-symbol-description@1.1.0:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0

  glob-parent@5.1.2:
    dependencies:
      is-glob: 4.0.3

  glob-parent@6.0.2:
    dependencies:
      is-glob: 4.0.3

  glob@7.1.6:
    dependencies:
      fs.realpath: 1.0.0
      inflight: 1.0.6
      inherits: 2.0.4
      minimatch: 3.1.2
      once: 1.4.0
      path-is-absolute: 1.0.1

  glob@7.2.3:
    dependencies:
      fs.realpath: 1.0.0
      inflight: 1.0.6
      inherits: 2.0.4
      minimatch: 3.1.2
      once: 1.4.0
      path-is-absolute: 1.0.1

  globals@14.0.0: {}

  globalthis@1.0.4:
    dependencies:
      define-properties: 1.2.1
      gopd: 1.2.0

  google-auth-library@9.15.1:
    dependencies:
      base64-js: 1.5.1
      ecdsa-sig-formatter: 1.0.11
      gaxios: 6.7.1
      gcp-metadata: 6.1.1
      gtoken: 7.1.0
      jws: 4.0.0
    transitivePeerDependencies:
      - encoding
      - supports-color

  google-logging-utils@0.0.2: {}

  gopd@1.2.0: {}

  gtoken@7.1.0:
    dependencies:
      gaxios: 6.7.1
      jws: 4.0.0
    transitivePeerDependencies:
      - encoding
      - supports-color

  has-bigints@1.1.0: {}

  has-flag@4.0.0: {}

  has-property-descriptors@1.0.2:
    dependencies:
      es-define-property: 1.0.1

  has-proto@1.2.0:
    dependencies:
      dunder-proto: 1.0.1

  has-symbols@1.1.0: {}

  has-tostringtag@1.0.2:
    dependencies:
      has-symbols: 1.1.0

  hasown@2.0.2:
    dependencies:
      function-bind: 1.1.2

  helmet@8.1.0: {}

  hpp@0.2.3:
    dependencies:
      lodash: 4.17.21
      type-is: 1.6.18

  http-errors@2.0.0:
    dependencies:
      depd: 2.0.0
      inherits: 2.0.4
      setprototypeof: 1.2.0
      statuses: 2.0.1
      toidentifier: 1.0.1

  https-proxy-agent@7.0.6:
    dependencies:
      agent-base: 7.1.3
      debug: 4.4.1
    transitivePeerDependencies:
      - supports-color

  husky@9.1.7: {}

  iconv-lite@0.6.3:
    dependencies:
      safer-buffer: 2.1.2

  ieee754@1.1.13: {}

  ignore@5.3.2: {}

  import-fresh@3.3.1:
    dependencies:
      parent-module: 1.0.1
      resolve-from: 4.0.0

  imurmurhash@0.1.4: {}

  inflight@1.0.6:
    dependencies:
      once: 1.4.0
      wrappy: 1.0.2

  inherits@2.0.3: {}

  inherits@2.0.4: {}

  internal-slot@1.1.0:
    dependencies:
      es-errors: 1.3.0
      hasown: 2.0.2
      side-channel: 1.1.0

  ipaddr.js@1.9.1: {}

  is-arguments@1.2.0:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-array-buffer@3.0.5:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      get-intrinsic: 1.3.0

  is-arrayish@0.3.2: {}

  is-async-function@2.1.1:
    dependencies:
      async-function: 1.0.0
      call-bound: 1.0.4
      get-proto: 1.0.1
      has-tostringtag: 1.0.2
      safe-regex-test: 1.1.0

  is-bigint@1.1.0:
    dependencies:
      has-bigints: 1.1.0

  is-binary-path@2.1.0:
    dependencies:
      binary-extensions: 2.3.0

  is-boolean-object@1.2.2:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-callable@1.2.7: {}

  is-core-module@2.16.1:
    dependencies:
      hasown: 2.0.2

  is-data-view@1.0.2:
    dependencies:
      call-bound: 1.0.4
      get-intrinsic: 1.3.0
      is-typed-array: 1.1.15

  is-date-object@1.1.0:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-extglob@2.1.1: {}

  is-finalizationregistry@1.1.1:
    dependencies:
      call-bound: 1.0.4

  is-fullwidth-code-point@4.0.0: {}

  is-fullwidth-code-point@5.0.0:
    dependencies:
      get-east-asian-width: 1.3.0

  is-generator-function@1.1.0:
    dependencies:
      call-bound: 1.0.4
      get-proto: 1.0.1
      has-tostringtag: 1.0.2
      safe-regex-test: 1.1.0

  is-glob@4.0.3:
    dependencies:
      is-extglob: 2.1.1

  is-map@2.0.3: {}

  is-number-object@1.1.1:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-number@7.0.0: {}

  is-promise@4.0.0: {}

  is-regex@1.2.1:
    dependencies:
      call-bound: 1.0.4
      gopd: 1.2.0
      has-tostringtag: 1.0.2
      hasown: 2.0.2

  is-set@2.0.3: {}

  is-shared-array-buffer@1.0.4:
    dependencies:
      call-bound: 1.0.4

  is-stream@2.0.1: {}

  is-string@1.1.1:
    dependencies:
      call-bound: 1.0.4
      has-tostringtag: 1.0.2

  is-symbol@1.1.1:
    dependencies:
      call-bound: 1.0.4
      has-symbols: 1.1.0
      safe-regex-test: 1.1.0

  is-typed-array@1.1.15:
    dependencies:
      which-typed-array: 1.1.19

  is-weakmap@2.0.2: {}

  is-weakref@1.1.1:
    dependencies:
      call-bound: 1.0.4

  is-weakset@2.0.4:
    dependencies:
      call-bound: 1.0.4
      get-intrinsic: 1.3.0

  isarray@1.0.0: {}

  isarray@2.0.5: {}

  isexe@2.0.0: {}

  jake@10.9.2:
    dependencies:
      async: 3.2.6
      chalk: 4.1.2
      filelist: 1.0.4
      minimatch: 3.1.2

  jmespath@0.16.0: {}

  js-yaml@4.1.0:
    dependencies:
      argparse: 2.0.1

  json-bigint@1.0.0:
    dependencies:
      bignumber.js: 9.3.0

  json-buffer@3.0.1: {}

  json-schema-traverse@0.4.1: {}

  json-stable-stringify-without-jsonify@1.0.1: {}

  json5@1.0.2:
    dependencies:
      minimist: 1.2.8

  jsonwebtoken@9.0.2:
    dependencies:
      jws: 3.2.2
      lodash.includes: 4.3.0
      lodash.isboolean: 3.0.3
      lodash.isinteger: 4.0.4
      lodash.isnumber: 3.0.3
      lodash.isplainobject: 4.0.6
      lodash.isstring: 4.0.1
      lodash.once: 4.1.1
      ms: 2.1.3
      semver: 7.7.2

  jwa@1.4.2:
    dependencies:
      buffer-equal-constant-time: 1.0.1
      ecdsa-sig-formatter: 1.0.11
      safe-buffer: 5.2.1

  jwa@2.0.1:
    dependencies:
      buffer-equal-constant-time: 1.0.1
      ecdsa-sig-formatter: 1.0.11
      safe-buffer: 5.2.1

  jws@3.2.2:
    dependencies:
      jwa: 1.4.2
      safe-buffer: 5.2.1

  jws@4.0.0:
    dependencies:
      jwa: 2.0.1
      safe-buffer: 5.2.1

  kareem@2.6.3: {}

  keyv@4.5.4:
    dependencies:
      json-buffer: 3.0.1

  kuler@2.0.0: {}

  levn@0.4.1:
    dependencies:
      prelude-ls: 1.2.1
      type-check: 0.4.0

  libphonenumber-js@1.12.8: {}

  lilconfig@3.1.3: {}

  linebreak@1.1.0:
    dependencies:
      base64-js: 0.0.8
      unicode-trie: 2.0.0

  lint-staged@16.0.0:
    dependencies:
      chalk: 5.4.1
      commander: 13.1.0
      debug: 4.4.1
      lilconfig: 3.1.3
      listr2: 8.3.3
      micromatch: 4.0.8
      nano-spawn: 1.0.1
      pidtree: 0.6.0
      string-argv: 0.3.2
      yaml: 2.7.1
    transitivePeerDependencies:
      - supports-color

  listr2@8.3.3:
    dependencies:
      cli-truncate: 4.0.0
      colorette: 2.0.20
      eventemitter3: 5.0.1
      log-update: 6.1.0
      rfdc: 1.4.1
      wrap-ansi: 9.0.0

  locate-path@6.0.0:
    dependencies:
      p-locate: 5.0.0

  lodash.get@4.4.2: {}

  lodash.includes@4.3.0: {}

  lodash.isboolean@3.0.3: {}

  lodash.isequal@4.5.0: {}

  lodash.isinteger@4.0.4: {}

  lodash.isnumber@3.0.3: {}

  lodash.isplainobject@4.0.6: {}

  lodash.isstring@4.0.1: {}

  lodash.merge@4.6.2: {}

  lodash.mergewith@4.6.2: {}

  lodash.once@4.1.1: {}

  lodash@4.17.21: {}

  log-update@6.1.0:
    dependencies:
      ansi-escapes: 7.0.0
      cli-cursor: 5.0.0
      slice-ansi: 7.1.0
      strip-ansi: 7.1.0
      wrap-ansi: 9.0.0

  logform@2.7.0:
    dependencies:
      '@colors/colors': 1.6.0
      '@types/triple-beam': 1.3.5
      fecha: 4.2.3
      ms: 2.1.3
      safe-stable-stringify: 2.5.0
      triple-beam: 1.4.1

  make-error@1.3.6: {}

  math-intrinsics@1.1.0: {}

  media-typer@0.3.0: {}

  media-typer@1.1.0: {}

  memory-pager@1.5.0: {}

  merge-descriptors@2.0.0: {}

  micromatch@4.0.8:
    dependencies:
      braces: 3.0.3
      picomatch: 2.3.1

  mime-db@1.52.0: {}

  mime-db@1.54.0: {}

  mime-types@2.1.35:
    dependencies:
      mime-db: 1.52.0

  mime-types@3.0.1:
    dependencies:
      mime-db: 1.54.0

  mimic-function@5.0.1: {}

  minimatch@3.1.2:
    dependencies:
      brace-expansion: 1.1.11

  minimatch@5.1.6:
    dependencies:
      brace-expansion: 2.0.1

  minimist@1.2.8: {}

  mkdirp@0.5.6:
    dependencies:
      minimist: 1.2.8

  mkdirp@1.0.4: {}

  moment@2.30.1: {}

  mongodb-connection-string-url@3.0.2:
    dependencies:
      '@types/whatwg-url': 11.0.5
      whatwg-url: 14.2.0

  mongodb@6.16.0:
    dependencies:
      '@mongodb-js/saslprep': 1.2.2
      bson: 6.10.3
      mongodb-connection-string-url: 3.0.2

  mongoose@8.14.3:
    dependencies:
      bson: 6.10.3
      kareem: 2.6.3
      mongodb: 6.16.0
      mpath: 0.9.0
      mquery: 5.0.0
      ms: 2.1.3
      sift: 17.1.3
    transitivePeerDependencies:
      - '@aws-sdk/credential-providers'
      - '@mongodb-js/zstd'
      - gcp-metadata
      - kerberos
      - mongodb-client-encryption
      - snappy
      - socks
      - supports-color

  morgan@1.10.0:
    dependencies:
      basic-auth: 2.0.1
      debug: 2.6.9
      depd: 2.0.0
      on-finished: 2.3.0
      on-headers: 1.0.2
    transitivePeerDependencies:
      - supports-color

  mpath@0.9.0: {}

  mquery@5.0.0:
    dependencies:
      debug: 4.4.1
    transitivePeerDependencies:
      - supports-color

  ms@2.0.0: {}

  ms@2.1.3: {}

  multer@2.0.0:
    dependencies:
      append-field: 1.0.0
      busboy: 1.6.0
      concat-stream: 1.6.2
      mkdirp: 0.5.6
      object-assign: 4.1.1
      type-is: 1.6.18
      xtend: 4.0.2

  nano-spawn@1.0.1: {}

  natural-compare@1.4.0: {}

  negotiator@0.6.4: {}

  negotiator@1.0.0: {}

  node-fetch@2.7.0:
    dependencies:
      whatwg-url: 5.0.0

  nodemailer@7.0.3: {}

  normalize-path@3.0.0: {}

  object-assign@4.1.1: {}

  object-inspect@1.13.4: {}

  object-is@1.1.6:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1

  object-keys@1.1.1: {}

  object.assign@4.1.7:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-object-atoms: 1.1.1
      has-symbols: 1.1.0
      object-keys: 1.1.1

  object.fromentries@2.0.8:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-object-atoms: 1.1.1

  object.groupby@1.0.3:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9

  object.values@1.2.1:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-object-atoms: 1.1.1

  on-finished@2.3.0:
    dependencies:
      ee-first: 1.1.1

  on-finished@2.4.1:
    dependencies:
      ee-first: 1.1.1

  on-headers@1.0.2: {}

  once@1.4.0:
    dependencies:
      wrappy: 1.0.2

  one-time@1.0.0:
    dependencies:
      fn.name: 1.1.0

  onetime@7.0.0:
    dependencies:
      mimic-function: 5.0.1

  openapi-types@12.1.3: {}

  optionator@0.9.4:
    dependencies:
      deep-is: 0.1.4
      fast-levenshtein: 2.0.6
      levn: 0.4.1
      prelude-ls: 1.2.1
      type-check: 0.4.0
      word-wrap: 1.2.5

  own-keys@1.0.1:
    dependencies:
      get-intrinsic: 1.3.0
      object-keys: 1.1.1
      safe-push-apply: 1.0.0

  p-limit@3.1.0:
    dependencies:
      yocto-queue: 0.1.0

  p-locate@5.0.0:
    dependencies:
      p-limit: 3.1.0

  pako@0.2.9: {}

  parent-module@1.0.1:
    dependencies:
      callsites: 3.1.0

  parseurl@1.3.3: {}

  path-exists@4.0.0: {}

  path-is-absolute@1.0.1: {}

  path-key@3.1.1: {}

  path-parse@1.0.7: {}

  path-to-regexp@8.2.0: {}

  path@0.12.7:
    dependencies:
      process: 0.11.10
      util: 0.10.4

  pdfkit@0.14.0:
    dependencies:
      crypto-js: 4.2.0
      fontkit: 1.9.0
      linebreak: 1.1.0
      png-js: 1.0.0

  picomatch@2.3.1: {}

  pidtree@0.6.0: {}

  pkce-challenge@5.0.0: {}

  png-js@1.0.0: {}

  possible-typed-array-names@1.1.0: {}

  prelude-ls@1.2.1: {}

  prettier@3.5.3: {}

  process-nextick-args@2.0.1: {}

  process@0.11.10: {}

  proxy-addr@2.0.7:
    dependencies:
      forwarded: 0.2.0
      ipaddr.js: 1.9.1

  proxy-from-env@1.1.0: {}

  punycode@1.3.2: {}

  punycode@2.3.1: {}

  qs@6.14.0:
    dependencies:
      side-channel: 1.1.0

  querystring@0.2.0: {}

  range-parser@1.2.1: {}

  raw-body@3.0.0:
    dependencies:
      bytes: 3.1.2
      http-errors: 2.0.0
      iconv-lite: 0.6.3
      unpipe: 1.0.0

  readable-stream@2.3.8:
    dependencies:
      core-util-is: 1.0.3
      inherits: 2.0.4
      isarray: 1.0.0
      process-nextick-args: 2.0.1
      safe-buffer: 5.1.2
      string_decoder: 1.1.1
      util-deprecate: 1.0.2

  readable-stream@3.6.2:
    dependencies:
      inherits: 2.0.4
      string_decoder: 1.3.0
      util-deprecate: 1.0.2

  readdirp@3.6.0:
    dependencies:
      picomatch: 2.3.1

  reflect-metadata@0.2.2: {}

  reflect.getprototypeof@1.0.10:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      get-intrinsic: 1.3.0
      get-proto: 1.0.1
      which-builtin-type: 1.2.1

  regexp.prototype.flags@1.5.4:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-errors: 1.3.0
      get-proto: 1.0.1
      gopd: 1.2.0
      set-function-name: 2.0.2

  resolve-from@4.0.0: {}

  resolve@1.22.10:
    dependencies:
      is-core-module: 2.16.1
      path-parse: 1.0.7
      supports-preserve-symlinks-flag: 1.0.0

  restore-cursor@5.1.0:
    dependencies:
      onetime: 7.0.0
      signal-exit: 4.1.0

  restructure@2.0.1: {}

  rfdc@1.4.1: {}

  rimraf@2.7.1:
    dependencies:
      glob: 7.2.3

  router@2.2.0:
    dependencies:
      debug: 4.4.1
      depd: 2.0.0
      is-promise: 4.0.0
      parseurl: 1.3.3
      path-to-regexp: 8.2.0
    transitivePeerDependencies:
      - supports-color

  safe-array-concat@1.1.3:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      get-intrinsic: 1.3.0
      has-symbols: 1.1.0
      isarray: 2.0.5

  safe-buffer@5.1.2: {}

  safe-buffer@5.2.1: {}

  safe-push-apply@1.0.0:
    dependencies:
      es-errors: 1.3.0
      isarray: 2.0.5

  safe-regex-test@1.1.0:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-regex: 1.2.1

  safe-stable-stringify@2.5.0: {}

  safer-buffer@2.1.2: {}

  sax@1.2.1: {}

  semver@6.3.1: {}

  semver@7.7.2: {}

  send@1.2.0:
    dependencies:
      debug: 4.4.1
      encodeurl: 2.0.0
      escape-html: 1.0.3
      etag: 1.8.1
      fresh: 2.0.0
      http-errors: 2.0.0
      mime-types: 3.0.1
      ms: 2.1.3
      on-finished: 2.4.1
      range-parser: 1.2.1
      statuses: 2.0.1
    transitivePeerDependencies:
      - supports-color

  serve-static@2.2.0:
    dependencies:
      encodeurl: 2.0.0
      escape-html: 1.0.3
      parseurl: 1.3.3
      send: 1.2.0
    transitivePeerDependencies:
      - supports-color

  set-function-length@1.2.2:
    dependencies:
      define-data-property: 1.1.4
      es-errors: 1.3.0
      function-bind: 1.1.2
      get-intrinsic: 1.3.0
      gopd: 1.2.0
      has-property-descriptors: 1.0.2

  set-function-name@2.0.2:
    dependencies:
      define-data-property: 1.1.4
      es-errors: 1.3.0
      functions-have-names: 1.2.3
      has-property-descriptors: 1.0.2

  set-proto@1.0.0:
    dependencies:
      dunder-proto: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1

  setprototypeof@1.2.0: {}

  shebang-command@2.0.0:
    dependencies:
      shebang-regex: 3.0.0

  shebang-regex@3.0.0: {}

  side-channel-list@1.0.0:
    dependencies:
      es-errors: 1.3.0
      object-inspect: 1.13.4

  side-channel-map@1.0.1:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      object-inspect: 1.13.4

  side-channel-weakmap@1.0.2:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      object-inspect: 1.13.4
      side-channel-map: 1.0.1

  side-channel@1.1.0:
    dependencies:
      es-errors: 1.3.0
      object-inspect: 1.13.4
      side-channel-list: 1.0.0
      side-channel-map: 1.0.1
      side-channel-weakmap: 1.0.2

  sift@17.1.3: {}

  signal-exit@4.1.0: {}

  simple-swizzle@0.2.2:
    dependencies:
      is-arrayish: 0.3.2

  slice-ansi@5.0.0:
    dependencies:
      ansi-styles: 6.2.1
      is-fullwidth-code-point: 4.0.0

  slice-ansi@7.1.0:
    dependencies:
      ansi-styles: 6.2.1
      is-fullwidth-code-point: 5.0.0

  source-map-support@0.5.21:
    dependencies:
      buffer-from: 1.1.2
      source-map: 0.6.1

  source-map@0.6.1: {}

  sparse-bitfield@3.0.3:
    dependencies:
      memory-pager: 1.5.0

  sprintf-js@1.0.3: {}

  stack-trace@0.0.10: {}

  statuses@2.0.1: {}

  stop-iteration-iterator@1.1.0:
    dependencies:
      es-errors: 1.3.0
      internal-slot: 1.1.0

  streamsearch@1.1.0: {}

  string-argv@0.3.2: {}

  string-width@7.2.0:
    dependencies:
      emoji-regex: 10.4.0
      get-east-asian-width: 1.3.0
      strip-ansi: 7.1.0

  string.prototype.trim@1.2.10:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-data-property: 1.1.4
      define-properties: 1.2.1
      es-abstract: 1.23.9
      es-object-atoms: 1.1.1
      has-property-descriptors: 1.0.2

  string.prototype.trimend@1.0.9:
    dependencies:
      call-bind: 1.0.8
      call-bound: 1.0.4
      define-properties: 1.2.1
      es-object-atoms: 1.1.1

  string.prototype.trimstart@1.0.8:
    dependencies:
      call-bind: 1.0.8
      define-properties: 1.2.1
      es-object-atoms: 1.1.1

  string_decoder@1.1.1:
    dependencies:
      safe-buffer: 5.1.2

  string_decoder@1.3.0:
    dependencies:
      safe-buffer: 5.2.1

  strip-ansi@7.1.0:
    dependencies:
      ansi-regex: 6.1.0

  strip-bom@3.0.0: {}

  strip-json-comments@2.0.1: {}

  strip-json-comments@3.1.1: {}

  strnum@1.1.2: {}

  supports-color@7.2.0:
    dependencies:
      has-flag: 4.0.0

  supports-preserve-symlinks-flag@1.0.0: {}

  swagger-jsdoc@6.2.8(openapi-types@12.1.3):
    dependencies:
      commander: 6.2.0
      doctrine: 3.0.0
      glob: 7.1.6
      lodash.mergewith: 4.6.2
      swagger-parser: 10.0.3(openapi-types@12.1.3)
      yaml: 2.0.0-1
    transitivePeerDependencies:
      - openapi-types

  swagger-parser@10.0.3(openapi-types@12.1.3):
    dependencies:
      '@apidevtools/swagger-parser': 10.0.3(openapi-types@12.1.3)
    transitivePeerDependencies:
      - openapi-types

  swagger-ui-dist@5.21.0:
    dependencies:
      '@scarf/scarf': 1.4.0

  swagger-ui-express@5.0.1(express@5.1.0):
    dependencies:
      express: 5.1.0
      swagger-ui-dist: 5.21.0

  text-hex@1.0.0: {}

  tiny-inflate@1.0.3: {}

  to-regex-range@5.0.1:
    dependencies:
      is-number: 7.0.0

  toidentifier@1.0.1: {}

  tr46@0.0.3: {}

  tr46@5.1.1:
    dependencies:
      punycode: 2.3.1

  tree-kill@1.2.2: {}

  triple-beam@1.4.1: {}

  ts-node-dev@2.0.0(@types/node@22.15.18)(typescript@5.8.3):
    dependencies:
      chokidar: 3.6.0
      dynamic-dedupe: 0.3.0
      minimist: 1.2.8
      mkdirp: 1.0.4
      resolve: 1.22.10
      rimraf: 2.7.1
      source-map-support: 0.5.21
      tree-kill: 1.2.2
      ts-node: 10.9.2(@types/node@22.15.18)(typescript@5.8.3)
      tsconfig: 7.0.0
      typescript: 5.8.3
    transitivePeerDependencies:
      - '@swc/core'
      - '@swc/wasm'
      - '@types/node'

  ts-node@10.9.2(@types/node@22.15.18)(typescript@5.8.3):
    dependencies:
      '@cspotcode/source-map-support': 0.8.1
      '@tsconfig/node10': 1.0.11
      '@tsconfig/node12': 1.0.11
      '@tsconfig/node14': 1.0.3
      '@tsconfig/node16': 1.0.4
      '@types/node': 22.15.18
      acorn: 8.14.1
      acorn-walk: 8.3.4
      arg: 4.1.3
      create-require: 1.1.1
      diff: 4.0.2
      make-error: 1.3.6
      typescript: 5.8.3
      v8-compile-cache-lib: 3.0.1
      yn: 3.1.1

  tsconfig-paths@3.15.0:
    dependencies:
      '@types/json5': 0.0.29
      json5: 1.0.2
      minimist: 1.2.8
      strip-bom: 3.0.0

  tsconfig@7.0.0:
    dependencies:
      '@types/strip-bom': 3.0.0
      '@types/strip-json-comments': 0.0.30
      strip-bom: 3.0.0
      strip-json-comments: 2.0.1

  tslib@2.6.2: {}

  type-check@0.4.0:
    dependencies:
      prelude-ls: 1.2.1

  type-is@1.6.18:
    dependencies:
      media-typer: 0.3.0
      mime-types: 2.1.35

  type-is@2.0.1:
    dependencies:
      content-type: 1.0.5
      media-typer: 1.1.0
      mime-types: 3.0.1

  typed-array-buffer@1.0.3:
    dependencies:
      call-bound: 1.0.4
      es-errors: 1.3.0
      is-typed-array: 1.1.15

  typed-array-byte-length@1.0.3:
    dependencies:
      call-bind: 1.0.8
      for-each: 0.3.5
      gopd: 1.2.0
      has-proto: 1.2.0
      is-typed-array: 1.1.15

  typed-array-byte-offset@1.0.4:
    dependencies:
      available-typed-arrays: 1.0.7
      call-bind: 1.0.8
      for-each: 0.3.5
      gopd: 1.2.0
      has-proto: 1.2.0
      is-typed-array: 1.1.15
      reflect.getprototypeof: 1.0.10

  typed-array-length@1.0.7:
    dependencies:
      call-bind: 1.0.8
      for-each: 0.3.5
      gopd: 1.2.0
      is-typed-array: 1.1.15
      possible-typed-array-names: 1.1.0
      reflect.getprototypeof: 1.0.10

  typedarray@0.0.6: {}

  typescript@5.8.3: {}

  unbox-primitive@1.1.0:
    dependencies:
      call-bound: 1.0.4
      has-bigints: 1.1.0
      has-symbols: 1.1.0
      which-boxed-primitive: 1.1.1

  undici-types@6.21.0: {}

  unicode-properties@1.4.1:
    dependencies:
      base64-js: 1.5.1
      unicode-trie: 2.0.0

  unicode-trie@2.0.0:
    dependencies:
      pako: 0.2.9
      tiny-inflate: 1.0.3

  unpipe@1.0.0: {}

  uri-js@4.4.1:
    dependencies:
      punycode: 2.3.1

  url@0.10.3:
    dependencies:
      punycode: 1.3.2
      querystring: 0.2.0

  util-deprecate@1.0.2: {}

  util@0.10.4:
    dependencies:
      inherits: 2.0.3

  util@0.12.5:
    dependencies:
      inherits: 2.0.4
      is-arguments: 1.2.0
      is-generator-function: 1.1.0
      is-typed-array: 1.1.15
      which-typed-array: 1.1.19

  uuid@11.1.0: {}

  uuid@8.0.0: {}

  uuid@9.0.1: {}

  v8-compile-cache-lib@3.0.1: {}

  validator@13.15.0: {}

  vary@1.1.2: {}

  webidl-conversions@3.0.1: {}

  webidl-conversions@7.0.0: {}

  whatwg-url@14.2.0:
    dependencies:
      tr46: 5.1.1
      webidl-conversions: 7.0.0

  whatwg-url@5.0.0:
    dependencies:
      tr46: 0.0.3
      webidl-conversions: 3.0.1

  which-boxed-primitive@1.1.1:
    dependencies:
      is-bigint: 1.1.0
      is-boolean-object: 1.2.2
      is-number-object: 1.1.1
      is-string: 1.1.1
      is-symbol: 1.1.1

  which-builtin-type@1.2.1:
    dependencies:
      call-bound: 1.0.4
      function.prototype.name: 1.1.8
      has-tostringtag: 1.0.2
      is-async-function: 2.1.1
      is-date-object: 1.1.0
      is-finalizationregistry: 1.1.1
      is-generator-function: 1.1.0
      is-regex: 1.2.1
      is-weakref: 1.1.1
      isarray: 2.0.5
      which-boxed-primitive: 1.1.1
      which-collection: 1.0.2
      which-typed-array: 1.1.19

  which-collection@1.0.2:
    dependencies:
      is-map: 2.0.3
      is-set: 2.0.3
      is-weakmap: 2.0.2
      is-weakset: 2.0.4

  which-typed-array@1.1.19:
    dependencies:
      available-typed-arrays: 1.0.7
      call-bind: 1.0.8
      call-bound: 1.0.4
      for-each: 0.3.5
      get-proto: 1.0.1
      gopd: 1.2.0
      has-tostringtag: 1.0.2

  which@2.0.2:
    dependencies:
      isexe: 2.0.0

  winston-transport@4.9.0:
    dependencies:
      logform: 2.7.0
      readable-stream: 3.6.2
      triple-beam: 1.4.1

  winston@3.17.0:
    dependencies:
      '@colors/colors': 1.6.0
      '@dabh/diagnostics': 2.0.3
      async: 3.2.6
      is-stream: 2.0.1
      logform: 2.7.0
      one-time: 1.0.0
      readable-stream: 3.6.2
      safe-stable-stringify: 2.5.0
      stack-trace: 0.0.10
      triple-beam: 1.4.1
      winston-transport: 4.9.0

  word-wrap@1.2.5: {}

  wrap-ansi@9.0.0:
    dependencies:
      ansi-styles: 6.2.1
      string-width: 7.2.0
      strip-ansi: 7.1.0

  wrappy@1.0.2: {}

  xml2js@0.6.2:
    dependencies:
      sax: 1.2.1
      xmlbuilder: 11.0.1

  xmlbuilder@11.0.1: {}

  xtend@4.0.2: {}

  yaml@2.0.0-1: {}

  yaml@2.7.1: {}

  yamljs@0.3.0:
    dependencies:
      argparse: 1.0.10
      glob: 7.2.3

  yn@3.1.1: {}

  yocto-queue@0.1.0: {}

  z-schema@5.0.5:
    dependencies:
      lodash.get: 4.4.2
      lodash.isequal: 4.5.0
      validator: 13.15.0
    optionalDependencies:
      commander: 9.5.0

  zod-to-json-schema@3.24.5(zod@3.24.4):
    dependencies:
      zod: 3.24.4

  zod@3.24.4: {}



================================================
FILE: README-VERCEL-OPTIMIZATION.md
================================================
# ðŸš€ Tá»‘i Æ°u Performance cho Vercel | Vercel Performance Optimization

## ðŸ“‹ Tá»•ng quan | Overview

## âš¡ CÃ¡c cáº£i tiáº¿n Ä‘Ã£ thá»±c hiá»‡n | Implemented Optimizations

### 1. ðŸ”§ **Cáº¥u hÃ¬nh Vercel.json nÃ¢ng cao**

```json
{
    "version": 2,
    "builds": [
        {
            "src": "src/server.ts",
            "use": "@vercel/node",
            "config": {
                "includeFiles": ["src/**", "swagger.yaml", "assets/**"]
            }
        }
    ],
    "functions": {
        "src/server.ts": {
            "maxDuration": 30
        }
    }
}
```

**TÃ­nh nÄƒng:**
- **Route-specific caching**: CÃ¡c endpoint khÃ¡c nhau cÃ³ cache riÃªng biá»‡t
- **Static asset optimization**: Cache lÃ¢u dÃ i cho swagger, images
- **Security headers**: Báº£o máº­t tá»± Ä‘á»™ng cho táº¥t cáº£ API routes
- **Function timeout**: TÄƒng thá»i gian xá»­ lÃ½ lÃªn 30s

### 2. ðŸ—„ï¸ **Tá»‘i Æ°u MongoDB Connection**

```typescript
// Cached connection cho serverless
let cachedConnection: typeof mongoose | null = null;

private async connectToDatabase() {
    // Sá»­ dá»¥ng connection cache
    if (cachedConnection && cachedConnection.connection.readyState === 1) {
        return cachedConnection;
    }

    const options = {
        // Connection pooling optimization
        maxPoolSize: 10,
        minPoolSize: 2,
        maxIdleTimeMS: 30000,
        // Serverless optimization
        bufferCommands: false,
        bufferMaxEntries: 0,
        // Faster timeouts
        serverSelectionTimeoutMS: 5000,
        connectTimeoutMS: 10000,
        socketTimeoutMS: 45000
    };
}
```

**Lá»£i Ã­ch:**
- **Connection reuse**: TÃ¡i sá»­ dá»¥ng káº¿t ná»‘i giá»¯a cÃ¡c function calls
- **Faster cold starts**: Khá»Ÿi Ä‘á»™ng nhanh hÆ¡n vá»›i buffer optimization
- **Better pooling**: Quáº£n lÃ½ connection pool hiá»‡u quáº£

### 3. ðŸ’¾ **In-Memory Caching System**

```typescript
// Cache middleware cho API responses
export const cacheMiddleware = (options: CacheOptions) => {
    // Tá»± Ä‘á»™ng cache GET requests
    // TTL configurable per route
    // Condition-based caching
};

// Pre-configured cache cho cÃ¡c loáº¡i data
export const serviceCacheMiddleware = cacheMiddleware({
    ttl: 5 * 60 * 1000, // 5 phÃºt
    condition: (req) => !req.headers.authorization
});

export const blogCacheMiddleware = cacheMiddleware({
    ttl: 3 * 60 * 1000, // 3 phÃºt
});
```

**Ãp dá»¥ng:**
```typescript
// Trong routes
router.get('/api/service', serviceCacheMiddleware, controller.getServices);
router.get('/api/blog', blogCacheMiddleware, controller.getBlogs);
```

### 4. ðŸ“Š **Performance Monitoring**

```typescript
// Database query optimization
const optimizedResults = DatabaseOptimizer.paginate(
    UserModel.find(filter),
    page,
    limit,
    { created_at: -1 }
);

// Performance tracking
const result = await PerformanceMonitor.monitor(
    'getUserData',
    () => userService.getData(userId)
);

// Memory management
MemoryManager.logMemoryUsage('After DB Query');
```

## ðŸŽ¯ **CÃ¡ch sá»­ dá»¥ng tá»‘i Æ°u | How to Use Optimizations**

### **BÆ°á»›c 1: Cáº­p nháº­t Routes vá»›i Cache**

```typescript
// TRÆ¯á»šC (Before) - No optimization
import { Router } from 'express';
import { authMiddleWare } from '../../core/middleware';

this.router.get(
    `${this.path}`,
    authMiddleWare([UserRoleEnum.ADMIN]),
    this.controller.listCases
);

// SAU (After) - With caching optimization  
import { Router } from 'express';
import { authMiddleWare } from '../../core/middleware';
import { cacheMiddleware } from '../../core/middleware/cache.middleware';

// Cache cho public data
const publicCacheMiddleware = cacheMiddleware({
    ttl: 5 * 60 * 1000, // 5 phÃºt
    condition: (req) => !req.headers.authorization
});

// Cache cho authenticated data
const adminCacheMiddleware = cacheMiddleware({
    ttl: 2 * 60 * 1000, // 2 phÃºt  
    condition: (req) => req.method === 'GET'
});

this.router.get(
    `${this.path}`,
    authMiddleWare([UserRoleEnum.ADMIN]),
    adminCacheMiddleware,
    this.controller.listCases
);
```

### **BÆ°á»›c 2: Tá»‘i Æ°u Database Queries**

```typescript
// TRÆ¯á»šC (Before) - Standard query
async listCases(req: Request, res: Response) {
    const { page = 1, limit = 10 } = req.query;
    const cases = await AdministrativeCase.find()
        .skip((page - 1) * limit)
        .limit(limit);
    
    const total = await AdministrativeCase.countDocuments();
    return res.json({ cases, total });
}

// SAU (After) - With optimization
async listCases(req: Request, res: Response) {
    const { page = 1, limit = 10 } = req.query;
    
    // Sá»­ dá»¥ng DatabaseOptimizer
    const query = AdministrativeCase.find();
    const optimizedResults = await DatabaseOptimizer.paginate(
        query,
        Number(page),
        Number(limit),
        { created_at: -1 } // sort
    );
    
    // Tracking performance
    const result = await PerformanceMonitor.monitor('listCases', () => {
        return optimizedResults;
    });
    
    return res.json(result);
}
```

### **BÆ°á»›c 3: Optimized Service Layer**

```typescript
// service.ts - Vá»›i performance monitoring
class AdministrativeCasesService {
    
    async getCases(filters: any = {}, page: number = 1, limit: number = 10) {
        // Memory logging trÆ°á»›c query
        MemoryManager.logMemoryUsage('Before DB Query');
        
        // Optimized query vá»›i lean() vÃ  select()
        let query = AdministrativeCase.find(filters);
        query = DatabaseOptimizer.lean(query);
        query = DatabaseOptimizer.select(query, 'title status created_at updated_at');
        
        const results = await DatabaseOptimizer.paginate(
            query, 
            page, 
            limit,
            { created_at: -1 }
        );
        
        // Memory logging sau query
        MemoryManager.logMemoryUsage('After DB Query');
        
        return results;
    }
    
    async getCaseById(id: string) {
        // Performance tracking cho single query
        return await PerformanceMonitor.monitor('getCaseById', async () => {
            let query = AdministrativeCase.findById(id);
            query = DatabaseOptimizer.lean(query);
            return await query.exec();
        });
    }
}
```

## ðŸš€ **Performance Best Practices**

### **1. Cache Strategy**

```typescript
// Cache levels theo Ä‘á»™ Æ°u tiÃªn
export const CacheStrategies = {
    // Public data - cache lÃ¢u nháº¥t
    PUBLIC: { ttl: 10 * 60 * 1000, condition: (req) => !req.headers.authorization },
    
    // User-specific data - cache trung bÃ¬nh  
    USER: { ttl: 5 * 60 * 1000, condition: (req) => req.method === 'GET' },
    
    // Admin data - cache ngáº¯n
    ADMIN: { ttl: 2 * 60 * 1000, condition: (req) => req.method === 'GET' },
    
    // Real-time data - khÃ´ng cache
    REALTIME: { ttl: 0 }
};
```

### **2. Database Query Patterns**

```typescript
// âœ… Tá»T - Optimized query
const optimizedQuery = async () => {
    return await DatabaseOptimizer.paginate(
        Model.find(filter)
            .lean() // Faster object creation
            .select('field1 field2') // Only needed fields
            .populate('relation', 'name'), // Limited populate
        page,
        limit,
        { created_at: -1 }
    );
};

// âŒ TRÃNH - Non-optimized query
const slowQuery = async () => {
    const docs = await Model.find(filter); // Full objects
    const total = await Model.countDocuments(filter); // Separate count
    return { docs, total };
};
```

### **3. Memory Management**

```typescript
// Monitor memory usage trong critical operations
const performCriticalOperation = async () => {
    MemoryManager.logMemoryUsage('Start Operation');
    
    // Large data processing
    const results = await heavyDataProcessing();
    
    MemoryManager.logMemoryUsage('After Processing');
    
    // Clear memory if needed
    if (process.memoryUsage().heapUsed > 100 * 1024 * 1024) { // 100MB
        global.gc && global.gc();
        MemoryManager.logMemoryUsage('After GC');
    }
    
    return results;
};
```

## ðŸ“ˆ **Monitoring & Analytics**

### **Performance Metrics Dashboard**

```typescript
// Custom metrics tracking
app.get('/api/admin/performance', async (req, res) => {
    const metrics = {
        memory: process.memoryUsage(),
        uptime: process.uptime(),
        
        // Database connection status
        database: {
            status: PerformanceMonitor.getPoolStatus(),
            activeQueries: DatabaseOptimizer.getActiveQueries()
        },
        
        // Cache statistics
        cache: CacheManager.getStats(),
        
        // Recent performance logs
        recentLogs: PerformanceMonitor.getRecentLogs(10)
    };
    
    res.json(metrics);
});
```

## ðŸ”§ **Environment Configuration**

### **Production Environment Variables**

```bash
# .env.production
NODE_ENV=production

# Database optimization
MONGODB_MAX_POOL_SIZE=10
MONGODB_MIN_POOL_SIZE=2
MONGODB_MAX_IDLE_TIME=30000

# Caching
CACHE_TTL_DEFAULT=300000  # 5 minutes
CACHE_MAX_SIZE=100        # Max cached items

# Performance
ENABLE_PERFORMANCE_MONITORING=true
ENABLE_MEMORY_LOGGING=true
GC_INTERVAL=60000         # Garbage collection interval

# Vercel specific
VERCEL_REGION=hkg1        # Hong Kong for Asia optimization
```

### **Package.json Scripts**

```json
{
    "scripts": {
        "start": "node dist/server.js",
        "build": "tsc && npm run copy-assets",
        "copy-assets": "cp -r assets dist/ && cp swagger.yaml dist/",
        "dev": "nodemon src/server.ts",
        "vercel-build": "npm run build",
        "test:performance": "node scripts/performance-test.js"
    }
}
```

## ðŸŽ¯ **Deployment Checklist**

### **Pre-deployment**

- [ ] âœ… Verify `vercel.json` configuration
- [ ] âœ… Check environment variables
- [ ] âœ… Test caching middleware
- [ ] âœ… Validate database connection pooling
- [ ] âœ… Performance test critical endpoints
### Validate Password Security
- [ ] âœ… Test password security configuration
- [ ] âœ… Verify BCRYPT_SALT_ROUNDS setting
- [ ] âœ… Check password validation rules from env
- [ ] âœ… Test password hashing performance
- [ ] âœ… Validate security headers configuration


### **Post-deployment**

- [ ] ðŸ“Š Monitor `/api/admin/performance` endpoint
- [ ] ðŸ” Check Vercel function logs
- [ ] âš¡ Test response times for cached vs uncached
- [ ] ðŸ’¾ Verify memory usage patterns
- [ ] ðŸ”„ Test pagination performance

## ðŸ“ž **Support & Troubleshooting**

### **Common Issues**

1. **High memory usage**: Enable garbage collection and monitor heap size
2. **Slow database queries**: Use `DatabaseOptimizer.lean()` and proper indexing
3. **Cache not working**: Check middleware order and cache conditions
4. **Connection timeouts**: Verify MongoDB connection pool settings

### **Debug Commands**

```bash
# Check memory usage
curl https://your-api.vercel.app/api/admin/performance

# Test specific endpoint performance
time curl https://your-api.vercel.app/api/your-endpoint

# View Vercel function logs
vercel logs your-function-name
```

---



================================================
FILE: render.yaml
================================================
services:
  - type: web
    name: rest-api-nodejs-express-mongodb
    env: node
    buildCommand: npm install -g pnpm && pnpm install && pnpm run build
    startCommand: pnpm start
    envVars:
      - key: NODE_ENV
        value: production



================================================
FILE: swagger.yaml
================================================
swagger: '2.0'
info:
  description: 'HuyIT Bloodline DNA Testing Service Management System API docs'
  version: '1.0.0'
  title: 'Bloodline DNA Testing Service Management System'
  termOfService: 'HuyIT'
  contact:
    email: 'huyit2003@gmail.com'
  license:
    name: 'MIT'
    url: 'https://opensource.org/licenses/MIT'
basePath: '/api'
tags:
- name: 'auth'
  description: 'Authentication APIs'
- name: 'users'
  description: 'User management APIs'
- name: 'services'
  description: 'Service management APIs'
- name: 'departments'
  description: 'Department management APIs'
- name: 'slots'
  description: 'Slot management APIs'
- name: 'kits'
  description: 'Kit management APIs'
- name: 'appointments'
  description: 'Appointment management APIs'
- name: 'appointment_logs'
  description: 'Appointment log APIs'

schemes:
- 'https'
- 'http'

# Declare security scheme
securityDefinitions:
  Bearer:
    type: 'apiKey'
    name: 'Authorization'
    in: 'header'
    description: 'Bearer token for authorization'
    x-tokenName: 'token'
    x-tokenPrefix: 'Bearer '

paths:
  /auth:
    post:
      tags:
      - 'auth'
      summary: 'Login API and get token'
      description: 'Input email and password'
      operationId: "login"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Login for user'
        required: true
        schema: 
          $ref: '#/definitions/LoginDto'
      responses:
        '200':
          description: 'Login successful'
          schema:
            $ref: '#/definitions/TokenResponse'
        '400':
          description: 'Invalid input'
    get:
      tags:
        - 'auth'
      summary: 'Get current logged-in user'
      description: 'Retrieve information about the current logged-in user'
      operationId: "getCurrentLoginUser"
      produces:
        - 'application/json'
      security:
        - Bearer: []
      responses:
        '200':
          description: 'Current logged-in user information'
          schema:
            $ref: '#/definitions/UserResponse'
        '401':
          description: 'Unauthorized - user not logged in'
        '404':
          description: 'User not found'

  /auth/google:
    post:
      tags:
      - 'auth'
      summary: 'Login API and get token By Google'
      description: 'Input google_id'
      operationId: "loginByGoogle"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Login for user via google'
        required: true
        schema: 
          $ref: '#/definitions/LoginGoogleDto'
      responses:
        '200':
          description: 'Login successful'
          schema:
            $ref: '#/definitions/TokenResponse'
        '400':
          description: 'Invalid input'
          
  /auth/verify-token:
    post:
      tags:
      - 'auth'
      summary: 'Verify Token'
      description: 'Input verifyToken'
      operationId: "verifyToken"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: ''
        required: true
        schema: 
          $ref: '#/definitions/VerifiedTokenDto'
      responses:
        '200':
          description: 'Token verified successfully'
        '400':
          description: 'Invalid input'
          
  /auth/resend-token:
    post:
      tags:
      - 'auth'
      summary: 'Resend Token'
      description: 'Resend verification token to user email'
      operationId: "resendToken"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Email to send verification token'
        required: true
        schema: 
          $ref: '#/definitions/EmailDto'
      responses:
        '200':
          description: 'Token resent successfully'
        '400':
          description: 'Invalid input'
          
  /auth/forgot-password:
    put:
      tags:
      - 'auth'
      summary: 'Forgot Password'
      description: 'Request a password reset'
      operationId: "forgotPassword"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Email to send reset password'
        required: true
        schema: 
          $ref: '#/definitions/EmailDto'
      responses:
        '200':
          description: 'Password reset email sent successfully'
        '400':
          description: 'Invalid input'
          
  /auth/logout:
    get:
      tags:
      - 'auth'
      summary: 'Logout'
      description: 'Logout current user session'
      operationId: "logout"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      responses:
        '200':
          description: 'Logout successful'
        '401':
          description: 'Unauthorized - user not logged in'

  # User routes
  /users:
    post:
      tags:
      - 'users'
      summary: 'Register new user'
      description: 'Register a new user account'
      operationId: "registerUser"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'User registration data'
        required: true
        schema: 
          $ref: '#/definitions/RegisterDto'
      responses:
        '201':
          description: 'User registered successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
          
  /users/generate:
    post:
      tags:
      - 'users'
      summary: 'Generate admin user'
      description: 'Generate default admin user'
      operationId: "generateAdminUser"
      produces:
      - 'application/json'
      responses:
        '201':
          description: 'Admin user created successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Error creating admin user'
          
  /users/google:
    post:
      tags:
      - 'users'
      summary: 'Register with Google'
      description: 'Register a new user with Google account'
      operationId: "registerWithGoogle"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Google registration data'
        required: true
        schema: 
          $ref: '#/definitions/LoginGoogleDto'
      responses:
        '201':
          description: 'User registered successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
          
  /users/create:
    post:
      tags:
      - 'users'
      summary: 'Create user (Admin only)'
      description: 'Create a new user (Admin only)'
      operationId: "createUser"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'User data'
        required: true
        schema: 
          $ref: '#/definitions/RegisterDto'
      responses:
        '201':
          description: 'User created successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/search:
    post:
      tags:
      - 'users'
      summary: 'Search users (Admin only)'
      description: 'Search for users with pagination'
      operationId: "searchUsers"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Search criteria and pagination'
        required: true
        schema: 
          $ref: '#/definitions/SearchPaginationUserDto'
      responses:
        '200':
          description: 'Search results'
          schema:
            $ref: '#/definitions/SearchPaginationResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/{id}:
    get:
      tags:
      - 'users'
      summary: 'Get user by ID'
      description: 'Get user information by ID'
      operationId: "getUserById"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'User ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'User information'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid ID'
        '404':
          description: 'User not found'
    put:
      tags:
      - 'users'
      summary: 'Update user'
      description: 'Update user information'
      operationId: "updateUser"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'User ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Updated user data'
        required: true
        schema: 
          $ref: '#/definitions/UpdateUserDto'
      responses:
        '200':
          description: 'User updated successfully'
          schema:
            $ref: '#/definitions/UserResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
    delete:
      tags:
      - 'users'
      summary: 'Delete user (Admin only)'
      description: 'Delete user by ID (soft delete)'
      operationId: "deleteUser"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'User ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'User deleted successfully'
        '400':
          description: 'Invalid ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'User not found'
          
  /users/change-password:
    put:
      tags:
      - 'users'
      summary: 'Change password'
      description: 'Change user password'
      operationId: "changePassword"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Password change data'
        required: true
        schema: 
          $ref: '#/definitions/ChangePasswordDto'
      responses:
        '200':
          description: 'Password changed successfully'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/change-status:
    put:
      tags:
      - 'users'
      summary: 'Change user status (Admin only)'
      description: 'Enable or disable a user account'
      operationId: "changeUserStatus"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Status change data'
        required: true
        schema: 
          $ref: '#/definitions/ChangeStatusDto'
      responses:
        '200':
          description: 'Status changed successfully'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /users/change-role:
    put:
      tags:
      - 'users'
      summary: 'Change user role (Admin only)'
      description: 'Change the role of a user'
      operationId: "changeUserRole"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Role change data'
        required: true
        schema: 
          $ref: '#/definitions/ChangeRoleDto'
      responses:
        '200':
          description: 'Role changed successfully'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
          
  /service/create:
    post:
      tags:
      - 'services'
      summary: 'Create new service (Admin, Manager only)'
      description: 'Create a new service '
      operationId: "createService"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Service information'
        required: true
        schema: 
          $ref: '#/definitions/CreateServiceDto'
      responses:
        '201':
          description: 'Service created successfully'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'

  /service/search:
    get:
      tags:
      - 'services'
      summary: 'Search and filter services (All roles)'
      description: 'Search services with pagination and filtering'
      operationId: "getServices"
      produces:
      - 'application/json'
      parameters:
      - in: 'query'
        name: 'type'
        description: 'Filter by service type (civil, administrative)'
        required: false
        type: 'string'
      - in: 'query'
        name: 'sample_method'
        description: 'Filter by sample method (self_collected, facility_collected, home_collected)'
        required: false
        type: 'string'
      - in: 'query'
        name: 'is_active'
        description: 'Filter by active status'
        required: false
        type: 'boolean'
      - in: 'query'
        name: 'min_price'
        description: 'Minimum price'
        required: false
        type: 'number'
      - in: 'query'
        name: 'max_price'
        description: 'Maximum price'
        required: false
        type: 'number'
      - in: 'query'
        name: 'pageNum'
        description: 'Page number'
        required: false
        type: 'integer'
        default: 1
      - in: 'query'
        name: 'pageSize'
        description: 'Items per page'
        required: false
        type: 'integer'
        default: 10
      - in: 'query'
        name: 'keyword'
        description: 'Search by name or description'
        required: false
        type: 'string'
      - in: 'query'
        name: 'sort_by'
        description: 'Sort field (name, price, created_at, estimated_time)'
        required: false
        type: 'string'
        default: 'created_at'
      - in: 'query'
        name: 'sort_order'
        description: 'Sort order (asc, desc)'
        required: false
        type: 'string'
        default: 'desc'
      - in: 'query'
        name: 'start_date'
        description: 'Filter by creation date (start)'
        required: false
        type: 'string'
        format: 'date'
      - in: 'query'
        name: 'end_date'
        description: 'Filter by creation date (end)'
        required: false
        type: 'string'
        format: 'date'
      responses:
        '200':
          description: 'Service list with pagination'
          schema:
            $ref: '#/definitions/ServicePaginationResponse'
        '401':
          description: 'Unauthorized'

  /service/{id}:
    get:
      tags:
      - 'services'
      summary: 'Get service by ID (All roles)'
      description: 'Retrieve service details by ID'
      operationId: "getServiceById"
      produces:
      - 'application/json'
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Service details'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'
          
    put:
      tags:
      - 'services'
      summary: 'Update service (Admin, Manager only)'
      description: 'Update service information'
      operationId: "updateService"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Updated service information'
        required: true
        schema: 
          $ref: '#/definitions/UpdateServiceDto'
      responses:
        '200':
          description: 'Service updated successfully'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

    delete:
      tags:
      - 'services'
      summary: 'Delete service (Admin, Manager only)'
      description: 'Delete service (soft delete)'
      operationId: "deleteService"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Service deleted successfully'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

  /service/{id}/child:
    get:
      tags:
      - 'services'
      summary: 'Get child services by parent service ID (All roles)'
      description: 'Retrieve all services that have the given service as their parent'
      operationId: "getChildServices"
      produces:
      - 'application/json'
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Parent service ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'List of child services'
          schema:
            type: array
            items:
              $ref: '#/definitions/ServiceResponse'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Parent service not found'

  /service/appointments:
    get:
      tags:
      - 'services'
      summary: 'Get services by appointment criteria (Admin, Manager, Staff only)'
      description: 'Filter services based on related appointments'
      operationId: "getServicesByAppointment"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'status'
        description: 'Filter by appointment status'
        required: false
        type: 'string'
      - in: 'query'
        name: 'start_appointment_date'
        description: 'Filter by appointment date (start)'
        required: false
        type: 'string'
        format: 'date'
      - in: 'query'
        name: 'end_appointment_date'
        description: 'Filter by appointment date (end)'
        required: false
        type: 'string'
        format: 'date'
      - in: 'query'
        name: 'appointment_type'
        description: 'Filter by appointment type (self, facility, home)'
        required: false
        type: 'string'
      - in: 'query'
        name: 'customer_id'
        description: 'Filter by customer ID'
        required: false
        type: 'string'
      - in: 'query'
        name: 'staff_id'
        description: 'Filter by staff ID'
        required: false
        type: 'string'
      - in: 'query'
        name: 'collection_address'
        description: 'Filter by collection address'
        required: false
        type: 'string'
      - in: 'query'
        name: 'pageNum'
        description: 'Page number'
        required: false
        type: 'integer'
        default: 1
      - in: 'query'
        name: 'pageSize'
        description: 'Items per page'
        required: false
        type: 'integer'
        default: 10
      responses:
        '200':
          description: 'Service list filtered by appointment data'
          schema:
            $ref: '#/definitions/ServicePaginationResponse'
        '401':
          description: 'Unauthorized'

  /department/create:
    post:
      tags:
      - 'departments'
      summary: 'Create new department (Admin only)'
      description: 'Create a new department with manager assignment'
      operationId: "createDepartment"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'body'
        name: 'body'
        description: 'Department information'
        required: true
        schema: 
          $ref: '#/definitions/CreateDepartmentDto'
      responses:
        '201':
          description: 'Department created successfully'
          schema:
            $ref: '#/definitions/DepartmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '409':
          description: 'Department with this name already exists'

  /department/search:
    get:
      tags:
      - 'departments'
      summary: 'Search and filter departments (Admin, Manager, Laboratory Technician, Staff)'
      description: 'Search departments with pagination and filtering'
      operationId: "getDepartments"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'pageNum'
        description: 'Page number'
        required: false
        type: 'integer'
        default: 1
      - in: 'query'
        name: 'pageSize'
        description: 'Items per page'
        required: false
        type: 'integer'
        default: 10
      - in: 'query'
        name: 'keyword'
        description: 'Search by name or description'
        required: false
        type: 'string'
      - in: 'query'
        name: 'sort_by'
        description: 'Sort field (name, created_at, updated_at)'
        required: false
        type: 'string'
        default: 'created_at'
      - in: 'query'
        name: 'sort_order'
        description: 'Sort order (asc, desc)'
        required: false
        type: 'string'
        default: 'desc'
      - in: 'query'
        name: 'is_deleted'
        description: 'Filter by deletion status'
        required: false
        type: 'boolean'
        default: false
      - in: 'query'
        name: 'is_active'
        description: 'Filter by active status'
        required: false
        type: 'boolean'
      responses:
        '200':
          description: 'Department list with pagination'
          schema:
            $ref: '#/definitions/DepartmentPaginationResponse'
        '401':
          description: 'Unauthorized'

  /department/manager/{managerId}:
    get:
      tags:
      - 'departments'
      summary: 'Get departments by manager ID (Admin, Manager)'
      description: 'Retrieve departments managed by a specific manager'
      operationId: "getManagerDepartments"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'managerId'
        description: 'Manager ID'
        required: true
        type: 'string'
      - in: 'query'
        name: 'is_deleted'
        description: 'Filter by deletion status'
        required: false
        type: 'boolean'
        default: false
      responses:
        '200':
          description: 'List of departments managed by the manager'
          schema:
            type: 'object'
            properties:
              departments:
                type: 'array'
                items:
                  $ref: '#/definitions/DepartmentResponse'
              count:
                type: 'integer'
                description: 'Number of departments'
        '400':
          description: 'Invalid manager ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Manager not found'

  /department/count:
    get:
      tags:
      - 'departments'
      summary: 'Count departments (Admin, Manager)'
      description: 'Count total number of departments in the system'
      operationId: "countDepartments"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'is_deleted'
        description: 'Filter by deletion status'
        required: false
        type: 'boolean'
        default: false
      responses:
        '200':
          description: 'Count of departments'
          schema:
            type: 'object'
            properties:
              totalDepartments:
                type: 'integer'
                description: 'Total number of departments'
        '401':
          description: 'Unauthorized'

  /department/{id}:
    get:
      tags:
      - 'departments'
      summary: 'Get department by ID (Admin, Manager, Laboratory Technician, Staff)'
      description: 'Retrieve department details by ID'
      operationId: "getDepartmentById"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Department ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Department details'
          schema:
            $ref: '#/definitions/DepartmentResponse'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'
          
    put:
      tags:
      - 'departments'
      summary: 'Update department (Admin, Manager)'
      description: 'Update department information'
      operationId: "updateDepartment"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Department ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Updated department information'
        required: true
        schema: 
          $ref: '#/definitions/UpdateDepartmentDto'
      responses:
        '200':
          description: 'Department updated successfully'
          schema:
            $ref: '#/definitions/DepartmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'
        '409':
          description: 'Department with this name already exists'

    delete:
      tags:
      - 'departments'
      summary: 'Delete department (Admin only)'
      description: 'Delete department (soft delete)'
      operationId: "deleteDepartment"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Department ID'
        required: true
        type: 'string'
      responses:
        '200':
          description: 'Department deleted successfully'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  # Additional service endpoints (not already in your swagger.yaml)
  /service/statistics:
    get:
      tags:
      - 'services'
      summary: 'Get service statistics (Admin, Manager)'
      description: 'Count services grouped by type, status, and sample method'
      operationId: "countServicesByType"
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'query'
        name: 'is_active'
        description: 'Filter by active status'
        required: false
        type: 'boolean'
      - in: 'query'
        name: 'keyword'
        description: 'Search by name or description'
        required: false
        type: 'string'
      responses:
        '200':
          description: 'Service statistics'
          schema:
            type: 'object'
            properties:
              total:
                type: 'integer'
                description: 'Total number of services'
              byType:
                type: 'object'
                description: 'Services counted by type'
                properties:
                  civil:
                    type: 'integer'
                  administrative:
                    type: 'integer'
              byStatus:
                type: 'object'
                description: 'Services counted by status'
                properties:
                  active:
                    type: 'integer'
                  inactive:
                    type: 'integer'
              bySampleMethod:
                type: 'object'
                description: 'Services counted by sample method'
                properties:
                  self_collected:
                    type: 'integer'
                  facility_collected:
                    type: 'integer'
                  home_collected:
                    type: 'integer'
        '401':
          description: 'Unauthorized'

  /service/{id}/status:
    patch:
      tags:
      - 'services'
      summary: 'Change service status (Admin, Manager)'
      description: 'Activate or deactivate a service'
      operationId: "changeServiceStatus"
      consumes:
      - 'application/json'
      produces:
      - 'application/json'
      security:
        - Bearer: []
      parameters:
      - in: 'path'
        name: 'id'
        description: 'Service ID'
        required: true
        type: 'string'
      - in: 'body'
        name: 'body'
        description: 'Status change data'
        required: true
        schema:
          type: 'object'
          properties:
            is_active:
              type: 'boolean'
              description: 'New active status'
          required:
            - is_active
      responses:
        '200':
          description: 'Service status changed successfully'
          schema:
            $ref: '#/definitions/ServiceResponse'
        '400':
          description: 'Invalid input or service is deleted'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

  # Staff Profile APIs
  /staff-profile/create:
    post:
      tags:
        - 'staff_profiles'
      summary: 'Create a new staff profile (Admin, Manager only)'
      description: 'Create a new staff profile with user and department association'
      operationId: 'createStaffProfile'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'body'
          name: 'body'
          description: 'Staff profile data'
          required: true
          schema:
            $ref: '#/definitions/CreateStaffProfileDto'
      responses:
        '201':
          description: 'Staff profile created successfully'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '409':
          description: 'User already has a staff profile'

  /staff-profile/search:
    get:
      tags:
        - 'staff_profiles'
      summary: 'Search staff profiles (Admin, Manager only)'
      description: 'Search for staff profiles with pagination and filtering'
      operationId: 'getStaffProfiles'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          description: 'Page number'
          required: false
          type: 'integer'
          default: 1
        - in: 'query'
          name: 'pageSize'
          description: 'Items per page'
          required: false
          type: 'integer'
          default: 10
        - in: 'query'
          name: 'department_id'
          description: 'Filter by department ID'
          required: false
          type: 'string'
        - in: 'query'
          name: 'status'
          description: 'Filter by staff status'
          required: false
          type: 'string'
        - in: 'query'
          name: 'keyword'
          description: 'Search by employee ID or job title'
          required: false
          type: 'string'
        - in: 'query'
          name: 'hire_date_from'
          description: 'Filter by hire date (start)'
          required: false
          type: 'string'
          format: 'date'
        - in: 'query'
          name: 'hire_date_to'
          description: 'Filter by hire date (end)'
          required: false
          type: 'string'
          format: 'date'
      responses:
        '200':
          description: 'Staff profile list with pagination'
          schema:
            $ref: '#/definitions/StaffProfilePaginationResponse'
        '401':
          description: 'Unauthorized'

  /staff-profile/department/{id}:
    get:
      tags:
        - 'staff_profiles'
      summary: 'Get staff profiles by department ID (Admin, Manager only)'
      description: 'Retrieve staff profiles associated with a specific department'
      operationId: 'getStaffProfilesByDepartment'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Department ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of staff profiles in the department'
          schema:
            $ref: '#/definitions/StaffProfilePaginationResponse'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  /staff-profile/{id}:
    get:
      tags:
        - 'staff_profiles'
      summary: 'Get staff profile by ID (Admin, Manager only)'
      description: 'Retrieve staff profile details by ID'
      operationId: 'getStaffProfileById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Staff profile ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'Staff profile details'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid staff profile ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'
    put:
      tags:
        - 'staff_profiles'
      summary: 'Update staff profile (Admin, Manager only)'
      description: 'Update staff profile information'
      operationId: 'updateStaffProfile'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Staff profile ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Updated staff profile data'
          required: true
          schema:
            $ref: '#/definitions/UpdateStaffProfileDto'
      responses:
        '200':
          description: 'Staff profile updated successfully'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'

  /staff-profile/{id}/status:
    put:
      tags:
        - 'staff_profiles'
      summary: 'Change staff status (Admin, Manager only)'
      description: 'Change the status of a staff profile'
      operationId: 'changeStaffStatus'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Staff profile ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Status change data'
          required: true
          schema:
            type: 'object'
            properties:
              status:
                type: 'string'
                description: 'New status'
                enum: ['active', 'on_leave', 'terminated']
      responses:
        '200':
          description: 'Staff status changed successfully'
          schema:
            $ref: '#/definitions/StaffProfileResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'

  # Slot APIs
  /slot/create:
    post:
      tags:
        - slots
      summary: 'Create a new slot (Admin, Manager only)'
      description: 'Create a new slot for staff profiles'
      operationId: 'createSlot'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'body'
          name: 'body'
          description: 'Slot data'
          required: true
          schema:
            $ref: '#/definitions/CreateSlotDto'
      responses:
        '201':
          description: 'Slot created successfully'
          schema:
            $ref: '#/definitions/SlotResponse'
      '400':
        description: 'Invalid input'
      '401':
        description: 'Unauthorized'

  /slot/search:
    get:
      tags:
        - slots
      summary: 'Search slots with filters (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Search for slots with pagination and filtering'
      operationId: 'getSlots'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          type: 'integer'
          default: 1
          description: 'Page number for pagination'
        - in: 'query'
          name: 'pageSize'
          type: 'integer'
          default: 10
          description: 'Number of items per page'
        - in: 'query'
          name: 'staff_profile_ids'
          type: 'string'
          description: 'Filter by staff profile IDs (comma-separated or single value)'
        - in: 'query'
          name: 'department_id'
          type: 'string'
          description: 'Filter by department ID'
        - in: 'query'
          name: 'appointment_id'
          type: 'string'
          description: 'Filter by appointment ID'
        - in: 'query'
          name: 'status'
          type: 'string'
          enum: ['available', 'booked', 'unavailable']
          description: 'Filter by slot status'
        - in: 'query'
          name: 'date_from'
          type: 'string'
          format: 'date'
          description: 'Filter by start date (inclusive)'
        - in: 'query'
          name: 'date_to'
          type: 'string'
          format: 'date'
          description: 'Filter by end date (inclusive)'
        - in: 'query'
          name: 'sort_by'
          type: 'string'
          default: 'start_time'
          description: 'Field to sort by'
        - in: 'query'
          name: 'sort_order'
          type: 'integer'
          default: 1
          enum: [1, -1]
          description: 'Sort order (1: ascending, -1: descending)'
      responses:
        '200':
          description: 'Slot list with pagination'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '401':
          description: 'Unauthorized'

  /slot/available:
    get:
      tags:
        - slots
      summary: 'Get available slots for booking (Public)'
      description: 'Retrieve available slots for booking with optional filters'
      operationId: 'getAvailableSlots'
      produces:
        - 'application/json'
      parameters:
        - in: 'query'
          name: 'start_date'
          type: 'string'
          format: 'date'
          required: true
          description: 'Start date to search for available slots'
        - in: 'query'
          name: 'end_date'
          type: 'string'
          format: 'date'
          description: 'End date to search for available slots (defaults to 7 days from start_date if not provided)'
        - in: 'query'
          name: 'type'
          type: 'string'
          enum: ['self_collected', 'facility_collected', 'home_collected']
          description: 'Filter by sample collection method'
      responses:
        '200':
          description: 'Available slots with pagination'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid input (e.g., missing required parameters)'

  /slot/{id}:
    get:
      tags:
        - slots
      summary: 'Get slot by ID (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Retrieve slot details by ID'
      operationId: 'getSlotById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          type: 'string'
          required: true
      responses:
        '200':
          description: 'Slot details'
          schema:
            $ref: '#/definitions/SlotResponse'
        '400':
          description: 'Invalid slot ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Slot not found'
    put:
      tags:
        - slots
      summary: 'Update slot (Admin, Manager only)'
      description: 'Update slot information'
      operationId: 'updateSlot'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Slot ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Updated slot data'
          required: true
          schema:
            $ref: '#/definitions/UpdateSlotDto'
      responses:
        '200':
          description: 'Slot updated successfully'
          schema:
            $ref: '#/definitions/SlotResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Slot not found'

  /slot/{id}/status:
    patch:
      tags:
        - slots
      summary: 'Change slot status (Admin, Manager only)'
      description: 'Change the status of a slot'
      operationId: 'changeSlotStatus'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Slot ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Status change data'
          required: true
          schema:
            type: 'object'
            properties:
              status:
                type: 'string'
                description: 'New status'
                enum: ['available', 'booked', 'unavailable']
            required:
              - status
      responses:
        '200':
          description: 'Slot status changed successfully'
          schema:
            $ref: '#/definitions/SlotResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Slot not found'

  /slot/staff/{staffProfileId}:
    get:
      tags:
        - slots
      summary: 'Get slots by staff profile ID (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Retrieve slots associated with a specific staff profile'
      operationId: 'getSlotsByStaff'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'staffProfileId'
          description: 'Staff profile ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of slots for the staff profile'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid staff profile ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Staff profile not found'

  /slot/department/{departmentId}:
    get:
      tags:
        - slots
      summary: 'Get slots by department ID (Admin, Manager only)'
      description: 'Retrieve slots associated with a specific department'
      operationId: 'getSlotsByDepartment'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'departmentId'
          description: 'Department ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of slots for the department'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  /slot/service/{serviceId}:
    get:
      tags:
        - slots
      summary: 'Get slots by service ID (Admin, Manager, Laboratory Technician, Staff only)'
      description: 'Retrieve slots associated with a specific service'
      operationId: 'getSlotsByService'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'serviceId'
          description: 'Service ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of slots for the service'
          schema:
            $ref: '#/definitions/SlotPaginationResponse'
        '400':
          description: 'Invalid service ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Service not found'

  /department/{departmentId}/statistics:
    get:
      tags:
        - 'departments'
      summary: 'Get department performance statistics (Admin, Manager only)'
      description: 'Retrieve performance statistics for a department, including staff count, slot count, and booking rate'
      operationId: 'getDepartmentPerformance'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'departmentId'
          description: 'Department ID'
          required: true
          type: 'string'
        - in: 'query'
          name: 'date_from'
          description: 'Filter by start date'
          required: false
          type: 'string'
          format: 'date'
        - in: 'query'
          name: 'date_to'
          description: 'Filter by end date'
          required: false
          type: 'string'
          format: 'date'
      responses:
        '200':
          description: 'Department performance statistics'
          schema:
            type: 'object'
            properties:
              totalStaff:
                type: 'integer'
                description: 'Total number of active staff in the department'
              totalSlots:
                type: 'integer'
                description: 'Total number of slots'
              bookedSlots:
                type: 'integer'
                description: 'Number of booked slots'
              bookingRate:
                type: 'number'
                format: 'float'
                description: 'Booking rate percentage'
        '400':
          description: 'Invalid department ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Department not found'

  # Kit APIs
  /kit/create:
    post:
      tags:
        - 'kits'
      summary: 'Create a new kit (Admin, Manager only)'
      description: 'Create a new kit with auto-generated code'
      operationId: 'createKit'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      responses:
        '201':
          description: 'Kit created successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '409':
          description: 'Kit code already exists'

  /kit/search:
    get:
      tags:
        - 'kits'
      summary: 'Search kits (Admin, Manager, Staff only)'
      description: 'Search for kits with pagination and filtering'
      operationId: 'searchKits'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          description: 'Page number'
          required: false
          type: 'integer'
          default: 1
        - in: 'query'
          name: 'pageSize'
          description: 'Items per page'
          required: false
          type: 'integer'
          default: 10
        - in: 'query'
          name: 'code'
          description: 'Filter by kit code'
          required: false
          type: 'string'
        - in: 'query'
          name: 'status'
          description: 'Filter by kit status'
          required: false
          type: 'string'
          enum: ['available', 'assigned', 'used', 'returned', 'damaged']
        - in: 'query'
          name: 'appointment_id'
          description: 'Filter by appointment ID'
          required: false
          type: 'string'
        - in: 'query'
          name: 'assigned_to_user_id'
          description: 'Filter by assigned user ID'
          required: false
          type: 'string'
      responses:
        '200':
          description: 'Kit list with pagination'
          schema:
            $ref: '#/definitions/KitPaginationResponse'
        '401':
          description: 'Unauthorized'

  /kit/available:
    get:
      tags:
        - 'kits'
      summary: 'Get available kits (Admin, Manager, Staff only)'
      description: 'Retrieve all available kits'
      operationId: 'getAvailableKits'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      responses:
        '200':
          description: 'List of available kits'
          schema:
            type: 'array'
            items:
              $ref: '#/definitions/KitResponse'
        '401':
          description: 'Unauthorized'

  /kit/{id}:
    get:
      tags:
        - 'kits'
      summary: 'Get kit by ID (Admin, Manager, Staff only)'
      description: 'Retrieve kit details by ID'
      operationId: 'getKitById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'Kit details'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid kit ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'
    put:
      tags:
        - 'kits'
      summary: 'Update kit (Admin, Manager only)'
      description: 'Update kit information'
      operationId: 'updateKit'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Updated kit data'
          required: true
          schema:
            $ref: '#/definitions/UpdateKitDto'
      responses:
        '200':
          description: 'Kit updated successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'
    delete:
      tags:
        - 'kits'
      summary: 'Delete kit (Admin, Manager only)'
      description: 'Mark a kit as damaged'
      operationId: 'deleteKit'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'Kit deleted successfully'
          schema:
            $ref: '#/definitions/SuccessResponse'
        '400':
          description: 'Invalid kit ID or kit is currently assigned/in use'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'

  /kit/{id}/status:
    patch:
      tags:
        - 'kits'
      summary: 'Change kit status (Admin, Manager, Staff only)'
      description: 'Change the status of a kit'
      operationId: 'changeKitStatus'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Status change data'
          required: true
          schema:
            type: 'object'
            properties:
              status:
                type: 'string'
                description: 'New status'
                enum: ['available', 'assigned', 'used', 'returned', 'damaged']
            required:
              - status
      responses:
        '200':
          description: 'Kit status changed successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'

  /kit/{id}/return:
    post:
      tags:
        - 'kits'
      summary: 'Return a kit (Admin, Manager, Staff only)'
      description: 'Return a previously assigned or used kit'
      operationId: 'returnKit'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Kit ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Return notes (optional)'
          required: false
          schema:
            type: 'object'
            properties:
              notes:
                type: string
                description: 'Notes about the returned kit'
      responses:
        '200':
          description: 'Kit returned successfully'
          schema:
            $ref: '#/definitions/KitResponse'
        '400':
          description: 'Invalid input or kit is not in assigned/used status'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Kit not found'

  # Appointment APIs
  /appointment/create:
    post:
      tags:
        - 'appointments'
      summary: 'Create a new appointment (Customer only)'
      description: 'Create a new appointment for a service'
      operationId: 'createAppointment'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'body'
          name: 'body'
          description: 'Appointment data'
          required: true
          schema:
            $ref: '#/definitions/CreateAppointmentDto'
      responses:
        '201':
          description: 'Appointment created successfully'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'

  /appointment/search:
    get:
      tags:
        - 'appointments'
      summary: 'Search appointments'
      description: 'Search for appointments with pagination and filtering'
      operationId: 'searchAppointments'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'query'
          name: 'pageNum'
          type: 'integer'
          default: 1
        - in: 'query'
          name: 'pageSize'
          type: 'integer'
          default: 10
        - in: 'query'
          name: 'status'
          type: 'string'
        - in: 'query'
          name: 'customer_id'
          type: 'string'
        - in: 'query'
          name: 'service_id'
          type: 'string'
        - in: 'query'
          name: 'staff_id'
          type: 'string'
        - in: 'query'
          name: 'date_from'
          type: 'string'
          format: 'date'
        - in: 'query'
          name: 'date_to'
          type: 'string'
          format: 'date'
    responses:
      '200':
        description: 'Appointment list with pagination'
        schema:
          $ref: '#/definitions/AppointmentPaginationResponse'
      '401':
        description: 'Unauthorized'

  /appointment/{id}:
    get:
      tags:
        - 'appointments'
      summary: 'Get appointment by ID'
      description: 'Retrieve appointment details by ID'
      operationId: 'getAppointmentById'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          type: 'string'
          required: true
      responses:
        '200':
          description: 'Appointment details'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid appointment ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

  /appointment/{id}/assign-staff:
    put:
      tags:
        - 'appointments'
      summary: 'Assign staff to appointment (Manager only)'
      description: 'Assign staff to an existing appointment'
      operationId: 'assignStaffToAppointment'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Appointment ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Staff assignment data'
          required: true
          schema:
            $ref: '#/definitions/AssignStaffDto'
      responses:
        '200':
          description: 'Staff assigned successfully'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

  /appointment/{id}/confirm:
    put:
      tags:
        - 'appointments'
      summary: 'Confirm appointment and assign kit (Staff only)'
      description: 'Confirm an appointment, assign a kit, and update its status'
      operationId: 'confirmAppointment'
      consumes:
        - 'application/json'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'id'
          description: 'Appointment ID'
          required: true
          type: 'string'
        - in: 'body'
          name: 'body'
          description: 'Confirmation data with kit assignment'
          required: true
          schema:
            $ref: '#/definitions/ConfirmAppointmentDto'
      responses:
        '200':
          description: 'Appointment confirmed successfully'
          schema:
            $ref: '#/definitions/AppointmentResponse'
        '400':
          description: 'Invalid input'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

  # Appointment Log APIs
  /appointment-logs/appointment/{appointmentId}:
    get:
      tags:
        - 'appointment_logs'
      summary: 'Get logs by appointment ID'
      description: 'Retrieve all logs for a specific appointment'
      operationId: 'getLogsByAppointment'
      produces:
        - 'application/json'
      security:
        - Bearer: []
      parameters:
        - in: 'path'
          name: 'appointmentId'
          description: 'Appointment ID'
          required: true
          type: 'string'
      responses:
        '200':
          description: 'List of appointment logs'
          schema:
            type: 'array'
            items:
              $ref: '#/definitions/AppointmentLogResponse'
        '400':
          description: 'Invalid appointment ID'
        '401':
          description: 'Unauthorized'
        '404':
          description: 'Appointment not found'

definitions:
  LoginDto:
    type: object
    properties:
      email:
        type: string
        format: email
        description: "User's email address"
        example: "string"
      password:
        type: string
        description: "User's password"
        minLength: 6
        example: "string"
    required:
      - email
      - password
      
  LoginGoogleDto:
    type: object
    properties:
      google_id:
        type: string
        description: "Google ID token"
        example: "string"
    required:
      - google_id
      
  VerifiedTokenDto:
    type: object
    properties:
      token:
        type: string
        description: "Verification token"
        example: "string"
    required:
      - token
      
  EmailDto:
    type: object
    properties:
      email:
        type: string
        format: email
        description: "User's email address"
        example: "string"
    required:
      - email
      
  TokenResponse:
    type: object
    properties:
      token:
        type: string
        description: "JWT authentication token"
        
  UserResponse:
    type: object
    properties:
      _id:
        type: string
        description: "User ID"
      first_name:
        type: string
        description: "User's first name"
      last_name:
        type: string
        description: "User's last name"
      email:
        type: string
        format: email
        description: "User's email address"
      google_id:
        type: string
        description: "Google ID (if applicable)"
      role:
        type: string
        enum: ["admin", "manager", "staff", "customer"]
        description: "User role"
      status:
        type: boolean
        description: "User account status"
      phone_number:
        type: string
        description: "User's phone number"
      avatar_url:
        type: string
        description: "URL to user's avatar"
      dob:
        type: string
        format: date
        description: "Date of birth"
      is_verified:
        type: boolean
        description: "Email verification status"
      created_at:
        type: string
        format: date-time
        description: "Account creation date"
      updated_at:
        type: string
        format: date-time
        description: "Account last update date"
        
  RegisterDto:
    type: object
    properties:
      google_id:
        type: string
        description: "Google ID (optional)"
      first_name:
        type: string
        description: "User's first name"
      last_name:
        type: string
        description: "User's last name"
      email:
        type: string
        format: email
        description: "User's email address"
      password:
        type: string
        minLength: 6
        description: "User's password"
      role:
        type: string
        enum: ["customer", "manager", "staff", "admin"]
        description: "User role"
      phone_number:
        type: string
        description: "User's phone number"
      avatar_url:
        type: string
        description: "URL to user's avatar"
      dob:
        type: string
        format: date
        description: "Date of birth"
      address:
        type: string
        description: "User's address"
      gender:
        type: string
        description: "User's gender"
    required:
      - first_name
      - last_name
      - email
      - password
      - phone_number
      - dob

  UpdateUserDto:
    type: object
    properties:
      first_name:
        type: string
        description: "User's first name"
      last_name:
        type: string
        description: "User's last name"
      phone_number:
        type: string
        description: "User's phone number"
      avatar_url:
        type: string
        description: "URL to user's avatar"
      dob:
        type: string
        format: date
        description: "Date of birth"
      address:
        type: string
        description: "User's address"
      gender:
        type: string
        description: "User's gender"
    required:
      - first_name
      - last_name
      
  ChangePasswordDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      old_password:
        type: string
        description: "Current password"
        minLength: 6
      new_password:
        type: string
        description: "New password"
        minLength: 6
    required:
      - user_id
      - old_password
      - new_password
      
  ChangeStatusDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      status:
        type: boolean
        description: "New status (true=active, false=inactive)"
    required:
      - user_id
      - status
      
  ChangeRoleDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      role:
        type: string
        enum: ["admin", "manager", "staff", "customer"]
        description: "New user role"
    required:
      - user_id
      - role
      
  SearchUserDto:
    type: object
    properties:
      keyword:
        type: string
        description: "Search keyword (email, first name, last name)"
        example: "string"
      role:
        type: string
        enum: ["", "all", "admin", "manager", "staff", "customer"]
        description: "Filter by role"
        example: ""
      is_verified:
        type: boolean
        description: "Filter by verification status"
        example: "true"
      status:
        type: boolean
        description: "Filter by user status"
        example: "true"
      is_deleted:
        type: boolean
        description: "Include deleted users"
        example: "false"
        
  PaginationRequestModel:
    type: object
    properties:
      pageNum:
        type: integer
        minimum: 1
        description: "Page number (starting from 1)"
        default: 1
      pageSize:
        type: integer
        minimum: 1
        description: "Number of items per page"
        default: 10
        
  SearchPaginationUserDto:
    type: object
    properties:
      pageInfo:
        $ref: '#/definitions/PaginationRequestModel'
      searchCondition:
        $ref: '#/definitions/SearchUserDto'
        
  SearchPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/UserResponse'
      pageInfo:
        type: object
        properties:
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"

  CreateServiceDto:
    type: object
    properties:
      name:
        type: string
        description: "Service name"
      description:
        type: string
        description: "Service description"
      parent_service_id:
        type: string
        description: "Parent service ID (optional)"
      price:
        type: number
        description: "Service price"
      type:
        type: string
        enum: ["civil", "administrative"]
        description: "Service type"
      sample_method:
        type: string
        enum: ["self_collected", "facility_collected", "home_collected"]
        description: "Sample collection method"
      estimated_time:
        type: number
        description: "Estimated time in hours"
    required:
      - name
      - description
      - price
      - type
      - sample_method
      - estimated_time

  UpdateServiceDto:
    type: object
    properties:
      name:
        type: string
        description: "Service name"
      description:
        type: string
        description: "Service description"
      parent_service_id:
        type: string
        description: "Parent service ID (optional)"
      price:
        type: number
        description: "Service price"
      type:
        type: string
        enum: ["civil", "administrative"]
        description: "Service type"
      sample_method:
        type: string
        enum: ["self_collected", "facility_collected", "home_collected"]
        description: "Sample collection method"
      estimated_time:
        type: number
        description: "Estimated time in hours"
    required:
      - name
      - description
      - price
      - type
      - sample_method
      - estimated_time

  ServiceResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Service ID"
      name:
        type: string
        description: "Service name"
      description:
        type: string
        description: "Service description"
      parent_service_id:
        type: string
        description: "Parent service ID (if any)"
      price:
        type: number
        description: "Service price"
      type:
        type: string
        enum: ["civil", "administrative"]
        description: "Service type"
      sample_method:
        type: string
        enum: ["self_collected", "facility_collected", "home_collected"]
        description: "Sample collection method"
      estimated_time:
        type: number
        description: "Estimated time in hours"
      is_active:
        type: boolean
        description: "Service status"
      is_deleted:
        type: boolean
        description: "Service deletion status"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  ServicePaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/ServiceResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateDepartmentDto:
    type: object
    properties:
      name:
        type: string
        description: "Department name"
        example: "Cardiology Department"
      description:
        type: string
        description: "Department description"
        example: "Department for heart-related services"
      manager_id:
        type: string
        description: "Manager ID (must be a user with MANAGER role)"
        example: "60d0fe4f5311236168a109ca"
    required:
      - name
      - description
      - manager_id

  UpdateDepartmentDto:
    type: object
    properties:
      name:
        type: string
        description: "Department name"
        example: "Cardiology Department"
      description:
        type: string
        description: "Department description"
        example: "Department for heart-related services"
      manager_id:
        type: string
        description: "Manager ID (must be a user with MANAGER role)"
        example: "60d0fe4f5311236168a109ca"
    required:
      - name
      - description
      - manager_id

  DepartmentResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Department ID"
      name:
        type: string
        description: "Department name"
      description:
        type: string
        description: "Department description"
      manager_id:
        type: object
        description: "Manager information"
        properties:
          _id:
            type: string
            description: "Manager ID"
          first_name:
            type: string
            description: "Manager's first name"
          last_name:
            type: string
            description: "Manager's last name"
          email:
            type: string
            description: "Manager's email"
      is_deleted:
        type: boolean
        description: "Deletion status"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  DepartmentPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/DepartmentResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateStaffProfileDto:
    type: object
    properties:
      user_id:
        type: string
        description: "User ID"
      department_id:
        type: string
        description: "Department ID"
      job_title:
        type: string
        description: "Job title"
      hire_date:
        type: string
        format: date
        description: "Hire date"
      salary:
        type: number
        description: "Salary"
      qualifications:
        type: array
        items:
          $ref: '#/definitions/Qualification'
    required:
      - user_id
      - department_id
      - job_title
      - hire_date
      - salary

  UpdateStaffProfileDto:
    type: object
    properties:
      department_id:
        type: string
        description: "Department ID"
      job_title:
        type: string
        description: "Job title"
      hire_date:
        type: string
        format: date
        description: "Hire date"
      salary:
        type: number
        description: "Salary"
      qualifications:
        type: array
        items:
          $ref: '#/definitions/Qualification'
    required:
      - department_id
      - job_title
      - hire_date
      - salary

  StaffProfileResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Staff profile ID"
      user_id:
        type: string
        description: "User ID"
      department_id:
        type: string
        description: "Department ID"
      job_title:
        type: string
        description: "Job title"
      hire_date:
        type: string
        format: date
        description: "Hire date"
      employee_id:
        type: string
        description: "Employee ID"
      salary:
        type: number
        description: "Salary"
      status:
        type: string
        description: "Status"
      qualifications:
        type: array
        items:
          $ref: '#/definitions/Qualification'
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  StaffProfilePaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/StaffProfileResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  Qualification:
    type: object
    properties:
      name:
        type: string
        description: "Qualification name"
      institution:
        type: string
        description: "Institution name"
      issue_date:
        type: string
        format: date
        description: "Issue date"
      expiry_date:
        type: string
        format: date
        description: "Expiry date"
      description:
        type: string
        description: "Description"

  CreateSlotDto:
    type: object
    properties:
      staff_profile_ids:
        type: array
        items:
          type: string
        description: "Array of staff profile IDs"
      service_id:
        type: string
        description: "Service ID"
      time_slots:
        type: array
        items:
          $ref: '#/definitions/TimeSlotDto'
        description: "Array of time slots"
      appointment_limit:
        type: integer
        description: "Maximum number of appointments allowed per slot"
    required:
      - staff_profile_ids
      - service_id
      - time_slots
      - appointment_limit

  TimeSlotDto:
    type: object
    properties:
      year:
        type: integer
        description: "Year"
      month:
        type: integer
        description: "Month (1-12)"
      day:
        type: integer
        description: "Day of month"
      start_time:
        $ref: '#/definitions/TimePointDto'
      end_time:
        $ref: '#/definitions/TimePointDto'
    required:
      - year
      - month
      - day
      - start_time
      - end_time

  TimePointDto:
    type: object
    properties:
      hour:
        type: integer
        minimum: 0
        maximum: 23
        description: "Hour (0-23)"
      minute:
        type: integer
        minimum: 0
        maximum: 59
        description: "Minute (0-59)"
    required:
      - hour
      - minute

  UpdateSlotDto:
    type: object
    properties:
      staff_profile_ids:
        type: array
        items:
          type: string
        description: "Array of staff profile IDs"
      service_id:
        type: string
        description: "Service ID"
      time_slots:
        type: array
        items:
          $ref: '#/definitions/TimeSlotDto'
        description: "Array of time slots"
      appointment_limit:
        type: integer
        description: "Maximum number of appointments allowed per slot"
      status:
        type: string
        enum: ["available", "booked", "unavailable"]
        description: "Slot status"
    required:
      - staff_profile_ids
      - service_id
      - time_slots
      - appointment_limit

  SlotResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Slot ID"
      staff_profile_ids:
        type: array
        items:
          type: object
          properties:
            _id:
              type: string
            employee_id:
              type: string
            job_title:
              type: string
            user_id:
              type: object
              properties:
                _id:
                  type: string
                first_name:
                  type: string
                last_name:
                  type: string
                email:
                  type: string
        description: "Array of staff profiles assigned to this slot"
      service_id:
        type: string
        description: "Service ID"
      appointment_id:
        type: object
        properties:
          _id:
            type: string
          code:
            type: string
          status:
            type: string
        description: "Associated appointment (if any)"
      time_slots:
        type: array
        items:
          $ref: '#/definitions/TimeSlotDto'
        description: "Array of time slots"
      appointment_limit:
        type: integer
        description: "Maximum number of appointments allowed per slot"
      status:
        type: string
        enum: ["available", "booked", "unavailable"]
        description: "Slot status"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  SlotPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/SlotResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateKitDto:
    type: object
    properties:
      code:
        type: string
        description: "Kit code (optional, will be auto-generated if not provided)"
        pattern: "^KIT-\\d{8}-\\d{3}$"
        example: "KIT-20230101-001"

  UpdateKitDto:
    type: object
    properties:
      notes:
        type: string
        description: "Notes about the kit"

  KitResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Kit ID"
      code:
        type: string
        description: "Kit code"
        example: "KIT-20230101-001"
      status:
        type: string
        description: "Kit status"
        enum: ["available", "assigned", "used", "returned", "damaged"]
      appointment_id:
        type: object
        description: "Associated appointment (if any)"
      assigned_to_user_id:
        type: object
        description: "User assigned to the kit (if any)"
      assigned_date:
        type: string
        format: date-time
        description: "Date when kit was assigned"
      return_date:
        type: string
        format: date-time
        description: "Date when kit was returned"
      notes:
        type: string
        description: "Notes about the kit"
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  KitPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/KitResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  CreateAppointmentDto:
    type: object
    properties:
      service_id:
        type: string
        description: "Service ID"
        example: "60d0fe4f5311236168a109ca"
      slot_id:
        type: string
        description: "Slot ID (optional)"
        example: "60d0fe4f5311236168a109cb"
      appointment_date:
        type: string
        format: date-time
        description: "Appointment date and time (optional if slot_id is provided)"
        example: "2023-10-15T14:30:00Z"
      type:
        type: string
        enum: ["self", "facility", "home"]
        description: "Type of appointment"
        example: "facility"
      collection_address:
        type: string
        description: "Address for home collection (required for home type)"
        example: "123 Main St, City, Country"
    required:
      - service_id
      - type

  AssignStaffDto:
    type: object
    properties:
      staff_id:
        type: string
        description: "Staff ID to assign to the appointment"
        example: "60d0fe4f5311236168a109cc"
    required:
      - staff_id

  ConfirmAppointmentDto:
    type: object
    properties:
      kit_id:
        type: string
        description: "Kit ID to assign to the appointment"
        example: "60d0fe4f5311236168a109cd"
    required:
      - kit_id

  AppointmentResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Appointment ID"
      user_id:
        type: object
        description: "Customer information"
      service_id:
        type: object
        description: "Service information"
      staff_id:
        type: object
        description: "Staff information (if assigned)"
      slot_id:
        type: string
        description: "Associated slot ID (if any)"
      appointment_date:
        type: string
        format: date-time
        description: "Appointment date and time"
      type:
        type: string
        enum: ["self", "facility", "home"]
        description: "Type of appointment"
      collection_address:
        type: string
        description: "Address for home collection"
      status:
        type: string
        description: "Appointment status"
        enum: ["pending", "confirmed", "sample_collected", "sample_received", "testing", "completed", "cancelled"]
      created_at:
        type: string
        format: date-time
        description: "Creation date"
      updated_at:
        type: string
        format: date-time
        description: "Last update date"

  AppointmentPaginationResponse:
    type: object
    properties:
      pageData:
        type: array
        items:
          $ref: '#/definitions/AppointmentResponse'
      pageInfo:
        type: object
        properties:
          totalItems:
            type: integer
            description: "Total number of items"
          totalPages:
            type: integer
            description: "Total number of pages"
          pageNum:
            type: integer
            description: "Current page number"
          pageSize:
            type: integer
            description: "Number of items per page"

  AppointmentLogResponse:
    type: object
    properties:
      _id:
        type: string
        description: "Log ID"
      appointment_id:
        type: string
        description: "Appointment ID"
      action:
        type: string
        description: "Action performed"
        enum: ["created", "updated", "status_changed", "staff_assigned", "feedback_added"]
      previous_state:
        type: object
        description: "Previous state of the appointment"
      new_state:
        type: object
        description: "New state of the appointment"
      performed_by:
        type: string
        description: "User ID who performed the action"
      notes:
        type: string
        description: "Additional notes"
      created_at:
        type: string
        format: date-time
        description: "Log creation date"

  SuccessResponse:
    type: object
    properties:
      success:
        type: boolean
        description: "Success status"
        example: true
      message:
        type: string
        description: "Success message"
        example: "Operation completed successfully"


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "typeRoots": [
      "./src/types",
    ],
    "target": "ES6",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "sourceMap": true,
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true
    // "baseUrl": "./src",
    // "paths": {
    //     "modules/*": ["modules/*"],
    //     "core/*": ["core/*"]
    // }
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.json",
    "src/modules/auth/swagger/auth.swagger.js",
  ],
  "exclude": [
    "node_modules"
  ]
}


================================================
FILE: vercel.json
================================================
{
    "version": 2,
    "builds": [
        {
            "src": "src/server.ts",
            "use": "@vercel/node"
        }
    ],
    "routes": [
        {
            "src": "/health",
            "dest": "/src/server.ts"
        },
        {
            "src": "/api-docs",
            "dest": "/src/server.ts"
        },
        {
            "src": "/swagger/(.*)",
            "dest": "/src/server.ts"
        },
        {
            "src": "/images/(.*)",
            "dest": "/src/server.ts"
        },
        {
            "src": "/api/(.*)",
            "dest": "/src/server.ts"
        },
        {
            "src": "/(.*)",
            "dest": "/src/server.ts"
        }
    ],
    "env": {
        "NODE_ENV": "production"
    }
}


================================================
FILE: web.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.webServer>
    <handlers>
      <add name="iisnode" path="dist/index.js" verb="*" modules="iisnode"/>
    </handlers>
    <rewrite>
      <rules>
        <rule name="NodeInspector" patternSyntax="ECMAScript" stopProcessing="true">
          <match url="^dist/index.js\/debug[\/]?" />
          <action type="Rewrite" url="http://localhost:8080/debug?port=5858" />
        </rule>
        <rule name="StaticContent">
          <action type="Rewrite" url="public{REQUEST_URI}"/>
        </rule>
        <rule name="DynamicContent">
          <conditions>
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="True"/>
          </conditions>
          <action type="Rewrite" url="dist/index.js"/>
        </rule>
      </rules>
    </rewrite>
    <iisnode 
      loggingEnabled="true"
      devErrorsEnabled="true"
      debuggingEnabled="false"
      node_env="production"
    />
    <security>
      <requestFiltering>
        <hiddenSegments>
          <add segment="node_modules"/>
        </hiddenSegments>
      </requestFiltering>
    </security>
  </system.webServer>
</configuration>


================================================
FILE: webpack.config.js
================================================
const path = require('path');
const nodeExternals = require('webpack-node-externals'); // Fix bug for express
const WebpackShellPlugin = require('webpack-shell-plugin'); // Run command after build finish
const TsconfigPathsPlugin = require('tsconfig-paths-webpack-plugin'); // Resolve module in tsconfig.json for webpack

const { NODE_ENV = 'production' } = process.env;
module.exports = {
    entry: './src/server.ts',
    watch: NODE_ENV === 'development',
    mode: NODE_ENV,
    target: 'node',
    externals: [nodeExternals()],
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'server.js',
    },
    resolve: {
        extensions: ['.ts', '.js'],
        plugins: [
            new TsconfigPathsPlugin({
                configFile: './tsconfig.json',
            }),
        ],
    },
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: ['ts-loader'],
                exclude: /node_modules/,
            },
        ],
    },
    context: path.resolve(__dirname)
};



================================================
FILE: .eslintrc
================================================
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
        "ecmaVersion": 2021,
        "sourceType": "module",
        "project": "./tsconfig.json"
    },
    "plugins": [
        "@typescript-eslint",
        "import"
    ],
    "extends": [
        "eslint:recommended",
        "plugin:@typescript-eslint/recommended",
        "plugin:@typescript-eslint/recommended-requiring-type-checking",
        "plugin:import/errors",
        "plugin:import/warnings",
        "plugin:import/typescript",
        "prettier"
    ],
    "rules": {
        // Error prevention
        "no-console": "error",
        "no-return-await": "error",
        "no-unused-vars": "off",
        "@typescript-eslint/no-unused-vars": [
            "error",
            {
                "argsIgnorePattern": "^_",
                "varsIgnorePattern": "^_"
            }
        ],
        "@typescript-eslint/explicit-function-return-type": [
            "error",
            {
                "allowExpressions": true
            }
        ],
        "@typescript-eslint/no-explicit-any": "error",
        "@typescript-eslint/no-unsafe-assignment": "error",
        "@typescript-eslint/no-unsafe-member-access": "error",
        "@typescript-eslint/no-unsafe-call": "error",
        // Code style
        "@typescript-eslint/naming-convention": [
            "error",
            {
                "selector": "interface",
                "format": [
                    "PascalCase"
                ],
                "prefix": [
                    "I"
                ]
            },
            {
                "selector": "typeAlias",
                "format": [
                    "PascalCase"
                ]
            },
            {
                "selector": "enum",
                "format": [
                    "PascalCase"
                ]
            }
        ],
        "@typescript-eslint/explicit-member-accessibility": [
            "error",
            {
                "overrides": {
                    "constructors": "no-public"
                }
            }
        ],
        "import/order": [
            "error",
            {
                "groups": [
                    "builtin",
                    "external",
                    "internal",
                    "parent",
                    "sibling",
                    "index"
                ],
                "newlines-between": "always",
                "alphabetize": {
                    "order": "asc",
                    "caseInsensitive": true
                }
            }
        ]
    },
    "overrides": [
        {
            "files": [
                "src/**/*.ts"
            ],
            "rules": {
                // Module-specific rules
                "import/no-unresolved": "error",
                "import/no-cycle": "error",
                "import/no-self-import": "error"
            }
        }
    ],
    "settings": {
        "import/resolver": {
            "node": {
                "extensions": [
                    ".js",
                    ".ts"
                ]
            },
            "typescript": {
                "alwaysTryTypes": true
            }
        }
    }
}


================================================
FILE: .lintstagedrc
================================================
{
  "*.ts": [
    "eslint --fix",
    "prettier --write"
  ]
} 


================================================
FILE: .prettierrc
================================================
{
    "semi": true,
    "trailingComma": "all",
    "singleQuote": true,
    "printWidth": 240,
    "tabWidth": 4
}


================================================
FILE: assets/fonts/NotoSans-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/NotoSans-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/NotoSans-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/NotoSans-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/NotoSans-Italic-VariableFont_wdth,wght.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/NotoSans-VariableFont_wdth,wght.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/OFL.txt
================================================
Copyright 2022 The Noto Project Authors (https://github.com/notofonts/latin-greek-cyrillic)

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
https://openfontlicense.org


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.



================================================
FILE: assets/fonts/Noto_Sans/README.txt
================================================
Noto Sans Variable Font
=======================

This download contains Noto Sans as both variable fonts and static fonts.

Noto Sans is a variable font with these axes:
  wdth
  wght

This means all the styles are contained in these files:
  NotoSans-VariableFont_wdth,wght.ttf
  NotoSans-Italic-VariableFont_wdth,wght.ttf

If your app fully supports variable fonts, you can now pick intermediate styles
that arenâ€™t available as static fonts. Not all apps support variable fonts, and
in those cases you can use the static font files for Noto Sans:
  static/NotoSans_ExtraCondensed-Thin.ttf
  static/NotoSans_ExtraCondensed-ExtraLight.ttf
  static/NotoSans_ExtraCondensed-Light.ttf
  static/NotoSans_ExtraCondensed-Regular.ttf
  static/NotoSans_ExtraCondensed-Medium.ttf
  static/NotoSans_ExtraCondensed-SemiBold.ttf
  static/NotoSans_ExtraCondensed-Bold.ttf
  static/NotoSans_ExtraCondensed-ExtraBold.ttf
  static/NotoSans_ExtraCondensed-Black.ttf
  static/NotoSans_Condensed-Thin.ttf
  static/NotoSans_Condensed-ExtraLight.ttf
  static/NotoSans_Condensed-Light.ttf
  static/NotoSans_Condensed-Regular.ttf
  static/NotoSans_Condensed-Medium.ttf
  static/NotoSans_Condensed-SemiBold.ttf
  static/NotoSans_Condensed-Bold.ttf
  static/NotoSans_Condensed-ExtraBold.ttf
  static/NotoSans_Condensed-Black.ttf
  static/NotoSans_SemiCondensed-Thin.ttf
  static/NotoSans_SemiCondensed-ExtraLight.ttf
  static/NotoSans_SemiCondensed-Light.ttf
  static/NotoSans_SemiCondensed-Regular.ttf
  static/NotoSans_SemiCondensed-Medium.ttf
  static/NotoSans_SemiCondensed-SemiBold.ttf
  static/NotoSans_SemiCondensed-Bold.ttf
  static/NotoSans_SemiCondensed-ExtraBold.ttf
  static/NotoSans_SemiCondensed-Black.ttf
  static/NotoSans-Thin.ttf
  static/NotoSans-ExtraLight.ttf
  static/NotoSans-Light.ttf
  static/NotoSans-Regular.ttf
  static/NotoSans-Medium.ttf
  static/NotoSans-SemiBold.ttf
  static/NotoSans-Bold.ttf
  static/NotoSans-ExtraBold.ttf
  static/NotoSans-Black.ttf
  static/NotoSans_ExtraCondensed-ThinItalic.ttf
  static/NotoSans_ExtraCondensed-ExtraLightItalic.ttf
  static/NotoSans_ExtraCondensed-LightItalic.ttf
  static/NotoSans_ExtraCondensed-Italic.ttf
  static/NotoSans_ExtraCondensed-MediumItalic.ttf
  static/NotoSans_ExtraCondensed-SemiBoldItalic.ttf
  static/NotoSans_ExtraCondensed-BoldItalic.ttf
  static/NotoSans_ExtraCondensed-ExtraBoldItalic.ttf
  static/NotoSans_ExtraCondensed-BlackItalic.ttf
  static/NotoSans_Condensed-ThinItalic.ttf
  static/NotoSans_Condensed-ExtraLightItalic.ttf
  static/NotoSans_Condensed-LightItalic.ttf
  static/NotoSans_Condensed-Italic.ttf
  static/NotoSans_Condensed-MediumItalic.ttf
  static/NotoSans_Condensed-SemiBoldItalic.ttf
  static/NotoSans_Condensed-BoldItalic.ttf
  static/NotoSans_Condensed-ExtraBoldItalic.ttf
  static/NotoSans_Condensed-BlackItalic.ttf
  static/NotoSans_SemiCondensed-ThinItalic.ttf
  static/NotoSans_SemiCondensed-ExtraLightItalic.ttf
  static/NotoSans_SemiCondensed-LightItalic.ttf
  static/NotoSans_SemiCondensed-Italic.ttf
  static/NotoSans_SemiCondensed-MediumItalic.ttf
  static/NotoSans_SemiCondensed-SemiBoldItalic.ttf
  static/NotoSans_SemiCondensed-BoldItalic.ttf
  static/NotoSans_SemiCondensed-ExtraBoldItalic.ttf
  static/NotoSans_SemiCondensed-BlackItalic.ttf
  static/NotoSans-ThinItalic.ttf
  static/NotoSans-ExtraLightItalic.ttf
  static/NotoSans-LightItalic.ttf
  static/NotoSans-Italic.ttf
  static/NotoSans-MediumItalic.ttf
  static/NotoSans-SemiBoldItalic.ttf
  static/NotoSans-BoldItalic.ttf
  static/NotoSans-ExtraBoldItalic.ttf
  static/NotoSans-BlackItalic.ttf

Get started
-----------

1. Install the font files you want to use

2. Use your app's font picker to view the font family and all the
available styles

Learn more about variable fonts
-------------------------------

  https://developers.google.com/web/fundamentals/design-and-ux/typography/variable-fonts
  https://variablefonts.typenetwork.com
  https://medium.com/variable-fonts

In desktop apps

  https://theblog.adobe.com/can-variable-fonts-illustrator-cc
  https://helpx.adobe.com/nz/photoshop/using/fonts.html#variable_fonts

Online

  https://developers.google.com/fonts/docs/getting_started
  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts/Variable_Fonts_Guide
  https://developer.microsoft.com/en-us/microsoft-edge/testdrive/demos/variable-fonts

Installing fonts

  MacOS: https://support.apple.com/en-us/HT201749
  Linux: https://www.google.com/search?q=how+to+install+a+font+on+gnu%2Blinux
  Windows: https://support.microsoft.com/en-us/help/314960/how-to-install-or-remove-a-font-in-windows

Android Apps

  https://developers.google.com/fonts/docs/android
  https://developer.android.com/guide/topics/ui/look-and-feel/downloadable-fonts

License
-------
Please read the full license text (OFL.txt) to understand the permissions,
restrictions and requirements for usage, redistribution, and modification.

You can use them in your products & projects â€“ print or digital,
commercial or otherwise.

This isn't legal advice, please consider consulting a lawyer and see the full
license for all details.



================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_Condensed-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_ExtraCondensed-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Black.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-BlackItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Bold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-BoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraLight.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ExtraLightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Italic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Light.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-LightItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Medium.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-MediumItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Regular.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-SemiBold.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-SemiBoldItalic.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-Thin.ttf
================================================
[Non-text file]


================================================
FILE: assets/fonts/Noto_Sans/static/NotoSans_SemiCondensed-ThinItalic.ttf
================================================
[Non-text file]


================================================
FILE: src/app.ts
================================================
import cors from 'cors';
import express from 'express';
import helmet from 'helmet';
import hpp from 'hpp';
import mongoose from 'mongoose';
import morgan from 'morgan';
import path from 'path';
import compression from 'compression';
import 'reflect-metadata'; // Import Ä‘á»ƒ sá»­ dá»¥ng class-transformer decorators
import { IRoute } from './core/interfaces';
import { errorMiddleware } from './core/middleware';
import { logger } from './core/utils';

// Biáº¿n cache connection MongoDB Ä‘á»ƒ tÃ¡i sá»­ dá»¥ng trong serverless
// Serverless functions cÃ³ thá»ƒ bá»‹ khá»Ÿi táº¡o láº¡i nhiá»u láº§n, cache giÃºp tÃ¡i sá»­ dá»¥ng connection
let cachedConnection: typeof mongoose | null = null;

export default class App {
    public app: express.Application; // Instance cá»§a Express app
    public port: string | number;    // Port Ä‘á»ƒ cháº¡y server
    public production: boolean;      // Flag kiá»ƒm tra mÃ´i trÆ°á»ng production

    constructor(routes: IRoute[]) {
        // Khá»Ÿi táº¡o Express application
        this.app = express();

        // Láº¥y port tá»« environment variables, Æ°u tiÃªn PORT, sau Ä‘Ã³ WEBSITES_PORT, cuá»‘i cÃ¹ng lÃ  3000
        this.port = process.env.PORT || process.env.WEBSITES_PORT || 3000;

        // Kiá»ƒm tra cÃ³ pháº£i mÃ´i trÆ°á»ng production khÃ´ng
        this.production = !!(process.env.NODE_ENV === 'production');

        // Káº¿t ná»‘i database trÆ°á»›c khi setup middleware
        this.connectToDatabase();

        // Setup cÃ¡c middleware (cors, compression, security, etc.)
        this.initializeMiddleware();

        // ÄÄƒng kÃ½ táº¥t cáº£ routes tá»« cÃ¡c modules
        this.initializeRoute(routes);

        // Setup middleware xá»­ lÃ½ lá»—i (pháº£i á»Ÿ cuá»‘i cÃ¹ng)
        this.initializeErrorMiddleware();
    }

    public listen() {
        // Kiá»ƒm tra náº¿u Ä‘ang cháº¡y trÃªn Vercel thÃ¬ khÃ´ng cáº§n gá»i listen()
        // Vercel tá»± Ä‘á»™ng handle viá»‡c nÃ y
        if (process.env.VERCEL) {
            logger.info('Running on Vercel - skipping listen()');
            return;
        }

        // Chá»‰ gá»i listen() khi cháº¡y local hoáº·c server thÆ°á»ng
        this.app.listen(this.port, () => {
            logger.info(`Server is running at port ${this.port}`);
        });
    }

    // HÃ m káº¿t ná»‘i MongoDB Ä‘Æ°á»£c tá»‘i Æ°u cho serverless
    private async connectToDatabase() {
        // Láº¥y MongoDB URI tá»« environment variables
        const mongoDbUri = process.env.MONGODB_URI;
        if (!mongoDbUri) {
            logger.error('MongoDb URI is empty!');
            return;
        }

        // Kiá»ƒm tra xem cÃ³ connection cache khÃ´ng vÃ  cÃ²n hoáº¡t Ä‘á»™ng khÃ´ng
        // readyState === 1 nghÄ©a lÃ  connected
        if (cachedConnection && cachedConnection.connection.readyState === 1) {
            logger.info('Using cached database connection');
            return cachedConnection; // TÃ¡i sá»­ dá»¥ng connection cÅ©
        }

        try {
            // Cáº¥u hÃ¬nh connection options Ä‘Æ°á»£c tá»‘i Æ°u cho serverless tá»« environment variables
            const options = {
                // Táº¯t auto-indexing trong production Ä‘á»ƒ khá»Ÿi Ä‘á»™ng nhanh hÆ¡n
                // Auto-indexing cÃ³ thá»ƒ lÃ m cháº­m quÃ¡ trÃ¬nh khá»Ÿi táº¡o
                autoIndex: process.env.DB_AUTO_INDEX === 'true',

                // Timeout ngáº¯n hÆ¡n phÃ¹ há»£p vá»›i serverless environment
                serverSelectionTimeoutMS: parseInt(process.env.DB_SERVER_SELECTION_TIMEOUT || '5000'),
                connectTimeoutMS: parseInt(process.env.DB_CONNECT_TIMEOUT || '10000'),
                socketTimeoutMS: parseInt(process.env.DB_SOCKET_TIMEOUT || '45000'),

                // Tá»‘i Æ°u connection pooling tá»« environment variables
                maxPoolSize: parseInt(process.env.DB_MAX_POOL_SIZE || '10'),
                minPoolSize: parseInt(process.env.DB_MIN_POOL_SIZE || '2'),
                maxIdleTimeMS: parseInt(process.env.DB_MAX_IDLE_TIME || '30000'),

                // Logic retry khi cÃ³ lá»—i tá»« environment variables
                retryWrites: process.env.DB_RETRY_WRITES === 'true',
                retryReads: process.env.DB_RETRY_READS === 'true'
            };

            // Táº¡o connection má»›i vÃ  lÆ°u vÃ o cache
            cachedConnection = await mongoose.connect(mongoDbUri, options);
            logger.info('Database connection established successfully');

            // ÄÄƒng kÃ½ event listeners Ä‘á»ƒ handle connection errors
            mongoose.connection.on('error', (err) => {
                logger.error('Database connection error:', err);
                cachedConnection = null; // XÃ³a cache khi cÃ³ lá»—i
            });

            mongoose.connection.on('disconnected', () => {
                logger.warn('Database disconnected');
                cachedConnection = null; // XÃ³a cache khi máº¥t káº¿t ná»‘i
            });

            return cachedConnection;
        } catch (err) {
            logger.error('Database connection failed:', err);
            cachedConnection = null; // XÃ³a cache khi tháº¥t báº¡i

            // Trong serverless environment, khÃ´ng nÃªn throw error náº¿u DB fail
            // Äá»ƒ app váº«n cÃ³ thá»ƒ khá»Ÿi Ä‘á»™ng vÃ  handle requests khÃ¡c
            if (process.env.VERCEL) {
                logger.warn('Running in Vercel - continuing without database connection');
                return null;
            } else {
                throw err; // NÃ©m lá»—i Ä‘á»ƒ caller xá»­ lÃ½ trong local environment
            }
        }
    }

    // HÃ m setup cÃ¡c middleware Ä‘Æ°á»£c tá»‘i Æ°u vá»›i environment variables
    private initializeMiddleware() {
        // Compression pháº£i Ä‘Æ°á»£c Ä‘áº·t Ä‘áº§u tiÃªn Ä‘á»ƒ nÃ©n response vá»›i config tá»« env
        this.app.use(compression({
            // Filter function Ä‘á»ƒ quyáº¿t Ä‘á»‹nh cÃ³ nÃ©n hay khÃ´ng
            filter: (req, res) => {
                // KhÃ´ng nÃ©n náº¿u client yÃªu cáº§u
                if (req.headers['x-no-compression']) {
                    return false;
                }
                // Sá»­ dá»¥ng filter máº·c Ä‘á»‹nh cá»§a compression
                return compression.filter(req, res);
            },
            level: parseInt(process.env.COMPRESSION_LEVEL || '6'),        // Má»©c nÃ©n tá»« env
            threshold: parseInt(process.env.COMPRESSION_THRESHOLD || '1024')  // Threshold tá»« env
        }));

        // Security middleware chá»‰ cháº¡y trong production
        if (this.production) {
            // HPP (HTTP Parameter Pollution) protection
            this.app.use(hpp());

            // Helmet cho security headers
            this.app.use(helmet({
                contentSecurityPolicy: {
                    directives: {
                        defaultSrc: ["'self'"],           // Chá»‰ cho phÃ©p resource tá»« cÃ¹ng origin
                        styleSrc: ["'self'", "'unsafe-inline'"], // CSS tá»« cÃ¹ng origin + inline
                        scriptSrc: ["'self'"],            // JS chá»‰ tá»« cÃ¹ng origin
                        imgSrc: ["'self'", "data:", "https:"], // Images tá»« nhiá»u nguá»“n
                    },
                },
                crossOriginEmbedderPolicy: false // Táº¯t COEP Ä‘á»ƒ tÆ°Æ¡ng thÃ­ch
            }));

            // Logging tá»‘i Æ°u cho production - bá» qua health check vÃ  swagger
            this.app.use(morgan('combined', {
                skip: (req) => req.url.includes('/health') || req.url.includes('/swagger')
            }));

            // CORS vá»›i origins tá»« environment variables
            const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['https://your-frontend-domain.com'];
            this.app.use(cors({
                origin: allowedOrigins,           // Danh sÃ¡ch domains Ä‘Æ°á»£c phÃ©p tá»« env
                credentials: true,                // Cho phÃ©p cookies
                optionsSuccessStatus: 200,        // Status cho preflight requests
                methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'], // Methods Ä‘Æ°á»£c phÃ©p
                allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'] // Headers Ä‘Æ°á»£c phÃ©p
            }));
        } else {
            // Development environment - logging Ä‘Æ¡n giáº£n vÃ  CORS má»Ÿ
            this.app.use(morgan('dev'));
            this.app.use(cors({ origin: true, credentials: true }));
        }

        // Body parsing vá»›i giá»›i háº¡n kÃ­ch thÆ°á»›c
        this.app.use(express.json({
            limit: '10mb', // Giá»›i háº¡n JSON payload 10MB
            verify: (req, res, buf) => {
                // LÆ°u raw body Ä‘á»ƒ verify webhooks náº¿u cáº§n
                (req as any).rawBody = buf;
            }
        }));
        this.app.use(express.urlencoded({
            extended: true,  // Cho phÃ©p parse objects phá»©c táº¡p
            limit: '10mb'    // Giá»›i háº¡n form data 10MB
        }));

        // Middleware thÃªm response time header vá»›i threshold tá»« env
        this.app.use((req, res, next) => {
            const start = Date.now(); // LÆ°u thá»i gian báº¯t Ä‘áº§u
            const threshold = parseInt(process.env.RESPONSE_TIME_THRESHOLD || '1000');

            // Override res.end Ä‘á»ƒ capture khi response káº¿t thÃºc
            const originalEnd = res.end;
            let finished = false;

            res.end = function (chunk?: any, encoding?: any) {
                if (!finished) {
                    finished = true;
                    const duration = Date.now() - start; // TÃ­nh thá»i gian xá»­ lÃ½

                    // Chá»‰ set header náº¿u headers chÆ°a Ä‘Æ°á»£c gá»­i
                    if (!res.headersSent) {
                        res.set('X-Response-Time', `${duration}ms`); // ThÃªm header
                    }

                    // Log warning náº¿u vÆ°á»£t threshold tá»« env
                    if (duration > threshold) {
                        logger.warn(`Slow request: ${req.method} ${req.path} took ${duration}ms (threshold: ${threshold}ms)`);
                    }
                }

                // Gá»i original end method
                return originalEnd.call(this, chunk, encoding);
            };

            next();
        });

        // Health check endpoint Ä‘á»ƒ monitoring
        this.app.get('/health', (req, res) => {
            const dbStatus = mongoose.connection.readyState === 1 ? 'connected' : 'disconnected';
            const isHealthy = dbStatus === 'connected' || process.env.VERCEL; // In Vercel, allow healthy even if DB disconnected temporarily

            res.status(isHealthy ? 200 : 503).json({
                status: isHealthy ? 'healthy' : 'unhealthy',
                timestamp: new Date().toISOString(),
                environment: process.env.NODE_ENV,
                database: dbStatus,
                vercel: !!process.env.VERCEL
            });
        });

        // Middleware kiá»ƒm tra database connection cho API requests
        this.app.use('/api', (req, res, next) => {
            // Bá» qua check cho health endpoint
            if (req.path === '/health') {
                return next();
            }

            // Kiá»ƒm tra database connection
            if (mongoose.connection.readyState !== 1) {
                // Trong serverless, thá»­ káº¿t ná»‘i láº¡i database
                if (process.env.VERCEL) {
                    logger.warn(`API request to ${req.path} - Database not connected, attempting reconnection`);
                    this.connectToDatabase().then(() => {
                        if (mongoose.connection.readyState === 1) {
                            next();
                        } else {
                            res.status(503).json({
                                success: false,
                                message: 'Database service temporarily unavailable',
                                error: 'DATABASE_CONNECTION_FAILED'
                            });
                        }
                    }).catch(() => {
                        res.status(503).json({
                            success: false,
                            message: 'Database service temporarily unavailable',
                            error: 'DATABASE_CONNECTION_FAILED'
                        });
                    });
                } else {
                    // Local environment - tráº£ vá» lá»—i ngay
                    res.status(503).json({
                        success: false,
                        message: 'Database service unavailable',
                        error: 'DATABASE_CONNECTION_FAILED'
                    });
                }
            } else {
                next();
            }
        });
    }

    // Middleware xá»­ lÃ½ lá»—i - pháº£i á»Ÿ cuá»‘i
    private initializeErrorMiddleware() {
        this.app.use(errorMiddleware);
    }

    // HÃ m khá»Ÿi táº¡o routes Ä‘Æ°á»£c tá»‘i Æ°u vá»›i static cache config tá»« env
    private initializeRoute(routes: IRoute[]) {
        // ÄÄƒng kÃ½ táº¥t cáº£ routes tá»« cÃ¡c modules
        routes.forEach((route) => {
            this.app.use('/', route.router);
        });

        // Cáº¥u hÃ¬nh EJS template engine
        this.app.set('view engine', 'ejs');
        // Báº­t view cache trong production Ä‘á»ƒ render nhanh hÆ¡n
        this.app.set('view cache', this.production);

        // ÄÆ°á»ng dáº«n tÃ¬m views - thá»© tá»± Æ°u tiÃªn
        this.app.set('views', [
            path.join(__dirname, 'modules/index/view'), // ThÆ° má»¥c view chÃ­nh
            path.join(__dirname, 'modules/index'),      // Backup
            path.join(__dirname, 'modules')             // Fallback
        ]);

        // Cáº¥u hÃ¬nh serve static files vá»›i caching tá»« environment variables
        const staticCacheMaxAge = parseInt(process.env.STATIC_CACHE_MAX_AGE || '31536000');
        const devCacheMaxAge = parseInt(process.env.DEV_CACHE_MAX_AGE || '86400');

        const staticOptions = {
            maxAge: this.production ? staticCacheMaxAge : devCacheMaxAge, // Cache time tá»« env
            etag: true,         // Báº­t ETag Ä‘á»ƒ kiá»ƒm tra file thay Ä‘á»•i
            lastModified: true, // Báº­t Last-Modified header
            setHeaders: (res: express.Response, path: string) => {
                // Set cache headers dá»±a theo loáº¡i file
                if (path.endsWith('.js') || path.endsWith('.css') || path.endsWith('.png') || path.endsWith('.jpg')) {
                    // Static assets cache vá»›i maxAge tá»« env
                    res.set('Cache-Control', `public, max-age=${staticCacheMaxAge}, immutable`);
                }
            }
        };

        // Route serve Swagger UI files
        this.app.use('/swagger', express.static(
            path.join(__dirname, '../node_modules/swagger-ui-dist'),
            staticOptions
        ));

        // Route serve images
        this.app.use('/images', express.static(
            path.join(__dirname, '../public/images'),
            staticOptions
        ));

        // 404 handler cho routes khÃ´ng tá»“n táº¡i
        this.app.use((req, res) => {
            res.status(404).json({
                success: false,
                message: 'Route not found',
                path: req.path // Tráº£ vá» path Ä‘á»ƒ debug
            });
        });
    }
}



================================================
FILE: src/server.ts
================================================
import dotenv from 'dotenv';
import App from './app';
import { validateEnv } from './core/utils';
import { DocsRoute } from './modules/docs';
import { IndexRoute } from './modules/index'
import { UserRoute } from './modules/user';
import { AuthRoute } from './modules/auth';
import { PaymentRoute } from './modules/payment';
import { ServiceRoute } from './modules/service';
import { DepartmentRoute } from './modules/department';
import { StaffProfileRoute } from './modules/staff_profile';
import { SlotRoute } from './modules/slot';
import { AppointmentRoute } from './modules/appointment';
import { AppointmentLogRoute } from './modules/appointment_log';
import { KitRoute } from './modules/kit';
import { SampleRoute } from './modules/sample';
import { ResultRoute } from './modules/result';
import { RegistrationFormRoute } from './modules/registration_form';
import { BlogRoute } from './modules/blog';
import { BlogCategoryRoute } from './modules/blog_category';
import { LogRoute } from './modules/blog/log';
import { ReviewRoute } from './modules/review';
import { AdministrativeCasesRoute } from './modules/administrative_cases';

// Load environment variables
dotenv.config();

// Validate environment variables
validateEnv();

// Initialize all routes
const routes = [
    new IndexRoute(),
    new DocsRoute(),
    new AuthRoute(),
    new UserRoute(),
    new PaymentRoute(),
    new ServiceRoute(),
    new DepartmentRoute(),
    new StaffProfileRoute(),
    new SlotRoute(),
    new AppointmentRoute(),
    new AppointmentLogRoute(),
    new KitRoute(),
    new SampleRoute(),
    new ResultRoute(),
    new RegistrationFormRoute(),
    new BlogRoute(),
    new BlogCategoryRoute(),
    new LogRoute(),
    new ReviewRoute(),
    new AdministrativeCasesRoute()
];

// Create app instance
const app = new App(routes);

// For Vercel serverless deployment, export the Express app
// The app.listen() is handled by your App class internally for Vercel detection
if (process.env.VERCEL) {
    // Export for Vercel serverless functions
    module.exports = app.app;
} else {
    // For local development, start the server
    app.listen();
}

// Default export for ES modules compatibility
export default app.app;



================================================
FILE: src/swagger.ts
================================================
import swaggerJsdoc from 'swagger-jsdoc'
import swaggerUi from 'swagger-ui-express'

const options = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Bloodline DNA Testing Service API',
            description: "API endpoints for a Bloodline DNA Testing Service documented on swagger",
            contact: {
                name: "Nguyá»…n Äan Huy",
                email: "huyit2003@gmail.com",
                url: "https://github.com/server-craftsman/wdp392-restApi-with-nodejs-express-mongodb"
            },
            version: '1.0.0',
        },
        servers: [
            {
                url: "http://localhost:8080/",
                description: "Local server"
            },
            {
                url: "https://restapi-dna-testing-fwdnadcqc9hsfmbf.canadacentral-01.azurewebsites.net/",
                description: "Live server"
            },
        ],
        components: {
            securitySchemes: {
                Bearer: {
                    type: "apiKey",
                    name: "Authorization",
                    in: "header",
                    description: "Bearer token for authorization",
                    scheme: "bearer",
                    bearerFormat: "JWT"
                }
            }
        },
        security: [
            {
                Bearer: []
            }
        ]
    },
    // Paths to files containing OpenAPI definitions
    apis: [
        './src/modules/*/swagger/*.js',  // QuÃ©t táº¥t cáº£ cÃ¡c file swagger trong cÃ¡c module
        './src/modules/*/dtos/*.ts'      // QuÃ©t cÃ¡c DTO Ä‘á»ƒ láº¥y thÃ´ng tin schema (náº¿u cáº§n)
    ],
}

const swaggerSpec = swaggerJsdoc(options)

function swaggerDocs(app: any, port: any) {
    // Swagger Page
    app.use('/docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
        swaggerOptions: {
            persistAuthorization: true,
            displayRequestDuration: true,
            docExpansion: 'none',
            filter: true,
            showExtensions: true,
            tryItOutEnabled: true,
            tagsSorter: 'alpha'
        },
        customCss: '.swagger-ui .topbar { background-color: #2C3E50; }'
    }))

    // Documentation in JSON format
    app.get('/docs.json', (req: any, res: any) => {
        res.setHeader('Content-Type', 'application/json');
        res.send(swaggerSpec);
    });
}

export default swaggerDocs


================================================
FILE: src/.eslintrc.js
================================================
module.exports = {
    extends: '../.eslintrc',
    rules: {
        // Enforce specific imports ordering for clarity
        'import/order': [
            'error',
            {
                'groups': [
                    'builtin',
                    'external',
                    'internal',
                    ['parent', 'sibling'],
                    'index'
                ],
                'pathGroups': [
                    {
                        'pattern': 'core/**',
                        'group': 'internal',
                        'position': 'before'
                    },
                    {
                        'pattern': 'modules/**',
                        'group': 'internal',
                        'position': 'after'
                    },
                    {
                        'pattern': 'types/**',
                        'group': 'internal',
                        'position': 'after'
                    }
                ],
                'pathGroupsExcludedImportTypes': ['builtin'],
                'newlines-between': 'always',
                'alphabetize': { 'order': 'asc', 'caseInsensitive': true }
            }
        ],

        // Enforce module boundaries
        'no-restricted-imports': [
            'error',
            {
                'patterns': [
                    {
                        'group': ['modules/*/internal'],
                        'message': 'Do not import from internal module folders. Use the public API.'
                    }
                ]
            }
        ],

        // Enforce return types for controllers and services
        '@typescript-eslint/explicit-function-return-type': [
            'error',
            {
                'allowExpressions': true,
                'allowTypedFunctionExpressions': true
            }
        ],

        // Enforce consistent model naming
        '@typescript-eslint/naming-convention': [
            'error',
            {
                'selector': 'interface',
                'format': ['PascalCase'],
                'prefix': ['I']
            },
            {
                'selector': 'typeAlias',
                'format': ['PascalCase']
            },
            {
                'selector': 'enum',
                'format': ['PascalCase']
            },
            {
                'selector': 'variable',
                'format': ['camelCase', 'UPPER_CASE', 'PascalCase'],
                'filter': {
                    'regex': 'Model$',
                    'match': true
                },
                'format': ['PascalCase']
            }
        ]
    },
    overrides: [
        {
            // Rules specific to controllers
            files: ['src/modules/*/controllers/*.ts'],
            rules: {
                '@typescript-eslint/explicit-function-return-type': 'error'
            }
        },
        {
            // Rules specific to services
            files: ['src/modules/*/services/*.ts'],
            rules: {
                '@typescript-eslint/explicit-function-return-type': 'error',
                'no-console': 'error'
            }
        },
        {
            // Rules specific to routes
            files: ['src/modules/*/routes/*.ts'],
            rules: {
                'import/no-cycle': 'error'
            }
        },
        {
            // Rules specific to models
            files: ['src/modules/*/models/*.ts'],
            rules: {
                '@typescript-eslint/naming-convention': [
                    'error',
                    {
                        'selector': 'variable',
                        'format': ['PascalCase'],
                        'filter': {
                            'regex': 'Schema|Model',
                            'match': true
                        }
                    }
                ]
            }
        }
    ]
}; 


================================================
FILE: src/core/constants/collection.constant.ts
================================================
export const COLLECTION_NAME = {
    SETTING: 'Setting',
    ADMINISTRATIVE_CASE: 'Administrative_Case',
    USER: 'User',
    BLOG: 'Blog',
    BLOG_LOG: 'Blog_Log',
    BLOG_CATEGORY: 'Blog_Category',
    SERVICE: 'Service',
    APPOINTMENT: 'Appointment',
    REVIEW: 'Review',
    KIT: 'Kit',
    SAMPLE: 'Sample',
    REGISTRATION_FORM: 'RegistrationForm',
    RESULT: 'Result',
    PAYMENT: 'Payment',
    TRANSACTION: 'Transaction',
    APPOINTMENT_LOG: 'AppointmentLog',
    DEPARTMENT: 'Department',
    STAFF_PROFILE: 'StaffProfile',
    SLOT: 'Slot',
    ATTENDANCE: 'Attendance',
    REFUND: 'Refund',
};



================================================
FILE: src/core/constants/common.constant.ts
================================================
export const SETTING = {
    id: '123456789',
}

export const PAGINATION = {
    pageNum: 1,
    pageSize: 10,
    totalItems: 0,
    totalPages: 0,
};



================================================
FILE: src/core/constants/date.constant.ts
================================================
export const DATE_FORMAT = {
    YYYYMMDD: 'YYYYMMDD',
};



================================================
FILE: src/core/constants/index.ts
================================================
import { COLLECTION_NAME } from './collection.constant';
import { PAGINATION, SETTING } from './common.constant';
import { DATE_FORMAT } from './date.constant';
import { API_PATH } from './path.constant';
import { PREFIX_TITLE } from './prefix.constant';

export { API_PATH, COLLECTION_NAME, DATE_FORMAT, PAGINATION, PREFIX_TITLE, SETTING };




================================================
FILE: src/core/constants/path.constant.ts
================================================
export const API_PATH = {
    // migrate
    MIGRATE: '/api/migrate',
    MIGRATE_SETTING: '/api/migrate/setting',
    MIGRATE_USERS: '/api/migrate/users',

    // setting
    SETTING: '/api/setting',
    SETTING_DEFAULT: '/api/setting/default',

    // administrative case
    ADMINISTRATIVE_CASES: '/api/administrative-cases',


    // auth
    AUTH: '/api/auth',
    AUTH_GOOGLE: '/api/auth/google',
    AUTH_VERIFY_TOKEN: '/api/auth/verify-token',
    AUTH_RESEND_TOKEN: '/api/auth/resend-token',
    AUTH_FORGOT_PASSWORD: '/api/auth/forgot-password',
    AUTH_LOGOUT: '/api/auth/logout',

    // user
    USERS: '/api/users',
    GENERATE_USERS: '/api/users/generate',
    SEARCH_USERS: '/api/users/search',
    CREATE_USERS: '/api/users/create',
    USERS_GOOGLE: '/api/users/google',
    CHANGE_PASSWORD_USERS: '/api/users/change-password',
    CHANGE_STATUS_USERS: '/api/users/change-status',
    CHANGE_ROLE_USER: '/api/users/change-role',
    REVIEW_PROFILE_ACCOUNT: '/api/users/review-profile-account',

    // DNA Testing Service API paths
    // Service
    SERVICE: '/api/service',
    SEARCH_SERVICE: '/api/service/search',
    CREATE_SERVICE: '/api/service/create',
    GET_SERVICE_BY_ID: '/api/service/:id',
    UPDATE_SERVICE: '/api/service/:id',
    DELETE_SERVICE: '/api/service/:id',


    // Appointment
    APPOINTMENT: '/api/appointment',
    SEARCH_APPOINTMENT: '/api/appointment/search',
    APPOINTMENT_FEEDBACK: '/api/appointment/feedback',
    CREATE_APPOINTMENT: '/api/appointment/create',
    GET_APPOINTMENT_BY_ID: '/api/appointment/:id',
    ASSIGN_STAFF_TO_APPOINTMENT: '/api/appointment/:id/assign-staff',
    CONFIRM_APPOINTMENT: '/api/appointment/:id/confirm',

    // Appointment Log
    APPOINTMENT_LOG: '/api/appointment-logs',
    GET_LOGS_BY_APPOINTMENT: '/api/appointment-logs/appointment/:appointmentId',

    // Kit
    KIT: '/api/kit',
    SEARCH_KIT: '/api/kit/search',
    CREATE_KIT: '/api/kit/create',
    CREATE_MULTIPLE_KITS: '/api/kit/create-multiple',
    GET_KIT_BY_ID: '/api/kit/:id',
    UPDATE_KIT: '/api/kit/:id',
    DELETE_KIT: '/api/kit/:id',
    CHANGE_KIT_STATUS: '/api/kit/:id/status',
    GET_AVAILABLE_KITS: '/api/kit/available',
    ASSIGN_KIT: '/api/kit/assign',
    RETURN_KIT: '/api/kit/:id/return',

    // Sample
    SAMPLE: '/api/sample',
    SEARCH_SAMPLE: '/api/sample/search',
    COLLECT_SAMPLE: '/api/sample/collect',
    RECEIVE_SAMPLE: '/api/sample/receive',

    // Registration Form
    REGISTRATION_FORM: '/api/registration-form',
    SEARCH_REGISTRATION_FORM: '/api/registration-form/search',

    // Result
    RESULT: '/api/result',
    SEARCH_RESULT: '/api/result/search',

    // Payment
    PAYMENT: '/api/payments',
    SEARCH_PAYMENT: '/api/payments/search',

    // Transaction
    TRANSACTION: '/api/transaction',
    SEARCH_TRANSACTION: '/api/transaction/search',


    // Department
    DEPARTMENT: '/api/department',
    SEARCH_DEPARTMENT: '/api/department/search',
    DEPARTMENT_STATISTICS: '/api/department/:departmentId/statistics',
    DEPARTMENT_CAPACITY: '/api/department/:departmentId/capacity',
    DEPARTMENT_PERFORMANCE: '/api/department/:departmentId/performance',


    // Staff Profile
    STAFF_PROFILE: '/api/staff-profile',
    SEARCH_STAFF_PROFILE: '/api/staff-profile/search',
    CREATE_STAFF_PROFILE: '/api/staff-profile/create',
    UPDATE_STAFF_PROFILE: '/api/staff-profile/:id',
    DELETE_STAFF_PROFILE: '/api/staff-profile/:id',

    // Work Schedule
    WORK_SCHEDULE: '/api/work-schedule',
    SEARCH_WORK_SCHEDULE: '/api/work-schedule/search',

    // Slot
    SLOT: '/api/slot',
    SEARCH_SLOT: '/api/slot/search',
    CREATE_SLOT: '/api/slot/create',
    UPDATE_SLOT: '/api/slot/:id',
    DELETE_SLOT: '/api/slot/:id',
    CHANGE_SLOT_STATUS: '/api/slot/:id/status',
    GET_SLOT_BY_SERVICE: '/api/slot/service/:serviceId',
    GET_SLOT_BY_STAFF: '/api/slot/staff/:id',
    GET_SLOT_BY_DEPARTMENT: '/api/slot/department/:departmentId',
    GET_SLOT_BY_ID: '/api/slot/:id',
    AVAILABLE_SLOT: '/api/slot/available',


    // Attendance
    ATTENDANCE: '/api/attendance',
    SEARCH_ATTENDANCE: '/api/attendance/search',

    // Refund
    REFUND: '/api/refund',
    SEARCH_REFUND: '/api/refund/search',
    APPROVE_REFUND: '/api/refund/approve',
    REJECT_REFUND: '/api/refund/reject',
    COMPLETE_REFUND: '/api/refund/complete',

    // Blog
    BLOG: '/api/blog',
    BLOG_SEARCH: '/api/blog/search',
    BLOG_CREATE: '/api/blog/create',
    BLOG_UPDATE: '/api/blog/:id',
    BLOG_LOGS: '/api/blog/:id/logs',
    BLOG_DELETE: '/api/blog/:id',

    // Blog Category
    BLOG_CATEGORY: '/api/blog-category',
    BLOG_CATEGORY_SEARCH: '/api/blog-category/search',
    BLOG_CATEGORY_CREATE: '/api/blog-category/create',
    BLOG_CATEGORY_UPDATE: '/api/blog-category/:id',
    BLOG_CATEGORY_DELETE: '/api/blog-category/:id',

    // Review
    REVIEW: '/api/review',
    REVIEW_SEARCH: '/api/review/search',

};



================================================
FILE: src/core/constants/prefix.constant.ts
================================================
export const PREFIX_TITLE = {
    APPOINTMENT: 'APPT',
    KIT: 'KIT',
    SAMPLE: 'SAMPLE',
    RESULT: 'RESULT',
    PAYMENT: 'PAY',
    TRANSACTION: 'TRANS',
    REFUND: 'REFUND',
};



================================================
FILE: src/core/enums/http.enum.ts
================================================
export enum HttpStatus {
    Success = 200,
    Created = 201,
    Accepted = 202,
    NoContent = 204,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
    Conflict = 409,
    InternalServerError = 500,
    NotImplemented = 501,
}



================================================
FILE: src/core/enums/index.ts
================================================
import { HttpStatus } from "./http.enum";

export { HttpStatus };



================================================
FILE: src/core/exceptions/http.exception.ts
================================================
class HttpException extends Error {
    public status: number;
    public message: string;
    public errors?: any[];

    constructor(status: number, message: string, errors: any[] = []) {
        super(message);
        this.name = 'HttpException';
        this.status = status;
        this.message = message;
        this.errors = errors;

        // This is needed to make instanceof work correctly in TypeScript
        Object.setPrototypeOf(this, HttpException.prototype);
    }
}

export default HttpException;



================================================
FILE: src/core/exceptions/index.ts
================================================
import HttpException from "./http.exception";

export { HttpException };



================================================
FILE: src/core/interfaces/error.interface.ts
================================================
interface IError {
    message: string;
    field?: string;
}

export default IError;



================================================
FILE: src/core/interfaces/index.ts
================================================
import IError from './error.interface';
import ISendMailDetail from './mail.interface';
import IRoute from './routes.interface';

export { IError, ISendMailDetail, IRoute };



================================================
FILE: src/core/interfaces/mail.interface.ts
================================================
interface ISendMailDetail {
    toMail: string;
    subject: string;
    content?: string;
    html?: string;
}

export default ISendMailDetail;



================================================
FILE: src/core/interfaces/routes.interface.ts
================================================
import { Router } from "express";

interface IRoute {
    path: string;
    router: Router;
}

export default IRoute;



================================================
FILE: src/core/middleware/auth.middleware.ts
================================================
import { NextFunction, Request, RequestHandler, Response } from 'express';
import jwt from 'jsonwebtoken';
import { DataStoredInToken } from '../../modules/auth';
import { UserRole, UserSchema } from '../../modules/user';
import { HttpStatus } from '../enums';
import { logger } from '../utils';

// List of paths that should bypass authentication
const PUBLIC_PATHS = [
    '/docs',
    '/docs/',
    '/docs.json',
    '/swagger',
    '/swagger/'
];

const authMiddleWare = (roles?: UserRole[], isClient = false): RequestHandler => {
    return (req: Request, res: Response, next: NextFunction) => {
        // kiá»ƒm tra xem Ä‘Æ°á»ng dáº«n cÃ³ náº±m trong danh sÃ¡ch cÃ¡c Ä‘Æ°á»ng dáº«n public khÃ´ng
        const path = req.path;
        // náº¿u cÃ³ thÃ¬ cho phÃ©p truy cáº­p
        if (PUBLIC_PATHS.some(publicPath => path.startsWith(publicPath))) {
            next(); // chuyá»ƒn tiáº¿p Ä‘áº¿n middleware tiáº¿p theo
            return;
        }

        const authHeader = req.headers['authorization'];

        if (isClient) {
            if (!authHeader) {
                req.user = { id: '', role: null, version: 0 };
                next();
                return;
            }
        } else {
            if (!authHeader) {
                res.status(HttpStatus.NotFound).json({ message: 'No token, authorization denied.' });
                return;
            }
        }

        handleCheckToken(req, res, next, authHeader, roles).catch(next);
    };
};

const handleCheckToken = async (
    req: Request,
    res: Response,
    next: NextFunction,
    authHeader: string | undefined,
    roles?: UserRole[],
) => {
    const userSchema = UserSchema;
    if (authHeader) {
        const token = authHeader.startsWith('Bearer ')
            ? authHeader.split(' ')[1]
            : authHeader;

        if (!token) {
            res.status(HttpStatus.NotFound).json({ message: 'No token, authorization denied.' });
            return;
        }

        try {
            const userToken = jwt.verify(token, process.env.JWT_TOKEN_SECRET ?? '') as DataStoredInToken;
            if (!req.user) {
                req.user = { id: '', role: null, version: 0 };
            }
            req.user.id = userToken.id;
            req.user.role = userToken.role;
            req.user.version = userToken.version;

            // check user version
            const user = await userSchema.findOne({ _id: userToken.id, is_deleted: false, is_verified: true }).lean();
            if (!user || Number(user?.token_version?.toString() || 0) !== userToken.version) {
                res.status(HttpStatus.Forbidden).json({ message: 'Access denied: invalid token!' });
                return;
            }

            // check roles if provided
            if (roles && roles.length > 0 && !roles.includes(req.user.role)) {
                res.status(HttpStatus.Forbidden).json({ message: 'Access denied: insufficient role' });
                return;
            }

            next();
        } catch (error) {
            logger.error(`[ERROR] Msg: ${token}`);
            if (error instanceof Error) {
                if (error.name === 'TokenExpiredError') {
                    res.status(HttpStatus.Forbidden).json({ message: 'Token is expired' });
                } else {
                    res.status(HttpStatus.Forbidden).json({ message: 'Token is not valid' });
                }
            } else {
                res.status(HttpStatus.InternalServerError).json({ message: 'An unknown error occurred' });
            }
        }
    }
};

export default authMiddleWare;



================================================
FILE: src/core/middleware/cache.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';
import crypto from 'crypto';
import logger from '../utils/logger';

/**
 * Interface Ä‘á»‹nh nghÄ©a cáº¥u trÃºc cho cache entry
 * Má»—i cache entry chá»©a data vÃ  thá»i gian expire
 */
interface CacheEntry {
    data: any;        // Dá»¯ liá»‡u Ä‘Æ°á»£c cache
    timestamp: number; // Thá»i gian lÆ°u cache (milliseconds)
    ttl: number;      // Time to live (thá»i gian sá»‘ng) tÃ­nh báº±ng milliseconds
}

/**
 * Lá»›p quáº£n lÃ½ cache trong memory vá»›i configuration tá»« environment variables
 * Sá»­ dá»¥ng Map Ä‘á»ƒ lÆ°u trá»¯ data táº¡m thá»i trong RAM
 */
class InMemoryCache {
    // Map lÆ°u trá»¯ cache entries vá»›i key lÃ  string vÃ  value lÃ  CacheEntry
    private cache = new Map<string, CacheEntry>();

    // Interval timer Ä‘á»ƒ dá»n dáº¹p cache entries Ä‘Ã£ háº¿t háº¡n
    private cleanupInterval: NodeJS.Timeout;

    // Cáº¥u hÃ¬nh tá»« environment variables
    private readonly maxEntries: number;
    private readonly debugEnabled: boolean;
    private readonly statsEnabled: boolean;

    constructor() {
        // Láº¥y cáº¥u hÃ¬nh tá»« environment variables
        this.maxEntries = parseInt(process.env.CACHE_MAX_ENTRIES || '1000');
        this.debugEnabled = process.env.CACHE_DEBUG_ENABLED === 'true';
        this.statsEnabled = process.env.CACHE_STATS_ENABLED === 'true';

        // Thiáº¿t láº­p interval tá»± Ä‘á»™ng dá»n dáº¹p cache vá»›i thá»i gian tá»« env
        const cleanupInterval = parseInt(process.env.CACHE_CLEANUP_INTERVAL || '300000');
        this.cleanupInterval = setInterval(() => {
            this.cleanup();
        }, cleanupInterval);

        // Log thÃ´ng tin khá»Ÿi táº¡o cache náº¿u debug enabled
        if (this.debugEnabled) {
            logger.debug(`Cache initialized - Max entries: ${this.maxEntries}, Cleanup interval: ${cleanupInterval}ms`);
        }
    }

    /**
     * LÆ°u data vÃ o cache vá»›i key vÃ  TTL xÃ¡c Ä‘á»‹nh
     * @param key Cache key - unique identifier cho data
     * @param data Dá»¯ liá»‡u cáº§n cache (cÃ³ thá»ƒ lÃ  báº¥t ká»³ type nÃ o)
     * @param ttl Time to live tÃ­nh báº±ng milliseconds (máº·c Ä‘á»‹nh tá»« env)
     */
    set(key: string, data: any, ttl: number = parseInt(process.env.CACHE_DEFAULT_TTL || '300000')): void {
        // Kiá»ƒm tra giá»›i háº¡n sá»‘ lÆ°á»£ng entries
        if (this.cache.size >= this.maxEntries) {
            // XÃ³a entry cÅ© nháº¥t náº¿u Ä‘Ã£ Ä‘áº¡t giá»›i háº¡n
            const oldestKey = this.cache.keys().next().value;
            if (oldestKey) {
                this.cache.delete(oldestKey);
                if (this.debugEnabled) {
                    logger.debug(`Cache evicted oldest entry: ${oldestKey} (max entries: ${this.maxEntries})`);
                }
            }
        }

        const entry: CacheEntry = {
            data,                          // LÆ°u data gá»‘c
            timestamp: Date.now(),         // Thá»i gian hiá»‡n táº¡i
            ttl                           // Thá»i gian sá»‘ng
        };

        this.cache.set(key, entry);

        // Log Ä‘á»ƒ debug vÃ  monitoring náº¿u debug enabled
        if (this.debugEnabled) {
            logger.debug(`Cache SET: ${key} (TTL: ${ttl}ms, Size: ${this.cache.size}/${this.maxEntries})`);
        }
    }

    /**
     * Láº¥y data tá»« cache theo key
     * @param key Cache key cáº§n tÃ¬m
     * @returns Data náº¿u tá»“n táº¡i vÃ  chÆ°a expire, null náº¿u khÃ´ng cÃ³ hoáº·c Ä‘Ã£ háº¿t háº¡n
     */
    get(key: string): any {
        const entry = this.cache.get(key);

        // Kiá»ƒm tra entry cÃ³ tá»“n táº¡i khÃ´ng
        if (!entry) {
            if (this.debugEnabled) {
                logger.debug(`Cache MISS: ${key}`);
            }
            return null;
        }

        // Kiá»ƒm tra entry Ä‘Ã£ háº¿t háº¡n chÆ°a
        const now = Date.now();
        const ageInMs = now - entry.timestamp;

        if (ageInMs > entry.ttl) {
            // Entry Ä‘Ã£ háº¿t háº¡n, xÃ³a khá»i cache
            this.cache.delete(key);
            if (this.debugEnabled) {
                logger.debug(`Cache EXPIRED: ${key} (age: ${ageInMs}ms, ttl: ${entry.ttl}ms)`);
            }
            return null;
        }

        // Entry cÃ²n hiá»‡u lá»±c, tráº£ vá» data
        if (this.debugEnabled) {
            logger.debug(`Cache HIT: ${key} (age: ${ageInMs}ms, TTL remaining: ${entry.ttl - ageInMs}ms)`);
        }
        return entry.data;
    }

    /**
     * XÃ³a má»™t cache entry theo key
     * @param key Cache key cáº§n xÃ³a
     */
    delete(key: string): void {
        const deleted = this.cache.delete(key);
        if (deleted && this.debugEnabled) {
            logger.debug(`Cache DELETE: ${key} (Size: ${this.cache.size}/${this.maxEntries})`);
        }
    }

    /**
     * XÃ³a toÃ n bá»™ cache
     * ThÆ°á»ng dÃ¹ng khi cáº§n reset cache hoáº·c memory cleanup
     */
    clear(): void {
        const sizeBefore = this.cache.size;
        this.cache.clear();
        logger.info(`Cache CLEAR: Removed ${sizeBefore} entries`);
    }

    /**
     * Dá»n dáº¹p cÃ¡c cache entries Ä‘Ã£ háº¿t háº¡n
     * Method nÃ y Ä‘Æ°á»£c gá»i tá»± Ä‘á»™ng theo interval tá»« env
     */
    private cleanup(): void {
        const now = Date.now();
        let removedCount = 0;
        let totalEntries = 0;

        // Duyá»‡t qua táº¥t cáº£ entries Ä‘á»ƒ kiá»ƒm tra expire
        for (const [key, entry] of this.cache.entries()) {
            totalEntries++;
            const ageInMs = now - entry.timestamp;

            // Náº¿u entry Ä‘Ã£ háº¿t háº¡n thÃ¬ xÃ³a
            if (ageInMs > entry.ttl) {
                this.cache.delete(key);
                removedCount++;
            }
        }

        // Log thÃ´ng tin cleanup náº¿u cÃ³ entries bá»‹ xÃ³a hoáº·c stats enabled
        if (removedCount > 0) {
            logger.info(`Cache CLEANUP: Removed ${removedCount}/${totalEntries} expired entries. Current size: ${this.cache.size}/${this.maxEntries}`);
        } else if (this.statsEnabled && totalEntries > 0) {
            logger.debug(`Cache CLEANUP: No expired entries. Current size: ${this.cache.size}/${this.maxEntries}`);
        }
    }

    /**
     * Láº¥y thÃ´ng tin thá»‘ng kÃª vá» cache vá»›i config tá»« env
     * @returns Object chá»©a thÃ´ng tin size vÃ  memory usage
     */
    getStats() {
        const memoryUsage = process.memoryUsage();
        const stats = {
            size: this.cache.size,                    // Sá»‘ lÆ°á»£ng entries hiá»‡n táº¡i
            maxEntries: this.maxEntries,              // Giá»›i háº¡n entries tá»« env
            memoryUsage: Math.round(memoryUsage.heapUsed / 1024 / 1024 * 100) / 100, // Memory usage in MB
            hitRatio: this.calculateHitRatio(),       // Tá»· lá»‡ cache hit
            configuredTTL: parseInt(process.env.CACHE_DEFAULT_TTL || '300000'), // TTL máº·c Ä‘á»‹nh tá»« env
            cleanupInterval: parseInt(process.env.CACHE_CLEANUP_INTERVAL || '300000'), // Cleanup interval tá»« env
            debugEnabled: this.debugEnabled,          // Tráº¡ng thÃ¡i debug tá»« env
            statsEnabled: this.statsEnabled           // Tráº¡ng thÃ¡i stats tá»« env
        };

        if (this.statsEnabled) {
            logger.info(`Cache Stats: ${JSON.stringify(stats)}`);
        }

        return stats;
    }

    /**
     * TÃ­nh tá»· lá»‡ cache hit (Æ°á»›c tÃ­nh)
     * @returns Tá»· lá»‡ cache hit tá»« 0 Ä‘áº¿n 1
     */
    private calculateHitRatio(): number {
        // Æ¯á»›c tÃ­nh dá»±a trÃªn sá»‘ entries hiá»‡n táº¡i so vá»›i max entries
        // ÄÃ¢y lÃ  má»™t Æ°á»›c tÃ­nh Ä‘Æ¡n giáº£n, cÃ³ thá»ƒ cáº£i thiá»‡n báº±ng cÃ¡ch track hits/misses
        return this.cache.size > 0 ? Math.min(this.cache.size / this.maxEntries, 1) : 0;
    }

    /**
     * Cleanup khi app shutdown
     * Dá»n dáº¹p interval timer Ä‘á»ƒ trÃ¡nh memory leaks
     */
    destroy(): void {
        clearInterval(this.cleanupInterval);
        this.clear();
        logger.info('Cache destroyed');
    }
}

// Singleton instance cá»§a cache
// Sá»­ dá»¥ng pattern nÃ y Ä‘á»ƒ Ä‘áº£m báº£o chá»‰ cÃ³ 1 cache instance trong toÃ n app
const cache = new InMemoryCache();

/**
 * Middleware function Ä‘á»ƒ cache API responses vá»›i TTL tá»« env
 * @param ttl Time to live cho cache entry (máº·c Ä‘á»‹nh tá»« env)
 * @returns Express middleware function
 */
export const cacheMiddleware = (ttl?: number) => {
    // Sá»­ dá»¥ng TTL tá»« parameter hoáº·c tá»« environment variable
    const cacheTTL = ttl || parseInt(process.env.CACHE_DEFAULT_TTL || '300000');

    return (req: Request, res: Response, next: NextFunction) => {
        // Chá»‰ cache GET requests - nhá»¯ng request khÃ´ng thay Ä‘á»•i data
        if (req.method !== 'GET') {
            return next();
        }

        // Táº¡o unique cache key tá»« URL vÃ  query parameters
        const key = generateCacheKey(req);

        // Thá»­ láº¥y data tá»« cache trÆ°á»›c
        const cachedData = cache.get(key);

        if (cachedData) {
            // Cache hit - tráº£ vá» data tá»« cache
            logger.info(`Cache hit for ${req.originalUrl}`);

            // ThÃªm header Ä‘á»ƒ client biáº¿t response tá»« cache
            res.set('X-Cache', 'HIT');
            res.set('X-Cache-Key', key);
            res.set('X-Cache-TTL', cacheTTL.toString());

            return res.json(cachedData);
        }

        // Cache miss - cáº§n gá»i API vÃ  cache káº¿t quáº£
        logger.info(`Cache miss for ${req.originalUrl}`);

        // Backup original res.json method
        const originalJson = res.json.bind(res);

        // Override res.json Ä‘á»ƒ intercept response data
        res.json = function (body: any) {
            // Cache response data náº¿u status code thÃ nh cÃ´ng (2xx)
            if (res.statusCode >= 200 && res.statusCode < 300) {
                cache.set(key, body, cacheTTL);
                logger.debug(`Cached response for ${req.originalUrl} with TTL ${cacheTTL}ms`);

                // ThÃªm headers Ä‘á»ƒ debug
                res.set('X-Cache', 'MISS');
                res.set('X-Cache-Key', key);
                res.set('X-Cache-TTL', cacheTTL.toString());
            }

            // Gá»i original json method Ä‘á»ƒ tráº£ response
            return originalJson(body);
        };

        // Tiáº¿p tá»¥c vá»›i middleware/controller tiáº¿p theo
        next();
    };
};

/**
 * Middleware Ä‘á»ƒ cache response cÃ³ Ä‘iá»u kiá»‡n vá»›i TTL tá»« env
 * Chá»‰ cache khi thá»a mÃ£n cÃ¡c Ä‘iá»u kiá»‡n nháº¥t Ä‘á»‹nh
 * @param condition Function kiá»ƒm tra Ä‘iá»u kiá»‡n cache
 * @param ttl Time to live cho cache (máº·c Ä‘á»‹nh tá»« env)
 * @returns Express middleware function
 */
export const conditionalCache = (
    condition: (req: Request, res: Response) => boolean,
    ttl?: number
) => {
    const cacheTTL = ttl || parseInt(process.env.CACHE_DEFAULT_TTL || '300000');

    return (req: Request, res: Response, next: NextFunction) => {
        // Chá»‰ cache GET requests
        if (req.method !== 'GET') {
            return next();
        }

        // Kiá»ƒm tra Ä‘iá»u kiá»‡n cache
        if (!condition(req, res)) {
            logger.debug(`Skipping cache for ${req.originalUrl} - condition not met`);
            return next();
        }

        // Ãp dá»¥ng cache middleware náº¿u thá»a Ä‘iá»u kiá»‡n
        return cacheMiddleware(cacheTTL)(req, res, next);
    };
};

/**
 * Middleware Ä‘á»ƒ invalidate (xÃ³a) cache dá»±a trÃªn patterns
 * ThÆ°á»ng dÃ¹ng cho POST/PUT/DELETE requests Ä‘á»ƒ xÃ³a cache liÃªn quan
 * @param patterns Array cá»§a regex patterns Ä‘á»ƒ match cache keys cáº§n xÃ³a
 * @returns Express middleware function
 */
export const invalidateCache = (patterns: RegExp[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        // Backup original response methods
        const originalJson = res.json.bind(res);
        const originalSend = res.send.bind(res);

        // Function Ä‘á»ƒ thá»±c hiá»‡n cache invalidation
        const performInvalidation = () => {
            // Chá»‰ invalidate náº¿u response thÃ nh cÃ´ng
            if (res.statusCode >= 200 && res.statusCode < 300) {
                let invalidatedCount = 0;

                // Duyá»‡t qua táº¥t cáº£ cache entries
                for (const key of (cache as any).cache.keys()) {
                    // Kiá»ƒm tra key cÃ³ match vá»›i patterns khÃ´ng
                    for (const pattern of patterns) {
                        if (pattern.test(key)) {
                            cache.delete(key);
                            invalidatedCount++;
                            break; // ThoÃ¡t khá»i vÃ²ng láº·p patterns
                        }
                    }
                }

                if (invalidatedCount > 0) {
                    logger.info(`Invalidated ${invalidatedCount} cache entries for ${req.originalUrl}`);
                }
            }
        };

        // Override res.json Ä‘á»ƒ trigger invalidation
        res.json = function (body: any) {
            performInvalidation();
            return originalJson(body);
        };

        // Override res.send Ä‘á»ƒ trigger invalidation
        res.send = function (body: any) {
            performInvalidation();
            return originalSend(body);
        };

        // Tiáº¿p tá»¥c vá»›i middleware/controller tiáº¿p theo
        next();
    };
};

/**
 * Táº¡o unique cache key tá»« request
 * Key format: METHOD:PATH:QUERY_HASH
 * @param req Express Request object
 * @returns Unique cache key string
 */
function generateCacheKey(req: Request): string {
    // Láº¥y base path (khÃ´ng bao gá»“m query parameters)
    const basePath = req.path;

    // Convert query object thÃ nh JSON string Ä‘á»ƒ hash
    const queryString = JSON.stringify(req.query, Object.keys(req.query).sort());

    // Táº¡o hash tá»« query string Ä‘á»ƒ rÃºt ngáº¯n key
    const queryHash = crypto
        .createHash('md5')
        .update(queryString)
        .digest('hex')
        .substring(0, 8); // Chá»‰ láº¥y 8 kÃ½ tá»± Ä‘áº§u Ä‘á»ƒ ngáº¯n gá»n

    // Format: GET:/api/users:a1b2c3d4
    return `${req.method}:${basePath}:${queryHash}`;
}

/**
 * Middleware Ä‘á»ƒ thÃªm cache control headers vá»›i config tá»« env
 * GiÃºp browser vÃ  CDN cache responses
 * @param maxAge Thá»i gian cache á»Ÿ browser (seconds) - máº·c Ä‘á»‹nh tá»« env
 * @param sMaxAge Thá»i gian cache á»Ÿ CDN (seconds) - máº·c Ä‘á»‹nh tá»« env
 * @returns Express middleware function
 */
export const cacheHeaders = (maxAge?: number, sMaxAge?: number) => {
    // Láº¥y giÃ¡ trá»‹ tá»« environment variables náº¿u khÃ´ng Ä‘Æ°á»£c cung cáº¥p
    const browserMaxAge = maxAge || parseInt(process.env.CACHE_BROWSER_MAX_AGE || '300');
    const cdnMaxAge = sMaxAge || parseInt(process.env.CACHE_CDN_MAX_AGE || '600');

    return (req: Request, res: Response, next: NextFunction) => {
        // Chá»‰ thÃªm headers cho GET requests
        if (req.method === 'GET') {
            const cacheControl = [
                `public`,                                    // CÃ³ thá»ƒ cache bá»Ÿi browser vÃ  proxy
                `max-age=${browserMaxAge}`                   // Cache time á»Ÿ browser tá»« env
            ];

            // ThÃªm s-maxage cho CDN/proxy tá»« env
            if (cdnMaxAge) {
                cacheControl.push(`s-maxage=${cdnMaxAge}`);
            }

            res.set('Cache-Control', cacheControl.join(', '));

            // ThÃªm ETag Ä‘á»ƒ validation
            res.set('ETag', `"${Date.now()}"`);

            // ThÃªm header cho monitoring
            res.set('X-Cache-Config', `browser:${browserMaxAge}s,cdn:${cdnMaxAge}s`);
        }

        next();
    };
};

/**
 * Utility function Ä‘á»ƒ manually clear cache
 * CÃ³ thá»ƒ dÃ¹ng trong admin endpoints hoáº·c scheduled jobs
 */
export const clearCache = () => {
    cache.clear();
};

/**
 * Utility function Ä‘á»ƒ get cache statistics vá»›i config tá»« env
 * Há»¯u Ã­ch cho monitoring vÃ  debugging
 * @returns Object chá»©a thá»‘ng kÃª cache
 */
export const getCacheStats = () => {
    return cache.getStats();
};

/**
 * Cleanup function Ä‘á»ƒ gá»i khi app shutdown
 * Äáº£m báº£o cleanup proper Ä‘á»ƒ trÃ¡nh memory leaks
 */
export const destroyCache = () => {
    cache.destroy();
};

// Export default cache middleware vá»›i TTL tá»« env
export default cacheMiddleware; 


================================================
FILE: src/core/middleware/error.middleware.ts
================================================
import { NextFunction, Request, Response } from "express";
import { HttpStatus } from "../enums";
import { HttpException } from "../exceptions";
import { logger } from "../utils";
import mongoose from "mongoose";

const errorMiddleware = (error: Error | HttpException, req: Request, res: Response, next: NextFunction) => {
    let status: number = HttpStatus.InternalServerError;
    let message: string = "Something went wrong!";
    let errors: any[] = [];
    let stack: string | undefined = process.env.NODE_ENV === 'production' ? undefined : error.stack;

    if (error instanceof HttpException) {
        status = error.status;
        message = error.message || "Something went wrong!";
        errors = error.errors || [];
    } else if (error instanceof mongoose.Error.ValidationError) {
        status = HttpStatus.BadRequest;
        message = "Validation error";
        errors = Object.values(error.errors).map(err => ({
            field: err.path,
            message: err.message
        }));
    } else if (error instanceof mongoose.Error.CastError) {
        status = HttpStatus.BadRequest;
        message = `Invalid ${error.path}: ${error.value}`;
    } else if (error.name === 'SyntaxError') {
        status = HttpStatus.BadRequest;
        message = "Invalid JSON syntax";
    } else {
        logger.error(`Unhandled error: ${error.message}`, error);
        message = error.message || "Internal server error";
    }

    // Log the error with more context
    logger.error(`[ERROR] - Status: ${status} - Msg: ${message}`);
    if (errors.length) {
        logger.error(`Error details: ${JSON.stringify(errors)}`);
    }

    // Include the request path and method in the log
    logger.error(`Request: ${req.method} ${req.path}`);

    res.status(status).json({
        success: false,
        message,
        errors: errors.length ? errors : undefined,
        stack: stack
    });
};

export default errorMiddleware;



================================================
FILE: src/core/middleware/index.ts
================================================
import authMiddleWare from "./auth.middleware";
import errorMiddleware from "./error.middleware";
import validationMiddleware from "./validation.middleware";
import { uploadSingleFile, uploadMultipleFiles } from "./upload.middleware";
import multer from "multer";

// Create multer instance with memory storage for direct use
const storage = multer.memoryStorage();
const uploadMiddleware = multer({
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024, // 5MB max file size
    }
});

export {
    authMiddleWare,
    errorMiddleware,
    validationMiddleware,
    uploadSingleFile,
    uploadMultipleFiles,
    uploadMiddleware
};




================================================
FILE: src/core/middleware/upload.middleware.ts
================================================
import multer from 'multer';
import path from 'path';
import { Request, Response, NextFunction } from 'express';
import { HttpException } from '../exceptions';
import { HttpStatus } from '../enums';
import { v4 as uuidv4 } from 'uuid';
import { PutObjectCommand } from '@aws-sdk/client-s3';
import { s3Client, bucketName, s3Folders } from '../utils/aws.config';
import { Readable } from 'stream';

// Memory storage instead of disk storage
const storage = multer.memoryStorage();

// File filter for images
const imageFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    // Accept only image files
    if (!file.originalname.match(/\.(jpg|jpeg|png|gif)$/i)) {
        return cb(new HttpException(HttpStatus.BadRequest, 'Only image files are allowed!'));
    }
    cb(null, true);
};

// Create upload instance with memory storage
const upload = multer({
    storage: storage,
    fileFilter: imageFilter,
    limits: {
        fileSize: 5 * 1024 * 1024, // 5MB max file size
    }
});

// Helper function to upload buffer directly to S3
const uploadBufferToS3 = async (
    buffer: Buffer,
    originalname: string,
    mimetype: string,
    sampleId?: string,
    folder: string = s3Folders.personImages
): Promise<string> => {
    try {
        // Generate a unique file name
        const fileExtension = path.extname(originalname);
        const fileName = `${uuidv4()}${fileExtension}`;

        // Create the folder path - if sampleId is provided, include it in the path
        const folderPath = sampleId ? `${folder}/${sampleId}` : folder;
        const key = `${folderPath}/${fileName}`;

        // Upload the buffer directly to S3
        const uploadParams = {
            Bucket: bucketName,
            Key: key,
            Body: buffer,
            ContentType: mimetype,
        };

        await s3Client.send(new PutObjectCommand(uploadParams));

        // Generate the URL for the uploaded file
        const region = typeof s3Client.config.region === 'string'
            ? s3Client.config.region
            : 'ap-southeast-2'; // Default region based on error message

        // Use the correct S3 URL format with dashed region
        const fileUrl = `https://${bucketName}.s3-${region}.amazonaws.com/${key}`;
        return fileUrl;
    } catch (error) {
        console.error('Error uploading buffer to S3:', error);
        throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload file to S3');
    }
};

// Middleware for single file upload directly to S3
export const uploadSingleFile = (fieldName: string, required: boolean = false) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const uploadMiddleware = upload.single(fieldName);

        uploadMiddleware(req, res, async (err: any) => {
            if (err instanceof multer.MulterError) {
                if (err.code === 'LIMIT_FILE_SIZE') {
                    return next(new HttpException(HttpStatus.BadRequest, 'File too large. Maximum size is 5MB.'));
                }
                // Handle field name mismatch error - common when form field name doesn't match expected name
                if (err.message.includes('Unexpected field')) {
                    console.warn(`Warning: Unexpected field name. Expected '${fieldName}'. Continuing without file upload.`);
                    return next(); // Continue without file upload
                }
                return next(new HttpException(HttpStatus.BadRequest, err.message));
            } else if (err) {
                return next(err);
            }

            // Check if file exists - only required if the 'required' parameter is true
            if (required && !req.file) {
                return next(new HttpException(HttpStatus.BadRequest, `Please upload a file for field '${fieldName}'`));
            }

            // If no file was uploaded and it's not required, just continue
            if (!req.file) {
                return next();
            }

            try {
                // Get sample_id from request body if available
                const sampleId = req.body?.sample_id;

                // Upload buffer directly to S3
                const fileUrl = await uploadBufferToS3(
                    req.file.buffer,
                    req.file.originalname,
                    req.file.mimetype,
                    sampleId
                );

                // Add the S3 URL to the request for later use
                req.file.path = fileUrl;
                (req.file as any).location = fileUrl; // AWS S3 compatible field

                next();
            } catch (error) {
                next(error);
            }
        });
    };
};

// Middleware for multiple file upload directly to S3
export const uploadMultipleFiles = (fieldName: string, maxCount: number = 5, required: boolean = true) => {
    return (req: Request, res: Response, next: NextFunction) => {
        const uploadMiddleware = upload.array(fieldName, maxCount);

        uploadMiddleware(req, res, async (err: any) => {
            if (err instanceof multer.MulterError) {
                if (err.code === 'LIMIT_FILE_SIZE') {
                    return next(new HttpException(HttpStatus.BadRequest, 'File too large. Maximum size is 5MB.'));
                } else if (err.code === 'LIMIT_UNEXPECTED_FILE') {
                    return next(new HttpException(HttpStatus.BadRequest, `Too many files. Maximum is ${maxCount}.`));
                }
                // Handle field name mismatch error - common when form field name doesn't match expected name
                if (err.message.includes('Unexpected field')) {
                    console.warn(`Warning: Unexpected field name. Expected '${fieldName}'. Continuing without file upload.`);
                    return next(); // Continue without file upload
                }
                return next(new HttpException(HttpStatus.BadRequest, err.message));
            } else if (err) {
                return next(err);
            }

            // Check if files exist - only required if the 'required' parameter is true
            if (required && (!req.files || (Array.isArray(req.files) && req.files.length === 0))) {
                return next(new HttpException(HttpStatus.BadRequest, `Please upload at least one file for field '${fieldName}'`));
            }

            // If no files were uploaded and it's not required, just continue
            if (!req.files || (Array.isArray(req.files) && req.files.length === 0)) {
                return next();
            }

            try {
                // Get sample_id from request body if available
                const sampleId = req.body?.sample_id;

                // Upload all files directly to S3
                const fileUrls = await Promise.all(
                    (req.files as Express.Multer.File[]).map(async (file) => {
                        const fileUrl = await uploadBufferToS3(
                            file.buffer,
                            file.originalname,
                            file.mimetype,
                            sampleId
                        );

                        // Add the S3 URL to each file
                        file.path = fileUrl;
                        (file as any).location = fileUrl; // AWS S3 compatible field

                        return fileUrl;
                    })
                );

                // Add the S3 URLs to the request for later use
                (req as any).fileUrls = fileUrls;

                next();
            } catch (error) {
                next(error);
            }
        });
    };
}; 


================================================
FILE: src/core/middleware/validation.middleware.ts
================================================

import { plainToInstance } from "class-transformer";
import { ValidationError, validate } from "class-validator";
import { NextFunction, Request, RequestHandler, Response } from "express";
import { HttpStatus } from "../enums";
import { HttpException } from "../exceptions";
import { IError } from "../interfaces";

const validationMiddleware = (type: any, skipMissingProperties = false): RequestHandler => {
    return (req: Request, res: Response, next: NextFunction) => {
        validate(plainToInstance(type, req.body), { skipMissingProperties: skipMissingProperties }).then(
            (errors: ValidationError[]) => {
                if (errors.length > 0) {
                    let errorResults: IError[] = [];

                    const extractConstraints = (error: ValidationError) => {
                        if (error.constraints) {
                            Object.values(error.constraints || {}).forEach((message) => {
                                errorResults.push({
                                    message,
                                    field: error.property,
                                });
                            });
                        }
                        if (error.children && error.children.length > 0) {
                            error.children.forEach((childError) => {
                                extractConstraints(childError);
                            });
                        }
                    };

                    errors.forEach((error) => {
                        extractConstraints(error);
                    });

                    next(new HttpException(HttpStatus.BadRequest, "", errorResults));
                } else {
                    next();
                }
            }
        );
    };
};

export default validationMiddleware;



================================================
FILE: src/core/models/index.ts
================================================
import { SearchPaginationRequestModel, SearchPaginationResponseModel } from "./searchPagination.model";

export { SearchPaginationRequestModel, SearchPaginationResponseModel };



================================================
FILE: src/core/models/pagination.model.ts
================================================

import { IsInt, Min } from 'class-validator';
import { PAGINATION } from '../constants';

export class PaginationRequestModel {
    constructor(pageNum: number = PAGINATION.pageNum, pageSize: number = PAGINATION.pageSize) {
        this.pageNum = pageNum;
        this.pageSize = pageSize;
    }

    @IsInt()
    @Min(PAGINATION.pageNum)
    public pageNum: number;

    @IsInt()
    @Min(PAGINATION.pageSize)
    public pageSize: number;
}

export class PaginationResponseModel {
    constructor(
        pageNum: number = PAGINATION.pageNum,
        pageSize: number = PAGINATION.pageSize,
        totalItems: number = PAGINATION.totalItems,
        totalPages: number = PAGINATION.totalPages,
    ) {
        this.pageNum = pageNum;
        this.pageSize = pageSize;
        this.totalItems = totalItems;
        this.totalPages = totalPages;
    }

    public pageNum: number;
    public pageSize: number;
    public totalItems: number;
    public totalPages: number;
}



================================================
FILE: src/core/models/searchPagination.model.ts
================================================
import { Type } from 'class-transformer';
import { IsNotEmptyObject, ValidateNested } from 'class-validator';
import 'reflect-metadata';
import { PaginationRequestModel, PaginationResponseModel } from './pagination.model';

export class SearchPaginationRequestModel<T> {
    constructor(pageInfo: PaginationRequestModel, searchCondition: T) {
        this.pageInfo = pageInfo;
        this.searchCondition = searchCondition;
    }

    @IsNotEmptyObject()
    @ValidateNested()
    @Type(() => PaginationRequestModel)
    public pageInfo: PaginationRequestModel;

    @IsNotEmptyObject()
    @ValidateNested()
    @Type(() => Object) // Use Object to allow any type for searchCondition
    public searchCondition: T;
}

export class SearchPaginationResponseModel<T> {
    constructor(pageData: T[] = [], pageInfo: PaginationResponseModel = new PaginationResponseModel()) {
        this.pageData = pageData;
        this.pageInfo = pageInfo;
    }

    public pageData: T[];
    public pageInfo: PaginationResponseModel;
}



================================================
FILE: src/core/utils/aws.config.ts
================================================
import dotenv from 'dotenv';
import { S3Client } from '@aws-sdk/client-s3';

dotenv.config();

// AWS S3 configuration
export const s3Config = {
    region: process.env.AWS_REGION || 'ap-southeast-2',
    credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
    },
    bucket: process.env.AWS_S3_BUCKET_NAME || 'wdp392-generate-pdf',
};

// Initialize S3 client
export const s3Client = new S3Client({
    region: s3Config.region,
    credentials: s3Config.credentials,
});

// Define folder paths
export const s3Folders = {
    personImages: 'person-sample-images',
    resultReports: 'result-reports',
    blogImages: 'blog-images',
};

// Export bucket name
export const bucketName = s3Config.bucket;


================================================
FILE: src/core/utils/helpers.ts
================================================
import jwt from 'jsonwebtoken';
import { DataStoredInToken } from '../../modules/auth';
import moment from 'moment';
import { DATE_FORMAT } from '../constants';

export const getUserIdCurrent = (authHeader: string) => {
    if (!authHeader) {
        return '';
    }
    const token = authHeader.split(' ')[1];
    const user = jwt.verify(token, process.env.JWT_TOKEN_SECRET ?? '') as DataStoredInToken;
    return user;
};

export const isEmptyObject = (obj: any): boolean => {
    return !Object.keys(obj).length;
};

export const formatResponse = <T>(data: T, success: boolean = true, message?: string) => {
    return {
        success,
        data,
        message
    };
};

export const generateRandomNo = (PREFIX_TITLE: string, numberLimit = 6) => {
    const randomNumbers = Array.from({ length: numberLimit }, () => Math.floor(Math.random() * 10)).join('');
    const yyyymmdd = moment().format(DATE_FORMAT.YYYYMMDD); // Format current date as YYYYMMDD
    return `${PREFIX_TITLE}_${randomNumbers}${yyyymmdd}`;
};



================================================
FILE: src/core/utils/index.ts
================================================
import { formatResponse, generateRandomNo, getUserIdCurrent, isEmptyObject } from './helpers';
import logger from './logger';
import { encodePasswordUserNormal } from './password';
import { itemsQuery } from './query';
import { formatPaginationResult } from './service';
import { sendMail, createVerificationEmailTemplate, createPasswordResetEmailTemplate, createNotificationEmailTemplate } from './sendMail';
import { createToken, createTokenVerifiedUser } from './token';
import validateEnv from './validateEnv';
import { checkUserMatch, checkValidUrl } from './validation';
import { uploadFileToS3, uploadMultipleFilesToS3 } from './s3Upload';
import { s3Client, bucketName, s3Folders } from './aws.config';

export {
    checkUserMatch,
    checkValidUrl,
    createToken,
    createTokenVerifiedUser,
    createVerificationEmailTemplate,
    createPasswordResetEmailTemplate,
    createNotificationEmailTemplate,
    encodePasswordUserNormal,
    formatPaginationResult,
    formatResponse,
    generateRandomNo,
    getUserIdCurrent,
    isEmptyObject,
    itemsQuery,
    logger,
    sendMail,
    validateEnv,
    uploadFileToS3,
    uploadMultipleFilesToS3,
    s3Client,
    bucketName,
    s3Folders,
};



================================================
FILE: src/core/utils/logger.ts
================================================
import winston from "winston";

const logger: winston.Logger = winston.createLogger({
    // transports: [
    //     // - Write all logs with importance level of `error` or less to `error.log`
    //     // - Write all logs with importance level of `info` or less to `combined.log`
    //     new winston.transports.File({ filename: "./logs/error.log", level: "error" }),
    //     new winston.transports.File({ filename: "./logs/combined.log" }),
    // ],
    // format: winston.format.combine(winston.format.colorize({ all: true }), winston.format.simple()),
});

// If we're not in production then log to the `console` with the format:
if (process.env.NODE_ENV !== "production") {
    // logger.add(
    //     new winston.transports.Console({
    //         format: winston.format.combine(winston.format.colorize({ all: true }), winston.format.simple()),
    //     })
    // );
}

export default logger;



================================================
FILE: src/core/utils/password.ts
================================================
import bcryptjs from 'bcryptjs';
import logger from './logger';

/**
 * Interface Ä‘á»‹nh nghÄ©a cáº¥u hÃ¬nh báº£o máº­t password tá»« environment variables
 */
interface PasswordConfig {
    saltRounds: number;           // Sá»‘ rounds cho bcrypt salt tá»« env
    minLength: number;            // Äá»™ dÃ i tá»‘i thiá»ƒu password tá»« env
    maxLength: number;            // Äá»™ dÃ i tá»‘i Ä‘a password tá»« env
    requireUppercase: boolean;    // YÃªu cáº§u chá»¯ hoa tá»« env
    requireLowercase: boolean;    // YÃªu cáº§u chá»¯ thÆ°á»ng tá»« env  
    requireNumbers: boolean;      // YÃªu cáº§u sá»‘ tá»« env
    requireSpecialChars: boolean; // YÃªu cáº§u kÃ½ tá»± Ä‘áº·c biá»‡t tá»« env
}

/**
 * Láº¥y cáº¥u hÃ¬nh password tá»« environment variables
 * @returns Object chá»©a config password security
 */
function getPasswordConfig(): PasswordConfig {
    return {
        saltRounds: parseInt(process.env.BCRYPT_SALT_ROUNDS || '12'),
        minLength: parseInt(process.env.PASSWORD_MIN_LENGTH || '8'),
        maxLength: parseInt(process.env.PASSWORD_MAX_LENGTH || '128'),
        requireUppercase: process.env.PASSWORD_REQUIRE_UPPERCASE === 'true',
        requireLowercase: process.env.PASSWORD_REQUIRE_LOWERCASE === 'true',
        requireNumbers: process.env.PASSWORD_REQUIRE_NUMBERS === 'true',
        requireSpecialChars: process.env.PASSWORD_REQUIRE_SPECIAL_CHARS === 'true'
    };
}

/**
 * Validate password theo cÃ¡c quy táº¯c tá»« environment variables
 * @param password Password cáº§n validate
 * @returns Object chá»©a káº¿t quáº£ validation vÃ  thÃ´ng bÃ¡o lá»—i
 */
export const validatePassword = (password: string): { isValid: boolean; errors: string[] } => {
    const config = getPasswordConfig();
    const errors: string[] = [];

    // Kiá»ƒm tra Ä‘á»™ dÃ i tá»‘i thiá»ƒu tá»« env
    if (password.length < config.minLength) {
        errors.push(`Password pháº£i cÃ³ Ã­t nháº¥t ${config.minLength} kÃ½ tá»±`);
    }

    // Kiá»ƒm tra Ä‘á»™ dÃ i tá»‘i Ä‘a tá»« env
    if (password.length > config.maxLength) {
        errors.push(`Password khÃ´ng Ä‘Æ°á»£c vÆ°á»£t quÃ¡ ${config.maxLength} kÃ½ tá»±`);
    }

    // Kiá»ƒm tra yÃªu cáº§u chá»¯ hoa náº¿u Ä‘Æ°á»£c báº­t trong env
    if (config.requireUppercase && !/[A-Z]/.test(password)) {
        errors.push('Password pháº£i chá»©a Ã­t nháº¥t má»™t chá»¯ cÃ¡i viáº¿t hoa');
    }

    // Kiá»ƒm tra yÃªu cáº§u chá»¯ thÆ°á»ng náº¿u Ä‘Æ°á»£c báº­t trong env
    if (config.requireLowercase && !/[a-z]/.test(password)) {
        errors.push('Password pháº£i chá»©a Ã­t nháº¥t má»™t chá»¯ cÃ¡i viáº¿t thÆ°á»ng');
    }

    // Kiá»ƒm tra yÃªu cáº§u sá»‘ náº¿u Ä‘Æ°á»£c báº­t trong env
    if (config.requireNumbers && !/\d/.test(password)) {
        errors.push('Password pháº£i chá»©a Ã­t nháº¥t má»™t chá»¯ sá»‘');
    }

    // Kiá»ƒm tra yÃªu cáº§u kÃ½ tá»± Ä‘áº·c biá»‡t náº¿u Ä‘Æ°á»£c báº­t trong env
    if (config.requireSpecialChars && !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
        errors.push('Password pháº£i chá»©a Ã­t nháº¥t má»™t kÃ½ tá»± Ä‘áº·c biá»‡t');
    }

    // Kiá»ƒm tra khÃ´ng chá»©a khoáº£ng tráº¯ng
    if (/\s/.test(password)) {
        errors.push('Password khÃ´ng Ä‘Æ°á»£c chá»©a khoáº£ng tráº¯ng');
    }

    return {
        isValid: errors.length === 0,
        errors
    };
};

/**
 * MÃ£ hÃ³a password sá»­ dá»¥ng bcryptjs vá»›i salt rounds tá»« environment variables
 * @param password Password cáº§n mÃ£ hÃ³a
 * @returns Promise tráº£ vá» password Ä‘Ã£ Ä‘Æ°á»£c hash
 */
export const encodePasswordUserNormal = async (password: string): Promise<string> => {
    try {
        // Validate password trÆ°á»›c khi hash
        const validation = validatePassword(password);
        if (!validation.isValid) {
            const errorMessage = `Password validation failed: ${validation.errors.join(', ')}`;
            logger.error(errorMessage);
            throw new Error(errorMessage);
        }

        const config = getPasswordConfig();

        // Táº¡o salt vá»›i sá»‘ rounds tá»« environment variables
        const salt = await bcryptjs.genSalt(config.saltRounds);

        // Hash password vá»›i salt Ä‘Ã£ táº¡o
        const hashedPassword = await bcryptjs.hash(password, salt);

        // Log thÃ´ng tin hash (khÃ´ng log password gá»‘c vÃ¬ báº£o máº­t)
        logger.info(`Password hashed successfully with ${config.saltRounds} salt rounds`);

        return hashedPassword;
    } catch (error) {
        logger.error('Error encoding password:', error);
        throw new Error('Failed to encode password');
    }
};

/**
 * So sÃ¡nh password vá»›i hash Ä‘Ã£ lÆ°u
 * @param password Password plain text
 * @param hashedPassword Password Ä‘Ã£ Ä‘Æ°á»£c hash
 * @returns Promise tráº£ vá» boolean cho biáº¿t password cÃ³ Ä‘Ãºng khÃ´ng
 */
export const comparePassword = async (password: string, hashedPassword: string): Promise<boolean> => {
    try {
        // Kiá»ƒm tra input validation
        if (!password || !hashedPassword) {
            logger.warn('Missing password or hash for comparison');
            return false;
        }

        // So sÃ¡nh password vá»›i hash
        const isMatch = await bcryptjs.compare(password, hashedPassword);

        // Log káº¿t quáº£ (khÃ´ng log password thá»±c táº¿)
        logger.debug(`Password comparison result: ${isMatch ? 'match' : 'no match'}`);

        return isMatch;
    } catch (error) {
        logger.error('Error comparing password:', error);
        return false; // Tráº£ vá» false khi cÃ³ lá»—i Ä‘á»ƒ báº£o máº­t
    }
};

/**
 * Táº¡o password ngáº«u nhiÃªn Ä‘Ã¡p á»©ng táº¥t cáº£ requirements tá»« env
 * @param length Äá»™ dÃ i password (máº·c Ä‘á»‹nh tá»« env)
 * @returns Password ngáº«u nhiÃªn thá»a mÃ£n táº¥t cáº£ Ä‘iá»u kiá»‡n
 */
export const generateSecurePassword = (length?: number): string => {
    const config = getPasswordConfig();
    const passwordLength = length || Math.max(config.minLength, 12); // Ãt nháº¥t 12 kÃ½ tá»±

    // Äá»‹nh nghÄ©a cÃ¡c bá»™ kÃ½ tá»±
    const lowercase = 'abcdefghijklmnopqrstuvwxyz';
    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const numbers = '0123456789';
    const specialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';

    let charset = '';
    let guaranteedChars = '';

    // ThÃªm cÃ¡c bá»™ kÃ½ tá»± báº¯t buá»™c tá»« config
    if (config.requireLowercase) {
        charset += lowercase;
        guaranteedChars += lowercase.charAt(Math.floor(Math.random() * lowercase.length));
    }

    if (config.requireUppercase) {
        charset += uppercase;
        guaranteedChars += uppercase.charAt(Math.floor(Math.random() * uppercase.length));
    }

    if (config.requireNumbers) {
        charset += numbers;
        guaranteedChars += numbers.charAt(Math.floor(Math.random() * numbers.length));
    }

    if (config.requireSpecialChars) {
        charset += specialChars;
        guaranteedChars += specialChars.charAt(Math.floor(Math.random() * specialChars.length));
    }

    // Náº¿u khÃ´ng cÃ³ yÃªu cáº§u gÃ¬, dÃ¹ng táº¥t cáº£
    if (!charset) {
        charset = lowercase + uppercase + numbers + specialChars;
    }

    // Táº¡o password vá»›i Ä‘á»™ dÃ i cÃ²n láº¡i
    let password = guaranteedChars;
    for (let i = guaranteedChars.length; i < passwordLength; i++) {
        password += charset.charAt(Math.floor(Math.random() * charset.length));
    }

    // Trá»™n cÃ¡c kÃ½ tá»± Ä‘á»ƒ trÃ¡nh pattern dá»… Ä‘oÃ¡n
    password = password.split('').sort(() => 0.5 - Math.random()).join('');

    logger.info(`Generated secure password with length ${password.length}`);
    return password;
};

/**
 * Kiá»ƒm tra password cÃ³ bá»‹ compromise khÃ´ng (cÃ³ thá»ƒ má»Ÿ rá»™ng vá»›i API check)
 * @param password Password cáº§n kiá»ƒm tra
 * @returns Promise tráº£ vá» boolean, true náº¿u password an toÃ n
 */
export const checkPasswordSecurity = async (password: string): Promise<{ isSafe: boolean; warnings: string[] }> => {
    const warnings: string[] = [];

    // Kiá»ƒm tra cÃ¡c pattern phá»• biáº¿n khÃ´ng an toÃ n
    const commonPatterns = [
        'password', '123456', 'qwerty', 'admin', 'letmein',
        'welcome', 'monkey', '1234567890', 'abc123'
    ];

    const lowerPassword = password.toLowerCase();
    for (const pattern of commonPatterns) {
        if (lowerPassword.includes(pattern)) {
            warnings.push(`Password chá»©a pattern khÃ´ng an toÃ n: "${pattern}"`);
        }
    }

    // Kiá»ƒm tra keyboard patterns
    const keyboardPatterns = ['qwerty', 'asdf', 'zxcv', '1234', 'abcd'];
    for (const pattern of keyboardPatterns) {
        if (lowerPassword.includes(pattern)) {
            warnings.push(`Password chá»©a keyboard pattern: "${pattern}"`);
        }
    }

    // Kiá»ƒm tra repeated characters
    if (/(.)\1{2,}/.test(password)) {
        warnings.push('Password chá»©a kÃ½ tá»± láº·p láº¡i liÃªn tiáº¿p');
    }

    // Kiá»ƒm tra sequential characters
    for (let i = 0; i < password.length - 2; i++) {
        const char1 = password.charCodeAt(i);
        const char2 = password.charCodeAt(i + 1);
        const char3 = password.charCodeAt(i + 2);

        if (char2 === char1 + 1 && char3 === char2 + 1) {
            warnings.push('Password chá»©a kÃ½ tá»± tuáº§n tá»±');
            break;
        }
    }

    const isSafe = warnings.length === 0;

    if (!isSafe) {
        logger.warn(`Password security check failed: ${warnings.join(', ')}`);
    }

    return { isSafe, warnings };
};

/**
 * Láº¥y thÃ´ng tin cáº¥u hÃ¬nh password hiá»‡n táº¡i (cho debugging/monitoring)
 * @returns Object chá»©a config password khÃ´ng sensitive
 */
export const getPasswordConfigInfo = () => {
    const config = getPasswordConfig();
    return {
        saltRounds: config.saltRounds,
        minLength: config.minLength,
        maxLength: config.maxLength,
        requirements: {
            uppercase: config.requireUppercase,
            lowercase: config.requireLowercase,
            numbers: config.requireNumbers,
            specialChars: config.requireSpecialChars
        }
    };
};

/**
 * Export function chÃ­nh Ä‘á»ƒ tÆ°Æ¡ng thÃ­ch vá»›i code cÅ©
 * ÄÆ°á»£c enhance vá»›i validation vÃ  config tá»« env
 */
export { encodePasswordUserNormal as hashPassword };



================================================
FILE: src/core/utils/performance.ts
================================================
import mongoose from 'mongoose';
import logger from './logger';

/**
 * Lá»›p tiá»‡n Ã­ch tá»‘i Æ°u Database queries
 * GiÃºp cáº£i thiá»‡n hiá»‡u suáº¥t truy váº¥n MongoDB
 */
export class DatabaseOptimizer {
    /**
     * ThÃªm .lean() vÃ o mongoose queries Ä‘á»ƒ tÄƒng hiá»‡u suáº¥t
     * .lean() tráº£ vá» plain JavaScript objects thay vÃ¬ Mongoose documents
     * Nhanh hÆ¡n vÃ¬ khÃ´ng cÃ³ getters/setters vÃ  validation
     * @param query Mongoose query object
     * @returns Query Ä‘Ã£ Ä‘Æ°á»£c tá»‘i Æ°u
     */
    static lean(query: any): any {
        return query.lean();
    }

    /**
     * ThÃªm projection Ä‘á»ƒ giá»›i háº¡n fields tráº£ vá»
     * Chá»‰ láº¥y nhá»¯ng fields cáº§n thiáº¿t Ä‘á»ƒ giáº£m bandwidth vÃ  memory
     * @param query Mongoose query object
     * @param fields Chuá»—i cÃ¡c fields cáº§n láº¥y (vd: 'name email created_at')
     * @returns Query vá»›i projection
     */
    static select(query: any, fields: string): any {
        return query.select(fields);
    }

    /**
     * Tá»‘i Æ°u pagination queries vá»›i validation vÃ  lean()
     * Tá»± Ä‘á»™ng thÃªm sort, skip, limit vÃ  lean() cho hiá»‡u suáº¥t tá»‘i Ä‘a
     * @param query Base query chÆ°a cÃ³ pagination
     * @param page Sá»‘ trang (báº¯t Ä‘áº§u tá»« 1)
     * @param limit Sá»‘ items má»—i trang
     * @param sort TiÃªu chÃ­ sáº¯p xáº¿p (máº·c Ä‘á»‹nh theo created_at giáº£m dáº§n)
     * @returns Query Ä‘Ã£ Ä‘Æ°á»£c tá»‘i Æ°u vá»›i pagination
     */
    static paginate(
        query: any,
        page: number = 1,
        limit: number = 10,
        sort: any = { created_at: -1 }
    ): any {
        // TÃ­nh sá»‘ documents cáº§n skip, Ä‘áº£m báº£o khÃ´ng Ã¢m
        const skip = Math.max(0, (page - 1) * limit);

        // Giá»›i háº¡n limit trong khoáº£ng 1-100 Ä‘á»ƒ trÃ¡nh overload
        const validLimit = Math.min(Math.max(1, limit), 100);

        return query
            .sort(sort)           // Sáº¯p xáº¿p trÆ°á»›c
            .skip(skip)           // Bá» qua documents cá»§a cÃ¡c trang trÆ°á»›c
            .limit(validLimit)    // Giá»›i háº¡n sá»‘ documents tráº£ vá»
            .lean();              // Tráº£ vá» plain objects Ä‘á»ƒ tÄƒng tá»‘c
    }

    /**
     * Táº¡o optimized count query
     * Sá»­ dá»¥ng countDocuments() thay vÃ¬ count() (deprecated)
     * @param model Mongoose model
     * @param filter Äiá»u kiá»‡n filter (máº·c Ä‘á»‹nh lÃ  rá»—ng)
     * @returns Promise tráº£ vá» sá»‘ lÆ°á»£ng documents
     */
    static count(model: mongoose.Model<any>, filter: any = {}) {
        return model.countDocuments(filter);
    }

    /**
     * Xá»­ lÃ½ batch cho datasets lá»›n Ä‘á»ƒ trÃ¡nh memory overflow
     * Chia nhá» dá»¯ liá»‡u thÃ nh cÃ¡c batch vÃ  xá»­ lÃ½ tuáº§n tá»±
     * @param model Mongoose model
     * @param filter Äiá»u kiá»‡n filter
     * @param processor HÃ m xá»­ lÃ½ má»—i batch
     * @param batchSize KÃ­ch thÆ°á»›c má»—i batch (máº·c Ä‘á»‹nh 100)
     */
    static async batchProcess(
        model: mongoose.Model<any>,
        filter: any,
        processor: (batch: any[]) => Promise<void>,
        batchSize: number = 100
    ): Promise<void> {
        let skip = 0;           // Sá»‘ documents Ä‘Ã£ xá»­ lÃ½
        let hasMore = true;     // Flag kiá»ƒm tra cÃ²n data khÃ´ng

        while (hasMore) {
            // Láº¥y má»™t batch documents
            const batch = await model
                .find(filter)
                .skip(skip)
                .limit(batchSize)
                .lean()               // Sá»­ dá»¥ng lean() Ä‘á»ƒ tÄƒng tá»‘c
                .exec();

            // Náº¿u khÃ´ng cÃ³ data thÃ¬ dá»«ng
            if (batch.length === 0) {
                hasMore = false;
                break;
            }

            // Xá»­ lÃ½ batch hiá»‡n táº¡i
            await processor(batch);
            skip += batchSize;

            // Náº¿u batch nhá» hÆ¡n batchSize thÃ¬ Ä‘Ã¢y lÃ  batch cuá»‘i
            if (batch.length < batchSize) {
                hasMore = false;
            }
        }
    }
}

/**
 * Lá»›p tiá»‡n Ã­ch monitoring hiá»‡u suáº¥t
 * GiÃºp Ä‘o thá»i gian thá»±c thi vÃ  log performance
 */
export class PerformanceMonitor {
    // Map lÆ°u trá»¯ thá»i gian báº¯t Ä‘áº§u cá»§a cÃ¡c timers
    private static timers = new Map<string, number>();

    /**
     * Báº¯t Ä‘áº§u Ä‘o thá»i gian cho má»™t operation
     * @param label TÃªn cá»§a timer Ä‘á»ƒ identify
     */
    static start(label: string): void {
        this.timers.set(label, Date.now());
    }

    /**
     * Káº¿t thÃºc Ä‘o thá»i gian vÃ  log káº¿t quáº£
     * @param label TÃªn timer cáº§n káº¿t thÃºc
     * @param logLevel Má»©c Ä‘á»™ log (info/warn/error)
     * @returns Thá»i gian thá»±c thi tÃ­nh báº±ng milliseconds
     */
    static end(label: string, logLevel: 'info' | 'warn' | 'error' = 'info'): number {
        const startTime = this.timers.get(label);

        // Kiá»ƒm tra timer cÃ³ tá»“n táº¡i khÃ´ng
        if (!startTime) {
            logger.warn(`Timer '${label}' was not started`);
            return 0;
        }

        // TÃ­nh thá»i gian thá»±c thi
        const duration = Date.now() - startTime;

        // XÃ³a timer khá»i map Ä‘á»ƒ tiáº¿t kiá»‡m memory
        this.timers.delete(label);

        const message = `${label} completed in ${duration}ms`;

        // Log theo má»©c Ä‘á»™ tÆ°Æ¡ng á»©ng
        switch (logLevel) {
            case 'warn':
                // Chá»‰ warn náº¿u > 1 giÃ¢y
                if (duration > 1000) logger.warn(message);
                break;
            case 'error':
                // Chá»‰ error náº¿u > 3 giÃ¢y
                if (duration > 3000) logger.error(message);
                break;
            default:
                logger.info(message);
        }

        return duration;
    }

    /**
     * Monitor má»™t async function vÃ  tá»± Ä‘á»™ng Ä‘o thá»i gian
     * Wrapper function Ä‘á»ƒ tá»± Ä‘á»™ng start/end timer
     * @param label TÃªn Ä‘á»ƒ identify operation
     * @param fn Async function cáº§n monitor
     * @returns Káº¿t quáº£ cá»§a function gá»‘c
     */
    static async monitor<T>(label: string, fn: () => Promise<T>): Promise<T> {
        this.start(label); // Báº¯t Ä‘áº§u Ä‘o thá»i gian
        try {
            const result = await fn(); // Thá»±c thi function
            this.end(label);           // Káº¿t thÃºc thÃ nh cÃ´ng
            return result;
        } catch (error) {
            this.end(label, 'error');  // Káº¿t thÃºc vá»›i lá»—i
            throw error;               // Re-throw error Ä‘á»ƒ caller xá»­ lÃ½
        }
    }

    /**
     * Táº¡o middleware tracking thá»i gian response
     * Middleware Express Ä‘á»ƒ Ä‘o thá»i gian xá»­ lÃ½ request
     * @param threshold NgÆ°á»¡ng cáº£nh bÃ¡o (ms), máº·c Ä‘á»‹nh 1000ms
     */
    static middleware(threshold: number = 1000) {
        return (req: any, res: any, next: any) => {
            const start = Date.now();
            const label = `${req.method} ${req.path}`;

            // Láº¯ng nghe event 'finish' khi response Ä‘Æ°á»£c gá»­i
            res.on('finish', () => {
                const duration = Date.now() - start;

                // ThÃªm header response time
                res.set('X-Response-Time', `${duration}ms`);

                // Log warning náº¿u vÆ°á»£t ngÆ°á»¡ng
                if (duration > threshold) {
                    logger.warn(`Slow request: ${label} took ${duration}ms`);
                } else {
                    logger.info(`${label} completed in ${duration}ms`);
                }
            });

            next(); // Tiáº¿p tá»¥c vá»›i middleware tiáº¿p theo
        };
    }
}

/**
 * Lá»›p quáº£n lÃ½ memory cho serverless environments
 * GiÃºp monitor vÃ  quáº£n lÃ½ viá»‡c sá»­ dá»¥ng bá»™ nhá»›
 */
export class MemoryManager {
    /**
     * Ã‰p buá»™c garbage collection náº¿u cÃ³ thá»ƒ
     * Chá»‰ hoáº¡t Ä‘á»™ng khi Node.js Ä‘Æ°á»£c start vá»›i flag --expose-gc
     */
    static forceGC(): void {
        if (global.gc) {
            global.gc(); // Gá»i garbage collector
            logger.info('Forced garbage collection');
        }
    }

    /**
     * Láº¥y thÃ´ng tin sá»­ dá»¥ng memory hiá»‡n táº¡i
     * Chuyá»ƒn Ä‘á»•i tá»« bytes sang MB Ä‘á»ƒ dá»… Ä‘á»c
     * @returns Object chá»©a thÃ´ng tin memory usage
     */
    static getMemoryUsage() {
        const usage = process.memoryUsage();
        return {
            // RSS: Resident Set Size - tá»•ng memory Ä‘Æ°á»£c process sá»­ dá»¥ng
            rss: Math.round(usage.rss / 1024 / 1024 * 100) / 100,

            // Heap Total: Tá»•ng heap memory Ä‘Æ°á»£c allocate
            heapTotal: Math.round(usage.heapTotal / 1024 / 1024 * 100) / 100,

            // Heap Used: Heap memory Ä‘ang Ä‘Æ°á»£c sá»­ dá»¥ng
            heapUsed: Math.round(usage.heapUsed / 1024 / 1024 * 100) / 100,

            // External: Memory Ä‘Æ°á»£c sá»­ dá»¥ng bá»Ÿi C++ objects liÃªn káº¿t vá»›i JS objects
            external: Math.round(usage.external / 1024 / 1024 * 100) / 100,
        };
    }

    /**
     * Log thÃ´ng tin memory usage vá»›i context
     * @param context MÃ´ táº£ ngá»¯ cáº£nh Ä‘á»ƒ debug (vd: 'After DB Query')
     */
    static logMemoryUsage(context: string = 'Memory Usage'): void {
        const usage = this.getMemoryUsage();
        logger.info(`${context} - RSS: ${usage.rss}MB, Heap: ${usage.heapUsed}/${usage.heapTotal}MB, External: ${usage.external}MB`);
    }

    /**
     * Kiá»ƒm tra xem memory usage cÃ³ Ä‘ang tiáº¿n gáº§n giá»›i háº¡n khÃ´ng
     * @param maxHeapMB Giá»›i háº¡n heap memory tá»‘i Ä‘a (MB), máº·c Ä‘á»‹nh 500MB
     * @returns true náº¿u vÆ°á»£t ngÆ°á»¡ng, false náº¿u cÃ²n an toÃ n
     */
    static checkMemoryLimits(maxHeapMB: number = 500): boolean {
        const usage = this.getMemoryUsage();
        if (usage.heapUsed > maxHeapMB) {
            logger.warn(`High memory usage detected: ${usage.heapUsed}MB (limit: ${maxHeapMB}MB)`);
            return true; // VÆ°á»£t ngÆ°á»¡ng
        }
        return false; // CÃ²n an toÃ n
    }
}

/**
 * Lá»›p tá»‘i Æ°u Connection Pool cho MongoDB
 * Monitor vÃ  log tráº¡ng thÃ¡i connection pool
 */
export class ConnectionPoolOptimizer {
    /**
     * Láº¥y thÃ´ng tin tráº¡ng thÃ¡i connection pool
     * @returns Object chá»©a thÃ´ng tin connection status
     */
    static getPoolStatus() {
        return {
            // Kiá»ƒm tra connection cÃ³ Ä‘ang hoáº¡t Ä‘á»™ng khÃ´ng (1 = connected)
            isConnected: mongoose.connection.readyState === 1,

            // Tráº¡ng thÃ¡i connection: 0=disconnected, 1=connected, 2=connecting, 3=disconnecting
            readyState: mongoose.connection.readyState,

            // Host Ä‘ang káº¿t ná»‘i
            host: mongoose.connection.host,

            // TÃªn database
            name: mongoose.connection.name
        };
    }

    /**
     * Log thÃ´ng tin pool status Ä‘á»ƒ monitoring
     */
    static logPoolStatus(): void {
        const status = this.getPoolStatus();
        logger.info(`DB Pool Status - Connected: ${status.isConnected}, State: ${status.readyState}, Host: ${status.host}, DB: ${status.name}`);
    }
}

/**
 * Lá»›p tiá»‡n Ã­ch tá»‘i Æ°u cho serverless environments
 * Detect vÃ  handle cÃ¡c Ä‘áº·c thÃ¹ cá»§a serverless platforms
 */
export class ServerlessOptimizer {
    /**
     * Kiá»ƒm tra cÃ³ Ä‘ang cháº¡y trong serverless environment khÃ´ng
     * @returns true náº¿u Ä‘ang cháº¡y trÃªn serverless platform
     */
    static isServerless(): boolean {
        return !!(process.env.VERCEL || process.env.AWS_LAMBDA_FUNCTION_NAME || process.env.NETLIFY);
    }

    /**
     * Láº¥y thÃ´ng tin chi tiáº¿t vá» serverless environment
     * @returns Object chá»©a thÃ´ng tin platform vÃ  region
     */
    static getServerlessInfo() {
        return {
            isServerless: this.isServerless(),

            // Detect platform dá»±a trÃªn environment variables
            platform: process.env.VERCEL ? 'Vercel' :
                process.env.AWS_LAMBDA_FUNCTION_NAME ? 'AWS Lambda' :
                    process.env.NETLIFY ? 'Netlify' : 'Unknown',

            // Region Ä‘ang cháº¡y
            region: process.env.VERCEL_REGION || process.env.AWS_REGION || 'unknown',

            // CÃ³ pháº£i cold start khÃ´ng (function má»›i Ä‘Æ°á»£c khá»Ÿi táº¡o)
            coldStart: !global.__serverless_cache_initialized
        };
    }

    /**
     * ÄÃ¡nh dáº¥u cache Ä‘Ã£ Ä‘Æ°á»£c khá»Ÿi táº¡o (warm start)
     * GiÃºp identify cold starts vs warm starts
     */
    static initializeCache(): void {
        global.__serverless_cache_initialized = true;
    }

    /**
     * Cleanup resources khi serverless function káº¿t thÃºc
     * ÄÃ³ng connections vÃ  giáº£i phÃ³ng memory
     */
    static cleanup(): void {
        // ÄÃ³ng MongoDB connection náº¿u Ä‘ang má»Ÿ
        if (mongoose.connection.readyState === 1) {
            mongoose.connection.close();
        }

        // Ã‰p buá»™c garbage collection Ä‘á»ƒ giáº£i phÃ³ng memory
        MemoryManager.forceGC();
    }
}

// Declare global type cho cache flag
// Biáº¿n global Ä‘á»ƒ track tráº¡ng thÃ¡i cache initialization
declare global {
    var __serverless_cache_initialized: boolean;
} 


================================================
FILE: src/core/utils/query.ts
================================================
export const itemsQuery = (query: Record<string, any>, items: Record<string, any>): Record<string, any> => {
    for (const key in items) {
        if (items[key] || items[key] === false) {
            query = {
                ...query,
                [key]: items[key],
            };
        }
    }
    return query;
};



================================================
FILE: src/core/utils/s3Upload.ts
================================================
import { PutObjectCommand } from '@aws-sdk/client-s3';
import { s3Client, bucketName, s3Folders } from './aws.config';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import fs from 'fs';
import { HttpException } from '../exceptions';
import { HttpStatus } from '../enums';

/**
 * Upload a file to AWS S3
 * @param file The file to upload (from multer)
 * @param sampleId The sample ID to use in the folder path
 * @param folder The base folder to upload to (from s3Folders)
 * @returns The URL of the uploaded file
 */
export const uploadFileToS3 = async (
    file: Express.Multer.File,
    sampleId?: string,
    folder: string = s3Folders.personImages
): Promise<string> => {
    try {
        // If the file already has a location (uploaded directly to S3), return it
        if ((file as any).location) {
            return (file as any).location;
        }

        // Generate a unique file name
        const fileExtension = path.extname(file.originalname);
        const fileName = `${uuidv4()}${fileExtension}`;

        // Create the folder path - if sampleId is provided, include it in the path
        const folderPath = sampleId ? `${folder}/${sampleId}` : folder;
        const key = `${folderPath}/${fileName}`;

        // Check if AWS credentials are configured
        if (!s3Client.config.credentials) {
            console.error('AWS credentials not properly configured');
            throw new HttpException(
                HttpStatus.InternalServerError,
                'AWS credentials not properly configured'
            );
        }

        // Check if bucket name is configured
        if (!bucketName) {
            console.error('AWS S3 bucket name not configured');
            throw new HttpException(
                HttpStatus.InternalServerError,
                'AWS S3 bucket name not configured'
            );
        }

        // Determine if we're using buffer or file path
        let body;
        if (file.buffer) {
            // Using multer memory storage (buffer)
            body = file.buffer;
            console.log('Uploading file from buffer:', file.originalname);
        } else if (file.path) {
            // Using multer disk storage (file path)
            // Check if file exists on disk
            if (!fs.existsSync(file.path)) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `File not found on disk: ${file.path}`
                );
            }
            body = fs.createReadStream(file.path);
            console.log('Uploading file from path:', file.path);
        } else {
            throw new HttpException(
                HttpStatus.BadRequest,
                'Invalid file: neither buffer nor path is available'
            );
        }

        // Upload the file to S3
        const uploadParams = {
            Bucket: bucketName,
            Key: key,
            Body: body,
            ContentType: file.mimetype,
        };

        try {
            await s3Client.send(new PutObjectCommand(uploadParams));
        } catch (awsError) {
            console.error('AWS S3 upload error:', awsError);
            throw new HttpException(
                HttpStatus.InternalServerError,
                `AWS S3 upload error: ${(awsError as Error).message || 'Unknown error'}`
            );
        }

        // Generate the URL for the uploaded file
        const region = typeof s3Client.config.region === 'string'
            ? s3Client.config.region
            : 'ap-southeast-2'; // Default region based on error message

        // Use the correct S3 URL format with dashed region
        const fileUrl = `https://${bucketName}.s3-${region}.amazonaws.com/${key}`;

        // Delete the temporary file if it exists on disk
        if (file.path && fs.existsSync(file.path)) {
            try {
                fs.unlinkSync(file.path);
            } catch (unlinkError) {
                console.warn(`Could not delete temporary file ${file.path}:`, unlinkError);
                // Continue execution even if temp file deletion fails
            }
        }

        return fileUrl;
    } catch (error) {
        console.error('Error uploading file to S3:', error);
        if (error instanceof HttpException) {
            throw error;
        }
        throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload file to S3');
    }
};

/**
 * Upload multiple files to AWS S3
 * @param files Array of files to upload (from multer)
 * @param sampleId The sample ID to use in the folder path
 * @param folder The base folder to upload to (from s3Folders)
 * @returns Array of URLs of the uploaded files
 */
export const uploadMultipleFilesToS3 = async (
    files: Express.Multer.File[],
    sampleId?: string,
    folder: string = s3Folders.personImages
): Promise<string[]> => {
    try {
        // Validate files array
        if (!files || !Array.isArray(files) || files.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'No files provided for upload');
        }

        // Check if each file has the necessary properties
        files.forEach((file, index) => {
            if (!file || (!file.buffer && !file.path)) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Invalid file at index ${index}: missing buffer or path`
                );
            }
        });

        const uploadPromises = files.map(file => uploadFileToS3(file, sampleId, folder));
        return await Promise.all(uploadPromises);
    } catch (error) {
        console.error('Error uploading multiple files to S3:', error);
        if (error instanceof HttpException) {
            throw error;
        }
        throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload files to S3');
    }
};

// // Re-export s3Folders from aws.config.ts
export { s3Folders };

// // Define additional folders
// export const s3Folders = {
//     ...s3Folders,
//     blogImages: 'blog-images'
// }; 


================================================
FILE: src/core/utils/sendMail.ts
================================================
import nodemailer from 'nodemailer';
import { ISendMailDetail } from '../interfaces';

/**
 * Táº¡o HTML template cho email xÃ¡c nháº­n Ä‘Äƒng kÃ½
 * @param userName TÃªn ngÆ°á»i dÃ¹ng
 * @param verificationLink Link xÃ¡c nháº­n
 * @returns HTML string
 */
export const createVerificationEmailTemplate = (userName: string, verificationLink: string): string => {
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Verify Your Email</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
                background-color: #f9f9f9;
            }
            .container {
                max-width: 600px;
                margin: 0 auto;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .header {
                text-align: center;
                padding: 20px 0;
                border-bottom: 1px solid #eee;
            }
            .logo {
                font-size: 24px;
                font-weight: bold;
                color: #2c3e50;
            }
            .content {
                padding: 20px 0;
            }
            .verification-button {
                display: inline-block;
                background-color: #3498db;
                color: white;
                text-decoration: none;
                padding: 12px 24px;
                border-radius: 4px;
                margin: 20px 0;
                font-weight: bold;
            }
            .verification-link {
                margin: 15px 0;
                word-break: break-all;
                color: #3498db;
            }
            .footer {
                text-align: center;
                color: #7f8c8d;
                font-size: 12px;
                margin-top: 30px;
                padding-top: 15px;
                border-top: 1px solid #eee;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <div class="logo">Bloodline DNA Testing Service</div>
            </div>
            <div class="content">
                <h2>Verify Your Email Address</h2>
                <p>Hello, <strong>${userName}</strong>!</p>
                <p>Thank you for registering with Bloodline DNA Testing Service. To complete your registration and access our services, please verify your email address by clicking the button below:</p>
                
                <div style="text-align: center;">
                    <a href="${verificationLink}" class="verification-button">Verify Email</a>
                </div>
                
                <p>If the button above doesn't work, please copy and paste the following link into your browser:</p>
                <div class="verification-link">
                    <a href="${verificationLink}">${verificationLink}</a>
                </div>
                
                <p>This verification link will expire in 24 hours.</p>
                
                <p>If you did not create an account with us, please disregard this email.</p>
            </div>
            <div class="footer">
                <p>&copy; ${new Date().getFullYear()} Bloodline DNA Testing Service. All rights reserved.</p>
                <p>This is an automated email, please do not reply.</p>
            </div>
        </div>
    </body>
    </html>
    `;
};

/**
 * Táº¡o HTML template cho email quÃªn máº­t kháº©u
 * @param userName TÃªn ngÆ°á»i dÃ¹ng
 * @param resetLink Link Ä‘áº·t láº¡i máº­t kháº©u
 * @returns HTML string
 */
export const createPasswordResetEmailTemplate = (userName: string, resetLink: string): string => {
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Reset Your Password</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
                background-color: #f9f9f9;
            }
            .container {
                max-width: 600px;
                margin: 0 auto;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .header {
                text-align: center;
                padding: 20px 0;
                border-bottom: 1px solid #eee;
            }
            .logo {
                font-size: 24px;
                font-weight: bold;
                color: #2c3e50;
            }
            .content {
                padding: 20px 0;
            }
            .reset-button {
                display: inline-block;
                background-color: #e74c3c;
                color: white;
                text-decoration: none;
                padding: 12px 24px;
                border-radius: 4px;
                margin: 20px 0;
                font-weight: bold;
            }
            .reset-link {
                margin: 15px 0;
                word-break: break-all;
                color: #e74c3c;
            }
            .footer {
                text-align: center;
                color: #7f8c8d;
                font-size: 12px;
                margin-top: 30px;
                padding-top: 15px;
                border-top: 1px solid #eee;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <div class="logo">Bloodline DNA Testing Service</div>
            </div>
            <div class="content">
                <h2>Reset Your Password</h2>
                <p>Hello, <strong>${userName}</strong>!</p>
                <p>We received a request to reset your password. If you didn't make this request, you can safely ignore this email.</p>
                
                <div style="text-align: center;">
                    <a href="${resetLink}" class="reset-button">Reset Password</a>
                </div>
                
                <p>If the button above doesn't work, please copy and paste the following link into your browser:</p>
                <div class="reset-link">
                    <a href="${resetLink}">${resetLink}</a>
                </div>
                
                <p>This password reset link will expire in 1 hour.</p>
                
                <p>If you did not request a password reset, please contact our support team immediately.</p>
            </div>
            <div class="footer">
                <p>&copy; ${new Date().getFullYear()} Bloodline DNA Testing Service. All rights reserved.</p>
                <p>This is an automated email, please do not reply.</p>
            </div>
        </div>
    </body>
    </html>
    `;
};

/**
 * Táº¡o HTML template cho email thÃ´ng bÃ¡o
 * @param userName TÃªn ngÆ°á»i dÃ¹ng
 * @param title TiÃªu Ä‘á» thÃ´ng bÃ¡o
 * @param message Ná»™i dung thÃ´ng bÃ¡o
 * @param actionLink Link hÃ nh Ä‘á»™ng (tÃ¹y chá»n)
 * @param actionText Ná»™i dung nÃºt hÃ nh Ä‘á»™ng (tÃ¹y chá»n)
 * @returns HTML string
 */
export const createNotificationEmailTemplate = (
    userName: string,
    title: string,
    message: string,
    actionLink?: string,
    actionText?: string
): string => {
    const actionButton = actionLink && actionText
        ? `<div style="text-align: center;">
            <a href="${actionLink}" style="display: inline-block; background-color: #3498db; color: white; text-decoration: none; padding: 12px 24px; border-radius: 4px; margin: 20px 0; font-weight: bold;">${actionText}</a>
           </div>`
        : '';

    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${title}</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
                background-color: #f9f9f9;
            }
            .container {
                max-width: 600px;
                margin: 0 auto;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .header {
                text-align: center;
                padding: 20px 0;
                border-bottom: 1px solid #eee;
            }
            .logo {
                font-size: 24px;
                font-weight: bold;
                color: #2c3e50;
            }
            .content {
                padding: 20px 0;
            }
            .footer {
                text-align: center;
                color: #7f8c8d;
                font-size: 12px;
                margin-top: 30px;
                padding-top: 15px;
                border-top: 1px solid #eee;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <div class="logo">Bloodline DNA Testing Service</div>
            </div>
            <div class="content">
                <h2>${title}</h2>
                <p>Hello, <strong>${userName}</strong>!</p>
                <p>${message}</p>
                
                ${actionButton}
                
            </div>
            <div class="footer">
                <p>&copy; ${new Date().getFullYear()} Bloodline DNA Testing Service. All rights reserved.</p>
                <p>This is an automated email, please do not reply.</p>
            </div>
        </div>
    </body>
    </html>
    `;
};

/**
 * Gá»­i email vá»›i ná»™i dung Ä‘Ã£ Ä‘Æ°á»£c Ä‘á»‹nh dáº¡ng
 * @param sendMailDetail Chi tiáº¿t email cáº§n gá»­i
 * @returns Promise<any>
 */
export const sendMail = async (sendMailDetail: ISendMailDetail): Promise<any> => {
    const { toMail, subject, content, html } = sendMailDetail;

    const emailAdmin = process.env.EMAIL_USER;

    // Táº¡o transporter cho nodemailer
    const transporter = nodemailer.createTransport({
        service: 'Gmail',
        auth: {
            user: emailAdmin,
            pass: process.env.EMAIL_PASSWORD,
        },
    });

    // Cáº¥u hÃ¬nh email
    const mailOptions = {
        from: `"Bloodline DNA Testing Service" <${emailAdmin}>`,
        to: toMail,
        subject,
        text: content || '',
        html: html || (content ? `<p>${content}</p>` : ''),
    };

    try {
        // Gá»­i email
        const info = await transporter.sendMail(mailOptions);
        return info;
    } catch (error) {
        throw error;
    }
};



================================================
FILE: src/core/utils/service.ts
================================================
import { SearchPaginationResponseModel } from '../models';
import { PaginationResponseModel } from '../models/pagination.model';

export const formatPaginationResult = <T>(
    result: SearchPaginationResponseModel<T>,
    items: any[],
    paginationInfo: PaginationResponseModel,
) => {
    result.pageInfo.pageNum = paginationInfo.pageNum;
    result.pageInfo.pageSize = paginationInfo.pageSize;
    if (paginationInfo.totalItems > 0) {
        result.pageData = items;
        result.pageInfo.totalItems = paginationInfo.totalItems;
        result.pageInfo.totalPages = Math.ceil(paginationInfo.totalItems / paginationInfo.pageSize);
    }

    return result;
};



================================================
FILE: src/core/utils/token.ts
================================================
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import { DataStoredInToken, TokenData } from '../../modules/auth';
import { IUser } from '../../modules/user';

export const createToken = (user: IUser): TokenData => {
    const dataInToken: DataStoredInToken = { id: user.id, role: user.role, version: user.token_version };
    const secret: string = process.env.JWT_TOKEN_SECRET!;
    const expiresIn: number = 28800; // 8 hours
    return {
        token: jwt.sign(dataInToken, secret, { expiresIn }),
    };
};

// create token verification
export const createTokenVerifiedUser = () => {
    return {
        verification_token: crypto.randomBytes(16).toString('hex'), // generate random bytes, convert to hex
        verification_token_expires: new Date(Date.now() + 1000 * 60 * 60 * 24), // 24 hours
    };
};



================================================
FILE: src/core/utils/validateEnv.ts
================================================
import { cleanEnv, str } from 'envalid';

// validate environment variables
const validateEnv = () => {
    cleanEnv(process.env, {
        NODE_ENV: str(),
        MONGODB_URI: str(),
    });
};

export default validateEnv;



================================================
FILE: src/core/utils/validation.ts
================================================
import { HttpStatus } from '../enums';
import { HttpException } from '../exceptions';

export const checkUserMatch = (userId: string, userInItem: string, title: string) => {
    if (userId !== userInItem) {
        throw new HttpException(HttpStatus.BadRequest, `You cannot update or delete another user's ${title}!`);
    }
};

export const checkValidUrl = (url: string) => {
    const urlPattern = /^(http:\/\/|https:\/\/)/i;
    return urlPattern.test(url);
};



================================================
FILE: src/modules/administrative_cases/administrative_cases.controller.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import AdministrativeCasesService from './administrative_cases.service';
import { UserRoleEnum } from '../user/user.enum';

export default class AdministrativeCasesController {
    private administrativeCasesService = new AdministrativeCasesService();

    public createCase = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const data = req.body;
            const applicantId = req.user.id;
            const result = await this.administrativeCasesService.createCase(data, applicantId);
            res.status(HttpStatus.Created).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    public getCaseById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const id = req.params.id;
            const result = await this.administrativeCasesService.getCaseById(id);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    public updateCase = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const id = req.params.id;
            const data = req.body;
            const result = await this.administrativeCasesService.updateCase(id, data);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    public deleteCase = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const id = req.params.id;
            const isDeleted = await this.administrativeCasesService.deleteCase(id);
            if (!isDeleted) {
                throw new HttpException(HttpStatus.NotFound, 'Administrative case not found');
            }
            res.status(HttpStatus.Success).json(formatResponse<string>('Deleted administrative case successfully!'));
        } catch (error) {
            next(error);
        }
    };

    public listCases = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (![UserRoleEnum.ADMIN, UserRoleEnum.MANAGER].includes(req.user.role)) {
                throw new HttpException(HttpStatus.Forbidden, 'Permission denied');
            }
            const result = await this.administrativeCasesService.listCases(req.query);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };
}



================================================
FILE: src/modules/administrative_cases/administrative_cases.enum.ts
================================================
export enum AdministrativeCaseStatus {
    PENDING = 'pending',
    APPROVED = 'approved',
    DENIED = 'denied'
}


================================================
FILE: src/modules/administrative_cases/administrative_cases.interface.ts
================================================
import { Document } from 'mongoose';
import { AdministrativeCaseStatus } from './administrative_cases.enum';

export type AdministrativeCaseStatusType =
    AdministrativeCaseStatus.PENDING |
    AdministrativeCaseStatus.APPROVED |
    AdministrativeCaseStatus.DENIED;

export interface IAdministrativeCase extends Document {
    id: string;

    // ÄÃ¢y lÃ  má»™t Ä‘á»‹nh danh duy nháº¥t cho cÃ¡c trÆ°á»ng há»£p xÃ©t nghiá»‡m DNA hÃ nh chÃ­nh, 
    // thÆ°á»ng Ä‘Æ°á»£c cÆ¡ quan chÃ­nh phá»§ cáº¥p Ä‘á»ƒ theo dÃµi, 
    // cháº³ng háº¡n nhÆ° trong cÃ¡c trÆ°á»ng há»£p nháº­p cÆ° . 
    // NÃ³ giÃºp liÃªn káº¿t cuá»™c háº¹n vá»›i má»™t vá»¥ viá»‡c cá»¥ thá»ƒ.
    case_number: string;

    // ÄÃ¢y lÃ  mÃ£ do cÆ¡ quan cÃ³ tháº©m quyá»n cung cáº¥p Ä‘á»ƒ phÃª duyá»‡t xÃ©t nghiá»‡m DNA, 
    // Ä‘áº£m báº£o ráº±ng xÃ©t nghiá»‡m Ä‘Æ°á»£c thá»±c hiá»‡n há»£p phÃ¡p . 
    // NÃ³ Ä‘Ã³ng vai trÃ² nhÆ° má»™t cÆ¡ cháº¿ xÃ¡c minh.
    authorization_code: string; // sá»‘ phÃ©p

    status: AdministrativeCaseStatusType;
    // cÆ¡ quan tháº©m quyá»n
    agency_contact_email: string;
    agency_contact_name: string;
    agency_contact_phone: string;

    // ngÆ°á»i gá»­i - admin, manager
    applicant_name: string;
    applicant_email: string;
    applicant_id: string | undefined;

    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;

}


================================================
FILE: src/modules/administrative_cases/administrative_cases.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IAdministrativeCase } from './administrative_cases.interface';
import { AdministrativeCaseStatus } from './administrative_cases.enum';

const AdministrativeCaseSchemaEntity: Schema<IAdministrativeCase> = new Schema({
    case_number: { type: String, required: true, unique: true },
    authorization_code: { type: String, required: true, unique: true },
    status: {
        type: String,
        enum: Object.values(AdministrativeCaseStatus),
        required: true,
        default: AdministrativeCaseStatus.PENDING
    },
    agency_contact_email: { type: String, required: true },
    agency_contact_name: { type: String, required: true },
    agency_contact_phone: { type: String, required: true },
    applicant_name: { type: String, required: true },
    applicant_email: { type: String, required: true },
    applicant_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false }
});

export const AdministrativeCaseSchema = mongoose.model<IAdministrativeCase>(COLLECTION_NAME.ADMINISTRATIVE_CASE, AdministrativeCaseSchemaEntity);




================================================
FILE: src/modules/administrative_cases/administrative_cases.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import AdministrativeCasesController from './administrative_cases.controller';
import { CreateAdministrativeCaseDto } from './dtos/commonAdminCases.dto';

export default class AdministrativeCasesRouter implements IRoute {
    public path = API_PATH.ADMINISTRATIVE_CASES;
    public router = Router();
    private administrativeCasesController = new AdministrativeCasesController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/administrative-cases -> Create administrative case
        this.router.post(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            // validationMiddleware(CreateAdministrativeCaseDto),
            this.administrativeCasesController.createCase
        );

        // GET: domain:/api/administrative-cases/:id -> Get administrative case by id
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.administrativeCasesController.getCaseById
        );

        // PUT: domain:/api/administrative-cases/:id -> Update administrative case
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            // validationMiddleware(CreateAdministrativeCaseDto),
            this.administrativeCasesController.updateCase
        );

        // DELETE: domain:/api/administrative-cases/:id -> Delete administrative case
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.administrativeCasesController.deleteCase
        );

        // GET: domain:/api/administrative-cases -> Get all administrative cases
        this.router.get(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.administrativeCasesController.listCases
        );
    }
}





================================================
FILE: src/modules/administrative_cases/administrative_cases.service.ts
================================================
import { AdministrativeCaseSchema } from './administrative_cases.model';
import { IAdministrativeCase } from './administrative_cases.interface';
import { AdministrativeCaseStatus } from './administrative_cases.enum';
import UserSchema from '../user/user.model';
import { UserRoleEnum } from '../user';
import { CreateAdministrativeCaseDto } from './dtos/commonAdminCases.dto';
import { validateOrReject } from 'class-validator';

export default class AdministrativeCasesService {
    public async createCase(data: Partial<IAdministrativeCase>, userId: string): Promise<IAdministrativeCase> {
        const user = await UserSchema.findById(userId).lean();
        if (!user) {
            throw new Error('User not found');
        }
        if (user.role !== UserRoleEnum.ADMIN && user.role !== UserRoleEnum.MANAGER) {
            throw new Error('Only ADMIN or MANAGER can create administrative case');
        }

        // Always override applicant fields from user
        const caseData: any = { ...data };
        caseData.applicant_name = `${user.first_name ?? ''} ${user.last_name ?? ''}`.trim();
        caseData.applicant_email = user.email;
        caseData.applicant_id = user._id?.toString?.() ?? userId;
        caseData.status = AdministrativeCaseStatus.PENDING;

        // Validate using DTO
        const dto = Object.assign(new CreateAdministrativeCaseDto(), caseData);
        await validateOrReject(dto);

        return AdministrativeCaseSchema.create({ ...caseData });
    }

    public async getCaseById(id: string): Promise<IAdministrativeCase | null> {
        return AdministrativeCaseSchema.findById(id).populate('applicant_id', 'email first_name last_name role');
    }

    public async updateCase(id: string, data: Partial<IAdministrativeCase>): Promise<IAdministrativeCase | null> {
        if (data.is_deleted) {
            throw new Error('Cannot update deleted case');
        }
        const existingCase = await AdministrativeCaseSchema.findById(id);
        if (!existingCase) {
            throw new Error('Case not found');
        }
        if (existingCase.is_deleted) {
            throw new Error('Cannot update deleted case');
        }
        if (data.applicant_id) {
            const user = await UserSchema.findById(data.applicant_id);
            if (!user) {
                throw new Error('User not found');
            }
            if (user.role !== UserRoleEnum.ADMIN && user.role !== UserRoleEnum.MANAGER) {
                throw new Error('Only ADMIN or MANAGER can be applicant');
            }
            data.applicant_name = user.first_name + ' ' + user.last_name;
            data.applicant_email = user.email;
        }
        if (data.agency_contact_email) {
            data.agency_contact_email = data.agency_contact_email.toLowerCase();
        }
        if (data.applicant_email) {
            data.applicant_email = data.applicant_email.toLowerCase();
        }
        data.updated_at = new Date();

        // Validate using DTO (merge with existing for full object)
        const merged = { ...existingCase.toObject(), ...data };
        const dto = Object.assign(new CreateAdministrativeCaseDto(), merged);
        await validateOrReject(dto);
        return AdministrativeCaseSchema.findByIdAndUpdate(id, data, { new: true }).populate('applicant_id', 'email first_name last_name role');
    }

    public async deleteCase(id: string): Promise<IAdministrativeCase | null> {
        return AdministrativeCaseSchema.findByIdAndUpdate(
            id,
            { is_deleted: true },
            { new: true }
        );
    }

    public async listCases(query: any): Promise<IAdministrativeCase[]> {
        return AdministrativeCaseSchema.find(query).populate('applicant_id', 'email first_name last_name role');
    }
}



================================================
FILE: src/modules/administrative_cases/index.ts
================================================
import { AdministrativeCaseSchema } from './administrative_cases.model';
import { IAdministrativeCase } from './administrative_cases.interface';
import AdministrativeCasesController from './administrative_cases.controller';
import AdministrativeCasesService from './administrative_cases.service';
import AdministrativeCasesRoute from './administrative_cases.route';

export {
    AdministrativeCaseSchema,
    IAdministrativeCase,
    AdministrativeCasesController,
    AdministrativeCasesService,
    AdministrativeCasesRoute
};


================================================
FILE: src/modules/administrative_cases/dtos/commonAdminCases.dto.ts
================================================
import { IsString, IsEmail, IsOptional, Matches, IsEnum } from 'class-validator';
import { AdministrativeCaseStatus } from '../administrative_cases.enum';

export class CreateAdministrativeCaseDto {
    @IsString()
    // Format: AC-YYYYMMDD-XXXX (AC = Administrative Case, date, 4 sá»‘)
    @Matches(/^AC-\d{8}-\d{4}$/, {
        message: 'case_number must be in format AC-YYYYMMDD-XXXX (e.g., AC-20240601-0001)'
    })
    case_number!: string;

    @IsString()
    // Format: AUTH-XXXXXX (AUTH = Authorization, 6 kÃ½ tá»± chá»¯/sá»‘)
    @Matches(/^AUTH-[A-Z0-9]{6}$/, {
        message: 'authorization_code must be in format AUTH-XXXXXX (e.g., AUTH-1A2B3C)'
    })
    authorization_code!: string;

    @IsEmail()
    agency_contact_email!: string;

    @IsString()
    agency_contact_name!: string;

    @IsString()
    agency_contact_phone!: string;

    @IsString()
    applicant_name!: string;

    @IsEmail()
    applicant_email!: string;

    @IsString()
    applicant_id!: string;

    @IsOptional()
    created_at?: Date;

    @IsOptional()
    updated_at?: Date;

    @IsOptional()
    @IsEnum(AdministrativeCaseStatus)
    status?: AdministrativeCaseStatus;

    @IsOptional()
    is_deleted?: boolean;
}



================================================
FILE: src/modules/administrative_cases/swagger/swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: administrative_cases
 *   description: Quáº£n lÃ½ cÃ¡c vá»¥ viá»‡c xÃ©t nghiá»‡m DNA hÃ nh chÃ­nh
 */

/**
 * @swagger
 * /api/administrative-cases:
 *   post:
 *     tags: [administrative_cases]
 *     summary: Táº¡o má»›i vá»¥ viá»‡c hÃ nh chÃ­nh
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/AdministrativeCase'
 *     responses:
 *       201:
 *         description: Táº¡o thÃ nh cÃ´ng
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AdministrativeCase'
 *   get:
 *     tags: [administrative_cases]
 *     summary: Láº¥y danh sÃ¡ch vá»¥ viá»‡c hÃ nh chÃ­nh
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Danh sÃ¡ch vá»¥ viá»‡c
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/AdministrativeCase'
 * /api/administrative-cases/{id}:
 *   get:
 *     tags: [administrative_cases]
 *     summary: Láº¥y chi tiáº¿t vá»¥ viá»‡c hÃ nh chÃ­nh
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Chi tiáº¿t vá»¥ viá»‡c
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AdministrativeCase'
 *   put:
 *     tags: [administrative_cases]
 *     summary: Cáº­p nháº­t vá»¥ viá»‡c hÃ nh chÃ­nh
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/AdministrativeCase'
 *     responses:
 *       200:
 *         description: Cáº­p nháº­t thÃ nh cÃ´ng
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AdministrativeCase'
 *   delete:
 *     tags: [administrative_cases]
 *     summary: XoÃ¡ vá»¥ viá»‡c hÃ nh chÃ­nh
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: XoÃ¡ thÃ nh cÃ´ng
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     AdministrativeCase:
 *       type: object
 *       properties:
 *         case_number:
 *           type: string
 *         authorization_code:
 *           type: string
 *         agency_contact_email:
 *           type: string
 *         agency_contact_name:
 *           type: string
 *         agency_contact_phone:
 *           type: string
 */


================================================
FILE: src/modules/appointment/appointment.constant.ts
================================================
import { AppointmentStatusEnum, TypeEnum } from './appointment.enum';

export const AppointmentStatuses = [
    '',
    AppointmentStatusEnum.PENDING,
    AppointmentStatusEnum.CONFIRMED,
    AppointmentStatusEnum.SAMPLE_COLLECTED,
    AppointmentStatusEnum.SAMPLE_RECEIVED,
    AppointmentStatusEnum.TESTING,
    AppointmentStatusEnum.COMPLETED,
    AppointmentStatusEnum.CANCELLED
];

export const CollectionTypes = [
    '',
    TypeEnum.SELF,
    TypeEnum.FACILITY,
    TypeEnum.HOME
]; 


================================================
FILE: src/modules/appointment/appointment.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IAppointment } from './appointment.interface';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';
import { AssignStaffDto } from './dtos/assign-staff.dto';
import { ConfirmAppointmentDto } from './dtos/confirm-appointment.dto';
import { SearchAppointmentDto } from './dtos/search-appointment.dto';
import AppointmentService from './appointment.service';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { UserRoleEnum } from '../user/user.enum';
import { ISample } from '../sample/sample.interface';

export default class AppointmentController {
    private appointmentService = new AppointmentService();

    /**
     * Create a new appointment
     */
    public createAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const appointmentData: CreateAppointmentDto = req.body;
            const appointment = await this.appointmentService.createAppointment(userId, appointmentData);

            // Return a success response with the created appointment
            res.status(HttpStatus.Created).json(formatResponse<IAppointment>(appointment));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get appointment by ID
     */
    public getAppointmentById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.id;
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Search appointments with filters
     */
    public searchAppointments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            const userRole = req.user.role;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Convert query parameters to SearchAppointmentDto
            const searchParams: SearchAppointmentDto = {
                pageNum: req.query.pageNum ? parseInt(req.query.pageNum as string) : 1,
                pageSize: req.query.pageSize ? parseInt(req.query.pageSize as string) : 10,
                user_id: req.query.user_id as string,
                service_id: req.query.service_id as string,
                status: req.query.status as any,
                type: req.query.type as any,
                staff_id: req.query.staff_id as string,
                start_date: req.query.start_date as string,
                end_date: req.query.end_date as string,
                search_term: req.query.search_term as string
            };

            const result = await this.appointmentService.searchAppointments(
                searchParams,
                userRole,
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointment>>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Assign staff to appointment
     * @route PUT /api/appointment/:id/assign-staff
     */
    public assignStaff = async (req: Request, res: Response, next: NextFunction) => {
        try {
            // Kiá»ƒm tra quyá»n truy cáº­p
            if (req.user.role !== UserRoleEnum.MANAGER && req.user.role !== UserRoleEnum.ADMIN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only managers and admins can assign staff to appointments');
            }

            const appointmentId = req.params.id;
            const assignStaffData: AssignStaffDto = req.body;

            try {
                const appointment = await this.appointmentService.assignStaff(appointmentId, assignStaffData);
                res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment));
            } catch (error) {
                // Kiá»ƒm tra náº¿u lá»—i liÃªn quan Ä‘áº¿n giá»›i háº¡n sá»‘ lÆ°á»£ng cuá»™c háº¹n
                if (error instanceof HttpException &&
                    error.status === HttpStatus.BadRequest &&
                    error.message.includes('appointment limit')) {

                    // Tráº£ vá» lá»—i vá»›i gá»£i Ã½ vá» nhÃ¢n viÃªn thay tháº¿
                    res.status(error.status).json({
                        success: false,
                        message: error.message,
                        suggestion: 'Consider using another staff member who has not reached their appointment limit'
                    });
                } else {
                    // Tráº£ vá» lá»—i thÃ´ng thÆ°á»ng
                    next(error);
                }
            }
        } catch (error) {
            next(error);
        }
    };

    /**
     * Confirm appointment and assign kit to laboratory technician (by staff)
     */
    public confirmAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const appointmentId = req.params.id;
            const confirmData: ConfirmAppointmentDto = req.body;
            const userRole = req.user.role;

            const updatedAppointment = await this.appointmentService.confirmAppointment(
                appointmentId,
                confirmData,
                staffId,
                userRole
            );

            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(updatedAppointment as IAppointment));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get samples for an appointment
     */
    public getAppointmentSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.id;
            const samples = await this.appointmentService.getAppointmentSamples(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    };

    public getAppointmentPrice = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { appointmentId } = req.params;
            const price = await this.appointmentService.getAppointmentPrice(appointmentId);

            res.status(HttpStatus.Success).json(
                formatResponse({ price }, true, 'Appointment price retrieved successfully')
            );
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get staff roles (Department Manager only)
     */
    public getStaffRoles = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            const userRole = req.user.role;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const staffRoles = await this.appointmentService.getUserRoleStaff();

            res.status(HttpStatus.Success).json(formatResponse<string[]>(staffRoles));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get available slots for logged-in staff
     */

    public getStaffAvailableSlots = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const slots = await this.appointmentService.getStaffAvailableSlots(staffId);

            res.status(HttpStatus.Success).json(formatResponse<any[]>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get appointments assigned to staff
     */
    public getStaffAssignedAppointments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Convert query parameters to SearchAppointmentDto format
            const searchParams: SearchAppointmentDto = {
                pageNum: req.query.pageNum ? parseInt(req.query.pageNum as string) : 1,
                pageSize: req.query.pageSize ? parseInt(req.query.pageSize as string) : 10,
                user_id: req.query.user_id as string,
                service_id: req.query.service_id as string,
                status: req.query.status as any,
                type: req.query.type as any,
                staff_id: req.query.staff_id as string,
                start_date: req.query.start_date as string,
                end_date: req.query.end_date as string,
                search_term: req.query.search_term as string
            };

            const appointments = await this.appointmentService.getStaffAssignedAppointments(staffId, searchParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointment>>(appointments));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get appointments assigned to laboratory technician
     */
    public getLabTechAssignedAppointments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const labTechId = req.user.id;
            if (!labTechId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Convert query parameters to SearchAppointmentDto format
            const searchParams: SearchAppointmentDto = {
                pageNum: req.query.pageNum ? parseInt(req.query.pageNum as string) : 1,
                pageSize: req.query.pageSize ? parseInt(req.query.pageSize as string) : 10,
                user_id: req.query.user_id as string,
                service_id: req.query.service_id as string,
                status: req.query.status as any,
                type: req.query.type as any,
                staff_id: req.query.staff_id as string,
                start_date: req.query.start_date as string,
                end_date: req.query.end_date as string,
                search_term: req.query.search_term as string
            };

            const appointments = await this.appointmentService.getLabTechAssignedAppointments(labTechId, searchParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointment>>(appointments));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Assign laboratory technician to appointment
     */
    public assignLabTechnician = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const { lab_tech_id } = req.body;
            const appointment = await this.appointmentService.assignLabTechnician(id, lab_tech_id);
            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get available laboratory technicians
     */
    public getAvailableLabTechnicians = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;
            if (userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(HttpStatus.Forbidden, 'Only staff can view laboratory technicians');
            }

            const labTechs = await this.appointmentService.getAvailableLabTechnicians();
            res.status(HttpStatus.Success).json(formatResponse<any[]>(labTechs));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Unassign staff from appointment
     * @route PUT /api/appointment/:id/unassign-staff
     */
    public unassignStaff = async (req: Request, res: Response, next: NextFunction) => {
        try {
            // Kiá»ƒm tra quyá»n truy cáº­p
            if (req.user.role !== UserRoleEnum.MANAGER && req.user.role !== UserRoleEnum.ADMIN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only managers and admins can unassign staff from appointments');
            }

            const appointmentId = req.params.id;
            const appointment = await this.appointmentService.unassignStaff(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<IAppointment>(appointment, true, 'Staff unassigned successfully'));
        } catch (error) {
            next(error);
        }
    };

}



================================================
FILE: src/modules/appointment/appointment.enum.ts
================================================
export enum AppointmentStatusEnum {
    PENDING = 'pending',
    CONFIRMED = 'confirmed',
    SAMPLE_ASSIGNED = 'sample_assigned',
    SAMPLE_COLLECTED = 'sample_collected',
    SAMPLE_RECEIVED = 'sample_received',
    TESTING = 'testing',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled'
}

export enum TypeEnum {
    SELF = 'self',
    FACILITY = 'facility',
    HOME = 'home'
}

export enum PaymentStatusEnum {
    UNPAID = 'unpaid',
    PAID = 'paid',
    REFUNDED = 'refunded',
    FAILED = 'failed'
} 


================================================
FILE: src/modules/appointment/appointment.interface.ts
================================================
import { Document } from 'mongoose';
import { AppointmentStatusEnum, TypeEnum, PaymentStatusEnum } from './appointment.enum';
import { ISample } from '../sample/sample.interface';

export type AppointmentStatus =
    AppointmentStatusEnum.PENDING |
    AppointmentStatusEnum.CONFIRMED |
    AppointmentStatusEnum.SAMPLE_COLLECTED |
    AppointmentStatusEnum.SAMPLE_RECEIVED |
    AppointmentStatusEnum.TESTING |
    AppointmentStatusEnum.COMPLETED |
    AppointmentStatusEnum.CANCELLED;

export type CollectionType =
    TypeEnum.SELF |
    TypeEnum.FACILITY |
    TypeEnum.HOME;

// Interface for sample information in appointment response
export interface ISampleInfo {
    _id: string;
    type: string;
    status: string;
    kit_id: string;
}

export interface IAppointment extends Document {
    _id: string;
    user_id: string | undefined;
    service_id: string | undefined;
    slot_id?: string | undefined;
    staff_id?: string | undefined;
    laboratory_technician_id?: string | undefined;
    agency_contact_email?: string;
    email?: string;
    appointment_date: Date;
    type: TypeEnum;
    collection_address?: string;
    status: AppointmentStatusEnum;
    payment_status: PaymentStatusEnum;
    administrative_case_id?: string | any;
    created_at: Date;
    updated_at: Date;
}


================================================
FILE: src/modules/appointment/appointment.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { AppointmentStatuses, CollectionTypes } from './appointment.constant';
import { IAppointment } from './appointment.interface';
import { AppointmentStatusEnum, TypeEnum, PaymentStatusEnum } from './appointment.enum';

const AppointmentSchemaEntity: Schema<IAppointment> = new Schema({
    user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE, required: true },
    slot_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SLOT },
    staff_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    laboratory_technician_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    agency_contact_email: { type: String }, // ThÃªm trÆ°á»ng nÃ y Ä‘á»ƒ lÆ°u email cá»§a agency táº¡i thá»i Ä‘iá»ƒm táº¡o appointment
    appointment_date: { type: Date, required: true }, // ThÃªm trÆ°á»ng nÃ y Ä‘á»ƒ lÆ°u ngÃ y táº¡o appointment
    type: {
        type: String,
        enum: Object.values(TypeEnum),
        required: true
    },
    collection_address: { type: String },
    status: {
        type: String,
        enum: Object.values(AppointmentStatusEnum),
        required: true,
        default: AppointmentStatusEnum.PENDING
    },
    payment_status: {
        type: String,
        enum: Object.values(PaymentStatusEnum),
        required: true,
        default: PaymentStatusEnum.UNPAID
    },
    administrative_case_id: { type: Schema.Types.ObjectId, ref: 'administrative_cases', required: false },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const AppointmentSchema = mongoose.model<IAppointment & mongoose.Document>(
    COLLECTION_NAME.APPOINTMENT,
    AppointmentSchemaEntity
);

export default AppointmentSchema;



================================================
FILE: src/modules/appointment/appointment.repository.ts
================================================
import AppointmentSchema from './appointment.model';
import { IAppointment } from './appointment.interface';
import SampleSchema from '../sample/sample.model';
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';

export default class AppointmentRepository {
    private appointmentSchema = AppointmentSchema;

    public async create(data: Partial<IAppointment>): Promise<IAppointment> {
        return AppointmentSchema.create(data);
    }

    public async findOne(query: any): Promise<IAppointment | null> {
        return AppointmentSchema.findOne(query);
    }

    public async findById(id: string): Promise<IAppointment | null> {
        return AppointmentSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, updateData: Partial<IAppointment>, options?: any): Promise<IAppointment | null> {
        return AppointmentSchema.findByIdAndUpdate(id, updateData, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return AppointmentSchema.countDocuments(query);
    }

    public async find(query: any): Promise<IAppointment[]> {
        return AppointmentSchema.find(query);
    }

    public async findAll(query: any): Promise<IAppointment[]> {
        return AppointmentSchema.find(query);
    }

    public async findWithPopulate(query: any): Promise<IAppointment[]> {
        return AppointmentSchema.find(query)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('staff_id', 'first_name last_name email phone_number')
            .populate('slot_id')
            .populate('laboratory_technician_id', 'first_name last_name email phone_number');
    }

    public async findByIdWithPopulate(id: string): Promise<IAppointment | null> {
        return AppointmentSchema.findById(id)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('staff_id', 'first_name last_name email phone_number')
            .populate('slot_id')
            .populate('administrative_case_id', 'case_number authorization_code agency_contact_email agency_contact_name agency_contact_phone')
            .populate('payment_status')
            .populate('laboratory_technician_id', 'first_name last_name email phone_number');
    }

    public async findWithPaginationAndPopulate(
        query: any,
        sort: any,
        skip: number,
        limit: number
    ): Promise<IAppointment[]> {
        return AppointmentSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price type is_active estimated_time')
            .populate('staff_id', 'first_name last_name email phone_number')
            .populate('slot_id')
            .populate('laboratory_technician_id', 'first_name last_name email phone_number');
    }

    public async findByUserIdWithPagination(
        userId: string,
        skip: number,
        limit: number,
        sort: any = { created_at: -1 }
    ): Promise<IAppointment[]> {
        const appointments = await this.appointmentSchema.find({ user_id: userId })
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('service_id', 'name price')
            .populate('staff_id', 'first_name last_name')
            .populate('slot_id')
            .populate('laboratory_technician_id', 'first_name last_name');
        return appointments;
    }

    public async findByStaffIdWithPagination(
        staffId: string,
        skip: number,
        limit: number,
        query: any = {},
        sort: any = { created_at: -1 }
    ): Promise<IAppointment[]> {
        const appointments = await this.appointmentSchema.find({
            staff_id: staffId,
            ...query
        })
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('slot_id');
        return appointments;
    }

    public async findByLabTechIdWithPagination(
        labTechId: string,
        skip: number,
        limit: number,
        query: any = {},
        sort: any = { created_at: -1 }
    ): Promise<IAppointment[]> {
        const appointments = await this.appointmentSchema.find({
            laboratory_technician_id: labTechId,
            ...query
        })
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email phone_number')
            .populate('service_id', 'name price')
            .populate('slot_id')
            .populate('staff_id', 'first_name last_name');
        return appointments;
    }

    public async countAppointmentsByStaffAndSlot(staffId: string, slotId: string): Promise<number> {
        return AppointmentSchema.countDocuments({
            staff_id: staffId,
            slot_id: slotId
        });
    }
}



================================================
FILE: src/modules/appointment/appointment.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import AppointmentController from './appointment.controller';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';
import { AssignStaffDto } from './dtos/assign-staff.dto';
import { ConfirmAppointmentDto } from './dtos/confirm-appointment.dto';

export default class AppointmentRoute implements IRoute {
    public path = API_PATH.APPOINTMENT;
    public router = Router();
    private appointmentController = new AppointmentController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/appointment/search -> Search appointments with filters
        this.router.get(
            `${this.path}/search`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.searchAppointments
        );

        // POST: domain:/api/appointment/create -> Create a new appointment
        this.router.post(
            `${API_PATH.CREATE_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.CUSTOMER]), // Only customers can create appointments
            validationMiddleware(CreateAppointmentDto),
            this.appointmentController.createAppointment
        );

        // GET: domain:/api/appointment/:id -> Get appointment by ID
        this.router.get(
            `${API_PATH.GET_APPOINTMENT_BY_ID}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.getAppointmentById
        );

        // GET: domain:/api/appointment/:id/samples -> Get samples for an appointment
        this.router.get(
            `${this.path}/:id/samples`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.getAppointmentSamples
        );

        // PUT: domain:/api/appointment/:id/assign-staff -> Assign staff to appointment
        this.router.put(
            `${API_PATH.ASSIGN_STAFF_TO_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.MANAGER]), // Only managers can assign staff
            validationMiddleware(AssignStaffDto),
            this.appointmentController.assignStaff
        );

        // PUT: domain:/api/appointment/:id/confirm -> Confirm appointment and assign kit
        this.router.put(
            `${API_PATH.CONFIRM_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.STAFF]), // Only staff can confirm appointments
            validationMiddleware(ConfirmAppointmentDto),
            this.appointmentController.confirmAppointment
        );

        // GET: domain:/api/appointment/:appointmentId/price -> Get price for an appointment
        this.router.get(
            `${this.path}/:appointmentId/price`,
            authMiddleWare(),
            this.appointmentController.getAppointmentPrice
        );

        // GET: domain:/api/appointment/staff/available -> Get available staff
        this.router.get(
            `${this.path}/staff/available`,
            authMiddleWare([UserRoleEnum.MANAGER]),
            this.appointmentController.getStaffRoles
        );

        // GET: domain:/api/appointment/staff/slots -> Get available slots for logged-in staff
        this.router.get(
            `${this.path}/staff/slots`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.getStaffAvailableSlots
        );

        // GET: domain: /api/appointments/staff/assigned -> Get appointments assigned to staff
        this.router.get(
            `${this.path}/staff/assigned`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.getStaffAssignedAppointments
        );

        // GET: domain: /api/appointments/lab-tech/assigned -> Get appointments assigned to laboratory technician
        this.router.get(
            `${this.path}/lab-tech/assigned`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.appointmentController.getLabTechAssignedAppointments
        );

        // POST: domain: /api/appointments/:id/assign-lab-tech -> Assign laboratory technician to appointment
        this.router.post(
            `${this.path}/:id/assign-lab-tech`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.assignLabTechnician
        );

        // GET: domain: /api/appointment/lab-tech/available -> Get available laboratory technicians
        this.router.get(
            `${this.path}/lab-tech/available`,
            authMiddleWare([UserRoleEnum.STAFF]),
            this.appointmentController.getAvailableLabTechnicians
        );

        // PUT domain:/api/appointment/:id/assign-staff -> Assign staff to an appointment
        this.router.put(
            `${this.path}/:id/assign-staff`,
            authMiddleWare([UserRoleEnum.MANAGER, UserRoleEnum.ADMIN]),
            validationMiddleware(AssignStaffDto),
            this.appointmentController.assignStaff
        );

        // PUT domain:/api/appointment/:id/unassign-staff -> Unassign staff from an appointment
        this.router.put(
            `${this.path}/:id/unassign-staff`,
            authMiddleWare([UserRoleEnum.MANAGER, UserRoleEnum.ADMIN]),
            this.appointmentController.unassignStaff
        );
    }
} 


================================================
FILE: src/modules/appointment/appointment.service.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { SearchPaginationResponseModel } from '../../core/models';
import { IAppointment } from './appointment.interface';
import { AppointmentStatusEnum, TypeEnum, PaymentStatusEnum } from './appointment.enum';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';
import { AssignStaffDto } from './dtos/assign-staff.dto';
import { ConfirmAppointmentDto } from './dtos/confirm-appointment.dto';
import { SearchAppointmentDto } from './dtos/search-appointment.dto';
import AppointmentRepository from './appointment.repository';
import SlotSchema from '../slot/slot.model';
import { SlotStatusEnum } from '../slot/slot.enum';
import ServiceSchema from '../service/service.model';
import { SampleMethodEnum } from '../service/service.enum';
import { AppointmentLogService } from '../appointment_log';
import { AppointmentLogTypeEnum } from '../appointment_log/appointment_log.enum';
import KitService from '../kit/kit.service';
import StaffProfileSchema from '../staff_profile/staff_profile.model';
import { StaffStatusEnum } from '../staff_profile/staff_profile.enum';
import UserSchema from '../user/user.model';
import { UserRoleEnum } from '../user/user.enum';
import SampleService from '../sample/sample.service';
import { ISample } from '../sample/sample.interface';
import { sendMail, createNotificationEmailTemplate } from '../../core/utils';
import { ISendMailDetail } from '../../core/interfaces';
import { AdministrativeCaseSchema } from '../administrative_cases/administrative_cases.model';
import { AdministrativeCaseStatus } from '../administrative_cases/administrative_cases.enum';
import { ServiceTypeEnum } from '../service/service.enum';
import PaymentService from '../payment/payment.service';

export default class AppointmentService {
    private readonly appointmentRepository: AppointmentRepository;
    private readonly appointmentLogService: AppointmentLogService;
    private readonly kitService: KitService;
    private readonly staffProfileSchema: typeof StaffProfileSchema;
    private sampleService?: SampleService;

    constructor() {
        this.appointmentRepository = new AppointmentRepository();
        this.appointmentLogService = new AppointmentLogService();
        this.kitService = new KitService();
        this.staffProfileSchema = StaffProfileSchema;
    }

    private getSampleService(): SampleService {
        if (!this.sampleService) {
            this.sampleService = new SampleService();
        }
        return this.sampleService;
    }

    /**
     * Create a new appointment
     */
    public async createAppointment(userId: string, appointmentData: CreateAppointmentDto): Promise<IAppointment> {
        let appointment: IAppointment | null = null;
        let service: any = null;
        let slot: any = null;
        let staffId: any = null;
        let administrative_case_id: string | undefined;

        try {
            service = await ServiceSchema.findById(appointmentData.service_id);
            if (!service) {
                throw new HttpException(HttpStatus.NotFound, 'Service not found');
            }

            // ADMINISTRATIVE logic
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                // Validate
                if (!appointmentData.case_number || !appointmentData.authorization_code) {
                    throw new HttpException(HttpStatus.BadRequest, 'case_number and authorization_code are required for ADMINISTRATIVE service');
                }
                // Chá»‰ tÃ¬m administrative_case, khÃ´ng Ä‘Æ°á»£c táº¡o má»›i
                const adminCase = await AdministrativeCaseSchema.findOne({
                    case_number: appointmentData.case_number,
                    authorization_code: appointmentData.authorization_code
                });
                if (!adminCase) {
                    throw new HttpException(HttpStatus.NotFound, 'Administrative case not found or invalid');
                }
                administrative_case_id = (adminCase._id as any).toString();
                // Ã‰p type = FACILITY
                appointmentData.type = TypeEnum.FACILITY;
            }

            // Náº¿u cÃ³ slot_id, kiá»ƒm tra slot vÃ  láº¥y staff_id
            if (appointmentData.slot_id) {
                slot = await SlotSchema.findById(appointmentData.slot_id);
                if (!slot) {
                    throw new HttpException(HttpStatus.NotFound, 'Slot not found');
                }

                // Kiá»ƒm tra xem slot cÃ³ kháº£ dá»¥ng khÃ´ng
                if (slot.status !== SlotStatusEnum.AVAILABLE) {
                    throw new HttpException(HttpStatus.BadRequest, 'Slot is not available');
                }

                // Láº¥y staff profile tá»« slot
                if (slot.staff_profile_ids && slot.staff_profile_ids.length > 0) {
                    const staffProfile = await StaffProfileSchema.findById(slot.staff_profile_ids[0]);
                    if (staffProfile) {
                        // Láº¥y user ID tá»« staff profile
                        const staffUser = await UserSchema.findOne({ _id: staffProfile.user_id });
                        if (staffUser) {
                            staffId = staffUser._id;
                        }
                    }
                }

                // Náº¿u khÃ´ng cÃ³ ngÃ y appointment, sá»­ dá»¥ng ngÃ y tá»« slot entity
                if (!appointmentData.appointment_date) {
                    // set the appointment date to the slot's date
                    appointmentData.appointment_date = new Date(
                        slot?.time_slots?.[0]?.year ?? new Date().getFullYear(),
                        (slot?.time_slots?.[0]?.month ?? new Date().getMonth() + 1) - 1,
                        slot?.time_slots?.[0]?.day ?? new Date().getDate()
                    );

                    // set the appointment time to the slot's start time
                    if (slot?.time_slots?.[0]?.start_time) {
                        appointmentData.appointment_date.setHours(
                            slot.time_slots[0].start_time.hour,
                            slot.time_slots[0].start_time.minute,
                            0, 0
                        );
                    }
                }

            } else if (!appointmentData.appointment_date) {
                appointmentData.appointment_date = new Date();
            }

            // Äá»‘i vá»›i dá»‹ch vá»¥ thu tháº­p táº¡i nhÃ , Ä‘á»‹a chá»‰ thu tháº­p lÃ  báº¯t buá»™c
            if (appointmentData.type === TypeEnum.HOME && !appointmentData.collection_address) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Collection address is required for home collection'
                );
            }

            // Kiá»ƒm tra xem cÃ³ agency_contact_email khÃ´ng
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE && !appointmentData.agency_contact_email) {
                throw new HttpException(HttpStatus.BadRequest, 'agency_contact_email is required for ADMINISTRATIVE service');
            }

            // set agency_contact_email to appointment entity báº±ng cÃ¡ch copy tá»« administrative_case
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE && appointmentData.agency_contact_email) {

                const adminCase = await AdministrativeCaseSchema.findOne({
                    case_number: appointmentData.case_number,
                    authorization_code: appointmentData.authorization_code
                });
                if (!adminCase) {
                    throw new HttpException(HttpStatus.NotFound, 'Administrative case not found or invalid');
                }
                administrative_case_id = (adminCase._id as any).toString();
                appointmentData.agency_contact_email = adminCase.agency_contact_email;
            }

            // Táº¡o appointment vá»›i staff_id náº¿u cÃ³
            appointment = await this.appointmentRepository.create({
                user_id: userId as any,
                service_id: appointmentData.service_id as any,
                slot_id: appointmentData.slot_id as any,
                staff_id: staffId as any, // ThÃªm staff_id náº¿u cÃ³
                appointment_date: new Date(appointmentData.appointment_date),
                type: appointmentData.type,
                collection_address: appointmentData.collection_address,
                status: AppointmentStatusEnum.PENDING,
                payment_status: service.type === ServiceTypeEnum.ADMINISTRATIVE ? PaymentStatusEnum.PAID : PaymentStatusEnum.UNPAID,
                administrative_case_id,
                agency_contact_email: service.type === ServiceTypeEnum.ADMINISTRATIVE ? appointmentData.agency_contact_email : undefined,
                created_at: new Date(),
                updated_at: new Date()
            });

            // Náº¿u lÃ  ADMINISTRATIVE, táº¡o payment PAID, amount=0, method=GOVERNMENT
            if (service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                try {
                    const paymentService = new PaymentService();
                    await paymentService.createAdministrativePayment(appointment._id.toString(), userId);
                } catch (paymentError) {
                    // Náº¿u lá»—i khi táº¡o payment cho ADMINISTRATIVE, log lá»—i nhÆ°ng KHÃ”NG throw 500
                    console.error('Failed to create administrative payment:', paymentError);
                    // CÃ³ thá»ƒ thÃªm thÃ´ng tin vÃ o appointment Ä‘á»ƒ tráº£ vá» cho client biáº¿t payment chÆ°a Ä‘Æ°á»£c táº¡o
                    (appointment as any).paymentError = 'Failed to create administrative payment. Please contact support.';
                }
            }

            // Chá»‰ cáº­p nháº­t status slot sau khi appointment Ä‘Æ°á»£c táº¡o thÃ nh cÃ´ng
            if (appointmentData.slot_id && slot) {
                // Atomically increment assigned_count
                const updatedSlot = await SlotSchema.findByIdAndUpdate(
                    appointmentData.slot_id,
                    { $inc: { assigned_count: 1 } }, // $inc ~ increment
                    { new: true }
                );
                if (!updatedSlot) {
                    throw new HttpException(HttpStatus.InternalServerError, 'Failed to update slot');
                }

                // If assigned_count reaches appointment_limit, set status to BOOKED
                if (updatedSlot && updatedSlot.assigned_count !== undefined && updatedSlot.assigned_count >= updatedSlot.appointment_limit) {
                    await SlotSchema.findByIdAndUpdate(
                        appointmentData.slot_id,
                        { status: SlotStatusEnum.BOOKED },
                        { new: true }
                    );
                } else if (updatedSlot.status !== SlotStatusEnum.AVAILABLE) {
                    // If not yet full, ensure status is AVAILABLE
                    await SlotSchema.findByIdAndUpdate(
                        appointmentData.slot_id,
                        { status: SlotStatusEnum.AVAILABLE },
                        { new: true }
                    );
                }
            }

            // táº¡o máº«u cho appointment náº¿u cÃ³ máº«u Ä‘Æ°á»£c cung cáº¥p
            if (appointmentData.samples && appointmentData.samples.length > 0) {
                console.log(`Sample types provided with appointment creation. These will be ignored.`);
                console.log(`Please use the /api/sample/add-to-appointment endpoint to add samples to this appointment.`);

                // ThÃªm thÃ´ng tin hÆ°á»›ng dáº«n vÃ o response
                (appointment as any).sampleInstructions =
                    "Please use the /api/sample/add-to-appointment endpoint to add samples to this appointment.";
            }

            // Log sá»± kiá»‡n táº¡o appointment
            try {
                await this.appointmentLogService.logAppointmentCreation(appointment);
            } catch (logError) {
                console.error('Failed to create appointment log:', logError);
            }

            // Send email notification to user
            try {
                await this.sendAppointmentCreationEmail(appointment);
            } catch (emailError) {
                console.error('Failed to send appointment creation email:', emailError);
            }

            return appointment;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            // Náº¿u lÃ  ADMINISTRATIVE thÃ¬ khÃ´ng tráº£ vá» 500 mÃ  tráº£ vá» 200 vá»›i appointment Ä‘Ã£ táº¡o (náº¿u cÃ³)
            if (
                service &&
                service.type === ServiceTypeEnum.ADMINISTRATIVE &&
                appointment
            ) {
                // Log the error
                console.error('Error after creating ADMINISTRATIVE appointment:', error);
                // CÃ³ thá»ƒ thÃªm thÃ´ng tin lá»—i vÃ o appointment Ä‘á»ƒ client biáº¿t
                (appointment as any).creationError = 'An error occurred after appointment creation. Please contact support.';
                return appointment;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating appointment');
        }
    }

    /**
     * Get appointment by ID
     */
    public async getAppointmentById(id: string): Promise<IAppointment> {
        try {
            if (!id) {
                throw new HttpException(HttpStatus.BadRequest, 'Appointment ID is required');
            }

            // Check if the id is a JSON string representation of an appointment object
            if (id.includes('_id') && id.includes('ObjectId')) {
                console.log('Received appointment object as string instead of ID:', id);

                // Try to extract the _id from the string
                try {
                    // Extract the ObjectId value using regex
                    const match = id.match(/ObjectId\('([^']+)'\)/);
                    if (match && match[1]) {
                        id = match[1];
                        console.log('Extracted ID from object string:', id);
                    } else {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            'Invalid appointment ID format: could not extract ObjectId'
                        );
                    }
                } catch (parseError) {
                    console.error('Error parsing appointment object string:', parseError);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'Invalid appointment ID format: not a valid ObjectId or appointment object'
                    );
                }
            }

            // Convert string ID to ObjectId if needed
            let objectId = id;
            if (typeof id === 'string') {
                try {
                    if (mongoose.Types.ObjectId.isValid(id)) {
                        objectId = new mongoose.Types.ObjectId(id).toString();
                    } else {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Invalid appointment ID format: ${id} is not a valid ObjectId`
                        );
                    }
                } catch (error: any) {
                    console.error(`Error converting appointment ID ${id} to ObjectId:`, error);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        `Invalid appointment ID format: ${error.message}`
                    );
                }
            }

            const appointment = await this.appointmentRepository.findByIdWithPopulate(objectId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, `Appointment not found with ID: ${id}`);
            }

            return appointment;
        } catch (error: any) {
            console.error(`Error in getAppointmentById for ID ${id}:`, error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, `Error getting appointment: ${error.message}`);
        }
    }

    /**
     * Assign staff to an appointment (by department manager)
     */
    public async assignStaff(
        appointmentId: string,
        assignStaffData: AssignStaffDto,
    ): Promise<IAppointment> {
        // Kiá»ƒm tra appointment cÃ³ tá»“n táº¡i vÃ  tráº¡ng thÃ¡i lÃ  PENDING
        const appointment = await this.getAppointmentById(appointmentId);
        if (appointment.status !== AppointmentStatusEnum.PENDING) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Cannot assign staff to appointment with status ${appointment.status}`
            );
        }

        // Validate staff IDs
        if (!assignStaffData.staff_ids || assignStaffData.staff_ids.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'At least one staff ID is required');
        }

        // Validate all staff IDs
        for (const staffId of assignStaffData.staff_ids) {
            if (!mongoose.Types.ObjectId.isValid(staffId)) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid staff ID: ${staffId}`);
            }
        }

        // Láº¥y thÃ´ng tin user cho táº¥t cáº£ staff
        const staffUsers = await UserSchema.find({
            _id: { $in: assignStaffData.staff_ids },
            role: UserRoleEnum.STAFF
        });

        if (staffUsers.length !== assignStaffData.staff_ids.length) {
            throw new HttpException(HttpStatus.NotFound, 'One or more staff users not found');
        }

        // Kiá»ƒm tra staff profile liÃªn káº¿t vá»›i user
        const staffProfiles = await StaffProfileSchema.find({
            user_id: { $in: assignStaffData.staff_ids }
        });

        if (staffProfiles.length !== assignStaffData.staff_ids.length) {
            throw new HttpException(
                HttpStatus.NotFound,
                'One or more staff profiles not found'
            );
        }

        // Kiá»ƒm tra táº¥t cáº£ staff cÃ³ active khÃ´ng
        for (const profile of staffProfiles) {
            if (profile.status !== StaffStatusEnum.ACTIVE) {
                const staffUser = staffUsers.find(u => u._id.toString() === profile.user_id?.toString());
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Staff ${staffUser?.first_name} ${staffUser?.last_name} is not active`
                );
            }
        }

        // Kiá»ƒm tra slot náº¿u cÃ³
        if (appointment.slot_id) {
            const slot = await SlotSchema.findById(appointment.slot_id);
            if (slot) {
                // Kiá»ƒm tra xem táº¥t cáº£ staff cÃ³ trong danh sÃ¡ch staff cá»§a slot khÃ´ng
                const slotStaffProfileIds = slot.staff_profile_ids?.map(id => id.toString()) || [];
                const assignedStaffProfileIds = staffProfiles.map(profile => profile._id.toString());

                const missingStaff = assignedStaffProfileIds.filter(id => !slotStaffProfileIds.includes(id));
                if (missingStaff.length > 0) {
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'One or more staff are not assigned to this slot'
                    );
                }

                // Kiá»ƒm tra giá»›i háº¡n sá»‘ lÆ°á»£ng appointment cho táº¥t cáº£ staff trong slot nÃ y
                for (const staffUser of staffUsers) {
                    const appointmentsInSlot = await this.appointmentRepository.countAppointmentsByStaffAndSlot(
                        staffUser._id.toString(),
                        slot._id.toString()
                    );

                    if (appointmentsInSlot >= slot.appointment_limit) {
                        // TÃ¬m staff khÃ¡c trong slot chÆ°a Ä‘áº¡t giá»›i háº¡n
                        const alternativeStaff = await this.findAvailableStaffInSlot(slot);

                        if (alternativeStaff) {
                            // Gá»£i Ã½ staff thay tháº¿
                            throw new HttpException(
                                HttpStatus.BadRequest,
                                `Staff ${staffUser.first_name} ${staffUser.last_name} has reached appointment limit for this slot. Consider assigning to ${alternativeStaff.first_name} ${alternativeStaff.last_name} (ID: ${alternativeStaff._id})`
                            );
                        } else {
                            throw new HttpException(
                                HttpStatus.BadRequest,
                                `Staff ${staffUser.first_name} ${staffUser.last_name} has reached appointment limit for this slot and no alternative staff is available`
                            );
                        }
                    }
                }

                // Cáº­p nháº­t thÃ´ng tin slot náº¿u cáº§n
                try {
                    // Kiá»ƒm tra xem slot cÃ³ Ä‘ang theo dÃµi sá»‘ lÆ°á»£ng appointment Ä‘Ã£ gÃ¡n khÃ´ng
                    if (!slot.assigned_count) {
                        // Náº¿u khÃ´ng cÃ³ trÆ°á»ng assigned_count, thÃªm vÃ o vÃ  Ä‘áº·t giÃ¡ trá»‹ lÃ  1
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                $set: { assigned_count: 1 },
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    } else {
                        // Náº¿u Ä‘Ã£ cÃ³ trÆ°á»ng assigned_count, tÄƒng giÃ¡ trá»‹ lÃªn 1
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                $inc: { assigned_count: 1 }, // $inc ~ increment
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    }

                    // Náº¿u sá»‘ lÆ°á»£ng Ä‘Ã£ gÃ¡n báº±ng vá»›i giá»›i háº¡n, Ä‘Ã¡nh dáº¥u slot lÃ  BOOKED
                    const updatedSlot = await SlotSchema.findById(slot._id);
                    if (updatedSlot && updatedSlot?.assigned_count && updatedSlot?.assigned_count >= updatedSlot?.appointment_limit) {
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                status: SlotStatusEnum.BOOKED,
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    } else if (updatedSlot && updatedSlot?.status !== SlotStatusEnum.AVAILABLE) {
                        // Náº¿u chÆ°a Ä‘áº¡t giá»›i háº¡n nhÆ°ng slot khÃ´ng á»Ÿ tráº¡ng thÃ¡i AVAILABLE, Ä‘áº·t láº¡i tráº¡ng thÃ¡i
                        await SlotSchema.findByIdAndUpdate(
                            slot._id,
                            {
                                status: SlotStatusEnum.AVAILABLE,
                                updated_at: new Date()
                            },
                            { new: true }
                        );
                    }
                } catch (error) {
                    console.error('Failed to update slot assigned count:', error);
                    // KhÃ´ng fail quÃ¡ trÃ¬nh gÃ¡n staff náº¿u cáº­p nháº­t slot tháº¥t báº¡i
                }
            }
        }

        // Cáº­p nháº­t appointment vá»›i array cá»§a user IDs
        const oldStatus = appointment.status;
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                staff_id: assignStaffData.staff_ids as any,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign staff to appointment');
        }

        // Log sá»± kiá»‡n gÃ¡n nhÃ¢n viÃªn
        try {
            await this.appointmentLogService.logStatusChange(
                updatedAppointment,
                oldStatus as unknown as AppointmentLogTypeEnum
            );
        } catch (logError) {
            console.error('Failed to create appointment log for staff assignment:', logError);
        }

        return updatedAppointment;
    }

    /**
     * Find available staff in a slot that hasn't reached appointment limit
     */
    private async findAvailableStaffInSlot(slot: any): Promise<any> {
        // Láº¥y danh sÃ¡ch staff profile tá»« slot
        const staffProfileIds = slot.staff_profile_ids;
        if (!staffProfileIds || staffProfileIds.length === 0) {
            return null;
        }

        // Láº¥y thÃ´ng tin staff profile
        const staffProfiles = await StaffProfileSchema.find({
            _id: { $in: staffProfileIds },
            status: StaffStatusEnum.ACTIVE
        });

        // Láº¥y user_id tá»« staff profile
        const staffUserIds = staffProfiles.map(profile => profile.user_id);

        // Láº¥y thÃ´ng tin user
        const staffUsers = await UserSchema.find({
            _id: { $in: staffUserIds },
            role: UserRoleEnum.STAFF
        });

        // Kiá»ƒm tra sá»‘ lÆ°á»£ng appointment cá»§a má»—i staff trong slot nÃ y
        for (const staffUser of staffUsers) {
            const appointmentsCount = await this.appointmentRepository.countAppointmentsByStaffAndSlot(
                staffUser._id.toString(),
                slot._id.toString()
            );

            if (appointmentsCount < slot.appointment_limit) {
                return staffUser; // Tráº£ vá» staff Ä‘áº§u tiÃªn chÆ°a Ä‘áº¡t giá»›i háº¡n
            }
        }

        return null; // KhÃ´ng tÃ¬m tháº¥y staff nÃ o cÃ³ thá»ƒ nháº­n thÃªm appointment
    }

    /**
     * Confirm appointment by selecting a slot (by staff)
     */
    public async confirmAppointment(
        appointmentId: string,
        confirmData: ConfirmAppointmentDto,
        staffId: string,
        userRole: UserRoleEnum
    ): Promise<IAppointment | undefined> {
        const appointment = await this.getAppointmentById(appointmentId);

        // Only staff can confirm appointments
        if (userRole !== UserRoleEnum.STAFF) {
            throw new HttpException(HttpStatus.Forbidden, 'Only staff can confirm appointments');
        }

        // Check if staff is assigned to the appointment
        if (!appointment.staff_id) {
            throw new HttpException(
                HttpStatus.BadRequest,
                'No staff assigned to this appointment yet. Department manager must assign staff first.'
            );
        }

        // Check if the appointment is in PENDING status
        if (appointment.status !== AppointmentStatusEnum.PENDING) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Cannot confirm appointment with status ${appointment.status}`
            );
        }

        // Check if the assigned staff matches the confirming staff
        const staffProfile = await StaffProfileSchema.findOne({ user_id: staffId });
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        const appointmentStaff = await UserSchema.findById(appointment.staff_id);
        if (!appointmentStaff) {
            throw new HttpException(HttpStatus.NotFound, 'Assigned staff not found');
        }

        if (appointmentStaff._id.toString() !== staffId) {
            throw new HttpException(
                HttpStatus.Forbidden,
                'You are not assigned to this appointment'
            );
        }

        // Validate slot
        const slot = await SlotSchema.findById(confirmData.slot_id);
        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        if (slot.status !== SlotStatusEnum.AVAILABLE) {
            throw new HttpException(HttpStatus.BadRequest, 'Slot is not available');
        }

        // Update appointment with new slot and status
        const oldStatus = appointment.status;
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                slot_id: confirmData.slot_id as any,
                status: AppointmentStatusEnum.CONFIRMED,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to confirm appointment');
        }

        // // Update slot status to BOOKED
        // await SlotSchema.findByIdAndUpdate(
        //     confirmData.slot_id,
        //     { status: SlotStatusEnum.BOOKED },
        //     { new: true }
        // );

        // Cáº­p nháº­t thÃ´ng tin slot náº¿u cáº§n
        try {
            // Kiá»ƒm tra xem slot cÃ³ Ä‘ang theo dÃµi sá»‘ lÆ°á»£ng appointment Ä‘Ã£ gÃ¡n khÃ´ng
            if (!slot.assigned_count) {
                // Náº¿u khÃ´ng cÃ³ trÆ°á»ng assigned_count, thÃªm vÃ o vÃ  Ä‘áº·t giÃ¡ trá»‹ lÃ  1
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        $set: { assigned_count: 1 },
                        updated_at: new Date()
                    },
                    { new: true }
                );
            } else {
                // Náº¿u Ä‘Ã£ cÃ³ trÆ°á»ng assigned_count, tÄƒng giÃ¡ trá»‹ lÃªn 1
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        $inc: { assigned_count: 1 }, // $inc ~ increment
                        updated_at: new Date()
                    },
                    { new: true }
                );
            }

            // Náº¿u sá»‘ lÆ°á»£ng Ä‘Ã£ gÃ¡n báº±ng vá»›i giá»›i háº¡n, Ä‘Ã¡nh dáº¥u slot lÃ  BOOKED
            const updatedSlot = await SlotSchema.findById(slot._id);
            if (updatedSlot && updatedSlot?.assigned_count && updatedSlot?.assigned_count >= updatedSlot?.appointment_limit) {
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        status: SlotStatusEnum.BOOKED,
                        updated_at: new Date()
                    },
                    { new: true }
                );
            } else if (updatedSlot && updatedSlot?.status !== SlotStatusEnum.AVAILABLE) {
                // Náº¿u chÆ°a Ä‘áº¡t giá»›i háº¡n nhÆ°ng slot khÃ´ng á»Ÿ tráº¡ng thÃ¡i AVAILABLE, Ä‘áº·t láº¡i tráº¡ng thÃ¡i
                await SlotSchema.findByIdAndUpdate(
                    slot._id,
                    {
                        status: SlotStatusEnum.AVAILABLE,
                        updated_at: new Date()
                    },
                    { new: true }
                );
            }

            // Log the confirmation
            try {
                await this.appointmentLogService.logStatusChange(
                    updatedAppointment,
                    oldStatus as unknown as AppointmentLogTypeEnum
                );
            } catch (logError) {
                console.error('Failed to create appointment log for confirmation:', logError);
            }

            // Send confirmation email to user
            try {
                await this.sendAppointmentConfirmationEmail(updatedAppointment);
            } catch (emailError) {
                console.error('Failed to send appointment confirmation email:', emailError);
            }

            return updatedAppointment;
        }
        catch (error) {
            console.error('Failed to update slot assigned count:', error);
            // KhÃ´ng fail quÃ¡ trÃ¬nh xÃ¡c nháº­n náº¿u cáº­p nháº­t slot tháº¥t báº¡i
        }
    }

    /**
     * Search appointments with filters
     */
    public async searchAppointments(
        searchParams: SearchAppointmentDto,
        userRole: UserRoleEnum,
        userId?: string
    ): Promise<SearchPaginationResponseModel<IAppointment>> {
        try {
            // Process pagination parameters
            const pageNum = searchParams.pageNum || 1;
            const pageSize = searchParams.pageSize || 10;
            const skip = (pageNum - 1) * pageSize;

            // Build the query based on filters
            const query: any = {};

            // If user is a customer, they can only see their own appointments
            if (userRole === UserRoleEnum.CUSTOMER && userId) {
                query.user_id = new mongoose.Types.ObjectId(userId);
            }
            // If user is a staff, they can only see appointments assigned to them
            else if (userRole === UserRoleEnum.STAFF && userId) {
                query.staff_id = new mongoose.Types.ObjectId(userId);
            }
            // If user is a laboratory technician, they can only see appointments assigned to them
            else if (userRole === UserRoleEnum.LABORATORY_TECHNICIAN && userId) {
                query.laboratory_technician_id = new mongoose.Types.ObjectId(userId);
            }
            // For other roles, apply filters if provided
            else {
                if (searchParams.user_id) {
                    query.user_id = new mongoose.Types.ObjectId(searchParams.user_id);
                }

                if (searchParams.staff_id) {
                    query.staff_id = new mongoose.Types.ObjectId(searchParams.staff_id);
                }
            }

            // Apply common filters
            if (searchParams.service_id) {
                query.service_id = new mongoose.Types.ObjectId(searchParams.service_id);
            }

            if (searchParams.status) {
                query.status = searchParams.status;
            }

            if (searchParams.type) {
                query.type = searchParams.type;
            }

            // Date range filter
            if (searchParams.start_date || searchParams.end_date) {
                query.appointment_date = {};

                if (searchParams.start_date) {
                    query.appointment_date.$gte = new Date(searchParams.start_date);
                }

                if (searchParams.end_date) {
                    query.appointment_date.$lte = new Date(searchParams.end_date);
                }
            }

            // Handle search term differently based on type
            if (searchParams.search_term) {
                const searchRegex = new RegExp(searchParams.search_term, 'i');

                // If there's a search term, we'll search in collection_address if type is HOME
                if (searchParams.type === TypeEnum.HOME) {
                    query.collection_address = { $regex: searchRegex };
                } else {
                    // For non-HOME types, we need to search in user names
                    // This requires a different approach using aggregation or lookup
                    // For now, we'll handle this by fetching all results and filtering
                    // This is not ideal for large datasets but works for the current use case
                }
            }

            let appointments: IAppointment[] = [];
            let totalCount: number = 0;

            // If we have a search term for non-HOME types, we need to handle it differently
            if (searchParams.search_term && searchParams.type !== TypeEnum.HOME) {
                // Fetch all appointments matching the base query (without pagination)
                const allAppointments = await this.appointmentRepository.findWithPopulate(query);

                // Filter by search term
                const searchRegex = new RegExp(searchParams.search_term, 'i');
                const filteredAppointments = allAppointments.filter(appointment => {
                    const user = appointment.user_id as any;
                    if (user && (user.first_name || user.last_name)) {
                        const fullName = `${user.first_name || ''} ${user.last_name || ''}`;
                        return searchRegex.test(fullName);
                    }
                    return false;
                });

                // Calculate total count from filtered results
                totalCount = filteredAppointments.length;

                // Apply pagination to filtered results
                const startIndex = skip;
                const endIndex = startIndex + pageSize;
                appointments = filteredAppointments.slice(startIndex, endIndex);
            } else {
                // For HOME type searches or no search term, use normal pagination
                // Count total documents matching the query
                totalCount = await this.appointmentRepository.countDocuments(query);

                // Sort by appointment date (newest first)
                const sort = { appointment_date: -1 };

                // Fetch appointments with pagination
                appointments = await this.appointmentRepository.findWithPaginationAndPopulate(
                    query,
                    sort,
                    skip,
                    pageSize
                );
            }

            return {
                pageData: appointments,
                pageInfo: {
                    totalItems: totalCount,
                    pageNum,
                    pageSize,
                    totalPages: Math.ceil(totalCount / pageSize)
                }
            };
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching appointments');
        }
    }

    /**
     * Process query parameters
     */
    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }

    /**
     * Update appointment status
     */
    public async updateAppointmentStatus(appointmentId: string, status: AppointmentStatusEnum): Promise<IAppointment> {
        // Validate appointmentId
        if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
        }

        // Find the appointment
        const appointment = await this.getAppointmentById(appointmentId);

        // Update appointment status
        const oldStatus = appointment.status;
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                status: status,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update appointment status');
        }

        // Log the status change
        try {
            await this.appointmentLogService.logStatusChange(
                updatedAppointment,
                oldStatus as unknown as AppointmentLogTypeEnum
            );
        } catch (logError) {
            console.error('Failed to create appointment log for status change:', logError);
        }

        // Send status update email to user
        try {
            await this.sendAppointmentStatusUpdateEmail(updatedAppointment, oldStatus);
        } catch (emailError) {
            console.error('Failed to send appointment status update email:', emailError);
        }

        return updatedAppointment;
    }

    /**
     * Get samples for an appointment
     */
    public async getAppointmentSamples(appointmentId: string): Promise<ISample[]> {
        // Validate appointment exists
        await this.getAppointmentById(appointmentId);

        // Get samples for the appointment
        const samples = await this.getSampleService().getSamplesByAppointmentId(appointmentId);
        return samples;
    }

    /**
     * Get price for an appointment
     * @param appointmentId The ID of the appointment
     * @returns The price of the service associated with the appointment
     */
    public async getAppointmentPrice(appointmentId: string): Promise<number> {
        try {
            if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            const appointment = await this.appointmentRepository.findById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                throw new HttpException(HttpStatus.NotFound, 'Service not found for this appointment');
            }

            return service.price;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting appointment price');
        }
    }

    /**
     * Get staff roles for department manager
     */
    public async getUserRoleStaff(): Promise<any[]> {
        try {
            // Get all staff users
            const staffUsers = await UserSchema.find({ role: UserRoleEnum.STAFF })
                .select('_id first_name last_name email phone_number');

            // Get staff profiles
            const staffProfiles = await StaffProfileSchema.find({
                user_id: { $in: staffUsers.map(user => user._id) }
            }).select('user_id status department');

            // Combine user and profile information, only include staff with profiles
            const staffWithRoles = staffUsers
                .map(user => {
                    const profile = staffProfiles.find(p => p.user_id?.toString() === user._id.toString());
                    if (!profile) return null;

                    return {
                        ...user.toObject(),
                        staff_profile: {
                            status: profile.status,
                            department: profile.department_id
                        }
                    };
                })
                .filter(staff => staff !== null);

            return staffWithRoles;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff roles');
        }
    }

    /**
     * Get available slots for logged-in staff
     */
    public async getStaffAvailableSlots(staffId: string): Promise<any[]> {
        try {
            // Get staff profile
            const staffProfile = await StaffProfileSchema.findOne({ user_id: staffId });
            if (!staffProfile) {
                throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
            }

            // Get all slots assigned to this staff
            const slots = await SlotSchema.find({
                staff_profile_ids: { $in: [staffProfile._id] },
                status: SlotStatusEnum.AVAILABLE
            })

            return slots;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff available slots');
        }
    }

    /**
     * Get appointments assigned to a staff member
     */
    public async getStaffAssignedAppointments(
        staffId: string,
        searchParams: SearchAppointmentDto
    ): Promise<SearchPaginationResponseModel<IAppointment>> {
        try {
            // staff_id will be automatically set by role-based filtering in searchAppointments
            return this.searchAppointments(searchParams, UserRoleEnum.STAFF, staffId);
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff assigned appointments');
        }
    }

    /**
     * Get appointments assigned to a laboratory technician in appointment collection
     */
    /**
     * Get appointments assigned to a laboratory technician
     */
    public async getLabTechAssignedAppointments(
        labTechId: string,
        searchParams: SearchAppointmentDto
    ): Promise<SearchPaginationResponseModel<IAppointment>> {
        try {
            // laboratory_technician_id will be automatically set by role-based filtering in searchAppointments
            return this.searchAppointments(searchParams, UserRoleEnum.LABORATORY_TECHNICIAN, labTechId);
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting laboratory technician assigned appointments');
        }
    }

    /**
     * Assign laboratory technician to an appointment
     */
    public async assignLabTechnician(
        appointmentId: string,
        labTechId: string
    ): Promise<IAppointment> {
        try {
            // Validate appointment exists
            const appointment = await this.getAppointmentById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            // Validate lab technician exists and has correct role
            const labTech = await UserSchema.findOne({
                _id: labTechId,
                role: UserRoleEnum.LABORATORY_TECHNICIAN
            });
            if (!labTech) {
                throw new HttpException(HttpStatus.NotFound, 'Laboratory technician not found');
            }

            // Update appointment with lab technician
            const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
                appointmentId,
                {
                    laboratory_technician_id: labTechId,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedAppointment) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign laboratory technician');
            }

            // Log the assignment
            try {
                await this.appointmentLogService.logAppointmentCreation(updatedAppointment);
            } catch (logError) {
                console.error('Failed to create appointment log for lab tech assignment:', logError);
            }

            return updatedAppointment;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error assigning laboratory technician');
        }
    }

    /**
     * Get available laboratory technicians
     */
    public async getAvailableLabTechnicians(): Promise<any[]> {
        try {
            // Get all laboratory technician users
            const labTechUsers = await UserSchema.find({ role: UserRoleEnum.LABORATORY_TECHNICIAN })
                .select('_id first_name last_name email phone_number');

            // Get staff profiles for these users
            const labTechProfiles = await StaffProfileSchema.find({
                user_id: { $in: labTechUsers.map(user => user._id) },
                status: StaffStatusEnum.ACTIVE
            }).select('user_id status department');

            // Only include users who have a staff profile
            const availableLabTechs = labTechUsers
                .map(user => {
                    const profile = labTechProfiles.find(p => p.user_id?.toString() === user._id.toString());
                    if (!profile) return null;

                    return {
                        ...user.toObject(),
                        staff_profile: {
                            status: profile.status,
                            department: profile.department_id
                        }
                    };
                })
                .filter(tech => tech !== null);

            return availableLabTechs;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting available laboratory technicians');
        }
    }

    /**
     * Unassign staff from an appointment
     * This method is used when you need to change the assigned staff
     * or when an appointment is cancelled
     */
    public async unassignStaff(appointmentId: string): Promise<IAppointment> {
        // Kiá»ƒm tra appointment cÃ³ tá»“n táº¡i
        const appointment = await this.getAppointmentById(appointmentId);

        // Náº¿u khÃ´ng cÃ³ staff_id hoáº·c slot_id, khÃ´ng cáº§n xá»­ lÃ½
        if (!appointment.staff_id || !appointment.slot_id) {
            return appointment;
        }

        // Cáº­p nháº­t slot Ä‘á»ƒ giáº£m assigned_count
        try {
            const slot = await SlotSchema.findById(appointment.slot_id);
            if (slot) {
                // Giáº£m assigned_count náº¿u cÃ³
                if (slot.assigned_count && slot.assigned_count > 0) {
                    await SlotSchema.findByIdAndUpdate(
                        slot._id,
                        {
                            $inc: { assigned_count: -1 },
                            updated_at: new Date()
                        },
                        { new: true }
                    );
                }

                // Náº¿u slot Ä‘ang á»Ÿ tráº¡ng thÃ¡i BOOKED vÃ  assigned_count < appointment_limit
                // thÃ¬ Ä‘áº·t láº¡i tráº¡ng thÃ¡i lÃ  AVAILABLE
                const updatedSlot = await SlotSchema.findById(slot._id);
                const assignedCount = updatedSlot?.assigned_count || 0;
                const appointmentLimit = updatedSlot?.appointment_limit || 1;
                if (updatedSlot &&
                    updatedSlot.status === SlotStatusEnum.BOOKED &&
                    assignedCount < appointmentLimit) {
                    await SlotSchema.findByIdAndUpdate(
                        slot._id,
                        {
                            status: SlotStatusEnum.AVAILABLE,
                            updated_at: new Date()
                        },
                        { new: true }
                    );
                }
            }
        } catch (error) {
            console.error('Failed to update slot assigned count during unassign:', error);
            // KhÃ´ng fail quÃ¡ trÃ¬nh unassign náº¿u cáº­p nháº­t slot tháº¥t báº¡i
        }

        // XÃ³a staff_id khá»i appointment báº±ng cÃ¡ch sá»­ dá»¥ng mongoose update operators
        const updatedAppointment = await this.appointmentRepository.findByIdAndUpdate(
            appointmentId,
            {
                // Sá»­ dá»¥ng type assertion Ä‘á»ƒ trÃ¡nh lá»—i TypeScript
                staff_id: undefined as unknown as string,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedAppointment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to unassign staff from appointment');
        }

        return updatedAppointment;
    }

    /**
     * Send email notification for appointment creation
     */
    private async sendAppointmentCreationEmail(appointment: IAppointment): Promise<void> {
        try {
            // Get user details
            const user = await UserSchema.findById(appointment.user_id);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;
            const appointmentDate = appointment.appointment_date
                ? new Date(appointment.appointment_date).toLocaleString()
                : 'To be confirmed';

            const title = 'Appointment Created Successfully';
            const message = `
                Your appointment for ${service.name} has been created successfully.
                <br><br>
                <strong>Appointment Details:</strong>
                <br>
                Service: ${service.name}
                <br>
                Date: ${appointmentDate}
                <br>
                Type: ${appointment.type}
                <br>
                Status: ${appointment.status}
                <br><br>
                We will notify you once your appointment is confirmed by our staff.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Appointment Created - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Appointment creation email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending appointment creation email:', error);
        }
    }

    /**
     * Send email notification for appointment confirmation
     */
    private async sendAppointmentConfirmationEmail(appointment: IAppointment): Promise<void> {
        try {
            // Get user details
            const user = await UserSchema.findById(appointment.user_id);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            // Get slot details if available
            let slotDetails = 'Not specified';
            if (appointment.slot_id) {
                const slot = await SlotSchema.findById(appointment.slot_id);
                if (slot && slot.time_slots && slot.time_slots.length > 0) {
                    const timeSlot = slot.time_slots[0];
                    const date = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
                    const formattedDate = date.toLocaleDateString();
                    const startTime = `${timeSlot.start_time.hour}:${timeSlot.start_time.minute.toString().padStart(2, '0')}`;
                    const endTime = `${timeSlot.end_time.hour}:${timeSlot.end_time.minute.toString().padStart(2, '0')}`;
                    slotDetails = `${formattedDate} from ${startTime} to ${endTime}`;
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Appointment Confirmed';
            const message = `
                Your appointment for ${service.name} has been confirmed.
                <br><br>
                <strong>Appointment Details:</strong>
                <br>
                Service: ${service.name}
                <br>
                Scheduled Time: ${slotDetails}
                <br>
                Type: ${appointment.type}
                <br>
                Status: ${appointment.status}
                <br><br>
                ${appointment.type === TypeEnum.HOME ?
                    `Our staff will visit your location at the scheduled time.` :
                    `Please arrive at our facility at the scheduled time.`}
                <br><br>
                If you need to reschedule or cancel your appointment, please contact us as soon as possible.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Appointment Confirmed - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Appointment confirmation email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending appointment confirmation email:', error);
        }
    }

    /**
     * Send email notification for appointment status update
     */
    private async sendAppointmentStatusUpdateEmail(appointment: IAppointment, oldStatus: AppointmentStatusEnum): Promise<void> {
        try {
            // Get user details
            const user = await UserSchema.findById(appointment.user_id);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;
            const appointmentDate = appointment.appointment_date
                ? new Date(appointment.appointment_date).toLocaleString()
                : 'To be confirmed';

            let title = 'Appointment Status Updated';
            let message = `
                Your appointment for ${service.name} has been updated from ${oldStatus} to ${appointment.status}.
                <br><br>
                <strong>Appointment Details:</strong>
                <br>
                Service: ${service.name}
                <br>
                Date: ${appointmentDate}
                <br>
                Type: ${appointment.type}
                <br>
                Status: ${appointment.status}
                <br><br>
            `;

            // Add specific messages based on the new status
            switch (appointment.status) {
                case AppointmentStatusEnum.COMPLETED:
                    message += 'Your appointment has been completed. Thank you for using our services.';
                    title = 'Appointment Completed';
                    break;
                case AppointmentStatusEnum.CANCELLED:
                    message += 'Your appointment has been cancelled. If you did not request this cancellation, please contact us.';
                    title = 'Appointment Cancelled';
                    break;
                case AppointmentStatusEnum.PENDING:
                    message += 'Your appointment is now in progress.';
                    title = 'Appointment In Progress';
                    break;
                case AppointmentStatusEnum.SAMPLE_COLLECTED:
                    message += 'Your samples have been collected. They will be processed by our laboratory.';
                    title = 'Samples Collected';
                    break;
                case AppointmentStatusEnum.CONFIRMED:
                    message += 'Your appointment has been confirmed. Please prepare for the appointment.';
                    title = 'Appointment Confirmed';
                    break;
                case AppointmentStatusEnum.SAMPLE_RECEIVED:
                    message += 'Your samples have been received by our laboratory. They will be processed soon.';
                    title = 'Samples Received';
                    break;
                case AppointmentStatusEnum.TESTING:
                    message += 'Your samples are now being tested by our laboratory.';
                    title = 'Samples Testing';
                    break;
                default:
                    message += 'If you have any questions about your appointment, please contact us.';
            }

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: `${title} - Bloodline DNA Testing Service`,
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Appointment status update email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending appointment status update email:', error);
        }
    }
}



================================================
FILE: src/modules/appointment/index.ts
================================================
import AppointmentSchema from './appointment.model';
import { IAppointment, AppointmentStatus, CollectionType } from './appointment.interface';
import { AppointmentStatusEnum, TypeEnum } from './appointment.enum';
import { AppointmentStatuses, CollectionTypes } from './appointment.constant';
import { CollectionMethodEnum } from '../sample/sample.enum';
import AppointmentRoute from './appointment.route';
import AppointmentController from './appointment.controller';
import AppointmentService from './appointment.service';
import AppointmentRepository from './appointment.repository';
import { CreateAppointmentDto } from './dtos/createAppointment.dto';

export {
    AppointmentSchema,
    IAppointment,
    AppointmentStatus,
    CollectionType,
    AppointmentStatusEnum,
    TypeEnum,
    CollectionMethodEnum,
    AppointmentStatuses,
    CollectionTypes,
    AppointmentRoute,
    AppointmentController,
    AppointmentService,
    AppointmentRepository,
    CreateAppointmentDto
}; 


================================================
FILE: src/modules/appointment/dtos/assign-staff.dto.ts
================================================
import { IsMongoId, IsArray } from 'class-validator';

export class AssignStaffDto {
    @IsArray()
    @IsMongoId({ each: true })
    staff_ids: string[] = [];
} 


================================================
FILE: src/modules/appointment/dtos/confirm-appointment.dto.ts
================================================
import { IsNotEmpty, IsString } from 'class-validator';

export class ConfirmAppointmentDto {
    @IsNotEmpty({ message: 'Slot ID is required' })
    @IsString({ message: 'Slot ID must be a string' })
    slot_id: string = '';

} 


================================================
FILE: src/modules/appointment/dtos/createAppointment.dto.ts
================================================
import { IsArray, IsDate, IsEnum, IsMongoId, IsOptional, IsString, ValidateNested } from 'class-validator';
import { TypeEnum } from '../appointment.enum';
import { Transform, Type } from 'class-transformer';
import { SampleTypeEnum } from '../../sample/sample.enum';

export class SampleSelectionDto {
    @IsEnum(SampleTypeEnum)
    type: SampleTypeEnum = SampleTypeEnum.SALIVA;
}

export class CreateAppointmentDto {
    @IsMongoId()
    service_id: string = '';

    @IsMongoId()
    @IsOptional()
    slot_id?: string;

    @IsOptional()
    @Type(() => Date)
    appointment_date?: Date;

    @IsEnum(TypeEnum)
    @IsOptional()
    type?: TypeEnum;

    @IsString()
    @IsOptional()
    collection_address?: string;

    /**
     * @deprecated Use /api/sample/add-to-appointment endpoint instead
     */
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SampleSelectionDto)
    @IsOptional()
    samples?: SampleSelectionDto[] = [];

    @IsOptional()
    administrative_case_id?: string;

    @IsString()
    @IsOptional()
    agency_contact_email?: string;

    @IsString()
    @IsOptional()
    case_number?: string;

    @IsString()
    @IsOptional()
    authorization_code?: string;
}



================================================
FILE: src/modules/appointment/dtos/search-appointment.dto.ts
================================================
import { IsDateString, IsEnum, IsMongoId, IsNumber, IsOptional, IsString } from 'class-validator';
import { AppointmentStatusEnum, TypeEnum } from '../appointment.enum';

export class SearchAppointmentDto {
    @IsOptional()
    @IsNumber()
    pageNum?: number = 1;

    @IsOptional()
    @IsNumber()
    pageSize?: number = 10;

    @IsOptional()
    @IsMongoId()
    user_id?: string;

    @IsOptional()
    @IsMongoId()
    service_id?: string;

    @IsOptional()
    @IsEnum(AppointmentStatusEnum)
    status?: AppointmentStatusEnum;

    @IsOptional()
    @IsEnum(TypeEnum)
    type?: TypeEnum;

    @IsOptional()
    @IsMongoId()
    staff_id?: string;

    @IsOptional()
    @IsDateString()
    start_date?: string;

    @IsOptional()
    @IsDateString()
    end_date?: string;

    @IsOptional()
    @IsString()
    search_term?: string;
} 


================================================
FILE: src/modules/appointment/swagger/appointment.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Appointment:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Appointment ID
 *         user_id:
 *           type: string
 *           description: ID of the user who made the appointment
 *         service_id:
 *           type: string
 *           description: ID of the service
 *         slot_id:
 *           type: string
 *           description: ID of the selected time slot
 *         staff_id:
 *           type: string
 *           description: ID of the assigned staff member
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the assigned laboratory technician
 *         appointment_date:
 *           type: string
 *           format: date-time
 *           description: Date and time of the appointment
 *         type:
 *           type: string
 *           enum: [FACILITY, HOME]
 *           description: Type of appointment
 *         collection_address:
 *           type: string
 *           description: Address for home collection
 *         status:
 *           type: string
 *           enum: [PENDING, CONFIRMED, IN_PROGRESS, COMPLETED, CANCELLED]
 *           description: Current status of the appointment
 *         payment_status:
 *           type: string
 *           enum: [UNPAID, PAID, REFUNDED]
 *           description: Payment status of the appointment
 *         administrative_case_id:
 *           type: string
 *           description: ID of the administrative case associated with the appointment
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 *     CreateAppointmentDto:
 *       type: object
 *       required:
 *         - service_id
 *         - type
 *       properties:
 *         service_id:
 *           type: string
 *         slot_id:
 *           type: string
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *         collection_address:
 *           type: string
 *         case_number:
 *           type: string
 *         authorization_code:
 *           type: string
 *     AppointmentResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *         message:
 *           type: string
 *         data:
 *           $ref: '#/components/schemas/Appointment'
 *     AppointmentListResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *         message:
 *           type: string
 *         data:
 *           type: object
 *           properties:
 *             pageData:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Appointment'
 *             pageInfo:
 *               type: object
 *               properties:
 *                 totalItems:
 *                   type: integer
 *                 totalPages:
 *                   type: integer
 *                 pageNum:
 *                   type: integer
 *                 pageSize:
 *                   type: integer
 *     AssignLabTechRequest:
 *       type: object
 *       required:
 *         - lab_tech_id
 *       properties:
 *         lab_tech_id:
 *           type: string
 *           description: ID of the laboratory technician to assign
 *     SlotWithAppointmentLimit:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Slot ID
 *         staff_profile_ids:
 *           type: array
 *           description: List of staff profile IDs assigned to this slot
 *           items:
 *             type: string
 *         appointment_limit:
 *           type: integer
 *           description: Maximum number of appointments a staff member can handle in this slot
 *           example: 3
 *         assigned_count:
 *           type: integer
 *           description: Current number of appointments assigned to this slot
 *           example: 1
 *         time_slots:
 *           type: array
 *           description: Time slots details
 *           items:
 *             type: object
 *             properties:
 *               year:
 *                 type: integer
 *               month:
 *                 type: integer
 *               day:
 *                 type: integer
 *               start_time:
 *                 type: object
 *                 properties:
 *                   hour:
 *                     type: integer
 *                   minute:
 *                     type: integer
 *               end_time:
 *                 type: object
 *                 properties:
 *                   hour:
 *                     type: integer
 *                   minute:
 *                     type: integer
 *         status:
 *           type: string
 *           enum: [AVAILABLE, BOOKED, UNAVAILABLE]
 *           description: Current status of the slot
 */



================================================
FILE: src/modules/appointment/swagger/appointment.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: appointments
 *   description: Appointment management APIs
 */

/**
 * @swagger
 * /api/appointment/create:
 *   post:
 *     tags:
 *       - appointments
 *     summary: Create a new appointment (Customer only)
 *     description: Book a new appointment for a DNA testing service
 *     operationId: createAppointment
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateAppointmentDto'
 *     responses:
 *       201:
 *         description: Appointment created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid input data or missing required fields
 *       401:
 *         description: Unauthorized - Customer authentication required
 *       404:
 *         description: Service or slot not found
 *       409:
 *         description: Slot already booked or unavailable
 */

/**
 * @swagger
 * /api/appointment/search:
 *   get:
 *     tags: [appointments]
 *     summary: Search appointments
 *     description: Search and filter appointments with pagination
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: user_id
 *         schema:
 *           type: string
 *         description: Filter by user ID (MongoDB ObjectId)
 *       - in: query
 *         name: staff_id
 *         schema:
 *           type: string
 *         description: Filter by staff ID (MongoDB ObjectId)
 *       - in: query
 *         name: service_id
 *         schema:
 *           type: string
 *         description: Filter by service ID (MongoDB ObjectId)
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, sample_received, testing, completed, cancelled]
 *         description: Filter by appointment status
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [self, facility, home]
 *         description: Filter by appointment type
 *       - in: query
 *         name: start_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter appointments from this date (YYYY-MM-DD)
 *       - in: query
 *         name: end_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter appointments until this date (YYYY-MM-DD)
 *       - in: query
 *         name: search_term
 *         schema:
 *           type: string
 *         description: Search term for customer name or address
 *     responses:
 *       200:
 *         description: Successful operation
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       401:
 *         description: Unauthorized - User not authenticated
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/{id}:
 *   get:
 *     tags:
 *       - appointments
 *     summary: Get appointment by ID (All authenticated users)
 *     description: Retrieve detailed information about a specific appointment
 *     operationId: getAppointmentById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Appointment details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid appointment ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - User cannot access this appointment
 *       404:
 *         description: Appointment not found
 */

/**
 * @swagger
 * /api/appointment/{id}/assign-staff:
 *   put:
 *     tags:
 *       - appointments
 *     summary: Assign staff to appointment (Manager only)
 *     description: Assign a staff member to an existing appointment. The system checks if the staff is assigned to the slot and if they haven't reached their appointment limit for that slot.
 *     operationId: assignStaffToAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - staff_id
 *             properties:
 *               staff_id:
 *                 type: string
 *                 description: ID of the staff member to assign
 *                 example: "60d0fe4f5311236168a109ca"
 *     responses:
 *       200:
 *         description: Staff assigned successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid input data, appointment ID format, or staff has reached appointment limit for this slot
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Staff has reached appointment limit for this slot. Consider assigning to John Doe (ID: 60d0fe4f5311236168a109cb)"
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       404:
 *         description: Appointment or staff not found
 *       422:
 *         description: Invalid operation - Appointment status must be 'pending'
 */

/**
 * @swagger
 * /api/appointment/{id}/confirm:
 *   put:
 *     tags:
 *       - appointments
 *     summary: Confirm appointment (Staff only)
 *     description: Confirm an appointment, assign a testing kit to a laboratory technician, and update appointment status to 'confirmed'
 *     operationId: confirmAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - slot_id
 *             properties:
 *               slot_id:
 *                 type: string
 *                 description: ID of the time slot for the appointment
 *                 example: "60d0fe4f5311236168a109cd"
 *     responses:
 *       200:
 *         description: Appointment confirmed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid input data, appointment ID format, or laboratory technician role
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required or staff not assigned to this appointment
 *       404:
 *         description: Appointment, kit, or laboratory technician not found
 *       409:
 *         description: Kit already assigned to another appointment
 *       422:
 *         description: Invalid operation - Appointment status must be 'pending' with assigned staff
 */

/**
 * @swagger
 * /api/appointment/{id}/samples:
 *   get:
 *     tags:
 *       - appointments
 *     summary: Get samples for an appointment
 *     description: Retrieve all samples associated with a specific appointment
 *     operationId: getAppointmentSamples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Samples retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Invalid appointment ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       404:
 *         description: Appointment not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/{appointmentId}/price:
 *   get:
 *     tags:
 *       - appointments
 *     summary: Get price for an appointment
 *     description: Retrieves the price for an appointment based on its associated service
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: appointmentId
 *         in: path
 *         required: true
 *         description: ID of the appointment
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Appointment price retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     price:
 *                       type: number
 *                       example: 100000
 *                 message:
 *                   type: string
 *                   example: "Appointment price retrieved successfully"
 *       '400':
 *         description: Bad request
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '401':
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '404':
 *         description: Appointment not found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '500':
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/appointment/staff/assigned:
 *   get:
 *     tags: [appointments]
 *     summary: Get appointments assigned to staff member (Staff only)
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of assigned appointments
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentListResponse'
 *       401:
 *         description: Unauthorized
 *
 * /api/appointment/lab-tech/assigned:
 *   get:
 *     tags: [appointments]
 *     summary: Get appointments assigned to laboratory technician (Lab technician only)
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *         description: Page number
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of assigned appointments
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentListResponse'
 *       401:
 *         description: Unauthorized
 *
 * /api/appointment/{id}/assign-lab-tech:
 *   post:
 *     tags: [appointments]
 *     summary: Assign a laboratory technician to an appointment (Staff only)
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/AssignLabTechRequest'
 *     responses:
 *       200:
 *         description: Laboratory technician assigned successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentResponse'
 *       400:
 *         description: Invalid request
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Appointment or laboratory technician not found
 */

/**
 * @swagger
 * /api/appointment/staff/available:
 *   get:
 *     tags: [appointments]
 *     summary: Get available staff (Manager only)
 *     description: Retrieve list of staff members with their roles and departments
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Staff roles retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Staff user ID
 *                       first_name:
 *                         type: string
 *                         description: Staff first name
 *                       last_name:
 *                         type: string
 *                         description: Staff last name
 *                       email:
 *                         type: string
 *                         description: Staff email
 *                       phone_number:
 *                         type: string
 *                         description: Staff phone number
 *                       staff_profile:
 *                         type: object
 *                         properties:
 *                           status:
 *                             type: string
 *                             enum: [ACTIVE, INACTIVE]
 *                             description: Staff profile status
 *                           department:
 *                             type: string
 *                             description: Department ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       500:
 *         description: Internal server error
 *
 * /api/appointment/staff/slots:
 *   get:
 *     tags: [appointments]
 *     summary: Get available slots for logged-in staff (Staff only)
 *     description: Retrieve all available time slots assigned to the logged-in staff member
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Available slots retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Slot ID
 *                       date:
 *                         type: string
 *                         format: date
 *                         description: Date of the slot
 *                       time_slots:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             start_time:
 *                               type: object
 *                               properties:
 *                                 hour:
 *                                   type: integer
 *                                 minute:
 *                                   type: integer
 *                             end_time:
 *                               type: object
 *                               properties:
 *                                 hour:
 *                                   type: integer
 *                                 minute:
 *                                   type: integer
 *                       status:
 *                         type: string
 *                         enum: [AVAILABLE, BOOKED]
 *                         description: Slot status
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required
 *       404:
 *         description: Staff profile not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/lab-tech/available:
 *   get:
 *     tags: [appointments]
 *     summary: Get available laboratory technicians (Staff only)
 *     description: Retrieve list of available laboratory technicians that can be assigned to appointments
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Available laboratory technicians retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Laboratory technician user ID
 *                       first_name:
 *                         type: string
 *                         description: Laboratory technician first name
 *                       last_name:
 *                         type: string
 *                         description: Laboratory technician last name
 *                       email:
 *                         type: string
 *                         description: Laboratory technician email
 *                       phone_number:
 *                         type: string
 *                         description: Laboratory technician phone number
 *                       staff_profile:
 *                         type: object
 *                         properties:
 *                           status:
 *                             type: string
 *                             enum: [ACTIVE, INACTIVE]
 *                             description: Staff profile status
 *                           department:
 *                             type: string
 *                             description: Department ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/staff/available-for-slot/{slotId}:
 *   get:
 *     tags: [appointments]
 *     summary: Get available staff for a specific slot (Manager only)
 *     description: Retrieve list of staff members assigned to a slot who haven't reached their appointment limit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: slotId
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Available staff for slot retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: Staff user ID
 *                       first_name:
 *                         type: string
 *                         description: Staff first name
 *                       last_name:
 *                         type: string
 *                         description: Staff last name
 *                       email:
 *                         type: string
 *                         description: Staff email
 *                       appointment_count:
 *                         type: integer
 *                         description: Current number of appointments assigned to this staff in this slot
 *                         example: 2
 *                       appointment_limit:
 *                         type: integer
 *                         description: Maximum number of appointments this staff can handle in this slot
 *                         example: 3
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       404:
 *         description: Slot not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/appointment/{id}/unassign-staff:
 *   put:
 *     tags:
 *       - appointments
 *     summary: Unassign staff from appointment (Manager/Admin only)
 *     description: Remove the assigned staff from an appointment and update the slot's assigned_count
 *     operationId: unassignStaffFromAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Staff unassigned successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/AppointmentResponse'
 *                 message:
 *                   type: string
 *                   example: "Staff unassigned successfully"
 *       400:
 *         description: Invalid appointment ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager/Admin access required
 *       404:
 *         description: Appointment not found
 */


================================================
FILE: src/modules/appointment_log/appointment_log.constant.ts
================================================
import { AppointmentLogTypeEnum } from './appointment_log.enum';

export const AppointmentLogTypes = [
    '',
    AppointmentLogTypeEnum.PENDING,
    AppointmentLogTypeEnum.CONFIRMED,
    AppointmentLogTypeEnum.SAMPLE_COLLECTED,
    AppointmentLogTypeEnum.TESTING,
    AppointmentLogTypeEnum.COMPLETED,
    AppointmentLogTypeEnum.CANCELLED
];



================================================
FILE: src/modules/appointment_log/appointment_log.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IAppointmentLog } from './appointment_log.interface';
import AppointmentLogService from './appointment_log.service';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class AppointmentLogController {
    private appointmentLogService = new AppointmentLogService();

    /**
     * Get logs for a specific appointment
     */
    public getLogsByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            if (!appointmentId) {
                throw new HttpException(HttpStatus.BadRequest, 'Appointment ID is required');
            }

            const logs = await this.appointmentLogService.getLogsByAppointmentId(appointmentId, req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IAppointmentLog>>(logs));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/appointment_log/appointment_log.enum.ts
================================================
export enum AppointmentLogTypeEnum {
    PENDING = 'pending',
    CONFIRMED = 'confirmed',
    SAMPLE_ASSIGNED = 'sample_assigned',
    SAMPLE_COLLECTED = 'sample_collected',
    SAMPLE_RECEIVED = 'sample_received',
    TESTING = 'testing',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled',
    SAMPLE_CREATED = 'sample_created'
}




================================================
FILE: src/modules/appointment_log/appointment_log.interface.ts
================================================
import { Schema } from 'mongoose';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import { CollectionType } from '../appointment/appointment.interface';

export interface IAppointmentLog extends Document {
    _id: string;
    customer_id: string | undefined;
    staff_id: string | undefined;
    laboratory_technician_id: string | undefined;
    appointment_id: string | undefined;
    old_status: AppointmentLogTypeEnum;
    new_status: AppointmentLogTypeEnum;
    type: CollectionType;
    notes?: string;
    created_at: Date;
    updated_at: Date;
}



================================================
FILE: src/modules/appointment_log/appointment_log.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import { IAppointmentLog } from './appointment_log.interface';
import { CollectionTypes } from '../appointment';
import { COLLECTION_NAME } from '../../core/constants';

const AppointmentLogSchema = new Schema({
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    staff_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    laboratory_technician_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    old_status: { type: String, enum: AppointmentLogTypeEnum },
    new_status: { type: String, enum: AppointmentLogTypeEnum },
    type: { type: String, enum: CollectionTypes },
    notes: { type: String },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const AppointmentLog = mongoose.model<IAppointmentLog>(COLLECTION_NAME.APPOINTMENT_LOG, AppointmentLogSchema);

export default AppointmentLog;  



================================================
FILE: src/modules/appointment_log/appointment_log.repository.ts
================================================
import AppointmentLogSchema from './appointment_log.model';
import { IAppointmentLog } from './appointment_log.interface';

export default class AppointmentLogRepository {
    public async create(data: Partial<IAppointmentLog>): Promise<IAppointmentLog> {
        return AppointmentLogSchema.create(data);
    }

    public async findOne(query: any): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findOne(query);
    }

    public async findById(id: string): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IAppointmentLog>, options: any = {}): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findByIdAndUpdate(id, update, options) as Promise<IAppointmentLog | null>;
    }

    public async countDocuments(query: any): Promise<number> {
        return AppointmentLogSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IAppointmentLog[]> {
        return AppointmentLogSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IAppointmentLog[]> {
        return AppointmentLogSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IAppointmentLog[]> {
        return AppointmentLogSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('customer_id', '_id first_name last_name')
            .populate('staff_id', '_id first_name last_name')
            .populate('laboratory_technician_id', '_id first_name last_name')
            .populate('appointment_id');
    }

    public async findByIdWithPopulate(id: string): Promise<IAppointmentLog | null> {
        return AppointmentLogSchema.findById(id)
            .populate('customer_id', '_id first_name last_name')
            .populate('staff_id', '_id first_name last_name')
            .populate('laboratory_technician_id', '_id first_name last_name')
            .populate('appointment_id');
    }
} 


================================================
FILE: src/modules/appointment_log/appointment_log.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import AppointmentLogController from './appointment_log.controller';

export default class AppointmentLogRoute implements IRoute {
    public path = API_PATH.APPOINTMENT_LOG;
    public router = Router();
    private appointmentLogController = new AppointmentLogController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/appointment-logs/appointment/:appointmentId -> Get logs for a specific appointment
        this.router.get(
            `${API_PATH.GET_LOGS_BY_APPOINTMENT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.CUSTOMER]),
            this.appointmentLogController.getLogsByAppointmentId
        );
    }
} 


================================================
FILE: src/modules/appointment_log/appointment_log.service.ts
================================================
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IAppointmentLog } from './appointment_log.interface';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import AppointmentLogRepository from './appointment_log.repository';
import { IAppointment } from '../appointment/appointment.interface';
import { SearchPaginationResponseModel } from '../../core/models';
import mongoose from 'mongoose';
import { ISample } from '../sample/sample.interface';

export default class AppointmentLogService {
    private appointmentLogRepository = new AppointmentLogRepository();

    /**
     * Táº¡o log cho sá»± kiá»‡n táº¡o appointment
     * @param appointmentData ThÃ´ng tin appointment
     * @param oldStatus Tráº¡ng thÃ¡i cÅ© (null cho sá»± kiá»‡n táº¡o má»›i)
     * @param newStatus Tráº¡ng thÃ¡i má»›i
     */
    public async createAppointmentLog(
        appointmentData: IAppointment,
        oldStatus: AppointmentLogTypeEnum | undefined,
        newStatus: AppointmentLogTypeEnum
    ): Promise<IAppointmentLog> {
        try {
            const appointmentLog = await this.appointmentLogRepository.create({
                appointment_id: appointmentData._id as any,
                customer_id: appointmentData.user_id,
                staff_id: appointmentData.staff_id,
                old_status: oldStatus,
                new_status: newStatus,
                type: appointmentData.type,
                created_at: new Date(),
                updated_at: new Date()
            });

            return appointmentLog;
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating appointment log');
        }
    }

    /**
     * Log sá»± kiá»‡n táº¡o appointment
     * @param appointmentData ThÃ´ng tin appointment má»›i Ä‘Æ°á»£c táº¡o
     */
    public async logAppointmentCreation(appointmentData: IAppointment): Promise<IAppointmentLog> {
        return this.createAppointmentLog(
            appointmentData,
            undefined, // KhÃ´ng cÃ³ tráº¡ng thÃ¡i cÅ© cho sá»± kiá»‡n táº¡o má»›i
            appointmentData.status as unknown as AppointmentLogTypeEnum
        );
    }

    /**
     * Log sá»± kiá»‡n thay Ä‘á»•i tráº¡ng thÃ¡i appointment
     * @param appointmentData ThÃ´ng tin appointment Ä‘Ã£ Ä‘Æ°á»£c cáº­p nháº­t
     * @param oldStatus Tráº¡ng thÃ¡i cÅ©
     */
    public async logStatusChange(
        appointmentData: IAppointment,
        oldStatus: AppointmentLogTypeEnum
    ): Promise<IAppointmentLog> {
        return this.createAppointmentLog(
            appointmentData,
            oldStatus,
            appointmentData.status as unknown as AppointmentLogTypeEnum
        );
    }

    /**
     * Láº¥y logs cho má»™t appointment cá»¥ thá»ƒ
     * @param appointmentId ID cá»§a appointment
     * @param queryParams Tham sá»‘ truy váº¥n cho phÃ¢n trang
     */
    public async getLogsByAppointmentId(
        appointmentId: string,
        queryParams: any = {}
    ): Promise<SearchPaginationResponseModel<IAppointmentLog>> {
        if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
        }

        // Xá»­ lÃ½ tham sá»‘ truy váº¥n
        const { pageNum = 1, pageSize = 10 } = this.processQueryParams(queryParams);
        const skip = (pageNum - 1) * pageSize; // Bá» qua bao nhiÃªu logs

        // XÃ¢y dá»±ng truy váº¥n
        const query = { appointment_id: appointmentId };

        // Äáº¿m tá»•ng sá»‘ logs
        const totalItems = await this.appointmentLogRepository.countDocuments(query);
        const totalPages = Math.ceil(totalItems / pageSize);

        // Láº¥y logs vá»›i phÃ¢n trang vÃ  sáº¯p xáº¿p theo ngÃ y táº¡o (má»›i nháº¥t trÆ°á»›c)
        const logs = await this.appointmentLogRepository.findWithPopulate(
            query,
            { created_at: -1 }, // Sáº¯p xáº¿p theo ngÃ y táº¡o (má»›i nháº¥t trÆ°á»›c)
            skip,
            pageSize
        );

        return {
            pageData: logs,
            pageInfo: {
                pageNum,
                pageSize,
                totalItems,
                totalPages
            }
        };
    }

    /**
     * Process query parameters
     */
    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }

    /**
     * Log sample creation for an appointment
     * @param appointmentData The appointment data
     * @param samples The created samples
     */
    public async logSampleCreation(
        appointmentData: IAppointment,
        samples: ISample[]
    ): Promise<IAppointmentLog> {
        try {
            const sampleTypes = samples.map(sample => sample.type).join(', ');
            const notes = `Created ${samples.length} sample(s): ${sampleTypes}`;

            const appointmentLog = await this.appointmentLogRepository.create({
                appointment_id: appointmentData._id as any,
                customer_id: appointmentData.user_id,
                staff_id: appointmentData.staff_id,
                old_status: appointmentData.status as unknown as AppointmentLogTypeEnum,
                new_status: AppointmentLogTypeEnum.SAMPLE_CREATED,
                type: appointmentData.type,
                notes: notes,
                created_at: new Date(),
                updated_at: new Date()
            });

            return appointmentLog;
        } catch (error) {
            console.error('Error creating sample creation log:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating sample creation log');
        }
    }
} 


================================================
FILE: src/modules/appointment_log/index.ts
================================================
import AppointmentLogSchema from './appointment_log.model';
import { IAppointmentLog } from './appointment_log.interface';
import { AppointmentLogTypeEnum } from './appointment_log.enum';
import { AppointmentLogTypes } from './appointment_log.constant';
import AppointmentLogService from './appointment_log.service';
import AppointmentLogRepository from './appointment_log.repository';
import { CreateAppointmentLogDto } from './dtos/createAppointmentLog.dto';
import AppointmentLogController from './appointment_log.controller';
import AppointmentLogRoute from './appointment_log.route';

export {
    AppointmentLogSchema,
    IAppointmentLog,
    AppointmentLogTypeEnum,
    AppointmentLogTypes,
    AppointmentLogService,
    AppointmentLogRepository,
    CreateAppointmentLogDto,
    AppointmentLogController,
    AppointmentLogRoute
}; 


================================================
FILE: src/modules/appointment_log/dtos/createAppointmentLog.dto.ts
================================================
import { IsEnum, IsMongoId, IsOptional } from 'class-validator';
import { AppointmentLogTypeEnum } from '../appointment_log.enum';
import { TypeEnum } from '../../appointment/appointment.enum';

export class CreateAppointmentLogDto {
    @IsMongoId()
    appointment_id: string = '';

    @IsMongoId()
    customer_id: string = '';

    @IsMongoId()
    @IsOptional()
    staff_id?: string;

    @IsMongoId()
    @IsOptional()
    laboratory_technician_id?: string;

    @IsEnum(AppointmentLogTypeEnum)
    @IsOptional()
    old_status?: AppointmentLogTypeEnum;

    @IsEnum(AppointmentLogTypeEnum)
    new_status: AppointmentLogTypeEnum = AppointmentLogTypeEnum.PENDING;

    @IsEnum(TypeEnum)
    type: TypeEnum = TypeEnum.SELF;
} 


================================================
FILE: src/modules/appointment_log/swagger/appointment_log.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateAppointmentLogDto:
 *       type: object
 *       required:
 *         - appointment_id
 *         - customer_id
 *         - new_status
 *         - type
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment being logged
 *           example: "60d0fe4f5311236168a109ce"
 *         customer_id:
 *           type: string
 *           description: ID of the customer associated with the appointment
 *           example: "60d0fe4f5311236168a109cf"
 *         staff_id:
 *           type: string
 *           description: ID of the staff member handling the appointment (optional)
 *           example: "60d0fe4f5311236168a109cc"
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the laboratory technician processing the sample (optional)
 *           example: "60d0fe4f5311236168a109cd"
 *         old_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Previous status of the appointment (optional)
 *           example: "pending"
 *         new_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: New status of the appointment
 *           example: "confirmed"
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Type of sample collection
 *           example: "facility"
 *
 *     AppointmentLogResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Unique log identifier
 *           example: "60d0fe4f5311236168a109d0"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment information
 *           properties:
 *             _id:
 *               type: string
 *               description: Appointment ID
 *               example: "60d0fe4f5311236168a109ce"
 *             service_id:
 *               type: string
 *               description: Service ID
 *               example: "60d0fe4f5311236168a109ca"
 *             status:
 *               type: string
 *               description: Current appointment status
 *               example: "confirmed"
 *         customer_id:
 *           type: object
 *           description: Customer information
 *           properties:
 *             _id:
 *               type: string
 *               description: Customer ID
 *               example: "60d0fe4f5311236168a109cf"
 *             first_name:
 *               type: string
 *               description: Customer's first name
 *               example: "John"
 *             last_name:
 *               type: string
 *               description: Customer's last name
 *               example: "Doe"
 *             email:
 *               type: string
 *               description: Customer's email
 *               example: "john.doe@example.com"
 *         staff_id:
 *           type: object
 *           description: Staff information (if assigned)
 *           properties:
 *             _id:
 *               type: string
 *               description: Staff ID
 *               example: "60d0fe4f5311236168a109cc"
 *             first_name:
 *               type: string
 *               description: Staff's first name
 *               example: "Jane"
 *             last_name:
 *               type: string
 *               description: Staff's last name
 *               example: "Smith"
 *         laboratory_technician_id:
 *           type: object
 *           description: Laboratory technician information (if assigned)
 *           properties:
 *             _id:
 *               type: string
 *               description: Laboratory technician ID
 *               example: "60d0fe4f5311236168a109cd"
 *             first_name:
 *               type: string
 *               description: Technician's first name
 *               example: "Mark"
 *             last_name:
 *               type: string
 *               description: Technician's last name
 *               example: "Johnson"
 *         old_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Previous status of the appointment
 *           example: "pending"
 *         new_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: New status of the appointment
 *           example: "confirmed"
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Type of sample collection
 *           example: "facility"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Log creation date
 *           example: "2023-10-01T12:30:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Log last update date
 *           example: "2023-10-01T12:30:00Z"
 *
 *     AppointmentLogPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/AppointmentLogResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 15
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 2
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     SearchAppointmentLogParams:
 *       type: object
 *       properties:
 *         pageNum:
 *           type: integer
 *           description: Page number for pagination
 *           default: 1
 *           example: 1
 *         pageSize:
 *           type: integer
 *           description: Number of items per page
 *           default: 10
 *           example: 10
 *         old_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Filter by previous status
 *           example: "pending"
 *         new_status:
 *           type: string
 *           enum: [pending, confirmed, sample_collected, testing, completed, cancelled]
 *           description: Filter by new status
 *           example: "confirmed"
 *         customer_id:
 *           type: string
 *           description: Filter logs by customer ID
 *           example: "60d0fe4f5311236168a109cf"
 *         staff_id:
 *           type: string
 *           description: Filter logs by staff ID
 *           example: "60d0fe4f5311236168a109cc"
 *         date_from:
 *           type: string
 *           format: date
 *           description: Filter logs from this date
 *           example: "2023-10-01"
 *         date_to:
 *           type: string
 *           format: date
 *           description: Filter logs until this date
 *           example: "2023-10-31"
 *         type:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Filter by appointment type
 *           example: "facility"
 */



================================================
FILE: src/modules/appointment_log/swagger/appointment_log.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: appointment_logs
 *   description: Appointment log management APIs
 */

/**
 * @swagger
 * /api/appointment-logs/appointment/{appointmentId}:
 *   get:
 *     tags:
 *       - appointment_logs
 *     summary: Get logs by appointment ID (Admin, Manager, Customer)
 *     description: Retrieve the history of status changes and actions for a specific appointment
 *     operationId: getLogsByAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID to retrieve logs for
 *         example: "60d0fe4f5311236168a109ce"
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *         example: 1
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of logs per page
 *         example: 10
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           enum: [created_at]
 *         description: Field to sort results by
 *         example: "created_at"
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *         description: Sort order (ascending or descending)
 *         example: "desc"
 *     responses:
 *       200:
 *         description: List of appointment logs with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AppointmentLogPaginationResponse'
 *       400:
 *         description: Invalid appointment ID format or query parameters
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - User does not have permission to view these logs
 *       404:
 *         description: Appointment not found
 */


================================================
FILE: src/modules/auth/auth.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { API_PATH } from '../../core/constants';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import { IUser } from '../user';
import { TokenData } from './auth.interface';
import AuthService from './auth.service';
import LoginDto from './dtos/login.dto';
import LoginGoogleDto from './dtos/loginGoogle.dto';

export default class AuthController {
    private authService = new AuthService();

    public login = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: LoginDto | LoginGoogleDto = req.body;
            const isGoogle = req.route.path === API_PATH.AUTH_GOOGLE ? true : false;
            const tokenData: TokenData = await this.authService.login(model, isGoogle);
            res.status(HttpStatus.Success).json(formatResponse<TokenData>(tokenData));
        } catch (error) {
            next(error);
        }
    };

    public verifiedToken = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.verifiedTokenUser(req.body.token);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public resendToken = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.resendTokenUser(req.body.email);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public getCurrentLoginUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const user: IUser = await this.authService.getCurrentLoginUser(req.user.id);
            res.status(HttpStatus.Success).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public forgotPassword = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.forgotPassword(req.body.email);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public logout = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.authService.logout(req.user.id);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };
}



================================================
FILE: src/modules/auth/auth.interface.ts
================================================
import { UserRole } from '../user';

export interface DataStoredInToken {
    id: string;
    role: UserRole | string;
    version: number;
}

export interface TokenData {
    token: string;
}

export const UserInfoInTokenDefault = {
    id: '',
    role: '',
    version: 0
};



================================================
FILE: src/modules/auth/auth.repository.ts
================================================
import { IUser, UserSchema } from '../user';

export default class AuthRepository {
    public async findUserByEmail(email: string): Promise<IUser | null> {
        return UserSchema.findOne({ email }).exec();
    }

    public async findUserById(userId: string): Promise<IUser | null> {
        return UserSchema.findById(userId).lean();
    }

    public async findUserByVerificationToken(token: string): Promise<IUser | null> {
        return UserSchema.findOne({ verification_token: token });
    }

    public async updateUser(user: IUser): Promise<IUser> {
        return user.save();
    }

    public async updateUserById(userId: string, update: Partial<IUser>): Promise<IUser | null> {
        return UserSchema.findByIdAndUpdate(userId, update, { new: true });
    }
}



================================================
FILE: src/modules/auth/auth.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import AuthController from './auth.controller';
import EmailDto from './dtos/emai.dto';
import LoginDto from './dtos/login.dto';
import LoginGoogleDto from './dtos/loginGoogle.dto';
import VerifiedTokenDto from './dtos/verifiedToken.dto';

export default class AuthRoute implements IRoute {
    public path = API_PATH.AUTH;
    public router = Router();
    public authController = new AuthController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST domain:/api/auth -> Login normal
        this.router.post(this.path, validationMiddleware(LoginDto), this.authController.login);

        // POST domain:/api/auth/google -> Login via google
        this.router.post(API_PATH.AUTH_GOOGLE, validationMiddleware(LoginGoogleDto), this.authController.login);

        // POST domain:/api/auth/verify-token -> Verify token
        this.router.post(
            API_PATH.AUTH_VERIFY_TOKEN,
            this.authController.verifiedToken,
        );

        // POST domain:/api/auth/resend-token -> Resend token via email
        this.router.post(API_PATH.AUTH_RESEND_TOKEN, validationMiddleware(EmailDto), this.authController.resendToken);

        // GET domain:/api/auth -> Require Login
        this.router.get(this.path, authMiddleWare(), this.authController.getCurrentLoginUser);

        // PUT domain:/api/auth/forgot-password -> Forgot password
        this.router.put(
            API_PATH.AUTH_FORGOT_PASSWORD,
            validationMiddleware(EmailDto),
            this.authController.forgotPassword,
        );

        // GET domain:/api/auth/logout -> Logout user
        this.router.get(API_PATH.AUTH_LOGOUT, authMiddleWare(), this.authController.logout);
    }
}



================================================
FILE: src/modules/auth/auth.service.ts
================================================
import bcryptjs from 'bcryptjs';
import crypto from 'crypto';
import { OAuth2Client } from 'google-auth-library';
import moment from 'moment';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { createToken, createTokenVerifiedUser, encodePasswordUserNormal, isEmptyObject } from '../../core/utils';
import { sendMail } from '../../core/utils/sendMail';
import { IUser, UserSchema } from '../user';
import { TokenData } from './auth.interface';
import LoginDto from './dtos/login.dto';
import LoginGoogleDto from './dtos/loginGoogle.dto';
import AuthRepository from './auth.repository';
import { AdministrativeCaseSchema } from '../administrative_cases';


export default class AuthService {
    public userSchema = UserSchema;
    private authRepository = new AuthRepository();

    public async login(model: LoginDto | LoginGoogleDto, isGoogle = false): Promise<TokenData> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model user is empty');
        }

        let emailCheck = model.email;
        let userLogin = model;

        // login by google
        if (isGoogle) {
            if (model.google_id) {
                try {
                    const client = new OAuth2Client();
                    // check google_id is valid
                    const ticket = await client.verifyIdToken({
                        idToken: model.google_id,
                    });
                    console.log(ticket);
                    // get user info from ticket
                    const payload = ticket.getPayload();
                    // If payload already exists, assign email and emailCheck
                    if (payload) {
                        userLogin.email = payload.email!;
                        emailCheck = payload.email!;
                    }
                } catch (error) {
                    throw new HttpException(HttpStatus.BadRequest, 'Account google is incorrect, please try again!');
                }
            } else {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Field google_id via IdToken is empty, please send google_id!',
                );
            }
        }

        const user = await this.authRepository.findUserByEmail(emailCheck);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Your email: ${emailCheck} is not exists.`);
        }

        if (!user.is_verified) {
            throw new HttpException(HttpStatus.BadRequest, 'User is not verified! Please check your email in 24h!');
        }

        if (user.google_id && model.password) {
            throw new HttpException(HttpStatus.BadRequest, 'You must login by google!');
        }

        // login normal
        if (!isGoogle && model.password) {
            const isMatchPassword = await bcryptjs.compare(model.password, user.password!);
            if (!isMatchPassword) {
                throw new HttpException(HttpStatus.BadRequest, `Your password is incorrect!`);
            }
        }

        if (!user.status) {
            throw new HttpException(
                HttpStatus.Forbidden,
                `Your account has been locked. Please contact admin via mail to activate!`,
            );
        }

        if (user.is_deleted) {
            throw new HttpException(
                HttpStatus.Forbidden,
                `Your account has been deleted. Please contact admin via mail to help!`,
            );
        }

        if (!user.token_version) {
            user.token_version = 0;
        }

        return createToken(user);
    }

    public async verifiedTokenUser(verifiedToken: string): Promise<boolean> {
        const user = await this.authRepository.findUserByVerificationToken(verifiedToken);

        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Token is not valid.`);
        }
        // use moment to parse verification_token_expires with format 'ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'
        const tokenExpires = moment(
            user?.verification_token_expires?.toString(),
            'ddd MMM DD YYYY HH:mm:ss [GMT]ZZ',
        ).toDate();
        // if current time is after token expires => throw error
        if (moment(new Date()).isAfter(moment(tokenExpires))) {
            throw new HttpException(HttpStatus.BadRequest, `Token is expired!`);
        }

        user.is_verified = true;
        user.verification_token = undefined;
        user.verification_token_expires = undefined;
        user.updated_at = new Date();

        const updateUserId = await this.authRepository.updateUser(user);
        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async resendTokenUser(email: string): Promise<boolean> {
        const user = await this.authRepository.findUserByEmail(email);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `User with mail: ${email} is not exists.`);
        }

        if (user.is_verified) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `User with mail: ${email} has already verified their email.`,
            );
        }

        // create token verification
        const tokenData = createTokenVerifiedUser();
        user.is_verified = false;
        user.verification_token = tokenData.verification_token;
        user.verification_token_expires = tokenData.verification_token_expires;
        user.updated_at = new Date();
        const domain = process.env.DOMAIN_FE;

        // send mail with token
        const sendMailResult = await sendMail({
            toMail: user.email,
            subject: 'Verify your email address',
            content: `Hello, ${user.first_name} ${user.last_name}.\nPlease click the following link to verify your email address:\n${domain}/verify-email/${tokenData.verification_token}`,
        });
        if (!sendMailResult) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${user.email}`);
        }

        const updateUser = await this.authRepository.updateUser(user);
        if (!updateUser) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async getCurrentLoginUser(userId: string): Promise<IUser> {
        // Láº¥y user kÃ¨m staff_profile (náº¿u cÃ³)
        const user = await this.userSchema
            .findById(userId)
            .populate('staff_profile')
            .lean({ virtuals: true });

        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `User is not exists.`);
        }

        // Láº¥y cÃ¡c administrative cases mÃ  user lÃ  applicant_id
        // Náº¿u Ä‘Ã£ cÃ³ administrative_cases (khÃ´ng pháº£i máº£ng rá»—ng), khÃ´ng ghi Ä‘Ã¨
        let administrative_cases = user.administrative_cases;
        if (!Array.isArray(administrative_cases) || administrative_cases.length === 0) {
            administrative_cases = await AdministrativeCaseSchema.find({ applicant_id: userId });
        }
        user.administrative_cases = administrative_cases;

        // XÃ³a password náº¿u cÃ³
        if ('password' in user) {
            delete user.password;
        }

        return user as IUser;
    }

    public async forgotPassword(email: string): Promise<boolean> {
        const user = await this.userSchema.findOne({ email, is_deleted: false, is_verified: true });
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `User with mail: ${email} is not exists.`);
        }

        if (user.google_id) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Your account is logged in by google. Please contact google for reset password!`,
            );
        }

        // handle encode password
        const generateRandomPassword = this.generateRandomPassword(10);

        // send mail with new password
        const sendMailResult = await sendMail({
            toMail: user.email,
            subject: 'Generate new password for user',
            html: `Hello, ${user.first_name} ${user.last_name}.<br>This is a new password for ${user.email} is:<br><strong>${generateRandomPassword}</strong>`,
        });
        if (!sendMailResult) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${user.email}`);
        }

        const newPassword = await encodePasswordUserNormal(generateRandomPassword);
        user.password = newPassword;
        user.updated_at = new Date();
        const updateUser = await this.authRepository.updateUser(user);
        if (!updateUser) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async logout(userId: string): Promise<boolean> {
        const user = await this.authRepository.updateUserById(userId, { token_version: 1 });
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot logout!`);
        }
        return true;
    }

    private generateRandomPassword(length: number) {
        return crypto
            .randomBytes(length) // generate random bytes
            .toString('base64') // convert to base64
            .slice(0, length) // slice the length of the string, 0 is the start index, length is the end index
            .replace(/[^a-zA-Z0-9]/g, ''); // replace all non-alphanumeric characters with an empty string
    }
}



================================================
FILE: src/modules/auth/index.ts
================================================
import { DataStoredInToken, TokenData, UserInfoInTokenDefault } from './auth.interface';
import AuthRoute from './auth.route';

export { AuthRoute, DataStoredInToken, TokenData, UserInfoInTokenDefault };



================================================
FILE: src/modules/auth/dtos/emai.dto.ts
================================================
import { IsEmail, IsNotEmpty } from 'class-validator';

export default class EmailDto {
    constructor(email: string) {
        this.email = email;
    }

    @IsNotEmpty()
    @IsEmail()
    public email: string;
}



================================================
FILE: src/modules/auth/dtos/login.dto.ts
================================================
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export default class LoginDto {
    constructor(google_id: string, email: string, password: string) {
        this.google_id = google_id || '';
        this.email = email;
        this.password = password;
    }

    public google_id: string;

    @IsNotEmpty()
    @IsEmail()
    public email: string;

    @IsNotEmpty()
    @MinLength(6)
    public password: string;
}



================================================
FILE: src/modules/auth/dtos/loginGoogle.dto.ts
================================================
import { IsNotEmpty } from 'class-validator';

export default class LoginGoogleDto {
    constructor(google_id: string, email: string, password: string) {
        this.google_id = google_id;
        this.email = email;
        this.password = password;
    }

    @IsNotEmpty()
    public google_id: string;

    public email: string;

    public password: string;
}



================================================
FILE: src/modules/auth/dtos/verifiedToken.dto.ts
================================================
import { IsNotEmpty } from 'class-validator';

export default class VerifiedTokenDto {
    constructor(verifiedToken: string) {
        this.verifiedToken = verifiedToken;
    }

    @IsNotEmpty()
    public verifiedToken: string;
}



================================================
FILE: src/modules/auth/swagger/auth.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     LoginDto:
 *       type: object
 *       required:
 *         - email
 *         - password
 *       properties:
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *           example: "thichtamphuc@gmail.com"
 *         password:
 *           type: string
 *           description: User's password (minimum 6 characters)
 *           minLength: 6
 *           example: "123456"
 *     LoginGoogleDto:
 *       type: object
 *       properties:
 *         google_id:
 *           type: string
 *           description: Google ID token
 *
 *     VerifiedTokenDto:
 *       type: object
 *       required:
 *         - verifiedToken
 *       properties:
 *         verifiedToken:
 *           type: string
 *           description: Verification token sent to user's email
 *           example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 *
 *     EmailDto:
 *       type: object
 *       required:
 *         - email
 *       properties:
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *
 *     TokenResponse:
 *       type: object
 *       properties:
 *         token:
 *           type: string
 *           description: JWT authentication token
 *           example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 *         user:
 *           $ref: '#/components/schemas/UserResponse'
 *
 *     AuthErrorResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Error message
 *           example: "Invalid email or password"
 *         status:
 *           type: integer
 *           description: HTTP status code
 *           example: 401
 *
 *     ForgotPasswordResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Password reset email sent successfully"
 *         success:
 *           type: boolean
 *           description: Operation success status
 *           example: true
 *
 *     VerificationResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Email verified successfully"
 *         success:
 *           type: boolean
 *           description: Operation success status
 *           example: true
 *         user:
 *           $ref: '#/components/schemas/UserResponse'
 *
 *     LogoutResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Logged out successfully"
 *         success:
 *           type: boolean
 *           description: Operation success status
 *           example: true
 */



================================================
FILE: src/modules/auth/swagger/auth.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: auth
 *   description: Authentication APIs
 */

/**
 * @swagger
 * /api/auth:
 *   post:
 *     tags:
 *       - auth
 *     summary: Login with email and password
 *     description: Authenticate a user with email and password credentials
 *     operationId: login
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/LoginDto'
 *     responses:
 *       200:
 *         description: Login successful, returns authentication token and user information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/TokenResponse'
 *       400:
 *         description: Invalid input - email format invalid or password too short
 *       401:
 *         description: Authentication failed - wrong email or password
 *       404:
 *         description: User not found
 *       422:
 *         description: User account is inactive or email not verified
 *   
 *   get:
 *     tags:
 *       - auth
 *     summary: Get current logged-in user
 *     description: Retrieve information about the currently authenticated user
 *     operationId: getCurrentLoginUser
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Current user information retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       401:
 *         description: Unauthorized - valid authentication token required
 *       404:
 *         description: User not found or deleted
 */

/**
 * @swagger
 * /api/auth/google:
 *   post:
 *     tags:
 *       - auth
 *     summary: Login with Google
 *     description: Authenticate a user with Google credentials (create account if not exists)
 *     operationId: loginWithGoogle
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               google_id:
 *                 type: string
 *                 description: Google ID token
 *     responses:
 *       200:
 *         description: Login successful, returns authentication token and user information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/TokenResponse'
 *       201:
 *         description: New user created with Google credentials
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/TokenResponse'
 *       400:
 *         description: Invalid input - missing required fields
 *       422:
 *         description: User account is inactive
 */

/**
 * @swagger
 * /api/auth/verify-token:
 *   post:
 *     tags:
 *       - auth
 *     summary: Verify email with token
 *     description: Verify user's email address using the verification token sent via email
 *     operationId: verifyToken
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/VerifiedTokenDto'
 *     responses:
 *       200:
 *         description: Email verified successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/VerificationResponse'
 *       400:
 *         description: Invalid input - token missing or malformed
 *       404:
 *         description: User not found
 *       410:
 *         description: Token expired or invalid
 */

/**
 * @swagger
 * /api/auth/resend-token:
 *   post:
 *     tags:
 *       - auth
 *     summary: Resend verification token
 *     description: Resend the email verification token to the user's email address
 *     operationId: resendToken
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/EmailDto'
 *     responses:
 *       200:
 *         description: Verification token resent successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Verification token has been sent to your email"
 *                 success:
 *                   type: boolean
 *                   example: true
 *       400:
 *         description: Invalid input - email format invalid
 *       404:
 *         description: User not found with provided email
 *       409:
 *         description: Email already verified
 */

/**
 * @swagger
 * /api/auth/forgot-password:
 *   put:
 *     tags:
 *       - auth
 *     summary: Request password reset
 *     description: Send a password reset link to the user's email address
 *     operationId: forgotPassword
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/EmailDto'
 *     responses:
 *       200:
 *         description: Password reset email sent successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ForgotPasswordResponse'
 *       400:
 *         description: Invalid input - email format invalid
 *       404:
 *         description: User not found with provided email
 */

/**
 * @swagger
 * /api/auth/logout:
 *   get:
 *     tags:
 *       - auth
 *     summary: Logout current user
 *     description: Invalidate the current user's authentication token
 *     operationId: logout
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Logout successful
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/LogoutResponse'
 *       401:
 *         description: Unauthorized - valid authentication token required
 */



================================================
FILE: src/modules/blog/blog.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { IBlog } from './blog.interface';
import BlogService from './blog.service';
import { BlogResponseDto, BlogSearchDto, CreateBlogDto, UpdateBlogDto } from './dtos/blog.dto';
import { ILog } from './log/log.interface';
import { LogService } from './log';
import { plainToInstance } from 'class-transformer';
import { validateOrReject } from 'class-validator';
import { formatResponse } from '../../core/utils';
import { HttpException } from '../../core/exceptions';
import { SearchPaginationResponseModel } from '../../core/models';

// Define a type for the files object from multer's fields middleware
interface MulterFiles {
    [fieldname: string]: Express.Multer.File[];
}

class BlogController {
    private blogService = new BlogService();
    private logService = new LogService();

    public createBlog = async (req: Request, res: Response, next: NextFunction) => {
        try {
            console.log('Starting blog creation process...');
            const blogData = plainToInstance(CreateBlogDto, req.body);

            try {
                await validateOrReject(blogData);
            } catch (errors) {
                console.error('Validation errors:', errors);
                const validationErrors = errors as Array<{ property: string, constraints: Record<string, string> }>;
                const formattedErrors = validationErrors.map(error =>
                    Object.values(error.constraints || {}).join(', ')
                ).join('; ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${formattedErrors}`);
            }

            if (req.user && req.user.id) {
                blogData.user_id = req.user.id;
            } else {
                throw new HttpException(HttpStatus.Unauthorized, 'User authentication required');
            }

            // Handle boolean conversion for is_published if it's a string
            if (req.body.is_published !== undefined) {
                if (req.body.is_published === 'true') {
                    blogData.is_published = true;
                } else if (req.body.is_published === 'false') {
                    blogData.is_published = false;
                }
            }

            // Handle date conversion for published_at if it's a string
            if (req.body.published_at) {
                try {
                    const date = new Date(req.body.published_at);
                    // Check if the date is valid
                    if (isNaN(date.getTime())) {
                        console.error('Invalid date format for published_at:', req.body.published_at);
                        // Set to current date instead of invalid date
                        blogData.published_at = new Date();
                    } else {
                        blogData.published_at = date;
                    }
                } catch (error) {
                    console.error('Error converting published_at to Date:', error);
                    // Set to current date if conversion fails
                    blogData.published_at = new Date();
                }
            } else {
                // If no published_at provided, set to current date
                blogData.published_at = new Date();
            }

            // Add uploaded files to the DTO
            const files: Express.Multer.File[] = [];

            console.log('Checking for uploaded files...');
            if (req.files && typeof req.files === 'object') {
                console.log('Files found in request:', Object.keys(req.files));
                const multerFiles = req.files as MulterFiles;

                // Handle files from both 'images' and 'image_files' fields
                if (multerFiles['images'] && Array.isArray(multerFiles['images'])) {
                    console.log(`Found ${multerFiles['images'].length} files in 'images' field`);

                    // Validate each file to ensure it has the necessary properties
                    multerFiles['images'].forEach((file, index) => {
                        console.log(`Checking file ${index}:`, {
                            hasBuffer: !!file.buffer,
                            hasOriginalName: !!file.originalname,
                            hasMimetype: !!file.mimetype,
                            size: file.size
                        });

                        if (!file.buffer || !file.originalname || !file.mimetype) {
                            console.error('Invalid file object:', file);
                        } else {
                            files.push(file);
                        }
                    });
                }

                if (files.length > 0) {
                    console.log(`Adding ${files.length} valid files to blogData`);
                    blogData.files = files;
                } else {
                    console.log('No valid files found to upload');
                }
            } else {
                console.log('No files found in request');
            }

            // Check if required fields are present
            if (!blogData.service_id) {
                throw new HttpException(HttpStatus.BadRequest, 'service_id is required');
            }

            if (!blogData.blog_category_id) {
                throw new HttpException(HttpStatus.BadRequest, 'blog_category_id is required');
            }

            // save log in blog_logs collection
            console.log('Sending data to blog service for creation...');
            const blog: IBlog = await this.blogService.createBlog(blogData);
            console.log('Blog created successfully with ID:', blog._id);
            res.status(HttpStatus.Created).json(formatResponse<IBlog>(blog));
        } catch (error) {
            console.error('Controller error:', error);
            next(error);
        }
    };

    public updateBlog = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const blogData = plainToInstance(UpdateBlogDto, req.body);

            try {
                await validateOrReject(blogData);
            } catch (errors) {
                console.error('Validation errors:', errors);
                const validationErrors = errors as Array<{ property: string, constraints: Record<string, string> }>;
                const formattedErrors = validationErrors.map(error =>
                    Object.values(error.constraints || {}).join(', ')
                ).join('; ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${formattedErrors}`);
            }

            // Handle boolean conversion for is_published if it's a string
            if (req.body.is_published !== undefined) {
                if (req.body.is_published === 'true') {
                    blogData.is_published = true;
                } else if (req.body.is_published === 'false') {
                    blogData.is_published = false;
                }
            }

            // Handle date conversion for published_at if it's a string
            if (req.body.published_at) {
                try {
                    const date = new Date(req.body.published_at);
                    // Check if the date is valid
                    if (isNaN(date.getTime())) {
                        console.error('Invalid date format for published_at:', req.body.published_at);
                        // Set to current date instead of invalid date
                        blogData.published_at = new Date();
                    } else {
                        blogData.published_at = date;
                    }
                } catch (error) {
                    console.error('Error converting published_at to Date:', error);
                    // Set to current date if conversion fails
                    blogData.published_at = new Date();
                }
            }

            // Process uploaded files
            // Note: If new files are uploaded, they will REPLACE existing images, not add to them
            const files: Express.Multer.File[] = [];

            if (req.files && typeof req.files === 'object') {
                console.log('Update blog: Processing uploaded files');
                const multerFiles = req.files as MulterFiles;

                // Handle files from 'images' field
                if (multerFiles['images'] && Array.isArray(multerFiles['images'])) {
                    console.log(`Update blog: Found ${multerFiles['images'].length} image files`);
                    // Validate each file to ensure it has the necessary properties
                    multerFiles['images'].forEach((file, index) => {
                        console.log(`Checking file ${index}:`, {
                            hasBuffer: !!file.buffer,
                            hasOriginalName: !!file.originalname,
                            hasMimetype: !!file.mimetype,
                            size: file.size
                        });

                        if (!file.buffer || !file.originalname || !file.mimetype) {
                            console.error('Invalid file object:', file);
                        } else {
                            files.push(file);
                        }
                    });
                }

                if (files.length > 0) {
                    console.log(`Update blog: Adding ${files.length} valid files to update request`);
                    blogData.files = files;
                } else {
                    console.log('Update blog: No valid files found to upload');
                }
            }

            // Extract user_id from JWT token for author tracking
            const authorId = req.user?.id || '';
            if (!authorId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User authentication required');
            }

            console.log('Update blog: Sending update request to service');
            const blog: IBlog = await this.blogService.updateBlog(blogId, blogData, authorId);
            console.log('Update blog: Blog updated successfully');
            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            console.error('Controller error during update:', error);
            next(error);
        }
    };

    public uploadBlogImages = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const files: Express.Multer.File[] = [];

            // Check if files were uploaded from either field
            if (req.files && typeof req.files === 'object') {
                const multerFiles = req.files as MulterFiles;

                if (multerFiles['images'] && Array.isArray(multerFiles['images'])) {
                    // Validate each file to ensure it has the necessary properties
                    multerFiles['images'].forEach(file => {
                        if (!file.buffer || !file.originalname || !file.mimetype) {
                            console.error('Invalid file object:', file);
                        } else {
                            files.push(file);
                        }
                    });
                }
            }

            if (files.length === 0) {
                return res.status(HttpStatus.BadRequest).json({
                    status: HttpStatus.BadRequest,
                    message: 'No files uploaded'
                });
            }

            // This method is used for standalone image uploads separate from blog creation/update
            // It follows the same process: uploads to S3 and automatically generates metadata
            const blog = await this.blogService.uploadBlogImages(blogId, files);

            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            console.error('Controller error during image upload:', error);
            next(error);
        }
    };

    public deleteBlogImage = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const imageUrl = req.body.image_url;

            if (!imageUrl) {
                throw new HttpException(HttpStatus.BadRequest, 'Image URL is required');
            }

            const isDeleted = await this.blogService.deleteBlogImage(blogId, imageUrl);
            if (isDeleted) {
                res.status(HttpStatus.Success).json(formatResponse<string>('Deleted blog image successfully!'));
            } else {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
        } catch (error) {
            next(error);
        }
    };

    public deleteBlog = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const isDeleted = await this.blogService.deleteBlog(blogId);
            if (isDeleted) {
                res.status(HttpStatus.Success).json(formatResponse<string>('Deleted blog successfully!'));
            } else {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
        } catch (error) {
            next(error);
        }
    };

    public getBlogById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const blog: IBlog = await this.blogService.getBlogById(blogId);
            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            next(error);
        }
    };

    public getBlogBySlug = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slug = req.params.slug;
            const blog: IBlog = await this.blogService.getBlogBySlug(slug);
            res.status(HttpStatus.Success).json(formatResponse<IBlog>(blog));
        } catch (error) {
            next(error);
        }
    };

    public getBlogs = async (req: Request, res: Response, next: NextFunction) => {
        try {
            console.log('Controller: Fetching all blogs');
            const blogs: IBlog[] = await this.blogService.getBlogs();
            console.log(`Controller: Successfully fetched ${blogs.length} blogs`);
            res.status(HttpStatus.Success).json(formatResponse<IBlog[]>(blogs));
        } catch (error) {
            console.error('Controller error fetching blogs:', error);
            next(error);
        }
    };

    public searchBlogs = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
            // Check if there are any blogs in the database first
            try {
                const totalBlogsCount = await this.blogService.getTotalBlogsCount();
                console.log(`Controller: Total blogs in database: ${totalBlogsCount}`);

                if (totalBlogsCount === 0) {
                    console.log('Controller: No blogs found in database');
                    // If no blogs exist, return empty pagination result with correct structure
                    const emptyResult = new SearchPaginationResponseModel<IBlog>();
                    emptyResult.pageInfo.pageNum = 1;
                    emptyResult.pageInfo.pageSize = 10;
                    emptyResult.pageInfo.totalItems = 0;
                    emptyResult.pageInfo.totalPages = 0;
                    res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IBlog>>(emptyResult));
                    return;
                }
            } catch (error) {
                console.error('Controller: Error checking total blogs count:', error);
                // Continue with search even if this check fails
            }

            // Default search condition and pagination if not provided
            const searchCondition = req.body.searchCondition || {};
            console.log('Controller: Raw search condition:', JSON.stringify(searchCondition));

            // Initialize with empty object if searchCondition is null or undefined
            const searchData = plainToInstance(BlogSearchDto, searchCondition);

            try {
                // Skip validation if empty search condition (will return all blogs with pagination)
                if (Object.keys(searchCondition).length > 0) {
                    await validateOrReject(searchData);
                }
                console.log('Controller: Search data validation passed');
            } catch (validationErrors) {
                console.error('Controller: Search data validation failed:', validationErrors);
                // Extract specific validation error messages for better debugging
                const errorDetails = Array.isArray(validationErrors)
                    ? validationErrors.map(err => Object.values(err.constraints || {}).join(', ')).join('; ')
                    : 'Validation failed';

                throw new HttpException(HttpStatus.BadRequest, `Invalid search parameters: ${errorDetails}`);
            }

            // Ensure pageInfo has valid values
            const pageInfo = req.body.pageInfo || { pageNum: 1, pageSize: 10 };
            const pageNum = parseInt(pageInfo.pageNum) || 1;
            const pageSize = parseInt(pageInfo.pageSize) || 10;

            console.log(`Controller: Searching blogs with pageNum=${pageNum}, pageSize=${pageSize}`);
            console.log('Controller: Search conditions:', JSON.stringify(searchData));

            const searchResult = await this.blogService.searchBlogs(searchData, pageNum, pageSize);

            console.log(`Controller: Search completed, found ${searchResult.pageData.length} blogs`);
            console.log(`Controller: Total items: ${searchResult.pageInfo.totalItems}, Total pages: ${searchResult.pageInfo.totalPages}`);
            console.log('Controller: Search result structure:', JSON.stringify({
                hasPageData: !!searchResult.pageData,
                pageDataLength: searchResult.pageData?.length || 0,
                hasPageInfo: !!searchResult.pageInfo,
                pageInfoProps: searchResult.pageInfo ? Object.keys(searchResult.pageInfo) : []
            }));

            // Format the response exactly as the frontend expects it
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IBlog>>(searchResult));
        } catch (error) {
            console.error('Controller error during blog search:', error);
            next(error);
        }
    };

    public getBlogLogs = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.id;
            const logs: ILog[] = await this.logService.getLogsByBlogId(blogId);
            res.status(HttpStatus.Success).json(formatResponse<ILog[]>(logs));
        } catch (error) {
            next(error);
        }
    };
}

export default BlogController;



================================================
FILE: src/modules/blog/blog.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IBlogImage {
    name: string;
    image_url: string;
    created_at: Date;
}

export interface IBlog extends Document {
    _id: string;
    title: string;
    content: string;
    slug: string;
    user_id: string | undefined;
    service_id: string | undefined;
    blog_category_id: string | undefined;
    is_published: boolean;
    published_at?: Date;
    images?: IBlogImage[];
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
} 


================================================
FILE: src/modules/blog/blog.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IBlog } from './blog.interface';

const BlogImageSchema = new Schema({
    name: { type: String, required: true },
    image_url: { type: String, required: true },
    created_at: { type: Date, default: Date.now }
});

const BlogSchemaEntity: Schema<IBlog> = new Schema({
    title: { type: String, required: true },
    content: { type: String, required: true },
    slug: { type: String, required: true, unique: true },
    user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE, required: true },
    blog_category_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG_CATEGORY, required: true },
    is_published: { type: Boolean, default: true },
    published_at: { type: Date, default: Date.now },
    images: [BlogImageSchema],
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false }
});

const BlogSchema = mongoose.model<IBlog & mongoose.Document>(
    COLLECTION_NAME.BLOG,
    BlogSchemaEntity
);

export default BlogSchema; 


================================================
FILE: src/modules/blog/blog.repository.ts
================================================
import { IBlog } from "./blog.interface";
import BlogSchemaEntity from "./blog.model";
import mongoose from "mongoose";
import { BlogSearchDto } from "./dtos/blog.dto";

export default class BlogRepository {
    public async createBlog(model: IBlog): Promise<IBlog> {
        try {
            return await BlogSchemaEntity.create(model);
        } catch (error) {
            console.error('Repository error creating blog:', error);
            throw error;
        }
    }

    public async updateBlog(id: string, model: Partial<IBlog>): Promise<IBlog | null> {
        try {
            console.log(`Repository: Updating blog ${id} with data:`, JSON.stringify(model));
            const blog = await BlogSchemaEntity.findByIdAndUpdate(
                id,
                { ...model, updated_at: new Date() },
                { new: true }
            );
            console.log(`Repository: Blog ${id} update result:`, blog ? 'Success' : 'Not found');
            return blog;
        } catch (error) {
            console.error(`Repository error updating blog ${id}:`, error);
            throw error;
        }
    }

    public async deleteBlog(id: string): Promise<IBlog | null> {
        return BlogSchemaEntity.findByIdAndUpdate(
            id,
            { is_deleted: true, updated_at: new Date() },
            { new: true }
        );
    }

    public async getBlogById(id: string): Promise<IBlog | null> {
        return BlogSchemaEntity.findById(id).where({ is_deleted: false });
    }

    public async getBlogBySlug(slug: string): Promise<IBlog | null> {
        return BlogSchemaEntity.findOne({ slug, is_deleted: false });
    }

    public async checkSlugExists(slug: string, excludeId?: string): Promise<boolean> {
        const query: any = { slug, is_deleted: false };

        // If excludeId is provided, exclude that blog from the check
        // This is useful when updating a blog to check if the slug exists for any blog other than the current one
        if (excludeId) {
            query._id = { $ne: excludeId };
        }

        const count = await BlogSchemaEntity.countDocuments(query);
        return count > 0;
    }

    public async getBlogs(): Promise<IBlog[]> {
        try {
            console.log('Repository: Fetching all non-deleted blogs');
            const blogs = await BlogSchemaEntity.find({ is_deleted: false })
                .sort({ created_at: -1 });
            console.log(`Repository: Found ${blogs.length} blogs`);
            return blogs;
        } catch (error) {
            console.error('Repository error fetching blogs:', error);
            throw error;
        }
    }

    /**
     * Get the total count of non-deleted blogs in the database
     */
    public async getTotalBlogsCount(): Promise<number> {
        try {
            console.log('Repository: Counting all non-deleted blogs');
            const count = await BlogSchemaEntity.countDocuments({ is_deleted: false });
            console.log(`Repository: Total non-deleted blogs: ${count}`);
            return count;
        } catch (error) {
            console.error('Repository error counting all blogs:', error);
            throw error;
        }
    }

    public async searchBlogs(searchParams: BlogSearchDto): Promise<IBlog[]> {
        const query: any = { is_deleted: false };

        if (searchParams.title) {
            query.title = { $regex: searchParams.title, $options: 'i' };
        }

        if (searchParams.blog_category_id) {
            query.blog_category_id = searchParams.blog_category_id;
        }

        if (searchParams.user_id) {
            query.user_id = searchParams.user_id;
        }

        if (searchParams.service_id) {
            query.service_id = searchParams.service_id;
        }

        if (searchParams.is_published !== undefined) {
            query.is_published = searchParams.is_published;
        }

        return BlogSchemaEntity.find(query);
    }

    public async countBlogs(searchParams: BlogSearchDto): Promise<number> {
        try {
            console.log('Repository: Counting blogs with search params:', JSON.stringify(searchParams));
            const query: any = { is_deleted: false };

            if (searchParams.title) {
                query.title = { $regex: searchParams.title, $options: 'i' };
            }

            // Build $or conditions for ID fields to handle potential schema inconsistencies
            const orConditions = [];

            if (searchParams.blog_category_id) {
                orConditions.push(
                    { blog_category_id: searchParams.blog_category_id },
                    { blog_category_id: searchParams.blog_category_id.toString() }
                );
            }

            if (searchParams.user_id) {
                orConditions.push(
                    { user_id: searchParams.user_id },
                    { user_id: searchParams.user_id.toString() }
                );
            }

            if (searchParams.service_id) {
                orConditions.push(
                    { service_id: searchParams.service_id },
                    { service_id: searchParams.service_id.toString() }
                );
            }

            // Add $or conditions to query if any exist
            if (orConditions.length > 0) {
                query.$or = orConditions;
            }

            if (searchParams.is_published !== undefined) {
                query.is_published = searchParams.is_published;
            }

            console.log('Repository: Final count query:', JSON.stringify(query));

            // First try with the specific query
            let count = await BlogSchemaEntity.countDocuments(query);
            console.log(`Repository: Found ${count} matching blogs with specific query`);

            // If no results and we have filters, try a fallback count of all non-deleted blogs
            if (count === 0 && Object.keys(query).length > 1) {
                const fallbackCount = await BlogSchemaEntity.countDocuments({ is_deleted: false });
                console.log(`Repository: Fallback count of all non-deleted blogs: ${fallbackCount}`);

                if (fallbackCount > 0) {
                    console.log('Repository: Using fallback count instead');
                    count = fallbackCount;
                }
            }

            return count;
        } catch (error) {
            console.error('Repository error counting blogs:', error);
            throw error;
        }
    }

    public async getBlogsWithPagination(query: any, skip: number, limit: number): Promise<IBlog[]> {
        try {
            console.log(`Repository: Getting paginated blogs with skip=${skip}, limit=${limit}`);
            console.log('Repository: Query:', JSON.stringify(query));

            // Ensure skip and limit are valid numbers
            const validSkip = Math.max(0, skip || 0);
            const validLimit = Math.max(1, Math.min(100, limit || 10));

            // Add explicit sorting to ensure consistent results
            const blogs = await BlogSchemaEntity.find(query)
                .skip(validSkip)
                .limit(validLimit)
                .sort({ created_at: -1 })
                .lean()  // Convert to plain JavaScript objects for better performance
                .exec(); // Explicitly execute the query

            // Ensure we always return an array
            const safeBlogs = Array.isArray(blogs) ? blogs : [];

            console.log(`Repository: Retrieved ${safeBlogs.length} blogs`);

            // Log a sample of the first blog for debugging (if available)
            if (safeBlogs.length > 0) {
                const sampleBlog = { ...safeBlogs[0] };
                if (sampleBlog.content && sampleBlog.content.length > 100) {
                    sampleBlog.content = sampleBlog.content.substring(0, 100) + '...';
                }
                console.log('Repository: Sample blog:', JSON.stringify(sampleBlog));
            } else {
                console.log('Repository: No blogs found with query:', JSON.stringify(query));

                // Debug: Try a simple query to check if any blogs exist
                const totalBlogsCount = await BlogSchemaEntity.countDocuments({ is_deleted: false });
                console.log(`Repository: Total non-deleted blogs in database: ${totalBlogsCount}`);

                if (totalBlogsCount > 0) {
                    // Get a sample blog to check schema
                    const sampleBlog = await BlogSchemaEntity.findOne({ is_deleted: false }).lean();
                    if (sampleBlog) {
                        console.log('Repository: Sample blog from database:', JSON.stringify({
                            id: sampleBlog._id,
                            title: sampleBlog.title,
                            fields: Object.keys(sampleBlog)
                        }));
                    }
                }
            }

            return safeBlogs;
        } catch (error) {
            console.error('Repository error getting paginated blogs:', error);
            // Return empty array instead of throwing to prevent complete failure
            // The service layer can handle this appropriately
            return [];
        }
    }
}



================================================
FILE: src/modules/blog/blog.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import multer from 'multer';
import { UserRoleEnum } from '../user/user.enum';
import BlogController from './blog.controller';
import { CreateBlogDto, UpdateBlogDto } from './dtos/blog.dto';

export default class BlogRoute implements IRoute {
    public path = API_PATH.BLOG;
    public router = Router();
    public blogController = new BlogController();

    // Configure multer for memory storage
    private storage = multer.memoryStorage();
    private upload = multer({
        storage: this.storage,
        limits: {
            fileSize: 5 * 1024 * 1024 // 5MB max file size
        },
        fileFilter: (req, file, cb) => {
            // Accept only image files
            if (!file.originalname.match(/\.(jpg|jpeg|png|gif)$/i)) {
                return cb(null, false);
            }
            cb(null, true);
        }
    });

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {

        // POST: domain:/api/blog/create -> Create blog with image upload
        // Uses multer middleware to handle multipart/form-data form with image uploads
        this.router.post(
            `${this.path}/create`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.upload.fields([
                { name: 'images', maxCount: 10 }
            ]),
            validationMiddleware(CreateBlogDto, true),
            this.blogController.createBlog
        );

        // GET: domain:/api/blog/:id -> Get blog by id
        this.router.get(
            `${this.path}/:id`,
            this.blogController.getBlogById
        );

        // GET: domain:/api/blog/slug/:slug -> Get blog by slug
        this.router.get(
            `${this.path}/slug/:slug`,
            this.blogController.getBlogBySlug
        );

        // GET: domain:/api/blog -> Get all blogs
        this.router.get(
            `${this.path}`,
            this.blogController.getBlogs
        );

        // POST: domain:/api/blog/search -> Search blogs
        this.router.post(
            `${this.path}/search`,
            this.blogController.searchBlogs
        );

        // GET: domain:/api/blog/:id/logs -> Get blog logs
        this.router.get(
            `${this.path}/:id/logs`,
            this.blogController.getBlogLogs
        );

        // DELETE: domain:/api/blog/:id/image -> Delete image from blog
        this.router.delete(
            `${this.path}/:id/image`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.blogController.deleteBlogImage
        );

        // PUT: domain:/api/blog/:id -> Update blog with image upload
        // Uses multer middleware to handle multipart/form-data form with image uploads
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.upload.fields([
                { name: 'images', maxCount: 10 }
            ]),
            validationMiddleware(UpdateBlogDto, true),
            this.blogController.updateBlog
        );

        // DELETE: domain:/api/blog/:id -> Delete blog
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.blogController.deleteBlog
        );
    }
}



================================================
FILE: src/modules/blog/blog.service.ts
================================================
import { UserRoleEnum, UserSchema } from "../user";
import mongoose, { Schema } from "mongoose";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { isEmptyObject } from "../../core/utils";
import { IBlog, IBlogImage } from "./blog.interface";
import BlogRepository from "./blog.repository";
import { BlogSearchDto, CreateBlogDto, UpdateBlogDto } from "./dtos/blog.dto";
import { ILog } from "./log/log.interface";
import LogService from "./log/log.service";
import { uploadMultipleFilesToS3, s3Folders } from "../../core/utils/s3Upload";

export default class BlogService {
    private blogRepository = new BlogRepository();
    private logService = new LogService();

    public async createBlog(createBlogDto: CreateBlogDto): Promise<IBlog> {
        try {
            console.log('Blog service: Starting blog creation...');
            // Generate a unique slug based on the title if not provided
            if (!createBlogDto.slug) {
                createBlogDto.slug = await this.generateSlug(createBlogDto.title);
            } else {
                // If slug is provided, ensure it's unique
                createBlogDto.slug = await this.generateSlug(createBlogDto.slug);
            }

            // Set default values for is_published and published_at if not provided
            if (createBlogDto.is_published === undefined) {
                createBlogDto.is_published = true;
            }

            // Ensure published_at is a valid date
            if (!createBlogDto.published_at || isNaN(createBlogDto.published_at.getTime())) {
                createBlogDto.published_at = new Date();
            }

            // Handle file uploads if files are provided
            if (createBlogDto.files && createBlogDto.files.length > 0) {
                console.log(`Blog service: Processing ${createBlogDto.files.length} files for upload`);
                try {
                    // Create blog first to get the ID
                    console.log('Blog service: Creating blog in database...');
                    const blog = await this.blogRepository.createBlog(createBlogDto as unknown as IBlog);
                    console.log(`Blog service: Blog created with ID: ${blog._id}`);

                    try {
                        // Upload images to S3 - this will store files in the blog-images/[blog_id] folder
                        const blogFolder = s3Folders.blogImages;
                        console.log(`Blog service: Uploading files to S3 folder: ${blogFolder}/${blog._id}`);
                        const imageUrls = await uploadMultipleFilesToS3(createBlogDto.files, blog._id, blogFolder);
                        console.log(`Blog service: ${imageUrls.length} files uploaded successfully`);

                        // Create image objects with auto-generated metadata:
                        // - name: original filename from the uploaded file
                        // - image_url: AWS S3 URL returned from the upload function
                        // - created_at: current timestamp
                        const blogImages: IBlogImage[] = imageUrls.map((url, index) => ({
                            name: createBlogDto.files![index].originalname,
                            image_url: url,
                            created_at: new Date()
                        }));
                        console.log('Blog service: Created image metadata objects:', blogImages);

                        // Update blog with images
                        console.log(`Blog service: Updating blog ${blog._id} with ${blogImages.length} images`);
                        const updatedBlog = await this.blogRepository.updateBlog(blog._id, {
                            images: blogImages,
                            updated_at: new Date()
                        });
                        console.log('Blog service: Blog updated with images successfully');

                        return updatedBlog || blog;
                    } catch (uploadError) {
                        console.error('Error uploading images to S3:', uploadError);

                        // Even if image upload fails, return the blog without images
                        return blog;
                    }
                } catch (dbError) {
                    console.error('Error creating blog in database:', dbError);
                    throw dbError;
                }
            } else {
                // Create blog without images
                console.log('Blog service: No files to upload, creating blog without images');
                const blog = await this.blogRepository.createBlog(createBlogDto as unknown as IBlog);
                return blog;
            }
        } catch (error) {
            console.error('Blog creation error:', error);
            if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            } else if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating blog');
        }
    }

    public async updateBlog(id: string, updateBlogDto: UpdateBlogDto, authorId: string): Promise<IBlog> {
        try {
            const existingBlog = await this.blogRepository.getBlogById(id);
            if (!existingBlog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            // If slug is being updated, ensure it's unique
            if (updateBlogDto.slug && updateBlogDto.slug !== existingBlog.slug) {
                updateBlogDto.slug = await this.generateSlug(updateBlogDto.slug, id);
            }
            // If title is being updated but slug isn't, update the slug based on the new title
            else if (updateBlogDto.title && !updateBlogDto.slug && updateBlogDto.title !== existingBlog.title) {
                updateBlogDto.slug = await this.generateSlug(updateBlogDto.title, id);
            }

            // Ensure published_at is a valid date if provided
            if (updateBlogDto.published_at !== undefined) {
                if (!updateBlogDto.published_at || isNaN(updateBlogDto.published_at.getTime())) {
                    updateBlogDto.published_at = new Date();
                }
            }

            // Handle file uploads if files are provided
            if (updateBlogDto.files && updateBlogDto.files.length > 0) {
                console.log(`Blog update: Processing ${updateBlogDto.files.length} new image files`);
                try {
                    // Upload images to S3 - this will store files in the blog-images/[blog_id] folder
                    const blogFolder = s3Folders.blogImages;
                    const imageUrls = await uploadMultipleFilesToS3(updateBlogDto.files, id, blogFolder);

                    // Create image objects with auto-generated metadata:
                    // - name: original filename from the uploaded file
                    // - image_url: AWS S3 URL returned from the upload function
                    // - created_at: current timestamp
                    const blogImages: IBlogImage[] = imageUrls.map((url, index) => ({
                        name: updateBlogDto.files![index].originalname,
                        image_url: url,
                        created_at: new Date()
                    }));

                    // Replace existing images with new ones instead of adding to them
                    // This fixes the bug where images accumulate on each update
                    updateBlogDto.images = blogImages;
                    console.log(`Blog update: Replacing existing images with ${blogImages.length} new images`);
                } catch (uploadError) {
                    console.error('Error uploading images to S3 during update:', uploadError);
                    // Continue with the update without changing images
                }
            } else if (updateBlogDto.images === undefined) {
                // If no new files are uploaded and images field is not explicitly set,
                // preserve the existing images
                updateBlogDto.images = existingBlog.images || [];
                console.log('Blog update: No new images provided, keeping existing images');
            }

            // Create log entry for the update
            await this.createBlogLog(existingBlog, updateBlogDto, authorId);

            const updatedBlog = await this.blogRepository.updateBlog(id, updateBlogDto as Partial<IBlog>);
            if (!updatedBlog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return updatedBlog;
        } catch (error) {
            console.error(`Blog update error for ID ${id}:`, error);
            if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            } else if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating blog');
        }
    }

    /**
     * Uploads images to an existing blog
     * Note: This method is primarily used internally by the createBlog and updateBlog methods
     * It's not exposed as a separate API endpoint as image uploads are integrated directly into
     * the blog creation and update processes
     * 
     * @param blogId The ID of the blog to upload images to
     * @param files The files to upload
     * @returns The updated blog with the new images
     */
    public async uploadBlogImages(blogId: string, files: Express.Multer.File[]): Promise<IBlog> {
        try {
            console.log(`uploadBlogImages: Processing ${files.length} files for blog ${blogId}`);

            // Check if blog exists
            const blog = await this.blogRepository.getBlogById(blogId);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            // Create a folder specific to this blog
            const blogFolder = s3Folders.blogImages;

            try {
                // Log file details for debugging
                files.forEach((file, index) => {
                    console.log(`File ${index} details:`, {
                        originalname: file.originalname,
                        mimetype: file.mimetype,
                        size: file.size,
                        hasBuffer: !!file.buffer,
                        hasPath: !!file.path
                    });
                });

                // Upload images to S3
                console.log(`Uploading files to S3 folder: ${blogFolder}/${blogId}`);
                const imageUrls = await uploadMultipleFilesToS3(files, blogId, blogFolder);
                console.log(`Successfully uploaded ${imageUrls.length} files to S3`);

                // Create image objects
                const blogImages: IBlogImage[] = imageUrls.map((url, index) => ({
                    name: files[index].originalname,
                    image_url: url,
                    created_at: new Date()
                }));
                console.log('Created image metadata objects:', blogImages);

                // Replace existing images with new ones (not adding to them)
                console.log(`Replacing ${blog.images?.length || 0} existing images with ${blogImages.length} new images`);

                // Update blog with new images
                const updatedBlog = await this.blogRepository.updateBlog(blogId, {
                    images: blogImages, // Replace existing images
                    updated_at: new Date()
                });

                if (!updatedBlog) {
                    throw new HttpException(HttpStatus.NotFound, 'Blog not found');
                }

                console.log('Blog successfully updated with new images');
                return updatedBlog;
            } catch (uploadError) {
                console.error('Error uploading images to S3:', uploadError);
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload files to S3');
            }
        } catch (error) {
            console.error(`Error in uploadBlogImages for blog ID ${blogId}:`, error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error uploading blog images');
        }
    }

    public async deleteBlogImage(blogId: string, imageUrl: string): Promise<boolean> {
        try {
            // Check if blog exists
            const blog = await this.blogRepository.getBlogById(blogId);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            // Check if blog has images
            if (!blog.images || blog.images.length === 0) {
                throw new HttpException(HttpStatus.NotFound, 'Blog has no images');
            }

            // Filter out the image to delete
            const updatedImages = blog.images.filter(image => image.image_url !== imageUrl);

            // Check if image was found
            if (updatedImages.length === blog.images.length) {
                throw new HttpException(HttpStatus.NotFound, 'Image not found');
            }

            // Update blog with filtered images
            const updatedBlog = await this.blogRepository.updateBlog(blogId, {
                images: updatedImages,
                updated_at: new Date()
            });

            if (!updatedBlog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }

            return true;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting blog image');
        }
    }

    public async deleteBlog(id: string): Promise<boolean> {
        try {
            const blog = await this.blogRepository.deleteBlog(id);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return true;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting blog');
        }
    }

    public async getBlogById(id: string): Promise<IBlog> {
        try {
            const blog = await this.blogRepository.getBlogById(id);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return blog;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog');
        }
    }

    public async getBlogBySlug(slug: string): Promise<IBlog> {
        try {
            const blog = await this.blogRepository.getBlogBySlug(slug);
            if (!blog) {
                throw new HttpException(HttpStatus.NotFound, 'Blog not found');
            }
            return blog;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog by slug');
        }
    }

    public async getBlogs(): Promise<IBlog[]> {
        try {
            console.log('Blog service: Fetching all blogs');
            const blogs = await this.blogRepository.getBlogs();
            console.log(`Blog service: Successfully fetched ${blogs.length} blogs`);
            return blogs;
        } catch (error) {
            console.error('Error fetching blogs:', error);
            if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            } else if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blogs');
        }
    }

    /**
     * Get the total count of non-deleted blogs in the database
     * This is useful for quickly checking if there are any blogs before performing a search
     */
    public async getTotalBlogsCount(): Promise<number> {
        try {
            console.log('Blog service: Getting total blogs count');
            const count = await this.blogRepository.getTotalBlogsCount();
            console.log(`Blog service: Total blogs count: ${count}`);
            return count;
        } catch (error) {
            console.error('Error getting total blogs count:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting total blogs count');
        }
    }

    public async searchBlogs(searchParams: BlogSearchDto, pageNum: number, pageSize: number): Promise<SearchPaginationResponseModel<IBlog>> {
        try {
            const query: any = { is_deleted: false };

            if (searchParams.title) {
                query.title = { $regex: searchParams.title, $options: 'i' };
            }

            // Simply use the ID strings directly without ObjectId conversion
            if (searchParams.blog_category_id) {
                // Try both formats (string and ObjectId) to handle potential schema inconsistencies
                query.$or = [
                    { blog_category_id: searchParams.blog_category_id },
                    { blog_category_id: searchParams.blog_category_id.toString() }
                ];
            }

            if (searchParams.user_id) {
                if (!query.$or) query.$or = [];
                query.$or.push(
                    { user_id: searchParams.user_id },
                    { user_id: searchParams.user_id.toString() }
                );
            }

            if (searchParams.service_id) {
                if (!query.$or) query.$or = [];
                query.$or.push(
                    { service_id: searchParams.service_id },
                    { service_id: searchParams.service_id.toString() }
                );
            }

            if (searchParams.is_published !== undefined) {
                query.is_published = searchParams.is_published;
            }

            // Count total items matching the query
            const totalItems = await this.blogRepository.countBlogs(searchParams);
            // Ensure pagination values are valid numbers
            const validPageNum = Math.max(1, pageNum || 1);
            const validPageSize = Math.max(1, Math.min(100, pageSize || 10)); // Limit max page size to 100

            // Calculate pagination values
            const totalPages = Math.ceil(totalItems / validPageSize);
            const skip = (validPageNum - 1) * validPageSize;

            // Get paginated results
            const blogs = await this.blogRepository.getBlogsWithPagination(query, skip, validPageSize);
            // If no blogs found with the query, try a fallback query to get any blogs
            if (blogs.length === 0 && Object.keys(query).length > 1) {
                console.log('Blog service: No blogs found with specific query, trying fallback query');
                const fallbackQuery = { is_deleted: false };
                const fallbackBlogs = await this.blogRepository.getBlogsWithPagination(
                    fallbackQuery, 0, validPageSize
                );

                if (fallbackBlogs.length > 0) {
                    // Use the fallback blogs but keep original pagination info
                    return new SearchPaginationResponseModel<IBlog>(
                        fallbackBlogs,
                        {
                            pageNum: validPageNum,
                            pageSize: validPageSize,
                            totalItems,
                            totalPages
                        }
                    );
                }
            }

            // Ensure blogs is always an array
            const safeBlogs = Array.isArray(blogs) ? blogs : [];

            // Create and return the search pagination response with proper structure
            const response = new SearchPaginationResponseModel<IBlog>(
                safeBlogs,
                {
                    pageNum: validPageNum,
                    pageSize: validPageSize,
                    totalItems,
                    totalPages
                }
            );
            return response;
        } catch (error) {
            console.error('Error searching blogs:', error);
            if (error instanceof HttpException) {
                throw error;
            } else if (error instanceof mongoose.Error.ValidationError) {
                const errorMessages = Object.values(error.errors).map(err => err.message).join(', ');
                throw new HttpException(HttpStatus.BadRequest, `Validation error: ${errorMessages}`);
            } else if (error instanceof mongoose.Error.CastError) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid ID format: ${error.path}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching blogs');
        }
    }

    /**
     * Generates a unique slug based on the provided text
     * @param text The text to generate a slug from
     * @param excludeId Optional blog ID to exclude from uniqueness check
     * @returns A unique slug
     */
    public async generateSlug(text: string, excludeId?: string): Promise<string> {
        // Convert to lowercase, replace spaces and special chars with hyphens
        let slug = text
            .toLowerCase()
            .trim()
            .replace(/[Ã Ã¡áº¡áº£Ã£Ã¢áº§áº¥áº­áº©áº«Äƒáº±áº¯áº·áº³áºµ]/g, 'a')
            .replace(/[Ã¨Ã©áº¹áº»áº½Ãªá»áº¿á»‡á»ƒá»…]/g, 'e')
            .replace(/[Ã¬Ã­á»‹á»‰Ä©]/g, 'i')
            .replace(/[Ã²Ã³á»á»ÃµÃ´á»“á»‘á»™á»•á»—Æ¡á»á»›á»£á»Ÿá»¡]/g, 'o')
            .replace(/[Ã¹Ãºá»¥á»§Å©Æ°á»«á»©á»±á»­á»¯]/g, 'u')
            .replace(/[á»³Ã½á»µá»·á»¹]/g, 'y')
            .replace(/Ä‘/g, 'd');

        // Then handle spaces and special characters
        slug = slug
            .replace(/[^\w\s-]/g, '') // XÃ³a cÃ¡c kÃ½ tá»± khÃ´ng pháº£i lÃ  tá»« ngoáº¡i trá»« khoáº£ng tráº¯ng vÃ  dáº¥u gáº¡ch ná»‘i
            .replace(/[\s_]+/g, '-') // Thay tháº¿ khoáº£ng tráº¯ng vÃ  dáº¥u gáº¡ch dÆ°á»›i báº±ng dáº¥u gáº¡ch ná»‘i
            .replace(/-+/g, '-') // XÃ³a cÃ¡c dáº¥u gáº¡ch ná»‘i liÃªn tiáº¿p
            .replace(/^-+|-+$/g, ''); // XÃ³a cÃ¡c dáº¥u gáº¡ch ná»‘i á»Ÿ Ä‘áº§u vÃ  cuá»‘i chuá»—i


        // Check if the slug already exists
        let isSlugExists = await this.blogRepository.checkSlugExists(slug, excludeId);
        let counter = 1;

        // If slug exists, append a number until we find a unique slug
        const originalSlug = slug;
        while (isSlugExists) {
            slug = `${originalSlug}-${counter}`;
            isSlugExists = await this.blogRepository.checkSlugExists(slug, excludeId);
            counter++;
        }

        return slug;
    }

    private async createBlogLog(oldBlog: IBlog, updateData: UpdateBlogDto, authorId: string): Promise<ILog> {
        const logData: any = {
            blog_id: oldBlog._id,
            author_id: authorId
        };

        // Only log fields that are being updated
        if (updateData.title !== undefined) {
            logData.old_title = oldBlog.title;
            logData.new_title = updateData.title;
        }

        if (updateData.content !== undefined) {
            logData.old_content = oldBlog.content;
            logData.new_content = updateData.content;
        }

        if (updateData.slug !== undefined) {
            logData.old_slug = oldBlog.slug;
            logData.new_slug = updateData.slug;
        }

        if (updateData.blog_category_id !== undefined) {
            logData.old_blog_category_id = oldBlog.blog_category_id;
            logData.new_blog_category_id = updateData.blog_category_id;
        }

        if (updateData.service_id !== undefined) {
            logData.old_service_id = oldBlog.service_id;
            logData.new_service_id = updateData.service_id;
        }

        if (updateData.user_id !== undefined) {
            logData.old_user_id = oldBlog.user_id;
            logData.new_user_id = updateData.user_id;
        }

        if (updateData.is_published !== undefined) {
            logData.old_is_published = oldBlog.is_published;
            logData.new_is_published = updateData.is_published;
        }

        if (updateData.published_at !== undefined) {
            logData.old_published_at = oldBlog.published_at;
            logData.new_published_at = updateData.published_at;
        }

        if (updateData.images !== undefined) {
            logData.old_images = oldBlog.images;
            logData.new_images = updateData.images;
        }

        return this.logService.createLog(logData);
    }
}



================================================
FILE: src/modules/blog/index.ts
================================================
import BlogSchema from './blog.model';
import { IBlog, IBlogImage } from './blog.interface';
import BlogController from './blog.controller';
import BlogService from './blog.service';
import BlogRepository from './blog.repository';
import { BlogResponseDto, BlogSearchDto, CreateBlogDto, UpdateBlogDto, BlogImageDto } from './dtos/blog.dto';
import { LogSchema, ILog, LogService, LogRepository } from './log';
import BlogRoute from './blog.route';

export {
    BlogSchema,
    IBlog,
    IBlogImage,
    BlogController,
    BlogService,
    BlogRepository,
    BlogResponseDto,
    BlogSearchDto,
    CreateBlogDto,
    UpdateBlogDto,
    BlogImageDto,
    LogSchema,
    ILog,
    LogService,
    LogRepository,
    BlogRoute
}; 


================================================
FILE: src/modules/blog/dtos/blog.dto.ts
================================================
import { IsArray, IsBoolean, IsDate, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

export class BlogImageDto {
    @IsString()
    @IsNotEmpty()
    name!: string;

    @IsString()
    @IsNotEmpty()
    image_url!: string;

    @IsOptional()
    @IsDate()
    created_at?: Date;
}

export class UploadBlogImagesDto {
    @IsMongoId()
    @IsNotEmpty()
    blog_id!: string;
}

export class CreateBlogDto {
    @IsString()
    @IsNotEmpty()
    title!: string;

    @IsString()
    @IsNotEmpty()
    content!: string;

    @IsString()
    @IsOptional()
    slug?: string;

    // @IsMongoId()
    @IsOptional()
    user_id: string = '';

    // @IsMongoId()
    @IsNotEmpty()
    service_id: string = '';

    // @IsMongoId()
    @IsNotEmpty()
    blog_category_id: string = '';

    @Type(() => Boolean)
    @IsOptional()
    is_published?: boolean;

    @IsOptional()
    @Type(() => Date)
    published_at?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    images?: BlogImageDto[];

    // This field is not validated by class-validator as it will be handled by multer
    files?: Express.Multer.File[];
}

export class UpdateBlogDto {
    @IsString()
    @IsOptional()
    title?: string;

    @IsString()
    @IsOptional()
    content?: string;

    @IsString()
    @IsOptional()
    slug?: string;

    @IsOptional()
    user_id: string = '';

    @IsOptional()
    service_id: string = '';

    @IsOptional()
    blog_category_id: string = '';

    @Type(() => Boolean)
    @IsOptional()
    is_published?: boolean;

    @IsOptional()
    @Type(() => Date)
    published_at?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    images?: BlogImageDto[];

    // This field is not validated by class-validator as it will be handled by multer
    files?: Express.Multer.File[];
}

export class BlogResponseDto {
    id!: string;
    title!: string;
    content!: string;
    slug!: string;
    user_id!: string;
    service_id!: string;
    blog_category_id!: string;
    is_published!: boolean;
    published_at?: Date;
    images!: BlogImageDto[];
    created_at!: Date;
    updated_at!: Date;
}

export class BlogSearchDto {
    @IsString()
    @IsOptional()
    title?: string;

    @IsString()
    @IsOptional()
    blog_category_id?: string;

    @IsString()
    @IsOptional()
    user_id?: string;

    @IsString()
    @IsOptional()
    service_id?: string;

    @IsBoolean()
    @IsOptional()
    @Type(() => Boolean)
    is_published?: boolean;
} 


================================================
FILE: src/modules/blog/log/index.ts
================================================
import LogSchema from './log.model';
import { ILog } from './log.interface';
import LogService from './log.service';
import LogRepository from './log.repository';
import LogController from './log.controller';
import LogRoute from './log.route';


export {
    LogSchema,
    ILog,
    LogService,
    LogRepository,
    LogController,
    LogRoute
};



================================================
FILE: src/modules/blog/log/log.controller.ts
================================================
import { NextFunction, Request, Response, Router } from 'express';
import { HttpStatus } from '../../../core/enums';
import { SearchPaginationResponseModel } from '../../../core/models';
import { ILog } from './log.interface';
import LogService from './log.service';
import { LogSearchDto } from './dtos/log.dto';
import { plainToInstance } from 'class-transformer';
import { validateOrReject } from 'class-validator';
import { formatResponse } from '../../../core/utils';

class LogController {
    private logService = new LogService();

    public getLogById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const logId = req.params.id;
            const log: ILog = await this.logService.getLogById(logId);
            res.status(HttpStatus.Success).json(formatResponse<ILog>(log));
        } catch (error) {
            next(error);
        }
    };

    public getLogsByBlogId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogId = req.params.blogId;
            const logs: ILog[] = await this.logService.getLogsByBlogId(blogId);
            res.status(HttpStatus.Success).json(formatResponse<ILog[]>(logs));
        } catch (error) {
            next(error);
        }
    };

    public searchLogs = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const searchData = plainToInstance(LogSearchDto, req.body.searchCondition || {});
            await validateOrReject(searchData);

            const pageInfo = req.body.pageInfo || { pageNum: 1, pageSize: 10 };
            const { pageNum, pageSize } = pageInfo;

            const searchResult = await this.logService.searchLogs(searchData, pageNum, pageSize);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ILog>>(searchResult));
        } catch (error) {
            next(error);
        }
    };
}

export default LogController;



================================================
FILE: src/modules/blog/log/log.interface.ts
================================================
import { Document, Schema } from "mongoose";
import { IBlogImage } from "../blog.interface";

export interface ILog extends Document {
    _id: string;
    blog_id: string;
    author_id: string;
    old_title: string;
    new_title: string;
    old_content: string;
    new_content: string;
    old_slug: string;
    new_slug: string;
    old_blog_category_id: string;
    new_blog_category_id: string;
    old_service_id: string;
    new_service_id: string;
    old_user_id: string;
    new_user_id: string;
    old_is_published: boolean;
    new_is_published: boolean;
    old_published_at: Date;
    new_published_at: Date;
    old_images: IBlogImage[];
    new_images: IBlogImage[];
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
}



================================================
FILE: src/modules/blog/log/log.model.ts
================================================
import mongoose, { Schema } from "mongoose";
import { ILog } from "./log.interface";
import { COLLECTION_NAME } from "../../../core/constants";

const BlogImageSchema = new Schema({
    name: { type: String },
    image_url: { type: String },
    created_at: { type: Date, default: Date.now }
});

const LogSchemaEntity = new Schema({
    blog_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG },
    author_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    old_title: { type: String },
    new_title: { type: String },
    old_content: { type: String },
    new_content: { type: String },
    old_slug: { type: String },
    new_slug: { type: String },
    old_blog_category_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG_CATEGORY },
    new_blog_category_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.BLOG_CATEGORY },
    old_service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE },
    new_service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE },
    old_user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    new_user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    old_is_published: { type: Boolean },
    new_is_published: { type: Boolean },
    old_published_at: { type: Date },
    new_published_at: { type: Date },
    old_images: [BlogImageSchema],
    new_images: [BlogImageSchema],
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false }
});

const LogSchema = mongoose.model<ILog & mongoose.Document>(
    COLLECTION_NAME.BLOG_LOG,
    LogSchemaEntity
);

export default LogSchema;



================================================
FILE: src/modules/blog/log/log.repository.ts
================================================
import { ILog } from "./log.interface";
import LogSchema from "./log.model";

export default class LogRepository {
    public async createLog(model: ILog): Promise<ILog> {
        return LogSchema.create(model);
    }

    public async getLogById(id: string): Promise<ILog | null> {
        return LogSchema.findById(id);
    }

    public async getLogsByBlogId(blogId: string): Promise<ILog[]> {
        return LogSchema.find({ blog_id: blogId }).sort({ created_at: -1 });
    }

    public async countLogs(query: any): Promise<number> {
        return LogSchema.countDocuments(query);
    }

    public async getLogsWithPagination(query: any, skip: number, limit: number): Promise<ILog[]> {
        return LogSchema.find(query)
            .skip(skip)
            .limit(limit)
            .sort({ created_at: -1 });
    }
}



================================================
FILE: src/modules/blog/log/log.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../../core/constants';
import { IRoute } from '../../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../../core/middleware';
import { UserRoleEnum } from '../../user/user.enum';
import LogController from './log.controller';

export default class LogRoute implements IRoute {
    public path = API_PATH.BLOG_LOGS;
    public router = Router();
    public logController = new LogController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/blog-logs/:id -> Get log by id
        this.router.get(
            `${this.path}/:id`,
            this.logController.getLogById
        );

        // GET: domain:/api/blog-logs/blog/:blogId -> Get logs by blog id
        this.router.get(
            `${this.path}/blog/:blogId`,
            this.logController.getLogsByBlogId
        );

        // POST: domain:/api/blog-logs/search -> Search logs
        this.router.post(
            `${this.path}/search`,
            this.logController.searchLogs
        );
    }
}



================================================
FILE: src/modules/blog/log/log.service.ts
================================================
import { HttpStatus } from "../../../core/enums";
import { HttpException } from "../../../core/exceptions";
import { SearchPaginationResponseModel } from "../../../core/models";
import { ILog } from "./log.interface";
import LogRepository from "./log.repository";
import { CreateLogDto, LogSearchDto } from "./dtos/log.dto";

export default class LogService {
    private logRepository = new LogRepository();

    public async createLog(createLogDto: CreateLogDto): Promise<ILog> {
        try {
            const log = await this.logRepository.createLog(createLogDto as unknown as ILog);
            return log;
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating blog log');
        }
    }

    public async getLogsByBlogId(blogId: string): Promise<ILog[]> {
        try {
            return await this.logRepository.getLogsByBlogId(blogId);
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog logs');
        }
    }

    public async getLogById(id: string): Promise<ILog> {
        try {
            const log = await this.logRepository.getLogById(id);
            if (!log) {
                throw new HttpException(HttpStatus.NotFound, 'Blog log not found');
            }
            return log;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog log');
        }
    }

    public async searchLogs(searchParams: LogSearchDto, pageNum: number, pageSize: number): Promise<SearchPaginationResponseModel<ILog>> {
        try {
            const query: any = {};

            if (searchParams.blog_id) {
                query.blog_id = searchParams.blog_id;
            }

            if (searchParams.author_id) {
                query.author_id = searchParams.author_id;
            }

            if (searchParams.created_at_from || searchParams.created_at_to) {
                query.created_at = {};

                if (searchParams.created_at_from) {
                    query.created_at.$gte = searchParams.created_at_from;
                }

                if (searchParams.created_at_to) {
                    query.created_at.$lte = searchParams.created_at_to;
                }
            }

            const totalItems = await this.logRepository.countLogs(query);
            const totalPages = Math.ceil(totalItems / pageSize);
            const skip = (pageNum - 1) * pageSize;

            const logs = await this.logRepository.getLogsWithPagination(query, skip, pageSize);

            return new SearchPaginationResponseModel<ILog>(
                logs,
                {
                    pageNum,
                    pageSize,
                    totalItems,
                    totalPages
                }
            );
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching blog logs');
        }
    }
}



================================================
FILE: src/modules/blog/log/dtos/log.dto.ts
================================================
import { IsArray, IsBoolean, IsDate, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { BlogImageDto } from '../../dtos/blog.dto';

export class CreateLogDto {
    @IsMongoId()
    @IsNotEmpty()
    blog_id!: string;

    @IsMongoId()
    @IsNotEmpty()
    author_id!: string;

    @IsString()
    @IsOptional()
    old_title?: string;

    @IsString()
    @IsOptional()
    new_title?: string;

    @IsString()
    @IsOptional()
    old_content?: string;

    @IsString()
    @IsOptional()
    new_content?: string;

    @IsString()
    @IsOptional()
    old_slug?: string;

    @IsString()
    @IsOptional()
    new_slug?: string;

    @IsMongoId()
    @IsOptional()
    old_blog_category_id?: string;

    @IsMongoId()
    @IsOptional()
    new_blog_category_id?: string;

    @IsMongoId()
    @IsOptional()
    old_service_id?: string;

    @IsMongoId()
    @IsOptional()
    new_service_id?: string;

    @IsMongoId()
    @IsOptional()
    old_user_id?: string;

    @IsMongoId()
    @IsOptional()
    new_user_id?: string;

    @IsBoolean()
    @IsOptional()
    old_is_published?: boolean;

    @IsBoolean()
    @IsOptional()
    new_is_published?: boolean;

    @IsDate()
    @IsOptional()
    old_published_at?: Date;

    @IsDate()
    @IsOptional()
    new_published_at?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    old_images?: BlogImageDto[];

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BlogImageDto)
    @IsOptional()
    new_images?: BlogImageDto[];
}

export class LogResponseDto {
    id!: string;
    blog_id!: string;
    author_id!: string;
    old_title?: string;
    new_title?: string;
    old_content?: string;
    new_content?: string;
    old_slug?: string;
    new_slug?: string;
    old_blog_category_id?: string;
    new_blog_category_id?: string;
    old_service_id?: string;
    new_service_id?: string;
    old_user_id?: string;
    new_user_id?: string;
    old_is_published?: boolean;
    new_is_published?: boolean;
    old_published_at?: Date;
    new_published_at?: Date;
    old_images?: BlogImageDto[];
    new_images?: BlogImageDto[];
    created_at!: Date;
    updated_at!: Date;
}

export class LogSearchDto {
    @IsMongoId()
    @IsOptional()
    blog_id?: string;

    @IsMongoId()
    @IsOptional()
    author_id?: string;

    @IsDate()
    @IsOptional()
    created_at_from?: Date;

    @IsDate()
    @IsOptional()
    created_at_to?: Date;
} 


================================================
FILE: src/modules/blog/log/swagger/log.swagger.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     LogResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the log
 *         blog_id:
 *           type: string
 *           description: ID of the blog
 *         author_id:
 *           type: string
 *           description: ID of the author who made the changes
 *         old_title:
 *           type: string
 *           description: Previous title of the blog
 *         new_title:
 *           type: string
 *           description: New title of the blog
 *         old_content:
 *           type: string
 *           description: Previous content of the blog
 *         new_content:
 *           type: string
 *           description: New content of the blog
 *         old_blog_category_id:
 *           type: string
 *           description: Previous blog category ID
 *         new_blog_category_id:
 *           type: string
 *           description: New blog category ID
 *         old_service_id:
 *           type: string
 *           description: Previous service ID
 *         new_service_id:
 *           type: string
 *           description: New service ID
 *         old_user_id:
 *           type: string
 *           description: Previous user ID
 *         new_user_id:
 *           type: string
 *           description: New user ID
 *         old_is_published:
 *           type: boolean
 *           description: Previous published status
 *         new_is_published:
 *           type: boolean
 *           description: New published status
 *         old_published_at:
 *           type: string
 *           format: date-time
 *           description: Previous published date
 *         new_published_at:
 *           type: string
 *           format: date-time
 *           description: New published date
 *         old_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Previous images
 *         new_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: New images
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was last updated
 *
 *     LogSearch:
 *       type: object
 *       properties:
 *         blog_id:
 *           type: string
 *           description: ID of the blog to filter by
 *         author_id:
 *           type: string
 *           description: ID of the author to filter by
 *         created_at_from:
 *           type: string
 *           format: date-time
 *           description: Filter logs created after this date
 *         created_at_to:
 *           type: string
 *           format: date-time
 *           description: Filter logs created before this date
 */

/**
 * @swagger
 * tags:
 *   name: BlogLogs
 *   description: Blog log management API
 */

/**
 * @swagger
 * /api/blog-logs/{id}:
 *   get:
 *     summary: Get a blog log by ID
 *     tags: [BlogLogs]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the log
 *     responses:
 *       200:
 *         description: Blog log details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/LogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog log fetched successfully
 *       404:
 *         description: Blog log not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-logs/blog/{blogId}:
 *   get:
 *     summary: Get logs for a specific blog
 *     tags: [BlogLogs]
 *     parameters:
 *       - in: path
 *         name: blogId
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: List of blog logs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/LogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog logs fetched successfully
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-logs/search:
 *   post:
 *     summary: Search blog logs with pagination
 *     tags: [BlogLogs]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               searchCondition:
 *                 $ref: '#/components/schemas/LogSearch'
 *               pageInfo:
 *                 type: object
 *                 properties:
 *                   pageNum:
 *                     type: number
 *                     example: 1
 *                   pageSize:
 *                     type: number
 *                     example: 10
 *     responses:
 *       200:
 *         description: Search results
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/LogResponse'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         pageNum:
 *                           type: number
 *                           example: 1
 *                         pageSize:
 *                           type: number
 *                           example: 10
 *                         totalItems:
 *                           type: number
 *                           example: 50
 *                         totalPages:
 *                           type: number
 *                           example: 5
 *                 message:
 *                   type: string
 *                   example: Blog logs searched successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */ 


================================================
FILE: src/modules/blog/swagger/blog.swagger.js
================================================
/**
 * @swagger
 * components:
 *   securitySchemes:
 *     Bearer:
 *       type: http
 *       scheme: bearer
 *       bearerFormat: JWT
 *   schemas:
 *     BlogImage:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the image (automatically generated from the uploaded file name)
 *         image_url:
 *           type: string
 *           description: URL of the image (automatically generated from AWS S3 upload)
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the image was created (automatically generated)
 *       required:
 *         - name
 *         - image_url
 *
 *     CreateBlog:
 *       type: object
 *       properties:
 *         title:
 *           type: string
 *           description: Title of the blog
 *         content:
 *           type: string
 *           description: Content of the blog
 *         slug:
 *           type: string
 *           description: URL slug for the blog (optional, will be generated from title if not provided)
 *         user_id:
 *           type: string
 *           description: ID of the user who created the blog (automatically extracted from JWT token)
 *         service_id:
 *           type: string
 *           description: ID of the service associated with the blog
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category
 *         is_published:
 *           type: boolean
 *           description: Whether the blog is published (optional, defaults to true)
 *         published_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was published (optional, defaults to current date)
 *         images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Images associated with the blog
 *       required:
 *         - title
 *         - content
 *         - service_id
 *         - blog_category_id
 *
 *     UpdateBlog:
 *       type: object
 *       properties:
 *         title:
 *           type: string
 *           description: Title of the blog
 *         content:
 *           type: string
 *           description: Content of the blog
 *         slug:
 *           type: string
 *           description: URL slug for the blog
 *         user_id:
 *           type: string
 *           description: ID of the user who created the blog (automatically extracted from JWT token)
 *         service_id:
 *           type: string
 *           description: ID of the service associated with the blog
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category
 *         is_published:
 *           type: boolean
 *           description: Whether the blog is published (optional)
 *         published_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was published (optional)
 *         images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Images associated with the blog
 *     BlogResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the blog
 *         title:
 *           type: string
 *           description: Title of the blog
 *         content:
 *           type: string
 *           description: Content of the blog
 *         slug:
 *           type: string
 *           description: URL slug for the blog
 *         user_id:
 *           type: string
 *           description: ID of the user who created the blog
 *         service_id:
 *           type: string
 *           description: ID of the service associated with the blog
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category
 *         is_published:
 *           type: boolean
 *           description: Whether the blog is published
 *         published_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was published
 *         images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Images associated with the blog
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog was last updated
 *
 *     BlogSearch:
 *       type: object
 *       properties:
 *         title:
 *           type: string
 *           description: Title to search for (partial match)
 *         blog_category_id:
 *           type: string
 *           description: ID of the blog category to filter by
 *         user_id:
 *           type: string
 *           description: ID of the user to filter by
 *         service_id:
 *           type: string
 *           description: ID of the service to filter by
 *         is_published:
 *           type: boolean
 *           description: Filter by published status
 *
 *     DeleteImageRequest:
 *       type: object
 *       properties:
 *         image_url:
 *           type: string
 *           description: URL of the image to delete
 *       required:
 *         - image_url
 *
 *     LogResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the log entry
 *         blog_id:
 *           type: string
 *           description: ID of the blog this log belongs to
 *         author_id:
 *           type: string
 *           description: ID of the user who made the changes
 *         old_title:
 *           type: string
 *           description: Previous title of the blog
 *         new_title:
 *           type: string
 *           description: New title of the blog
 *         old_content:
 *           type: string
 *           description: Previous content of the blog
 *         new_content:
 *           type: string
 *           description: New content of the blog
 *         old_slug:
 *           type: string
 *           description: Previous slug of the blog
 *         new_slug:
 *           type: string
 *           description: New slug of the blog
 *         old_blog_category_id:
 *           type: string
 *           description: Previous blog category ID
 *         new_blog_category_id:
 *           type: string
 *           description: New blog category ID
 *         old_service_id:
 *           type: string
 *           description: Previous service ID
 *         new_service_id:
 *           type: string
 *           description: New service ID
 *         old_user_id:
 *           type: string
 *           description: Previous user ID
 *         new_user_id:
 *           type: string
 *           description: New user ID
 *         old_is_published:
 *           type: boolean
 *           description: Previous published status
 *         new_is_published:
 *           type: boolean
 *           description: New published status
 *         old_published_at:
 *           type: string
 *           format: date-time
 *           description: Previous published date
 *         new_published_at:
 *           type: string
 *           format: date-time
 *           description: New published date
 *         old_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: Previous images of the blog
 *         new_images:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/BlogImage'
 *           description: New images of the blog
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the log was last updated
 *
 *     LogSearch:
 *       type: object
 *       properties:
 *         blog_id:
 *           type: string
 *           description: ID of the blog to filter logs by
 *         author_id:
 *           type: string
 *           description: ID of the author to filter logs by
 *         created_at_from:
 *           type: string
 *           format: date-time
 *           description: Start date for filtering logs
 *         created_at_to:
 *           type: string
 *           format: date-time
 *           description: End date for filtering logs
 */

/**
 * @swagger
 * tags:
 *   name: Blogs
 *   description: Blog management API
 */

/**
 * @swagger
 * /api/blog:
 *   get:
 *     summary: Get all blogs
 *     tags: [Blogs]
 *     responses:
 *       200:
 *         description: List of blogs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blogs fetched successfully
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/create:
 *   post:
 *     summary: Create a new blog with optional image uploads
 *     description: Creates a new blog with the provided data. Images are uploaded to AWS S3, and their metadata (name, URL, creation date) are automatically generated and stored in the database. The original file name is used for the image name, the S3 URL is stored as image_url, and the current date is used for created_at. The user_id is automatically extracted from the JWT token.
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 description: Title of the blog
 *               content:
 *                 type: string
 *                 description: Content of the blog
 *               slug:
 *                 type: string
 *                 description: URL slug for the blog (optional)
 *               service_id:
 *                 type: string
 *                 description: ID of the service associated with the blog
 *               blog_category_id:
 *                 type: string
 *                 description: ID of the blog category
 *               is_published:
 *                 type: boolean
 *                 description: Whether the blog is published (optional, defaults to true)
 *               published_at:
 *                 type: string
 *                 format: date-time
 *                 description: Date when the blog was published (optional, defaults to current date)
 *               images:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *                 description: Images to upload (up to 10). These will be automatically uploaded to AWS S3.
 *             required:
 *               - title
 *               - content
 *               - service_id
 *               - blog_category_id
 *     responses:
 *       201:
 *         description: Blog created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 201
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog created successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/slug/{slug}:
 *   get:
 *     summary: Get a blog by slug
 *     tags: [Blogs]
 *     parameters:
 *       - in: path
 *         name: slug
 *         schema:
 *           type: string
 *         required: true
 *         description: Slug of the blog
 *     responses:
 *       200:
 *         description: Blog details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog fetched successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/{id}:
 *   get:
 *     summary: Get a blog by ID
 *     tags: [Blogs]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: Blog details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog fetched successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 *
 *   put:
 *     summary: Update a blog with optional image uploads
 *     description: Updates a blog with the provided data. If images are uploaded, they are stored in AWS S3, and their metadata (name, URL, creation date) are automatically generated and stored in the database. The original file name is used for the image name, the S3 URL is stored as image_url, and the current date is used for created_at. Any uploaded images will REPLACE the blog's existing images, not add to them. The user_id for tracking changes is automatically extracted from the JWT token.
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 description: Title of the blog
 *               content:
 *                 type: string
 *                 description: Content of the blog
 *               slug:
 *                 type: string
 *                 description: URL slug for the blog
 *               service_id:
 *                 type: string
 *                 description: ID of the service associated with the blog
 *               blog_category_id:
 *                 type: string
 *                 description: ID of the blog category
 *               is_published:
 *                 type: boolean
 *                 description: Whether the blog is published (optional)
 *               published_at:
 *                 type: string
 *                 format: date-time
 *                 description: Date when the blog was published (optional)
 *               images:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *                 description: New images to upload (up to 10). These will be automatically uploaded to AWS S3 and will REPLACE any existing images.
 *     responses:
 *       200:
 *         description: Blog updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog updated successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 *
 *   delete:
 *     summary: Delete a blog
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: Blog deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog deleted successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/{id}/image:
 *   delete:
 *     summary: Delete an image from a blog
 *     description: Deletes an image from a blog by its URL. Note that this only removes the image reference from the database, not from AWS S3.
 *     tags: [Blogs]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/DeleteImageRequest'
 *     responses:
 *       200:
 *         description: Image deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog image deleted successfully
 *       400:
 *         description: Image URL is required
 *       404:
 *         description: Blog not found or image not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/search:
 *   post:
 *     summary: Search blogs with pagination
 *     tags: [Blogs]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               searchCondition:
 *                 $ref: '#/components/schemas/BlogSearch'
 *               pageInfo:
 *                 type: object
 *                 properties:
 *                   pageNum:
 *                     type: number
 *                     example: 1
 *                   pageSize:
 *                     type: number
 *                     example: 10
 *     responses:
 *       200:
 *         description: Search results
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/BlogResponse'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         pageNum:
 *                           type: number
 *                           example: 1
 *                         pageSize:
 *                           type: number
 *                           example: 10
 *                         totalItems:
 *                           type: number
 *                           example: 50
 *                         totalPages:
 *                           type: number
 *                           example: 5
 *                 message:
 *                   type: string
 *                   example: Blogs searched successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog/{id}/logs:
 *   get:
 *     summary: Get logs for a blog
 *     tags: [Blogs]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog
 *     responses:
 *       200:
 *         description: Blog logs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/LogResponse'
 *                 message:
 *                   type: string
 *                   example: Blog logs fetched successfully
 *       404:
 *         description: Blog not found
 *       500:
 *         description: Server error
 */ 


================================================
FILE: src/modules/blog_category/blog_category.controller.ts
================================================
import { NextFunction, Request, Response, Router } from 'express';
import { HttpStatus } from '../../core/enums';
import { IBlogCategory } from './blog_category.interface';
import BlogCategoryService from './blog_category.service';
import { BlogCategoryResponseDto, BlogCategorySearchDto, CreateBlogCategoryDto, UpdateBlogCategoryDto } from './dtos/blog_category.dto';
import { plainToInstance } from 'class-transformer';
import { validateOrReject } from 'class-validator';
import { formatResponse } from '../../core/utils';
import { SearchPaginationResponseModel } from '../../core/models';

class BlogCategoryController {
    private blogCategoryService = new BlogCategoryService();

    public createBlogCategory = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryData = plainToInstance(CreateBlogCategoryDto, req.body);
            await validateOrReject(categoryData);

            const blogCategory: IBlogCategory = await this.blogCategoryService.createBlogCategory(categoryData);
            res.status(HttpStatus.Created).json(formatResponse<IBlogCategory>(blogCategory));
        } catch (error) {
            next(error);
        }
    };

    public updateBlogCategory = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryId = req.params.id;
            const categoryData = plainToInstance(UpdateBlogCategoryDto, req.body);
            await validateOrReject(categoryData);

            const blogCategory: IBlogCategory = await this.blogCategoryService.updateBlogCategory(categoryId, categoryData);
            res.status(HttpStatus.Success).json(formatResponse<IBlogCategory>(blogCategory));
        } catch (error) {
            next(error);
        }
    };

    public deleteBlogCategory = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryId = req.params.id;
            const blogCategory: IBlogCategory = await this.blogCategoryService.deleteBlogCategory(categoryId);
            res.status(HttpStatus.Success).json(formatResponse<string>('Blog category deleted successfully'));
        } catch (error) {
            next(error);
        }
    };

    public getBlogCategoryById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const categoryId = req.params.id;
            const blogCategory: IBlogCategory = await this.blogCategoryService.getBlogCategoryById(categoryId);
            res.status(HttpStatus.Success).json(formatResponse<IBlogCategory>(blogCategory));
        } catch (error) {
            next(error);
        }
    };

    public getBlogCategories = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const blogCategories: IBlogCategory[] = await this.blogCategoryService.getBlogCategories();
            res.status(HttpStatus.Success).json(formatResponse<IBlogCategory[]>(blogCategories));
        } catch (error) {
            next(error);
        }
    };

    public searchBlogCategories = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const searchData = plainToInstance(BlogCategorySearchDto, req.body.searchCondition || {});
            await validateOrReject(searchData);

            const pageInfo = req.body.pageInfo || { pageNum: 1, pageSize: 10 };
            const { pageNum, pageSize } = pageInfo;

            const searchResult = await this.blogCategoryService.searchBlogCategories(searchData, pageNum, pageSize);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IBlogCategory>>(searchResult));
        } catch (error) {
            next(error);
        }
    };

    public mapBlogCategoryToResponseDto(blogCategory: IBlogCategory): BlogCategoryResponseDto {
        return {
            id: blogCategory._id,
            name: blogCategory.name,
            created_at: blogCategory.created_at,
            updated_at: blogCategory.updated_at
        };
    }
}

export default BlogCategoryController;



================================================
FILE: src/modules/blog_category/blog_category.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IBlogCategory extends Document {
    _id: string;
    name: string;
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
}


================================================
FILE: src/modules/blog_category/blog_category.model.ts
================================================
import mongoose, { Schema } from "mongoose";
import { IBlogCategory } from "./blog_category.interface";
import { COLLECTION_NAME } from "../../core/constants/collection.constant";

const BlogCategorySchema: Schema<IBlogCategory> = new Schema({
    name: {
        type: String,
        required: true,
        unique: true,
    },
    created_at: {
        type: Date,
        default: Date.now,
    },
    updated_at: {
        type: Date,
        default: Date.now,
    },
    is_deleted: {
        type: Boolean,
        default: false,
    },
})

export const BlogCategoryModel = mongoose.model<IBlogCategory>(
    COLLECTION_NAME.BLOG_CATEGORY,
    BlogCategorySchema
);



================================================
FILE: src/modules/blog_category/blog_category.repository.ts
================================================
import { IBlogCategory } from "./blog_category.interface";
import { BlogCategoryModel } from "./blog_category.model";

export default class BlogCategoryRepository {
    public async createBlogCategory(model: IBlogCategory): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.create(model);
        if (!blogCategory) {
            throw new Error('Blog category not created');
        }
        return blogCategory;
    }

    public async updateBlogCategory(id: string, model: IBlogCategory): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.findByIdAndUpdate(id, model, { new: true });
        if (!blogCategory) {
            throw new Error('Blog category not found');
        }
        return blogCategory;
    }

    public async deleteBlogCategory(id: string): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.findByIdAndUpdate(
            id,
            { is_deleted: true },
            { new: true }
        );
        if (!blogCategory) {
            throw new Error('Blog category not found');
        }
        return blogCategory;
    }

    public async getBlogCategoryById(id: string): Promise<IBlogCategory> {
        const blogCategory = await BlogCategoryModel.findById(id);
        if (!blogCategory) {
            throw new Error('Blog category not found');
        }
        return blogCategory;
    }

    public async getBlogCategories(): Promise<IBlogCategory[]> {
        return BlogCategoryModel.find();
    }

    public async getBlogCategoriesWithPagination(query: any): Promise<IBlogCategory[]> {
        return BlogCategoryModel.find(query);
    }
}


================================================
FILE: src/modules/blog_category/blog_category.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import BlogCategoryController from './blog_category.controller';
import { CreateBlogCategoryDto, UpdateBlogCategoryDto } from './dtos/blog_category.dto';

export default class BlogCategoryRoute implements IRoute {
    public path = API_PATH.BLOG_CATEGORY;
    public router = Router();
    public blogCategoryController = new BlogCategoryController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        this.router.post(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(CreateBlogCategoryDto),
            this.blogCategoryController.createBlogCategory
        );

        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(UpdateBlogCategoryDto),
            this.blogCategoryController.updateBlogCategory
        );

        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.blogCategoryController.deleteBlogCategory
        );

        this.router.get(
            `${this.path}/:id`,
            this.blogCategoryController.getBlogCategoryById
        );

        this.router.get(
            `${this.path}`,
            this.blogCategoryController.getBlogCategories
        );

        this.router.post(
            `${this.path}/search`,
            this.blogCategoryController.searchBlogCategories
        );
    }
}



================================================
FILE: src/modules/blog_category/blog_category.service.ts
================================================
import mongoose, { Schema } from "mongoose";
import { IBlogCategory } from "./blog_category.interface";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { isEmptyObject } from "../../core/utils";
import { UserRoleEnum, UserSchema } from "../user";
import BlogCategoryRepository from "./blog_category.repository";
import { BlogCategorySearchDto, CreateBlogCategoryDto, UpdateBlogCategoryDto } from "./dtos/blog_category.dto";

export default class BlogCategoryService {
    private blogCategoryRepository = new BlogCategoryRepository();

    public async createBlogCategory(createBlogCategoryDto: CreateBlogCategoryDto): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.createBlogCategory(createBlogCategoryDto as unknown as IBlogCategory);
            return blogCategory;
        } catch (error: any) {
            if (error.code === 11000) { // Duplicate key error
                throw new HttpException(HttpStatus.Conflict, 'Blog category with this name already exists');
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating blog category');
        }
    }

    public async updateBlogCategory(id: string, updateBlogCategoryDto: UpdateBlogCategoryDto): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.updateBlogCategory(id, updateBlogCategoryDto as unknown as IBlogCategory);
            if (!blogCategory) {
                throw new HttpException(HttpStatus.NotFound, 'Blog category not found');
            }
            return blogCategory;
        } catch (error: any) {
            if (error instanceof HttpException) {
                throw error;
            }
            if (error.code === 11000) { // Duplicate key error
                throw new HttpException(HttpStatus.Conflict, 'Blog category with this name already exists');
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating blog category');
        }
    }

    public async deleteBlogCategory(id: string): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.deleteBlogCategory(id);
            if (!blogCategory) {
                throw new HttpException(HttpStatus.NotFound, 'Blog category not found');
            }
            return blogCategory;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting blog category');
        }
    }

    public async getBlogCategoryById(id: string): Promise<IBlogCategory> {
        try {
            const blogCategory = await this.blogCategoryRepository.getBlogCategoryById(id);
            if (!blogCategory) {
                throw new HttpException(HttpStatus.NotFound, 'Blog category not found');
            }
            return blogCategory;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog category');
        }
    }

    public async getBlogCategories(): Promise<IBlogCategory[]> {
        try {
            return await this.blogCategoryRepository.getBlogCategories();
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching blog categories');
        }
    }

    public async searchBlogCategories(searchParams: BlogCategorySearchDto, pageNum: number, pageSize: number): Promise<SearchPaginationResponseModel<IBlogCategory>> {
        try {
            const query: any = {};

            if (searchParams.name) {
                query.name = { $regex: searchParams.name, $options: 'i' };
            }

            const totalItems = await this.blogCategoryRepository.getBlogCategoriesWithPagination(query).then(categories => categories.length);
            const totalPages = Math.ceil(totalItems / pageSize);
            const skip = (pageNum - 1) * pageSize;

            const blogCategories = await this.blogCategoryRepository.getBlogCategoriesWithPagination(query)
                .then(categories => categories.slice(skip, skip + pageSize));

            return new SearchPaginationResponseModel<IBlogCategory>(
                blogCategories,
                {
                    pageNum,
                    pageSize,
                    totalItems,
                    totalPages
                }
            );
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching blog categories');
        }
    }
}




================================================
FILE: src/modules/blog_category/index.ts
================================================
import { BlogCategoryModel } from './blog_category.model';
import { IBlogCategory } from './blog_category.interface';
import BlogCategoryController from './blog_category.controller';
import BlogCategoryService from './blog_category.service';
import BlogCategoryRepository from './blog_category.repository';
import { BlogCategoryResponseDto, BlogCategorySearchDto, CreateBlogCategoryDto, UpdateBlogCategoryDto } from './dtos/blog_category.dto';
import BlogCategoryRoute from './blog_category.route';

export {
    BlogCategoryModel,
    IBlogCategory,
    BlogCategoryController,
    BlogCategoryService,
    BlogCategoryRepository,
    BlogCategoryResponseDto,
    BlogCategorySearchDto,
    CreateBlogCategoryDto,
    UpdateBlogCategoryDto,
    BlogCategoryRoute
};



================================================
FILE: src/modules/blog_category/dtos/blog_category.dto.ts
================================================
import { IsBoolean, IsDate, IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class CreateBlogCategoryDto {
    @IsString()
    @IsNotEmpty()
    name!: string;
}

export class UpdateBlogCategoryDto {
    @IsString()
    @IsOptional()
    name?: string;
}

export class BlogCategoryResponseDto {
    id!: string;
    name!: string;
    created_at!: Date;
    updated_at!: Date;
}

export class BlogCategorySearchDto {
    @IsString()
    @IsOptional()
    name?: string;
} 


================================================
FILE: src/modules/blog_category/swagger/blog_category.swagger.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateBlogCategory:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the blog category
 *       required:
 *         - name
 *
 *     UpdateBlogCategory:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the blog category
 *
 *     BlogCategoryResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: ID of the blog category
 *         name:
 *           type: string
 *           description: Name of the blog category
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog category was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date when the blog category was last updated
 *
 *     BlogCategorySearch:
 *       type: object
 *       properties:
 *         name:
 *           type: string
 *           description: Name to search for (partial match)
 */

/**
 * @swagger
 * tags:
 *   name: blog_categories
 *   description: Blog category management API
 */

/**
 * @swagger
 * /api/blog-category:
 *   post:
 *     summary: Create a new blog category
 *     tags: [blog_categories]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateBlogCategory'
 *     responses:
 *       201:
 *         description: Blog category created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 201
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category created successfully
 *       400:
 *         description: Invalid input
 *       409:
 *         description: Blog category with this name already exists
 *       500:
 *         description: Server error
 *
 *   get:
 *     summary: Get all blog categories
 *     tags: [blog_categories]
 *     responses:
 *       200:
 *         description: List of blog categories
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog categories fetched successfully
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-category/{id}:
 *   get:
 *     summary: Get a blog category by ID
 *     tags: [blog_categories]
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog category
 *     responses:
 *       200:
 *         description: Blog category details
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category fetched successfully
 *       404:
 *         description: Blog category not found
 *       500:
 *         description: Server error
 *
 *   put:
 *     summary: Update a blog category
 *     tags: [blog_categories]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog category
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateBlogCategory'
 *     responses:
 *       200:
 *         description: Blog category updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category updated successfully
 *       404:
 *         description: Blog category not found
 *       409:
 *         description: Blog category with this name already exists
 *       500:
 *         description: Server error
 *
 *   delete:
 *     summary: Delete a blog category
 *     tags: [blog_categories]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: ID of the blog category
 *     responses:
 *       200:
 *         description: Blog category deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   $ref: '#/components/schemas/BlogCategoryResponse'
 *                 message:
 *                   type: string
 *                   example: Blog category deleted successfully
 *       404:
 *         description: Blog category not found
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /api/blog-category/search:
 *   post:
 *     summary: Search blog categories with pagination
 *     tags: [blog_categories]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               searchCondition:
 *                 $ref: '#/components/schemas/BlogCategorySearch'
 *               pageInfo:
 *                 type: object
 *                 properties:
 *                   pageNum:
 *                     type: number
 *                     example: 1
 *                   pageSize:
 *                     type: number
 *                     example: 10
 *     responses:
 *       200:
 *         description: Search results
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 200
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/BlogCategoryResponse'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         pageNum:
 *                           type: number
 *                           example: 1
 *                         pageSize:
 *                           type: number
 *                           example: 10
 *                         totalItems:
 *                           type: number
 *                           example: 50
 *                         totalPages:
 *                           type: number
 *                           example: 5
 *                 message:
 *                   type: string
 *                   example: Blog categories searched successfully
 *       400:
 *         description: Invalid input
 *       500:
 *         description: Server error
 */ 


================================================
FILE: src/modules/department/department.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import DepartmentService from './department.service';
import CreateDepartmentDto from './dtos/createDepartment.dto';
import UpdateDepartmentDto from './dtos/updateDepartment.dto';
import { IDepartment } from './department.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class DepartmentController {
    private departmentService = new DepartmentService();

    /**
     * Táº¡o phÃ²ng ban má»›i
     */
    public createDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: CreateDepartmentDto = req.body;
            const department = await this.departmentService.createDepartment(model);
            res.status(HttpStatus.Created).json(formatResponse<IDepartment>(department));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Láº¥y danh sÃ¡ch phÃ²ng ban
     */
    public getDepartments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const departments = await this.departmentService.getDepartments(req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IDepartment>>(departments));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Láº¥y thÃ´ng tin phÃ²ng ban theo ID
     */
    public getDepartmentById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const department = await this.departmentService.getDepartmentById(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<IDepartment>(department));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Cáº­p nháº­t thÃ´ng tin phÃ²ng ban
     */
    public updateDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: UpdateDepartmentDto = req.body;
            const department = await this.departmentService.updateDepartment(req.params.id, model);
            res.status(HttpStatus.Success).json(formatResponse<IDepartment>(department));
        } catch (error) {
            next(error);
        }
    }

    /**
     * XÃ³a phÃ²ng ban
     */
    public deleteDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.departmentService.deleteDepartment(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<string>('Delete department successfully'));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Láº¥y danh sÃ¡ch phÃ²ng ban cá»§a má»™t manager
     */
    public getManagerDepartments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const managerId = req.params.managerId;
            const result = await this.departmentService.getManagerDepartments(managerId, req.query);
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Äáº¿m tá»•ng sá»‘ phÃ²ng ban trong há»‡ thá»‘ng
     */
    public countDepartments = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const count = await this.departmentService.countDepartments(req.query);
            res.status(HttpStatus.Success).json(formatResponse({
                totalDepartments: count
            }));
        } catch (error) {
            next(error);
        }
    }
}


================================================
FILE: src/modules/department/department.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IDepartment extends Document {
    _id: string;
    name: string;
    description: string;
    manager_id: string | undefined;
    is_deleted: boolean;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/department/department.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IDepartment } from './department.interface';

const DepartmentSchemaEntity: Schema<IDepartment> = new Schema({
    name: { type: String, required: true },
    description: { type: String, required: true },
    manager_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    is_deleted: { type: Boolean, default: false },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const DepartmentSchema = mongoose.model<IDepartment & mongoose.Document>(
    COLLECTION_NAME.DEPARTMENT,
    DepartmentSchemaEntity
);

export default DepartmentSchema; 


================================================
FILE: src/modules/department/department.repository.ts
================================================
import DepartmentSchema from './department.model';
import { IDepartment } from './department.interface';
import { Schema } from 'mongoose';

export default class DepartmentRepository {
    public async createDepartment(data: Partial<IDepartment>): Promise<IDepartment> {
        return DepartmentSchema.create(data);
    }

    public async findOne(query: any): Promise<IDepartment | null> {
        return DepartmentSchema.findOne(query);
    }

    public async findById(id: string): Promise<IDepartment | null> {
        return DepartmentSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IDepartment>, options: any = {}): Promise<IDepartment | null> {
        return DepartmentSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return DepartmentSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IDepartment[]> {
        return DepartmentSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IDepartment[]> {
        return DepartmentSchema.find(query);
    }

    public async findByIdWithPopulate(id: string): Promise<IDepartment | null> {
        return DepartmentSchema.findById(id).populate('manager_id', 'first_name last_name email');
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IDepartment[]> {
        return DepartmentSchema.find(query).sort(sort).skip(skip).limit(limit).populate('manager_id', 'first_name last_name email');
    }
}



================================================
FILE: src/modules/department/department.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import DepartmentController from './department.controller';
import CreateDepartmentDto from './dtos/createDepartment.dto';
import UpdateDepartmentDto from './dtos/updateDepartment.dto';
import { UserRoleEnum } from '../user/user.enum';

export default class DepartmentRoute implements IRoute {
    public path = API_PATH.DEPARTMENT;
    public router = Router();
    private departmentController = new DepartmentController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/department/create -> Create department
        this.router.post(
            `${this.path}/create`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(CreateDepartmentDto),
            this.departmentController.createDepartment
        );

        // GET: domain:/api/department/search -> Get all departments with pagination
        this.router.get(
            API_PATH.SEARCH_DEPARTMENT,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.departmentController.getDepartments
        );

        // GET: domain:/api/department/manager/:managerId -> Get departments by manager ID
        this.router.get(
            `${this.path}/manager/:managerId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.departmentController.getManagerDepartments
        );

        // GET: domain:/api/department/count -> Count all departments
        this.router.get(
            `${this.path}/count`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.departmentController.countDepartments
        );

        // GET: domain:/api/department/:id -> Get department by ID
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.departmentController.getDepartmentById
        );

        // PUT: domain:/api/department/:id -> Update department
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateDepartmentDto),
            this.departmentController.updateDepartment
        );

        // DELETE: domain:/api/department/:id -> Delete department
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN]),
            this.departmentController.deleteDepartment
        );
    }
}


================================================
FILE: src/modules/department/department.service.ts
================================================
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { IDepartment } from "./department.interface";
import CreateDepartmentDto from "./dtos/createDepartment.dto";
import UpdateDepartmentDto from "./dtos/updateDepartment.dto";
import { isEmptyObject } from "../../core/utils";
import { UserRoleEnum, UserSchema } from "../user";
import mongoose, { Schema } from "mongoose";
import DepartmentRepository from './department.repository';

export default class DepartmentService {
    private userSchema = UserSchema;
    private departmentRepository = new DepartmentRepository();

    /**
     * Táº¡o phÃ²ng ban má»›i
     */
    public async createDepartment(model: CreateDepartmentDto): Promise<IDepartment> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Dá»¯ liá»‡u Ä‘áº§u vÃ o khÃ´ng Ä‘Æ°á»£c trá»‘ng');
        }

        // Kiá»ƒm tra tÃªn phÃ²ng ban Ä‘Ã£ tá»“n táº¡i chÆ°a
        const existingDepartment = await this.departmentRepository.findOne({ name: model.name });
        if (existingDepartment) {
            throw new HttpException(HttpStatus.Conflict, `The department with name "${model.name}" already exists`);
        }

        // Kiá»ƒm tra manager_id cÃ³ tá»“n táº¡i vÃ  cÃ³ pháº£i lÃ  Manager khÃ´ng
        if (!mongoose.Types.ObjectId.isValid(model.manager_id) || !(await this.userSchema.findById(model.manager_id))) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        const manager = await this.userSchema.findById(model.manager_id);
        if (!manager || manager.role !== UserRoleEnum.MANAGER) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager must have the role of Manager');
        }

        if (!mongoose.Types.ObjectId.isValid(model.manager_id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        // Táº¡o phÃ²ng ban má»›i
        const department = await this.departmentRepository.createDepartment({
            ...model,
            manager_id: model.manager_id as any,
            created_at: new Date(),
            updated_at: new Date()
        }) as IDepartment;

        return department;
    }

    /**
     * Láº¥y danh sÃ¡ch phÃ²ng ban vá»›i bá»™ lá»c vÃ  phÃ¢n trang
     */
    public async getDepartments(queryParams: any = {}): Promise<SearchPaginationResponseModel<IDepartment>> {
        try {
            const {
                pageNum,
                pageSize,
                sort_by,
                sort_order,
                keyword,
                is_deleted
            } = this.processQueryParams(queryParams);

            const skip = (pageNum - 1) * pageSize;

            // XÃ¢y dá»±ng truy váº¥n
            const query: any = {};

            // 1. Xá»­ lÃ½ tráº¡ng thÃ¡i is_deleted
            if (is_deleted !== undefined) {
                query.is_deleted = is_deleted;
            } else {
                // Máº·c Ä‘á»‹nh chá»‰ hiá»ƒn thá»‹ cÃ¡c phÃ²ng ban chÆ°a bá»‹ xÃ³a logic
                query.is_deleted = false;
                query.is_active = true;
            }

            // 2. TÃ¬m kiáº¿m theo tá»« khÃ³a náº¿u cÃ³
            if (keyword) {
                query.$or = [
                    { name: { $regex: keyword, $options: 'i' } },
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            // Äáº¿m tá»•ng sá»‘ phÃ²ng ban
            const totalItems = await this.departmentRepository.countDocuments(query);

            const sortOptions: any = {};
            sortOptions[sort_by] = sort_order === 'asc' ? 1 : -1; // Sáº¯p xáº¿p theo trÆ°á»ng vÃ  thá»© tá»±

            // Láº¥y dá»¯ liá»‡u vá»›i phÃ¢n trang vÃ  populate
            const departments = await this.departmentRepository.findWithPopulate(query, sortOptions, skip, pageSize);

            // TÃ­nh tá»•ng sá»‘ trang
            const totalPages = Math.ceil(totalItems / pageSize);

            // Káº¿t quáº£ tráº£ vá»
            return {
                pageData: departments,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: pageNum,
                    pageSize: pageSize
                }
            };
        } catch (error) {
            console.error('Error in getDepartments:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error when getting the list of departments');
        }
    }

    /**
     * Láº¥y thÃ´ng tin phÃ²ng ban theo ID
     */
    public async getDepartmentById(id: string): Promise<IDepartment> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The department ID is invalid');
        }

        const department = await this.departmentRepository.findByIdWithPopulate(id);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'The department is not found');
        }

        return department;
    }

    /**
     * Cáº­p nháº­t thÃ´ng tin phÃ²ng ban
     */
    public async updateDepartment(id: string, model: UpdateDepartmentDto): Promise<IDepartment> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Dá»¯ liá»‡u cáº­p nháº­t khÃ´ng Ä‘Æ°á»£c trá»‘ng');
        }

        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The department ID is invalid');
        }

        // Kiá»ƒm tra phÃ²ng ban tá»“n táº¡i
        const department = await this.departmentRepository.findById(id);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'The department is not found');
        }

        // Kiá»ƒm tra tÃªn phÃ²ng ban Ä‘Ã£ tá»“n táº¡i chÆ°a (náº¿u tÃªn thay Ä‘á»•i)
        if (model.name !== department.name) {
            const existingDepartment = await this.departmentRepository.findOne({ name: model.name, _id: { $ne: id } });
            if (existingDepartment) {
                throw new HttpException(HttpStatus.Conflict, `The department with name "${model.name}" already exists`);
            }
        }

        // Kiá»ƒm tra manager_id cÃ³ tá»“n táº¡i
        if (model.manager_id && !mongoose.Types.ObjectId.isValid(model.manager_id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        if (model.manager_id) {
            const manager = await this.userSchema.findById(model.manager_id);
            if (!manager || manager.role !== UserRoleEnum.MANAGER) {
                throw new HttpException(HttpStatus.BadRequest, 'The manager must have the role of Manager');
            }
        }

        // Cáº­p nháº­t phÃ²ng ban
        const updatedDepartment = await this.departmentRepository.findByIdAndUpdate(
            id,
            {
                ...model,
                manager_id: model.manager_id ? (model.manager_id as any) : department.manager_id,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedDepartment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Cannot update the department');
        }

        return updatedDepartment;
    }

    /**
     * XÃ³a phÃ²ng ban báº±ng cÃ¡ch cáº­p nháº­t cá»™t is_deleted thÃ nh true
     */
    public async deleteDepartment(id: string): Promise<IDepartment> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'The department ID is invalid');
        }

        // Kiá»ƒm tra phÃ²ng ban tá»“n táº¡i
        const department = await this.departmentRepository.findById(id);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'The department is not found');
        }

        // Cáº­p nháº­t cá»™t is_deleted thÃ nh true
        const deletedDepartment = await this.departmentRepository.findByIdAndUpdate(
            id,
            { is_deleted: true, updated_at: new Date() },
            { new: true }
        );

        if (!deletedDepartment) {
            throw new HttpException(HttpStatus.InternalServerError, 'Cannot delete the department');
        }

        return deletedDepartment;
    }

    /**
     * Xá»­ lÃ½ tham sá»‘ truy váº¥n
     */
    private processQueryParams(params: any): {
        pageNum: number;
        pageSize: number;
        is_deleted?: boolean;
        sort_by: string;
        sort_order: string;
        keyword?: string;
    } {
        const processedParams: Record<string, any> = {}; // Khá»Ÿi táº¡o má»™t Ä‘á»‘i tÆ°á»£ng Ä‘á»ƒ lÆ°u trá»¯ cÃ¡c tham sá»‘ Ä‘Ã£ xá»­ lÃ½

        // Xá»­ lÃ½ tham sá»‘
        Object.keys(params).forEach(key => {
            const trimmedKey = key.trim(); // Loáº¡i bá» khoáº£ng tráº¯ng á»Ÿ Ä‘áº§u vÃ  cuá»‘i
            const normalizedKey = trimmedKey.replace(/-/g, '_'); // Thay tháº¿ dáº¥u '-' báº±ng dáº¥u '_'
            processedParams[normalizedKey] = params[key]; // LÆ°u trá»¯ giÃ¡ trá»‹ vÃ o processedParams
        });

        // XÃ¡c thá»±c trÆ°á»ng sáº¯p xáº¿p há»£p lá»‡
        const allowedSortFields = ['name', 'created_at', 'updated_at'];
        const sortBy = processedParams.sort_by?.toLowerCase();

        // Xá»­ lÃ½ cÃ¡c tham sá»‘ boolean
        const processBoolean = (value: any): boolean | undefined => {
            if (value === undefined || value === '') return undefined; // Náº¿u giÃ¡ trá»‹ khÃ´ng xÃ¡c Ä‘á»‹nh hoáº·c rá»—ng, tráº£ vá» undefined
            if (typeof value === 'boolean') return value; // Náº¿u giÃ¡ trá»‹ lÃ  boolean, tráº£ vá» giÃ¡ trá»‹ Ä‘Ã³
            if (value === 'true') return true; // Náº¿u giÃ¡ trá»‹ lÃ  'true', tráº£ vá» true
            if (value === 'false') return false; // Náº¿u giÃ¡ trá»‹ lÃ  'false', tráº£ vá» false
            return undefined; // Náº¿u khÃ´ng pháº£i lÃ  boolean, tráº£ vá» undefined
        };

        return {
            pageNum: processedParams.pageNum ? parseInt(processedParams.pageNum) : 1,
            pageSize: processedParams.pageSize ? parseInt(processedParams.pageSize) : 10,
            sort_by: allowedSortFields.includes(sortBy) ? sortBy : 'created_at',
            sort_order: processedParams.sort_order === 'asc' ? 'asc' : 'desc',
            keyword: processedParams.keyword,
            is_deleted: processBoolean(processedParams.is_deleted)
        };
    }

    /**
     * Láº¥y danh sÃ¡ch phÃ²ng ban cá»§a má»™t manager
     */
    public async getManagerDepartments(managerId: string, queryParams: any = {}): Promise<{
        departments: IDepartment[];
        count: number;
    }> {
        // Kiá»ƒm tra managerId cÃ³ há»£p lá»‡ khÃ´ng
        if (!mongoose.Types.ObjectId.isValid(managerId)) {
            throw new HttpException(HttpStatus.BadRequest, 'The manager ID is invalid');
        }

        // Kiá»ƒm tra manager cÃ³ tá»“n táº¡i khÃ´ng
        const manager = await this.userSchema.findById(managerId);
        if (!manager) {
            throw new HttpException(HttpStatus.NotFound, 'Manager not found');
        }

        // Xá»­ lÃ½ cÃ¡c tham sá»‘ truy váº¥n
        const { is_deleted } = this.processQueryParams(queryParams);

        // XÃ¢y dá»±ng truy váº¥n
        // Äáº£m báº£o Ä‘ang tÃ¬m kiáº¿m theo manager_id trong database
        const query: any = { manager_id: managerId };

        // Xá»­ lÃ½ tráº¡ng thÃ¡i is_deleted
        if (is_deleted !== undefined) {
            query.is_deleted = is_deleted;
        } else {
            // Máº·c Ä‘á»‹nh chá»‰ hiá»ƒn thá»‹ cÃ¡c phÃ²ng ban chÆ°a bá»‹ xÃ³a logic
            query.is_deleted = false;
        }

        // Láº¥y danh sÃ¡ch phÃ²ng ban vÃ  Ä‘áº¿m sá»‘ lÆ°á»£ng
        const departments = await this.departmentRepository.findWithPopulate(query, {}, 0, 1000);

        return {
            departments,
            count: departments.length
        };
    }

    /**
     * Äáº¿m tá»•ng sá»‘ phÃ²ng ban trong há»‡ thá»‘ng 
     */
    public async countDepartments(queryParams: any = {}): Promise<number> {
        // Xá»­ lÃ½ cÃ¡c tham sá»‘ truy váº¥n
        const { is_deleted } = this.processQueryParams(queryParams);

        // XÃ¢y dá»±ng truy váº¥n
        const query: any = {};

        // Xá»­ lÃ½ tráº¡ng thÃ¡i is_deleted
        if (is_deleted !== undefined) {
            query.is_deleted = is_deleted;
        } else {
            // Máº·c Ä‘á»‹nh chá»‰ Ä‘áº¿m cÃ¡c phÃ²ng ban chÆ°a bá»‹ xÃ³a logic
            query.is_deleted = false;
        }

        // Äáº¿m sá»‘ lÆ°á»£ng phÃ²ng ban
        return await this.departmentRepository.countDocuments(query);
    }
}


================================================
FILE: src/modules/department/index.ts
================================================
import DepartmentSchema from './department.model';
import { IDepartment } from './department.interface';
import DepartmentController from './department.controller';
import DepartmentService from './department.service';
import DepartmentRoute from './department.route';

export {
    DepartmentSchema,
    IDepartment,
    DepartmentController,
    DepartmentService,
    DepartmentRoute
}; 


================================================
FILE: src/modules/department/dtos/createDepartment.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString } from "class-validator";
import { IDepartment } from "../department.interface";

export default class CreateDepartmentDto {
    constructor(
        name: string,
        description: string,
        manager_id: string
    ) {
        this.name = name;
        this.description = description;
        this.manager_id = manager_id;
    }

    @IsString()
    @IsNotEmpty()
    public name: string;

    @IsString()
    @IsNotEmpty()
    public description: string;

    @IsString()
    @IsNotEmpty()
    public manager_id: string;
}





================================================
FILE: src/modules/department/dtos/updateDepartment.dto.ts
================================================
import { IsNotEmpty, IsString } from "class-validator";

export default class UpdateDepartmentDto {
    constructor(
        name: string,
        description: string,
        manager_id: string
    ) {
        this.name = name;
        this.description = description;
        this.manager_id = manager_id;
    }

    @IsString()
    @IsNotEmpty()
    public name: string;

    @IsString()
    @IsNotEmpty()
    public description: string;

    @IsString()
    @IsNotEmpty()
    public manager_id: string;
}




================================================
FILE: src/modules/department/swagger/department.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateDepartmentDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - manager_id
 *       properties:
 *         name:
 *           type: string
 *           description: Department name
 *           example: "Cardiology Department"
 *         description:
 *           type: string
 *           description: Department description
 *           example: "Department for heart-related services and diagnostics"
 *         manager_id:
 *           type: string
 *           description: Manager ID (must be a user with MANAGER role)
 *           example: "60d0fe4f5311236168a109ca"
 *
 *     UpdateDepartmentDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - manager_id
 *       properties:
 *         name:
 *           type: string
 *           description: Department name
 *           example: "Cardiology Department"
 *         description:
 *           type: string
 *           description: Department description
 *           example: "Department for heart-related services and diagnostics"
 *         manager_id:
 *           type: string
 *           description: Manager ID (must be a user with MANAGER role)
 *           example: "60d0fe4f5311236168a109ca"
 *
 *     DepartmentResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Department ID
 *           example: "60d0fe4f5311236168a109cb"
 *         name:
 *           type: string
 *           description: Department name
 *           example: "Cardiology Department"
 *         description:
 *           type: string
 *           description: Department description
 *           example: "Department for heart-related services and diagnostics"
 *         manager_id:
 *           type: object
 *           description: Manager information
 *           properties:
 *             _id:
 *               type: string
 *               description: Manager ID
 *               example: "60d0fe4f5311236168a109ca"
 *             first_name:
 *               type: string
 *               description: Manager's first name
 *               example: "John"
 *             last_name:
 *               type: string
 *               description: Manager's last name
 *               example: "Smith"
 *             email:
 *               type: string
 *               description: Manager's email
 *               example: "john.smith@example.com"
 *         is_deleted:
 *           type: boolean
 *           description: Deletion status
 *           example: false
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-06-15T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-06-20T14:20:00.000Z"
 *
 *     DepartmentPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/DepartmentResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     DepartmentCountResponse:
 *       type: object
 *       properties:
 *         totalDepartments:
 *           type: integer
 *           description: Total number of departments
 *           example: 8
 *
 *     ManagerDepartmentsResponse:
 *       type: object
 *       properties:
 *         departments:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/DepartmentResponse'
 *         count:
 *           type: integer
 *           description: Number of departments managed by the manager
 *           example: 2
 *
 *     ErrorResponse:
 *       type: object
 *       properties:
 *         message:
 *           type: string
 *           description: Error message
 *           example: "Department not found"
 *         status:
 *           type: integer
 *           description: HTTP status code
 *           example: 404
 */



================================================
FILE: src/modules/department/swagger/department.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: departments
 *   description: Department management APIs
 */

/**
 * @swagger
 * /api/department/create:
 *   post:
 *     tags:
 *       - departments
 *     summary: Create new department (Admin only)
 *     description: Create a new department with manager assignment
 *     operationId: createDepartment
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateDepartmentDto'
 *     responses:
 *       201:
 *         description: Department created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentResponse'
 *       400:
 *         description: Invalid input data or invalid manager ID
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: Manager not found or not a valid manager
 *       409:
 *         description: Department with this name already exists
 */

/**
 * @swagger
 * /api/department/search:
 *   get:
 *     tags:
 *       - departments
 *     summary: Search and filter departments (Admin, Manager, Laboratory Technician, Staff)
 *     description: Search departments with pagination and filtering options
 *     operationId: getDepartments
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *         example: 1
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *         example: 10
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by department name or description
 *         example: "cardiology"
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           default: created_at
 *           enum: [name, created_at, updated_at]
 *         description: Field to sort results by
 *         example: "name"
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           default: desc
 *           enum: [asc, desc]
 *         description: Sort order (ascending or descending)
 *         example: "asc"
 *       - in: query
 *         name: is_deleted
 *         schema:
 *           type: boolean
 *           default: false
 *         description: Filter by deletion status
 *         example: false
 *     responses:
 *       200:
 *         description: List of departments with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentPaginationResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 */

/**
 * @swagger
 * /api/department/manager/{managerId}:
 *   get:
 *     tags:
 *       - departments
 *     summary: Get departments by manager ID (Admin, Manager)
 *     description: Retrieve all departments managed by a specific manager
 *     operationId: getManagerDepartments
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: managerId
 *         required: true
 *         schema:
 *           type: string
 *         description: Manager ID
 *         example: "60d0fe4f5311236168a109ca"
 *       - in: query
 *         name: is_deleted
 *         schema:
 *           type: boolean
 *           default: false
 *         description: Include deleted departments
 *         example: false
 *     responses:
 *       200:
 *         description: List of departments managed by the specified manager
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ManagerDepartmentsResponse'
 *       400:
 *         description: Invalid manager ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Manager not found
 */

/**
 * @swagger
 * /api/department/count:
 *   get:
 *     tags:
 *       - departments
 *     summary: Count departments (Admin, Manager)
 *     description: Get the total number of departments in the system
 *     operationId: countDepartments
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: is_deleted
 *         schema:
 *           type: boolean
 *           default: false
 *         description: Include deleted departments in count
 *         example: false
 *     responses:
 *       200:
 *         description: Total count of departments
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentCountResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 */

/**
 * @swagger
 * /api/department/{id}:
 *   get:
 *     tags:
 *       - departments
 *     summary: Get department by ID (Admin, Manager, Laboratory Technician, Staff)
 *     description: Retrieve detailed information about a specific department
 *     operationId: getDepartmentById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     responses:
 *       200:
 *         description: Department details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentResponse'
 *       400:
 *         description: Invalid department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Department not found
 *
 *   put:
 *     tags:
 *       - departments
 *     summary: Update department (Admin, Manager)
 *     description: Update department information including name, description, and manager
 *     operationId: updateDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateDepartmentDto'
 *     responses:
 *       200:
 *         description: Department updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentResponse'
 *       400:
 *         description: Invalid input data or department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Department or manager not found
 *       409:
 *         description: Department with this name already exists
 *
 *   delete:
 *     tags:
 *       - departments
 *     summary: Delete department (Admin only)
 *     description: Soft delete a department (marks as deleted but keeps in database)
 *     operationId: deleteDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     responses:
 *       200:
 *         description: Department deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Department deleted successfully"
 *       400:
 *         description: Invalid department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin access required
 *       404:
 *         description: Department not found
 */

/**
 * @swagger
 * /api/department/{departmentId}/statistics:
 *   get:
 *     tags:
 *       - departments
 *     summary: Get department statistics (Admin, Manager)
 *     description: Retrieve statistical information about a department
 *     operationId: getDepartmentStatistics
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: departmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *         example: "60d0fe4f5311236168a109cb"
 *     responses:
 *       200:
 *         description: Department statistics retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 staffCount:
 *                   type: integer
 *                   description: Number of staff in the department
 *                   example: 15
 *                 activeAppointments:
 *                   type: integer
 *                   description: Number of active appointments
 *                   example: 28
 *                 completedAppointments:
 *                   type: integer
 *                   description: Number of completed appointments
 *                   example: 142
 *                 serviceTypes:
 *                   type: integer
 *                   description: Number of different service types offered
 *                   example: 8
 *       400:
 *         description: Invalid department ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Department not found
 */


================================================
FILE: src/modules/docs/docs.route.ts
================================================
import { Router } from 'express';
import { IRoute } from '../../core/interfaces';
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';
import path from 'path';
import fs from 'fs';

export default class DocsRoute implements IRoute {
    public path = '/api-docs';
    public router = Router();

    constructor() {
        this.initializeRoutes();
    }

    /**
     * Count the number of endpoints in the project by analyzing route files
     * @returns The total number of endpoints
     */
    private countEndpoints(): number {
        let totalEndpoints = 0;
        const moduleDir = path.join(__dirname, '..');

        try {
            // Get all module directories
            const modules = fs.readdirSync(moduleDir).filter(file =>
                fs.statSync(path.join(moduleDir, file)).isDirectory()
            );

            // For each module, check if it has a route file
            modules.forEach(moduleName => {
                const routeFilePath = path.join(moduleDir, moduleName, `${moduleName}.route.ts`);

                if (fs.existsSync(routeFilePath)) {
                    // Read the route file content
                    const routeContent = fs.readFileSync(routeFilePath, 'utf8');

                    // Count occurrences of router.get, router.post, router.put, router.delete, etc.
                    const getEndpoints = (routeContent.match(/router\.get\(/g) || []).length;
                    const postEndpoints = (routeContent.match(/router\.post\(/g) || []).length;
                    const putEndpoints = (routeContent.match(/router\.put\(/g) || []).length;
                    const deleteEndpoints = (routeContent.match(/router\.delete\(/g) || []).length;
                    const patchEndpoints = (routeContent.match(/router\.patch\(/g) || []).length;

                    const moduleEndpoints = getEndpoints + postEndpoints + putEndpoints + deleteEndpoints + patchEndpoints;
                    totalEndpoints += moduleEndpoints;
                }
            });

            console.log(`Total endpoints: ${totalEndpoints}`);
            return totalEndpoints;
        } catch (error) {
            console.error('Error counting endpoints:', error);
            return 0;
        }
    }

    private initializeRoutes() {
        // Count endpoints
        const endpointCount = this.countEndpoints();

        // Swagger options
        const options = {
            definition: {
                openapi: '3.0.0',
                info: {
                    title: 'Bloodline DNA Testing Service API',
                    description: `API endpoints for a Bloodline DNA Testing Service documented on swagger. This API has ${endpointCount} endpoints in total.`,
                    contact: {
                        name: "Nguyá»…n Äan Huy",
                        email: "huyit2003@gmail.com",
                        url: "https://github.com/server-craftsman/wdp392-restApi-with-nodejs-express-mongodb"
                    },
                    version: '1.0.0',
                },
                servers: [
                    {
                        url: "https://restapi-dnatesting.vercel.app/",
                        description: "Live server"
                    },
                    {
                        url: "http://localhost:6969/",
                        description: "Local server"
                    },
                ],
                components: {
                    securitySchemes: {
                        Bearer: {
                            type: "apiKey",
                            name: "Authorization",
                            in: "header",
                            description: "Bearer token for authorization",
                            scheme: "bearer",
                            bearerFormat: "JWT"
                        }
                    }
                }
            },
            apis: [
                './src/modules/*/swagger/*.js',
                './src/modules/*/dtos/*.ts'
            ],
        };

        const swaggerSpec = swaggerJsdoc(options);

        // Add endpoint count to swagger UI
        this.router.use(this.path, (req, res, next) => {
            // Add endpoint count to res.locals for access in the view
            res.locals.endpointCount = endpointCount;
            next();
        });

        // Serve swagger UI
        this.router.use(this.path, swaggerUi.serve);
        this.router.get(this.path, swaggerUi.setup(swaggerSpec, {
            swaggerOptions: {
                persistAuthorization: true,
                displayRequestDuration: true,
                docExpansion: 'list',
                filter: true,
                showExtensions: true,
                tryItOutEnabled: true,
                tagsSorter: 'alpha',
                defaultModelsExpandDepth: 1,
                operationsSorter: 'alpha'
            },
            customCss: `
                .swagger-ui .topbar { background-color: rgb(0, 0, 0); }
                .swagger-ui .opblock-tag { font-size: 16px; margin: 10px 0 5px 0; }
                .swagger-ui .opblock .opblock-summary-description { font-size: 13px; }
                .swagger-ui .opblock-tag:hover { background-color: rgba(0, 0, 0, 0.1); }
                .endpoint-count { 
                    background-color: #49cc90; 
                    color: white; 
                    padding: 5px 10px; 
                    border-radius: 4px; 
                    margin: 10px 0; 
                    display: inline-block; 
                    font-weight: bold;
                }
            `,
            customSiteTitle: `API Documentation (${endpointCount} endpoints)`,
            customfavIcon: "/favicon.ico"
        }));

        // Serve swagger spec as JSON
        this.router.get(`${this.path}.json`, (req, res) => {
            res.setHeader('Content-Type', 'application/json');
            res.send(swaggerSpec);
        });
    }
} 


================================================
FILE: src/modules/docs/index.ts
================================================
import DocsRoute from './docs.route';

export {
    DocsRoute
}; 


================================================
FILE: src/modules/index/index.controller.ts
================================================
import { NextFunction, Request, Response } from "express";
import { HttpStatus } from "../../core/enums";
import { formatResponse } from "../../core/utils";
import { version } from "../../../package.json";
import path from 'path';
import fs from 'fs';

export default class IndexController {
    /**
     * API root endpoint
     * Returns information about the API in various formats based on Accept header
     */
    public index = (req: Request, res: Response, next: NextFunction) => {
        try {
            const apiInfo = {
                name: "Bloodline DNA Testing Service API",
                version: version,
                status: "running",
                documentation: "/api-docs",
                timestamp: new Date().toISOString()
            };

            // Get the Accept header
            const acceptHeader = req.header('Accept');

            // Respond based on the requested format
            if (acceptHeader && acceptHeader.includes('text/html')) {
                // HTML response
                const htmlResponse = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>${apiInfo.name}</title>
                    <style>
                        body {
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                            line-height: 1.6;
                            color: #333;
                            max-width: 800px;
                            margin: 0 auto;
                            padding: 20px;
                        }
                        header {
                            border-bottom: 1px solid #eee;
                            padding-bottom: 20px;
                            margin-bottom: 20px;
                        }
                        h1 {
                            color: #2c3e50;
                        }
                        .status {
                            display: inline-block;
                            background-color: #27ae60;
                            color: white;
                            padding: 5px 10px;
                            border-radius: 4px;
                            font-weight: bold;
                        }
                        .api-details {
                            background-color: #f9f9f9;
                            border-left: 4px solid #2c3e50;
                            padding: 15px;
                            margin: 20px 0;
                        }
                        .api-details p {
                            margin: 10px 0;
                        }
                        .docs-button {
                            display: inline-block;
                            background-color: #3498db;
                            color: white;
                            padding: 10px 20px;
                            text-decoration: none;
                            border-radius: 4px;
                            font-weight: bold;
                            margin-top: 20px;
                        }
                        .docs-button:hover {
                            background-color: #2980b9;
                        }
                        footer {
                            margin-top: 40px;
                            text-align: center;
                            color: #7f8c8d;
                            font-size: 0.9em;
                        }
                    </style>
                </head>
                <body>
                    <header>
                        <h1>${apiInfo.name}</h1>
                        <div class="status">Status: ${apiInfo.status}</div>
                    </header>
                    
                    <main>
                        <div class="api-details">
                            <p><strong>Version:</strong> ${apiInfo.version}</p>
                            <p><strong>Last Updated:</strong> ${apiInfo.timestamp}</p>
                        </div>
                                                
                        <a href="${apiInfo.documentation}" class="docs-button">View API Documentation</a>
                    </main>
                    
                    <footer>
                        &copy; ${new Date().getFullYear()} Bloodline DNA Testing Service
                    </footer>
                </body>
                </html>
                `;
                res.header('Content-Type', 'text/html').send(htmlResponse);
            } else if (acceptHeader && acceptHeader.includes('application/xml')) {
                // XML response
                const xmlResponse = `<?xml version="1.0" encoding="UTF-8"?>
                <api>
                    <name>${apiInfo.name}</name>
                    <version>${apiInfo.version}</version>
                    <status>${apiInfo.status}</status>
                    <documentation>${apiInfo.documentation}</documentation>
                    <timestamp>${apiInfo.timestamp}</timestamp>
                </api>`;
                res.header('Content-Type', 'application/xml').send(xmlResponse);
            } else {
                // Default JSON response
                res.status(HttpStatus.Success).json(formatResponse(apiInfo));
            }
        } catch (error) {
            next(error);
        }
    };

    /**
     * Serve a welcome page
     * Returns a static HTML welcome page
     */
    public welcomePage = (req: Request, res: Response, next: NextFunction) => {
        try {
            res.sendFile(path.join(__dirname, '../../../public/welcome.html'));
        } catch (error) {
            next(error);
        }
    };

    /**
     * API documentation redirect
     * Redirects to the Swagger documentation
     */
    public apiDocs = (req: Request, res: Response, next: NextFunction) => {
        try {
            res.redirect('/api-docs');
        } catch (error) {
            next(error);
        }
    };
}


================================================
FILE: src/modules/index/index.route.ts
================================================
import { Router } from 'express';
import { IRoute } from '../../core/interfaces';
import IndexController from './index.controller';

export default class IndexRoute implements IRoute {
    public path = '/';
    public router = Router();

    public indexController = new IndexController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        this.router.get(this.path, this.indexController.index);
        this.router.get('/api', this.indexController.apiDocs);
        this.router.get('/welcome', this.indexController.welcomePage);
    }
}



================================================
FILE: src/modules/index/index.ts
================================================
import IndexController from "./index.controller";
import IndexRoute from "./index.route";

export { IndexController, IndexRoute };



================================================
FILE: src/modules/index/view/index.ejs
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloodline DNA Testing Service Management System</title>
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #2ec4b6;
            --dark: #212529;
            --light: #f8f9fa;
            --gray: #6c757d;
            --border: #e9ecef;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }
        
        .container {
            background-color: white;
            padding: 3rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 600px;
            width: 100%;
            animation: fadeIn 0.8s ease-out;
            border-top: 5px solid var(--primary);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            color: var(--primary);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            font-weight: 600;
        }
        
        .info-block {
            background-color: var(--light);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 0.75rem 0;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }
        
        .info-item:last-child {
            border-bottom: none;
        }
        
        .label {
            font-weight: 600;
            color: var(--gray);
        }
        
        .value {
            color: var(--dark);
            font-weight: 500;
        }
        
        .links {
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        
        .btn {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background-color: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 30px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(67, 97, 238, 0.15);
        }
        
        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(67, 97, 238, 0.2);
        }
        
        .btn-secondary {
            background-color: white;
            color: var(--primary);
            border: 2px solid var(--primary);
        }
        
        .btn-secondary:hover {
            background-color: var(--light);
            color: var(--primary-dark);
            border-color: var(--primary-dark);
        }
        .info-item:last-child {
            border-bottom: none;
        }        
    </style>
</head>
<body>
    <div class="container">
        <h1><%= message %></h1>
        
        <div class="info-block">
            <div class="info-item">
                <span class="label">API Version</span>
                <span class="value"><%= api_version %></span>
            </div>
            <div class="info-item">
                <span class="label">Server Time</span>
                <span class="value"><%= server_time %></span>
            </div>
            <div class="info-item">
                <span class="label">Author</span>
                <span class="value"><%= author %></span>
            </div>
        </div>
        
        <div class="links">
            <a href="<%= links.documentation %>" class="btn">Documentation</a>
            <a href="<%= links.services %>" class="btn btn-secondary">Services</a>
        </div>
    </div>
</body>
</html>


================================================
FILE: src/modules/kit/index.ts
================================================
import KitSchema from './kit.model';
import { IKit, KitStatus } from './kit.interface';
import { KitStatusEnum } from './kit.enum';
import { KitStatuses } from './kit.constant';
import KitRepository from './kit.repository';
import KitService from './kit.service';
import KitController from './kit.controller';
import KitRoute from './kit.route';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { SearchKitDto } from './dtos/searchKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';

export {
    KitSchema,
    IKit,
    KitStatus,
    KitStatusEnum,
    KitStatuses,
    KitRepository,
    KitService,
    KitController,
    KitRoute,
    CreateKitDto,
    UpdateKitDto,
    SearchKitDto,
    ReturnKitDto
}; 


================================================
FILE: src/modules/kit/kit.constant.ts
================================================
import { KitStatusEnum } from './kit.enum';

export const KitStatuses = [
    KitStatusEnum.AVAILABLE,
    KitStatusEnum.ASSIGNED,
    KitStatusEnum.USED,
    KitStatusEnum.RETURNED,
    KitStatusEnum.DAMAGED
]; 


================================================
FILE: src/modules/kit/kit.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IKit } from './kit.interface';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { SearchKitDto } from './dtos/searchKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';
import KitService from './kit.service';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class KitController {
    private kitService = new KitService();

    /**
     * Create a new kit with auto-generated code
     */
    public createKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitData: CreateKitDto = req.body;
            const kit = await this.kitService.createKit(kitData);
            res.status(HttpStatus.Created).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get kit by ID
     */
    public getKitById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const kit = await this.kitService.getKitById(kitId);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Search kits
     */
    public searchKits = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const searchParams: SearchKitDto = req.query as any;
            const searchResult = await this.kitService.searchKits(searchParams);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IKit>>(searchResult));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Update kit
     */
    public updateKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const kitData: UpdateKitDto = req.body;
            const updatedKit = await this.kitService.updateKit(kitId, kitData);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(updatedKit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Delete kit
     */
    public deleteKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            await this.kitService.deleteKit(kitId);

            res.status(HttpStatus.Success).json(formatResponse<string>('Kit deleted successfully'));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Change kit status
     */
    public changeKitStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const { status } = req.body;
            const updatedKit = await this.kitService.changeKitStatus(kitId, status);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(updatedKit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get available kits
     */
    public getAvailableKits = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kits = await this.kitService.getAvailableKits();

            res.status(HttpStatus.Success).json(formatResponse<IKit[]>(kits));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Return a kit
     */
    public returnKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const { notes } = req.body;

            const kit = await this.kitService.returnKit(kitId, notes);

            res.status(HttpStatus.Success).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Assign a kit to a laboratory technician
     */
    public assignKit = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const kitId = req.params.id;
            const { appointment_id, laboratory_technician_id } = req.body;

            const kit = await this.kitService.assignKit(
                kitId,
                appointment_id,
                laboratory_technician_id
            );

            res.status(HttpStatus.Success).json(formatResponse<IKit>(kit));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/kit/kit.enum.ts
================================================
export enum KitStatusEnum {
    AVAILABLE = 'available',
    ASSIGNED = 'assigned',
    USED = 'used',
    RETURNED = 'returned',
    DAMAGED = 'damaged' // Ä‘Ã£ hÆ° há»ng
} 


================================================
FILE: src/modules/kit/kit.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { KitStatusEnum } from './kit.enum';

export type KitStatus =
    KitStatusEnum.AVAILABLE |
    KitStatusEnum.ASSIGNED |
    KitStatusEnum.USED |
    KitStatusEnum.RETURNED |
    KitStatusEnum.DAMAGED;

export interface IKit extends Document {
    _id: string;
    code: string;
    status: KitStatus;
    appointment_id?: string | undefined;
    assigned_date?: Date;
    assigned_to_user_id?: string | undefined;
    return_date?: Date;
    notes?: string;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/kit/kit.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { KitStatuses } from './kit.constant';
import { IKit } from './kit.interface';

// Define schema with clear types
const KitSchemaEntity = new Schema({
    code: { type: String, required: true, unique: true },
    status: {
        type: String,
        enum: KitStatuses,
        required: true
    },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: false },
    assigned_date: { type: Date },
    assigned_to_user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: false },
    return_date: { type: Date },
    notes: { type: String },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

// Create and export the model with explicit typing
const KitSchema = mongoose.model<IKit>(COLLECTION_NAME.KIT, KitSchemaEntity);
export default KitSchema; 


================================================
FILE: src/modules/kit/kit.repository.ts
================================================
import KitSchema from './kit.model';
import { IKit } from './kit.interface';

export default class KitRepository {
    public async create(data: Partial<IKit>): Promise<IKit> {
        return await KitSchema.create(data);
    }

    public async findOne(query: any): Promise<IKit | null> {
        return KitSchema.findOne(query);
    }

    public async findById(id: string): Promise<IKit | null> {
        return KitSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IKit>, options: any = {}): Promise<IKit | null> {
        return KitSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return KitSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IKit[]> {
        return KitSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IKit[]> {
        return KitSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IKit[]> {
        return KitSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('appointment_id')
            .populate('assigned_to_user_id', '_id first_name last_name');
    }

    public async findByIdWithPopulate(id: string): Promise<IKit | null> {
        return KitSchema.findById(id)
            .populate('appointment_id')
            .populate('assigned_to_user_id', '_id first_name last_name');
    }

    public async findWithDetailedPopulate(query: any): Promise<IKit[]> {
        return KitSchema.find(query)
            .populate({
                path: 'appointment_id',
                populate: {
                    path: 'service_id',
                    select: '_id name description price'
                }
            })
            .populate({
                path: 'assigned_to_user_id',
                select: '_id first_name last_name email role'
            });
    }
} 


================================================
FILE: src/modules/kit/kit.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import KitController from './kit.controller';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';
import { AssignKitDto } from './dtos/assignKit.dto';

export default class KitRoute implements IRoute {
    public path = API_PATH.KIT;
    public router = Router();
    private kitController = new KitController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/kit/search -> Search kits
        this.router.get(
            `${API_PATH.SEARCH_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.searchKits
        );

        // GET: domain:/api/kit/available -> Get available kits
        this.router.get(
            `${API_PATH.GET_AVAILABLE_KITS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.getAvailableKits
        );

        // GET: domain:/api/kit/:id -> Get kit by ID
        this.router.get(
            `${API_PATH.GET_KIT_BY_ID}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.getKitById
        );

        // POST: domain:/api/kit/create -> Create a kit
        this.router.post(
            `${API_PATH.CREATE_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.kitController.createKit
        );

        // PUT: domain:/api/kit/:id -> Update a kit
        this.router.put(
            `${API_PATH.UPDATE_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateKitDto),
            this.kitController.updateKit
        );

        // POST: domain:/api/kit/:id/assign -> Assign a kit to a laboratory technician
        this.router.post(
            `${API_PATH.ASSIGN_KIT}`,
            authMiddleWare([UserRoleEnum.STAFF]),
            validationMiddleware(AssignKitDto),
            this.kitController.assignKit
        );

        // PATCH: domain:/api/kit/:id/status -> Change kit status
        this.router.patch(
            `${API_PATH.CHANGE_KIT_STATUS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.changeKitStatus
        );

        // DELETE: domain:/api/kit/:id -> Delete a kit
        this.router.delete(
            `${API_PATH.DELETE_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.kitController.deleteKit
        );

        // POST: domain:/api/kit/:id/return -> Return a kit
        this.router.post(
            `${API_PATH.RETURN_KIT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.kitController.returnKit
        );
    }
} 


================================================
FILE: src/modules/kit/kit.service.ts
================================================
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IKit } from './kit.interface';
import { KitStatusEnum } from './kit.enum';
import KitRepository from './kit.repository';
import mongoose from 'mongoose';
import { CreateKitDto } from './dtos/createKit.dto';
import { UpdateKitDto } from './dtos/updateKit.dto';
import { SearchKitDto } from './dtos/searchKit.dto';
import { ReturnKitDto } from './dtos/returnKit.dto';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { PaginationResponseModel } from '../../core/models/pagination.model';
import { format, isValid, parse } from "date-fns";

export default class KitService {
    private kitRepository = new KitRepository();

    // HÃ m tá»± Ä‘á»™ng sinh mÃ£ kit
    private async generateKitCode(): Promise<string> {
        const today = new Date();
        const dateStr = format(today, "yyyyMMdd"); // e.g., 20250528

        // TÃ¬m sá»‘ lÆ°á»£ng kit Ä‘Ã£ táº¡o trong ngÃ y Ä‘á»ƒ xÃ¡c Ä‘á»‹nh sá»‘ thá»© tá»±
        const kitsToday = await this.kitRepository.countDocuments({
            code: { $regex: `^KIT-${dateStr}-` }
        });

        const sequence = (kitsToday + 1).toString().padStart(3, "0"); // e.g., 001, 002, ...
        if (parseInt(sequence) > 999) {
            throw new HttpException(HttpStatus.Conflict, "Maximum kits for today reached (999)");
        }

        return `KIT-${dateStr}-${sequence}`; // e.g., KIT-20250528-001
    }

    // HÃ m validate mÃ£ kit náº¿u ngÆ°á»i dÃ¹ng nháº­p thá»§ cÃ´ng
    private validateKitCode(code: string): void {
        // Kiá»ƒm tra Ä‘á»‹nh dáº¡ng tá»•ng quÃ¡t
        const codeRegex = /^KIT-\d{8}-\d{3}$/;
        if (!codeRegex.test(code)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid code format');
        }

        // Kiá»ƒm tra pháº§n ngÃ y
        const dateStr = code.split("-")[1]; // e.g., 20250528
        const parsedDate = parse(dateStr, "yyyyMMdd", new Date());
        if (!isValid(parsedDate)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid date');
        }

        // Kiá»ƒm tra sá»‘ thá»© tá»±
        const sequence = parseInt(code.split("-")[2], 10); // e.g., 001 -> 1
        if (sequence < 1 || sequence > 999) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid sequence');
        }
    }

    /**
     * Create a new kit with auto-generated code
     */
    public async createKit(kitData?: CreateKitDto): Promise<IKit> {
        let code: string;

        try {
            // Handle code generation or validation
            if (!kitData || !kitData.code) {
                code = await this.generateKitCode();
            } else {
                code = kitData.code;
                this.validateKitCode(code);
            }

            // Check if kit already exists
            const existingKit = await this.kitRepository.findOne({ code });
            if (existingKit) {
                throw new HttpException(HttpStatus.Conflict, 'Kit code already exists');
            }

            // Create kit object
            const kitObject = {
                code,
                status: KitStatusEnum.AVAILABLE,
                created_at: new Date(),
                updated_at: new Date()
            };

            // Create kit in database
            const kit = await this.kitRepository.create(kitObject);
            return kit;
        } catch (error) {
            // Handle errors
            if (error instanceof HttpException) {
                throw error;
            }

            console.error('Error creating kit:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating kit');
        }
    }

    /**
     * Find an available kit by ID
     */
    public async findAvailableKitById(kitId: string): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status !== KitStatusEnum.AVAILABLE) {
            throw new HttpException(HttpStatus.BadRequest, 'Kit is not available');
        }

        return kit;
    }

    /**
     * Get kit by ID
     */
    public async getKitById(kitId: string): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findByIdWithPopulate(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        return kit;
    }

    /**
     * Search kits with pagination
     */
    public async searchKits(searchParams: SearchKitDto): Promise<SearchPaginationResponseModel<IKit>> {
        try {
            const { pageNum = 1, pageSize = 10, ...filters } = searchParams;

            const query: any = {};

            if (filters.code) {
                query.code = { $regex: filters.code, $options: 'i' }; // $regex: dÃ¹ng Ä‘á»ƒ tÃ¬m kiáº¿m theo mÃ£ kit
            }

            if (filters.status) {
                query.status = filters.status;
            }

            if (filters.appointment_id) {
                query.appointment_id = filters.appointment_id;
            }

            if (filters.assigned_to_user_id) {
                query.assigned_to_user_id = filters.assigned_to_user_id;
            }

            const skip = (pageNum - 1) * pageSize; // skip: bá» qua bao nhiÃªu dÃ²ng
            const limit = pageSize; // limit: láº¥y bao nhiÃªu dÃ²ng

            const [kits, totalCount] = await Promise.all([ // Promise.all: cháº¡y song song cÃ¡c promise
                this.kitRepository.findWithPopulate(query, { created_at: -1 }, skip, limit), // findWithPopulate: láº¥y dá»¯ liá»‡u vÃ  populate dá»¯ liá»‡u
                this.kitRepository.countDocuments(query) // countDocuments: Ä‘áº¿m sá»‘ dÃ²ng
            ]);

            const paginationInfo = new PaginationResponseModel(
                pageNum,
                pageSize,
                totalCount,
                Math.ceil(totalCount / pageSize) // Math.ceil: lÃ m trÃ²n lÃªn
            );

            return new SearchPaginationResponseModel<IKit>(kits, paginationInfo); // tráº£ vá» dá»¯ liá»‡u vÃ  phÃ¢n trang
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching kits');
        }
    }

    /**
     * Update a kit
     */
    public async updateKit(kitId: string, kitData: UpdateKitDto): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status !== KitStatusEnum.AVAILABLE) {
            throw new HttpException(HttpStatus.BadRequest, 'Kit is not available');
        }

        if (kitData.notes) {
            kit.notes = kitData.notes;
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                ...kitData,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update kit');
        }

        return updatedKit;
    }

    /**
     * Delete a kit
     */
    public async deleteKit(kitId: string): Promise<void> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status === KitStatusEnum.ASSIGNED || kit.status === KitStatusEnum.USED) {
            throw new HttpException(
                HttpStatus.BadRequest,
                'Cannot delete kit that is currently assigned or in use'
            );
        }

        await this.kitRepository.findByIdAndUpdate(kitId, { status: KitStatusEnum.DAMAGED });
    }

    /**
     * Change kit status
     */
    public async changeKitStatus(kitId: string, status: KitStatusEnum): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        if (!Object.values(KitStatusEnum).includes(status)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid status');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                status,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update kit status');
        }

        return updatedKit;
    }

    /**
     * Get all available kits
     */
    public async getAvailableKits(): Promise<IKit[]> {
        return this.kitRepository.find({ status: KitStatusEnum.AVAILABLE });
    }

    /**
     * Assign a kit to an appointment and laboratory technician
     * @param kitId - The ID of the kit to assign
     * @param appointmentId - The ID of the appointment
     * @param technicianId - The ID of the laboratory technician
     */
    public async assignKit(kitId: string, appointmentId: string, technicianId: string): Promise<IKit> {
        const kit = await this.findAvailableKitById(kitId);

        // Validate userId is a valid ObjectId
        if (!mongoose.Types.ObjectId.isValid(technicianId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid laboratory technician ID');
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                status: KitStatusEnum.ASSIGNED,
                appointment_id: appointmentId as any,
                assigned_to_user_id: technicianId as any,
                assigned_date: new Date(),
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign kit');
        }

        return updatedKit;
    }

    /**
     * Return a kit
     */
    public async returnKit(kitId: string, notes?: string): Promise<IKit> {
        if (!mongoose.Types.ObjectId.isValid(kitId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid kit ID');
        }

        const kit = await this.kitRepository.findById(kitId);
        if (!kit) {
            throw new HttpException(HttpStatus.NotFound, 'Kit not found');
        }

        if (kit.status !== KitStatusEnum.ASSIGNED && kit.status !== KitStatusEnum.USED) {
            throw new HttpException(
                HttpStatus.BadRequest,
                'Only assigned or used kits can be returned'
            );
        }

        const updatedKit = await this.kitRepository.findByIdAndUpdate(
            kitId,
            {
                status: KitStatusEnum.RETURNED,
                return_date: new Date(),
                notes,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedKit) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to return kit');
        }

        return updatedKit;
    }

    /**
     * Process query parameters
     */
    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }
} 


================================================
FILE: src/modules/kit/dtos/assignKit.dto.ts
================================================
import { IsMongoId, IsNotEmpty } from 'class-validator';

export class AssignKitDto {
    @IsNotEmpty({ message: 'Appointment ID is required' })
    @IsMongoId({ message: 'Invalid appointment ID format' })
    appointment_id: string = '';

    @IsNotEmpty({ message: 'Laboratory technician ID is required' })
    @IsMongoId({ message: 'Invalid laboratory technician ID format' })
    laboratory_technician_id: string = '';
} 


================================================
FILE: src/modules/kit/dtos/createKit.dto.ts
================================================
import { IsOptional, IsString, Matches } from 'class-validator';

export class CreateKitDto {
    constructor(
        code?: string
    ) {
        this.code = code;
    }

    @IsOptional()
    @IsString({ message: 'Kit code must be a string' })
    // @Matches(/^KIT-\d{8}-\d{3}$/, {
    //     message: 'Kit code must follow the format KIT-YYYYMMDD-###',
    //     each: false
    // })
    code?: string;
}


================================================
FILE: src/modules/kit/dtos/returnKit.dto.ts
================================================
import { IsMongoId, IsOptional, IsString } from 'class-validator';

export class ReturnKitDto {
    @IsMongoId()
    kit_id: string = '';

    @IsString()
    @IsOptional()
    notes?: string;
} 


================================================
FILE: src/modules/kit/dtos/searchKit.dto.ts
================================================
import { IsString, IsOptional, IsEnum, IsMongoId, IsNumber } from 'class-validator';
import { KitStatusEnum } from '../kit.enum';

export class SearchKitDto {
    @IsString()
    @IsOptional()
    code?: string;

    @IsEnum(KitStatusEnum)
    @IsOptional()
    status?: KitStatusEnum;

    @IsMongoId()
    @IsOptional()
    appointment_id?: string;

    @IsMongoId()
    @IsOptional()
    assigned_to_user_id?: string;

    @IsNumber()
    @IsOptional()
    pageNum?: number;

    @IsNumber()
    @IsOptional()
    pageSize?: number;
}



================================================
FILE: src/modules/kit/dtos/updateKit.dto.ts
================================================
import { IsString, IsOptional } from 'class-validator';

export class UpdateKitDto {
    @IsString()
    @IsOptional()
    notes?: string;
} 


================================================
FILE: src/modules/kit/swagger/kit.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateKitDto:
 *       type: object
 *       properties:
 *         code:
 *           type: string
 *           description: Kit code (optional, will be auto-generated if not provided)
 *           pattern: "^KIT-\\d{8}-\\d{3}$"
 *           example: "KIT-20230615-001"
 *
 *     AssignKitDto:
 *       type: object
 *       required:
 *         - appointment_id
 *         - laboratory_technician_id
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment to assign the kit to
 *           example: "60d5ec9af682fbd12a0f4d4d"
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the laboratory technician to assign the kit to
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *
 *     UpdateKitDto:
 *       type: object
 *       properties:
 *         notes:
 *           type: string
 *           description: Notes about the kit
 *           example: "Kit has been sterilized and verified for proper functionality"
 *
 *     ReturnKitDto:
 *       type: object
 *       required:
 *         - kit_id
 *       properties:
 *         kit_id:
 *           type: string
 *           description: ID of the kit being returned
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         notes:
 *           type: string
 *           description: Notes about the returned kit condition
 *           example: "Kit returned in good condition, all components present"
 *
 *     ChangeKitStatusDto:
 *       type: object
 *       required:
 *         - status
 *       properties:
 *         status:
 *           type: string
 *           enum: [available, assigned, used, returned, damaged]
 *           description: New status for the kit
 *           example: "available"
 *
 *     KitResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Kit ID
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         code:
 *           type: string
 *           description: Kit unique identifier code
 *           example: "KIT-20230615-001"
 *         status:
 *           type: string
 *           description: Current kit status
 *           enum: [available, assigned, used, returned, damaged]
 *           example: "available"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment (if any)
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4d4d"
 *             appointment_code:
 *               type: string
 *               example: "APP-20230615-001"
 *         assigned_to_user_id:
 *           type: object
 *           description: Laboratory technician assigned to the kit (if any)
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4a1a"
 *             first_name:
 *               type: string
 *               example: "Alex"
 *             last_name:
 *               type: string
 *               example: "Johnson"
 *             email:
 *               type: string
 *               example: "alex.johnson@example.com"
 *             role:
 *               type: string
 *               example: "laboratory_technician"
 *         assigned_date:
 *           type: string
 *           format: date-time
 *           description: Date when kit was assigned
 *           example: "2023-06-15T09:30:00.000Z"
 *         return_date:
 *           type: string
 *           format: date-time
 *           description: Date when kit was returned
 *           example: "2023-06-20T14:20:00.000Z"
 *         notes:
 *           type: string
 *           description: Notes about the kit
 *           example: "Kit has been sterilized and verified for proper functionality"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-06-20T14:20:00.000Z"
 *
 *     KitPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/KitResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     SearchKitDto:
 *       type: object
 *       properties:
 *         code:
 *           type: string
 *           description: Filter by kit code
 *           example: "KIT-20230615"
 *         status:
 *           type: string
 *           enum: [available, assigned, used, returned, damaged]
 *           description: Filter by kit status
 *           example: "available"
 *         appointment_id:
 *           type: string
 *           description: Filter by appointment ID
 *           example: "60d5ec9af682fbd12a0f4d4d"
 *         assigned_to_user_id:
 *           type: string
 *           description: Filter by assigned laboratory technician ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         pageNum:
 *           type: integer
 *           description: Page number for pagination
 *           default: 1
 *           example: 1
 *         pageSize:
 *           type: integer
 *           description: Number of items per page
 *           default: 10
 *           example: 10
 *
 *     SuccessResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *           description: Success status
 *           example: true
 *         message:
 *           type: string
 *           description: Success message
 *           example: "Operation completed successfully"
 *
 *     KitDetailedResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Kit ID
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         code:
 *           type: string
 *           description: Kit unique identifier code
 *           example: "KIT-20230615-001"
 *         status:
 *           type: string
 *           description: Current kit status
 *           enum: [available, assigned, used, returned, damaged]
 *           example: "available"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment (if any)
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4d4d"
 *             appointment_code:
 *               type: string
 *               example: "APP-20230615-001"
 *             service_id:
 *               type: object
 *               properties:
 *                 _id:
 *                   type: string
 *                   example: "60d5ec9af682fbd12a0f4d4e"
 *                 name:
 *                   type: string
 *                   example: "DNA Paternity Test"
 *                 description:
 *                   type: string
 *                   example: "Standard paternity test with 99.99% accuracy"
 *                 price:
 *                   type: number
 *                   example: 1500
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-06-01T09:30:00.000Z"
 */



================================================
FILE: src/modules/kit/swagger/kit.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: kits
 *   description: Kit management APIs
 */

/**
 * @swagger
 * /api/kit/create:
 *   post:
 *     tags:
 *       - kits
 *     summary: Create a new kit (Admin, Manager only)
 *     description: Create a new kit with auto-generated code or specified code
 *     operationId: createKit
 *     security:
 *       - Bearer: []
 *     responses:
 *       201:
 *         description: Kit created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid input or malformed kit code
 *       401:
 *         description: Unauthorized - Admin or Manager access required
 *       409:
 *         description: Kit code already exists
 */

/**
 * @swagger
 * /api/kit/search:
 *   get:
 *     tags:
 *       - kits
 *     summary: Search kits (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Search for kits with pagination and filtering options
 *     operationId: searchKits
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *         example: 1
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *         example: 10
 *       - in: query
 *         name: code
 *         schema:
 *           type: string
 *         description: Filter by kit code (full or partial)
 *         example: "KIT-20230615"
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, assigned, used, returned, damaged]
 *         description: Filter by kit status
 *         example: "available"
 *       - in: query
 *         name: appointment_id
 *         schema:
 *           type: string
 *         description: Filter by appointment ID
 *         example: "60d5ec9af682fbd12a0f4d4d"
 *       - in: query
 *         name: assigned_to_user_id
 *         schema:
 *           type: string
 *         description: Filter by assigned laboratory technician ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     responses:
 *       200:
 *         description: List of kits with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitPaginationResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 */

/**
 * @swagger
 * /api/kit/available:
 *   get:
 *     tags:
 *       - kits
 *     summary: Get available kits (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Retrieve all kits with 'available' status
 *     operationId: getAvailableKits
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: List of available kits
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/KitResponse'
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 */

/**
 * @swagger
 * /api/kit/{id}:
 *   get:
 *     tags:
 *       - kits
 *     summary: Get kit by ID (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Retrieve detailed information about a specific kit
 *     operationId: getKitById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     responses:
 *       200:
 *         description: Kit details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid kit ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Kit not found
 *   
 *   put:
 *     tags:
 *       - kits
 *     summary: Update kit (Admin, Manager only)
 *     description: Update kit information (currently only notes can be updated)
 *     operationId: updateKit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateKitDto'
 *     responses:
 *       200:
 *         description: Kit updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid input data or kit ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Kit not found
 *         
 *   delete:
 *     tags:
 *       - kits
 *     summary: Delete kit (Admin, Manager only)
 *     description: Mark a kit as damaged or delete it from the system
 *     operationId: deleteKit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     responses:
 *       200:
 *         description: Kit deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SuccessResponse'
 *       400:
 *         description: Invalid kit ID format or kit is currently assigned/in use
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Admin or Manager access required
 *       404:
 *         description: Kit not found
 */

/**
 * @swagger
 * /api/kit/{id}/status:
 *   patch:
 *     tags:
 *       - kits
 *     summary: Change kit status (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Change the status of a kit (available, assigned, used, returned, damaged)
 *     operationId: changeKitStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangeKitStatusDto'
 *     responses:
 *       200:
 *         description: Kit status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid input data or kit ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Kit not found
 *       422:
 *         description: Invalid status transition (e.g., cannot change from used to available directly)
 */

/**
 * @swagger
 * /api/kit/{id}/return:
 *   post:
 *     tags:
 *       - kits
 *     summary: Return a kit (Admin, Manager, Staff, Laboratory Technician only)
 *     description: Mark a kit as returned and update its status
 *     operationId: returnKit
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Kit ID
 *         example: "60d5ec9af682fbd12a0f4c3c"
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               notes:
 *                 type: string
 *                 description: Notes about the returned kit
 *                 example: "Kit returned in good condition"
 *     responses:
 *       200:
 *         description: Kit returned successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/KitResponse'
 *       400:
 *         description: Invalid kit ID format or kit is not in a returnable state
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Insufficient permissions
 *       404:
 *         description: Kit not found
 */


================================================
FILE: src/modules/payment/index.ts
================================================
import PaymentSchema from './payment.model';
import { IPayment, PaymentMethod, PaymentStatus } from './payment.interface';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';
import { PaymentMethods, PaymentStatuses } from './payment.constant';
import PaymentRoute from './payment.route';
export {
    PaymentSchema,
    IPayment,
    PaymentMethod,
    PaymentStatus,
    PaymentMethodEnum,
    PaymentStatusEnum,
    PaymentMethods,
    PaymentStatuses,
    PaymentRoute
}; 


================================================
FILE: src/modules/payment/payment.constant.ts
================================================
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';

export const PaymentMethods = [
    '',
    PaymentMethodEnum.CASH,
    PaymentMethodEnum.PAY_OS
];

export const PaymentStatuses = [
    '',
    PaymentStatusEnum.PENDING,
    PaymentStatusEnum.COMPLETED,
    PaymentStatusEnum.FAILED,
    PaymentStatusEnum.REFUNDED
]; 


================================================
FILE: src/modules/payment/payment.controller.ts
================================================
import { NextFunction, Request, Response, Router } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import PaymentService from './payment.service';
import { CreatePayosPaymentDto } from './dtos/createPayosPayment.dto';
import { CreateSamplePaymentDto } from './dtos/createSamplePayment.dto';
import { CreateAppointmentPaymentDto } from './dtos/createAppointmentPayment.dto';

export default class PaymentController {
    private paymentService = new PaymentService();

    // Xá»­ lÃ½ webhook tá»« PayOS khi cÃ³ thay Ä‘á»•i tráº¡ng thÃ¡i thanh toÃ¡n
    public handlePayosWebhook = async (req: Request, res: Response, next: NextFunction) => {
        try {
            console.log('PayOS Webhook received:', {
                headers: req.headers,
                body: req.body,
                method: req.method,
                url: req.url
            });

            // Validate webhook data
            if (!req.body) {
                console.error('PayOS Webhook: Empty request body');
                return res.status(HttpStatus.BadRequest).json(
                    formatResponse(false, false, 'Empty webhook data')
                );
            }

            const webhookData = req.body;

            // Process webhook
            const result = await this.paymentService.processPayosWebhook(webhookData);

            // PayOS expects a 200 response for successful webhook processing
            const statusCode = result.success ? HttpStatus.Success : HttpStatus.BadRequest;

            res.status(statusCode).json(
                formatResponse(result, result.success, result.message)
            );

        } catch (error: any) {
            console.error('PayOS Webhook handler error:', error);

            // Always return 200 to PayOS to prevent retries for server errors
            // but log the actual error for debugging
            res.status(HttpStatus.Success).json(
                formatResponse(false, false, 'Webhook processing failed')
            );
        }
    };

    // Táº¡o chá»¯ kÃ½ webhook test cho development
    public generateTestWebhookSignature = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (process.env.NODE_ENV === 'production') {
                return res.status(HttpStatus.Forbidden).json(
                    formatResponse(false, false, 'Test endpoint not available in production')
                );
            }

            const testData = req.body;
            if (!testData) {
                return res.status(HttpStatus.BadRequest).json(
                    formatResponse(false, false, 'No test data provided')
                );
            }

            // Import the signature generation function
            const { generatePayosSignature } = await import('./payment.util');
            const signature = generatePayosSignature(testData);

            res.status(HttpStatus.Success).json(
                formatResponse({
                    signature,
                    data: testData,
                    signedData: { ...testData, signature }
                }, true, 'Test signature generated successfully')
            );

        } catch (error) {
            next(error);
        }
    };

    // Xá»­ lÃ½ return URL tá»« PayOS sau khi thanh toÃ¡n
    public handlePayosReturn = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
            const { orderCode } = req.query;
            if (!orderCode) {
                res.status(HttpStatus.BadRequest).json({ message: 'Missing orderCode' });
                return;
            }

            // Find the payment by orderCode
            const payment = await this.paymentService.findPaymentByOrderCode(Number(orderCode));
            if (!payment) {
                res.status(HttpStatus.NotFound).json({ message: 'Payment not found' });
                return;
            }

            // Now you have payos_web_id
            const idWebPayOs = payment.payos_web_id;

            const result = await this.paymentService.verifyPaymentStatus(orderCode.toString());

            // Redirect to frontend with /payos path
            const frontendUrl = process.env.DOMAIN_FE || '/';
            const params = new URLSearchParams([
                ['code', '00'],
                ['id', idWebPayOs || ''],
                ['orderCode', orderCode.toString()],
                ['status', result.payment_status || payment.status || '']
            ]);
            // Add /payos after the domain
            res.redirect(`${frontendUrl.replace(/\/$/, '')}/payos?${params.toString()}`);
            return;
        } catch (error) {
            next(error);
        }
    };

    // Xá»­ lÃ½ cancel URL tá»« PayOS khi há»§y thanh toÃ¡n
    public handlePayosCancel = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
            const { orderCode } = req.query;
            console.log('PayOS cancel handler called with:', { orderCode });

            if (orderCode) {
                // Cancel the payment if it exists
                await this.paymentService.cancelPayment(orderCode.toString());
            }

            // Redirect to frontend with cancel status
            const frontendUrl = process.env.DOMAIN_FE || '/';
            const params = new URLSearchParams([
                ['code', '99'],
                ['orderCode', orderCode?.toString() || ''],
                ['status', 'cancelled']
            ]);
            res.redirect(`${frontendUrl.replace(/\/$/, '')}/payos?${params.toString()}`);
            return;
        } catch (error) {
            console.error('Error in handlePayosCancel:', error);
            const frontendUrl = process.env.DOMAIN_FE || '/';
            const params = new URLSearchParams([
                ['code', '99'],
                ['status', 'error']
            ]);
            res.redirect(`${frontendUrl.replace(/\/$/, '')}/payos?${params.toString()}`);
        }
    };

    // Táº¡o thanh toÃ¡n cho lá»‹ch háº¹n xÃ©t nghiá»‡m DNA
    public createAppointmentPayment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                res.status(HttpStatus.Unauthorized).json(
                    formatResponse(false, true, 'User not authenticated')
                );
                return;
            }

            const paymentData: CreateAppointmentPaymentDto = req.body;

            // If sample_ids is not provided, it will be handled in the service
            // by automatically fetching all samples for the appointment

            const result = await this.paymentService.createAppointmentPayment(userId, paymentData);

            res.status(HttpStatus.Success).json(
                formatResponse(result, true, 'Appointment payment created successfully')
            );
        } catch (error) {
            next(error);
        }
    };

    // XÃ¡c minh tráº¡ng thÃ¡i thanh toÃ¡n vá»›i PayOS
    public verifyPayment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { paymentNo } = req.params;
            const result = await this.paymentService.verifyPaymentStatus(paymentNo);

            res.status(HttpStatus.Success).json(
                formatResponse(result, true, 'Payment verification completed')
            );
        } catch (error) {
            next(error);
        }
    };

    // Há»§y thanh toÃ¡n Ä‘ang á»Ÿ tráº¡ng thÃ¡i pending
    public cancelPayment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { paymentNo } = req.params;
            const result = await this.paymentService.cancelPayment(paymentNo);

            res.status(HttpStatus.Success).json(
                formatResponse(result, true, result.message)
            );
        } catch (error) {
            next(error);
        }
    };

    // Xá»­ lÃ½ callback thÃ nh cÃ´ng tá»« PayOS
    public handlePaymentSuccess = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { orderCode, amount, status } = req.query;
            console.log('Payment success handler called with:', { orderCode, amount, status });

            if (!orderCode) {
                console.error('Missing orderCode in payment success callback');
                return res.redirect(process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed');
            }

            // Verify the payment status
            const result = await this.paymentService.verifyPaymentStatus(orderCode.toString());

            if (result.payment_status === 'completed') {
                console.log(`Payment ${orderCode} verified as completed`);

                // Get frontend success URL from environment or use default
                const successUrl = process.env.FRONTEND_PAYMENT_SUCCESS_URL || '/payments/success';

                // Add payment info to URL if needed
                const redirectUrl = `${successUrl}?orderCode=${orderCode}&status=success`;

                // Redirect to frontend success page
                return res.redirect(redirectUrl);
            } else {
                console.log(`Payment ${orderCode} verification failed or payment not completed`);

                // If payment verification failed, check if we should retry
                if (result.payment_status === 'pending') {
                    // Payment is still pending, we can show a processing page
                    const pendingUrl = process.env.FRONTEND_PAYMENT_PENDING_URL || '/payments/pending';
                    return res.redirect(`${pendingUrl}?orderCode=${orderCode}`);
                } else {
                    // Payment failed or was cancelled
                    const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
                    return res.redirect(`${failedUrl}?orderCode=${orderCode}&status=${result.payment_status}`);
                }
            }
        } catch (error) {
            console.error('Error in handlePaymentSuccess:', error);
            const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
            return res.redirect(`${failedUrl}?error=internal`);
        }
    };

    // Xá»­ lÃ½ callback tháº¥t báº¡i tá»« PayOS
    public handlePaymentFailure = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { orderCode } = req.query;
            console.log('Payment failure handler called with:', { orderCode });

            if (orderCode) {
                // Cancel the payment if it exists
                await this.paymentService.cancelPayment(orderCode.toString());
            }

            // Redirect to frontend failed page
            const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
            return res.redirect(`${failedUrl}?orderCode=${orderCode || 'unknown'}&status=cancelled`);
        } catch (error) {
            console.error('Error in handlePaymentFailure:', error);
            const failedUrl = process.env.FRONTEND_PAYMENT_FAILED_URL || '/payments/failed';
            return res.redirect(`${failedUrl}?error=internal`);
        }
    };

    // Láº¥y danh sÃ¡ch máº«u xÃ©t nghiá»‡m cá»§a thanh toÃ¡n
    public getPaymentSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { paymentId } = req.params;
            const samples = await this.paymentService.getPaymentSamples(paymentId);

            res.status(HttpStatus.Success).json(
                formatResponse(samples, true, 'Samples retrieved successfully')
            );
        } catch (error) {
            next(error);
        }
    };
}



================================================
FILE: src/modules/payment/payment.enum.ts
================================================
export enum PaymentMethodEnum {
    CASH = 'cash',
    PAY_OS = 'pay_os',
    GOVERNMENT = 'government'
}

export enum PaymentStatusEnum {
    PENDING = 'pending',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled',
    FAILED = 'failed',
    REFUNDED = 'refunded'
} 


================================================
FILE: src/modules/payment/payment.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';

export type PaymentMethod =
    PaymentMethodEnum.CASH |
    PaymentMethodEnum.PAY_OS;

export type PaymentStatus =
    PaymentStatusEnum.PENDING |
    PaymentStatusEnum.COMPLETED |
    PaymentStatusEnum.FAILED |
    PaymentStatusEnum.CANCELLED |
    PaymentStatusEnum.REFUNDED;

export interface IPayment extends Document {
    _id: string;
    appointment_id: string | undefined;
    sample_ids?: string[] | undefined;
    amount: number;
    payment_no?: string;
    payment_method: PaymentMethod;
    status: PaymentStatus;
    balance_origin: number;
    payos_payment_id?: string;
    payos_payment_url?: string;
    payos_payment_status?: string;
    payos_order_code?: number;
    payos_web_id?: string;
    payos_payment_status_message?: string;
    payos_payment_status_code?: string;
    payos_payment_status_detail?: string;
    payos_payment_status_time?: Date;
    payos_webhook_received_at?: Date;

    payer_name?: string;
    payer_email?: string;
    payer_phone?: string;

    // // demo payOs
    // order_code?: string;
    // order_id?: string;
    // // end demo payOs

    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/payment/payment.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IPayment } from './payment.interface';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';

const PaymentSchemaEntity: Schema<IPayment> = new Schema({
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    sample_ids: [{ type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SAMPLE }],
    amount: { type: Number, required: true },
    payment_no: { type: String },
    payment_method: {
        type: String,
        enum: Object.values(PaymentMethodEnum),
        required: true
    },
    status: {
        type: String,
        enum: Object.values(PaymentStatusEnum),
        default: PaymentStatusEnum.PENDING
    },
    balance_origin: { type: Number, default: 0 },
    payos_payment_id: { type: String },
    payos_order_code: { type: Number },
    payos_web_id: { type: String },
    payos_payment_url: { type: String },
    payos_payment_status: { type: String },
    payos_payment_status_message: { type: String },
    payos_payment_status_code: { type: String },
    payos_payment_status_detail: { type: String },
    payos_payment_status_time: { type: Date },
    payer_name: { type: String },
    payer_email: { type: String },
    payer_phone: { type: String },

    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const PaymentSchema = mongoose.model<IPayment & mongoose.Document>(
    COLLECTION_NAME.PAYMENT,
    PaymentSchemaEntity
);

export default PaymentSchema; 


================================================
FILE: src/modules/payment/payment.route.ts
================================================
import { Router } from 'express';
import { IRoute } from '../../core/interfaces';
import PaymentController from './payment.controller';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { CreatePayosPaymentDto } from './dtos/createPayosPayment.dto';
import { CreateSamplePaymentDto } from './dtos/createSamplePayment.dto';
import { API_PATH } from '../../core/constants';
import { UserRoleEnum } from '../user/user.enum';
import { CreateAppointmentPaymentDto } from './dtos/createAppointmentPayment.dto';

export default class PaymentRoute implements IRoute {
    public path = API_PATH.PAYMENT;
    public router = Router();
    private paymentController = new PaymentController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {

        // POST: domain:/api/payments/webhook -> Handle PayOS webhook
        this.router.post(
            `${this.path}/webhook/payos`,
            this.paymentController.handlePayosWebhook as any
        );

        // GET: domain:/api/payments/payos-return -> Handle PayOS return
        this.router.get(
            `${this.path}/payos-return`,
            this.paymentController.handlePayosReturn.bind(this.paymentController)
        );

        // GET: domain:/api/payments/payos-cancel -> Handle PayOS cancel
        this.router.get(
            `${this.path}/payos-cancel`,
            this.paymentController.handlePayosCancel.bind(this.paymentController)
        );

        // POST: domain:/api/payments/appointment -> Create a payment for an appointment with selected payment method
        this.router.post(
            `${this.path}/appointment`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(CreateAppointmentPaymentDto),
            this.paymentController.createAppointmentPayment
        );

        // GET: domain:/api/payments/verify/:paymentNo -> Verify payment status
        this.router.get(
            `${this.path}/:paymentNo/verify`,
            authMiddleWare(),
            this.paymentController.verifyPayment
        );

        // POST: domain:/api/payments/cancel/:paymentNo -> Cancel payment
        this.router.post(
            `${this.path}/:paymentNo/cancel`,
            authMiddleWare(),
            this.paymentController.cancelPayment
        );

        // GET: domain:/api/payments/success -> Handle successful payment redirect
        this.router.get(
            `${this.path}/success`,
            this.paymentController.handlePaymentSuccess
        );

        // GET: domain:/api/payments/failed -> Handle failed payment redirect
        this.router.get(
            `${this.path}/failed`,
            this.paymentController.handlePaymentFailure
        );

        // GET: domain:/api/payments/:paymentId/samples -> Get samples for a payment
        this.router.get(
            `${this.path}/:paymentId/samples`,
            authMiddleWare(),
            this.paymentController.getPaymentSamples
        );

        // POST: domain:/api/payments/test-webhook-signature -> Generate test webhook signature (dev only)
        this.router.post(
            `${this.path}/test-webhook-signature`,
            this.paymentController.generateTestWebhookSignature as any
        );
    }
}



================================================
FILE: src/modules/payment/payment.service.ts
================================================
import { v4 as uuidv4 } from 'uuid';
import moment from 'moment';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { createPayosPayment, verifyPayosWebhook } from './payment.util';
import PaymentSchema from './payment.model';
import AppointmentSchema from '../appointment/appointment.model';
import { AppointmentStatusEnum, PaymentStatusEnum as AppointmentPaymentStatusEnum } from '../appointment/appointment.enum';
import { TransactionSchema } from '../transaction';
import { PaymentMethodEnum, PaymentStatusEnum } from './payment.enum';
import { CreatePayosPaymentDto } from './dtos/createPayosPayment.dto';
import { CreateWebhookDto } from './dtos/createWebhook.dto';
import { SampleService } from '../sample';
import { CreateAppointmentPaymentDto } from './dtos/createAppointmentPayment.dto';
import ServiceSchema from '../service/service.model';
import UserService from '../user/user.service';
import { sendMail, createNotificationEmailTemplate } from '../../core/utils';
import { ISendMailDetail } from '../../core/interfaces';
import { TransactionStatusEnum } from '../transaction/transaction.enum';

export default class PaymentService {
    private paymentSchema = PaymentSchema;
    private appointmentSchema = AppointmentSchema;
    private transactionSchema = TransactionSchema;
    private sampleService = new SampleService();
    private userService = new UserService();

    /**
     * Process PayOS Webhook - Fixed version with better error handling
     */
    public async processPayosWebhook(data: CreateWebhookDto): Promise<{ success: boolean; message: string }> {
        try {
            console.log('PayOS Webhook received:', JSON.stringify(data, null, 2));

            // Validate required webhook data
            if (!data.payment_no || !data.status) {
                console.error('PayOS Webhook: Missing required data (payment_no or status)');
                return { success: false, message: 'Invalid webhook data - missing required fields' };
            }

            // Verify webhook signature
            const receivedSignature = data.signature || '';
            if (!receivedSignature) {
                console.error('PayOS Webhook: Missing signature');
                return { success: false, message: 'Missing webhook signature' };
            }

            const isValidSignature = verifyPayosWebhook(data, receivedSignature);
            if (!isValidSignature) {
                console.error('PayOS Webhook: Invalid signature received');
                return { success: false, message: 'Invalid webhook signature' };
            }

            console.log('PayOS Webhook: Signature verified successfully');

            const { payment_no, amount, status } = data;
            console.log(`Processing PayOS webhook for payment ${payment_no} with status ${status}`);

            // Find the payment by payment_no or payos_order_code
            const payment = await this.paymentSchema.findOne({
                $or: [
                    { payment_no: payment_no },
                    { payos_order_code: parseInt(payment_no) || 0 }
                ]
            });

            if (!payment) {
                console.error(`PayOS Webhook: Payment not found: ${payment_no}`);
                return { success: false, message: 'Payment not found' };
            }

            // Verify amount if provided
            if (amount && payment.amount !== Number(amount)) {
                console.error(`PayOS Webhook: Amount mismatch. Expected: ${payment.amount}, Received: ${amount}`);
                return { success: false, message: 'Amount mismatch' };
            }

            // Update payment with webhook received timestamp
            payment.payos_webhook_received_at = new Date();
            payment.updated_at = new Date();

            // Process based on status
            if (status === TransactionStatusEnum.SUCCESS || status === 'PAID') {
                console.log(`Payment ${payment_no} successful, recording webhook data`);

                // Update payment webhook data
                payment.payos_payment_status = TransactionStatusEnum.SUCCESS;
                payment.payos_payment_status_time = new Date();

                // NEW: Mark payment as completed if not already and update appointment status to PAID
                let appointment: any = undefined;
                if (payment.status !== PaymentStatusEnum.COMPLETED) {
                    payment.status = PaymentStatusEnum.COMPLETED;
                    appointment = await this.appointmentSchema.findByIdAndUpdate(
                        payment.appointment_id,
                        { payment_status: AppointmentPaymentStatusEnum.PAID },
                        { new: true }
                    );
                }

                await payment.save();

                // Send success email notification (only once)
                try {
                    if (!appointment) {
                        // Fetch appointment if we didn't update it above
                        appointment = await this.appointmentSchema.findById(payment.appointment_id);
                    }
                    if (appointment) {
                        await this.sendPaymentSuccessEmail(payment, appointment);
                    }
                } catch (emailErr) {
                    console.error('Failed to send payment success email:', emailErr);
                }

                // Create/update transactions for tracking (without changing payment status)
                if (payment.sample_ids && payment.sample_ids.length > 0) {
                    const transactionPromises = payment.sample_ids.map(async (sampleId) => {
                        return await this.transactionSchema.findOneAndUpdate(
                            {
                                payment_id: payment._id,
                                sample_id: sampleId
                            },
                            {
                                payment_id: payment._id,
                                receipt_number: `${payment_no}-${sampleId.toString().substring(0, 6)}`,
                                transaction_date: new Date(),
                                sample_id: sampleId,
                                payos_transaction_id: payment.payos_payment_id,
                                payos_payment_status: TransactionStatusEnum.SUCCESS,
                                payos_payment_status_time: new Date(),
                                payos_webhook_received_at: new Date(),
                                updated_at: new Date(),
                            },
                            {
                                upsert: true,
                                new: true,
                                setDefaultsOnInsert: true
                            }
                        );
                    });

                    try {
                        const transactions = await Promise.all(transactionPromises);
                        console.log(`Created/updated ${transactions.length} transactions for payment ${payment_no}`);
                    } catch (transactionError) {
                        console.error(`Error creating transactions for payment ${payment_no}:`, transactionError);
                    }
                }

                console.log(`Payment webhook ${payment_no} processed successfully - webhook data recorded`);
                return { success: true, message: 'Payment webhook processed successfully' };

            } else if (status === TransactionStatusEnum.FAILED || status === 'CANCELLED') {
                console.log(`Payment ${payment_no} failed/cancelled with status ${status}`);

                // Update payment webhook data (but not status as requested)
                payment.payos_payment_status = status;
                payment.payos_payment_status_time = new Date();
                await payment.save();

                // Update any existing transactions webhook data
                if (payment.sample_ids && payment.sample_ids.length > 0) {
                    await this.transactionSchema.updateMany(
                        { payment_id: payment._id },
                        {
                            payos_payment_status: status,
                            payos_payment_status_time: new Date(),
                            payos_webhook_received_at: new Date(),
                            updated_at: new Date(),
                        }
                    );
                }

                console.log(`Payment webhook ${payment_no} processed - failure status recorded`);
                return { success: true, message: 'Payment webhook processed - failure recorded' };

            } else {
                console.log(`Payment ${payment_no} webhook received with unknown status: ${status}`);

                // Still update webhook received time
                payment.payos_payment_status = status;
                payment.payos_payment_status_time = new Date();
                await payment.save();

                return { success: true, message: `Webhook processed - status: ${status}` };
            }

        } catch (error) {
            console.error('PayOS Webhook processing error:', error);
            return { success: false, message: 'Internal webhook processing error' };
        }
    }

    /**
     * Create payment for appointment with selected payment method
     * @param userId ID of the user making the payment
     * @param paymentData Payment data including method and appointment ID
     * @returns Payment details including checkout URL if PAY_OS is selected
     */
    public async createAppointmentPayment(userId: string, paymentData: CreateAppointmentPaymentDto): Promise<{
        payment_no: string;
        payment_method: string;
        status: string;
        amount: number;
        checkout_url?: string;
    }> {
        try {
            // Validate appointment
            const appointment = await this.appointmentSchema.findById(paymentData.appointment_id);
            if (!appointment) {
                throw new HttpException(HttpStatus.BadRequest, 'Appointment not found');
            }

            // Check if user has permission
            if (appointment.user_id && appointment.user_id.toString() !== userId) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to pay for this appointment');
            }

            // Check if payment already exists
            const existingPayment = await this.paymentSchema.findOne({
                appointment_id: paymentData.appointment_id,
                status: { $in: [PaymentStatusEnum.COMPLETED, PaymentStatusEnum.PENDING] }
            });

            if (existingPayment) {
                throw new HttpException(HttpStatus.BadRequest, 'Payment already exists for this appointment');
            }

            // Get service price from appointment
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                throw new HttpException(HttpStatus.BadRequest, 'Service not found for this appointment');
            }

            const amount = service.price;
            if (amount <= 0) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid payment amount');
            }

            const paymentNo = `PAY-${uuidv4().substring(0, 8)}-${moment().format('HHmmss')}`;

            // Tá»± Ä‘á»™ng láº¥y táº¥t cáº£ cÃ¡c máº«u dá»¯ liá»‡u liÃªn quan Ä‘áº¿n cuá»™c háº¹n
            const samples = await this.sampleService.getSamplesByAppointmentId(paymentData.appointment_id);
            if (!samples || samples.length === 0) {
                console.log(`No samples found for appointment ${paymentData.appointment_id}`);
            } else {
                console.log(`Found ${samples.length} samples for appointment ${paymentData.appointment_id}`);
            }

            // LÆ°u danh sÃ¡ch ID máº«u
            const sampleIds = samples.map(sample => sample._id.toString());

            const payment = await this.paymentSchema.create({
                appointment_id: paymentData.appointment_id,
                sample_ids: sampleIds,
                amount: amount,
                payment_no: paymentNo,
                payment_method: paymentData.payment_method,
                status: PaymentStatusEnum.PENDING,
                balance_origin: 0,
                created_at: new Date(),
                updated_at: new Date(),
            });

            // Update appointment payment status
            await this.appointmentSchema.findByIdAndUpdate(
                paymentData.appointment_id,
                { payment_status: AppointmentPaymentStatusEnum.UNPAID },
                { new: true }
            );

            // Send payment initiated email
            try {
                await this.sendPaymentInitiatedEmail(payment, appointment, userId);
            } catch (emailError) {
                console.error('Failed to send payment initiated email:', emailError);
            }

            // Immediately verify payment for CASH (and mark as completed, update appointment, create transaction)
            if (paymentData.payment_method === PaymentMethodEnum.CASH) {
                await this.verifyPaymentStatus(paymentNo);
            }

            // Return result based on payment method
            const result = {
                payment_no: paymentNo,
                payment_method: paymentData.payment_method,
                status: PaymentStatusEnum.PENDING,
                amount: amount,
            };

            // If PAY_OS, generate checkout URL
            if (paymentData.payment_method === PaymentMethodEnum.PAY_OS) {
                // Get user information for payment
                const user = await this.userService.getUserById(userId);

                const description = `Thanh toÃ¡n ${paymentNo}`;
                const { checkoutUrl, orderCode } = await createPayosPayment(
                    amount,
                    paymentNo,
                    description,
                    `${user.first_name || ''} ${user.last_name || ''}`.trim(),
                    user.email || '',
                    user.phone_number || ''
                );

                const payosWebId = checkoutUrl.split('/web/')[1];

                await this.paymentSchema.findByIdAndUpdate(
                    payment._id,
                    {
                        payos_payment_url: checkoutUrl,
                        payment_no: paymentNo,
                        payos_order_code: orderCode,
                        payos_web_id: payosWebId
                    },
                    { new: true }
                );

                return {
                    ...result,
                    checkout_url: checkoutUrl
                };
            }

            // For CASH payment, no checkout URL is needed
            return result;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating appointment payment');
        }
    }

    /**
     * Verify payment status - Fixed version with proper PayOS API integration
     */
    public async verifyPaymentStatus(paymentIdentifier: string): Promise<{
        payment_status: string;
        appointment_id: string;
        paymentNo: string;
        payos_status?: string;
        last_verified_at?: Date;
    }> {
        try {
            console.log(`Verifying payment status for: ${paymentIdentifier}`);

            // Try to find payment by payment_no first
            let payment = await this.paymentSchema.findOne({ payment_no: paymentIdentifier });

            // If not found, try by payos_order_code (number)
            if (!payment && /^\d+$/.test(paymentIdentifier)) {
                payment = await this.paymentSchema.findOne({ payos_order_code: parseInt(paymentIdentifier, 10) });
            }

            if (!payment) {
                throw new HttpException(HttpStatus.NotFound, 'Payment not found');
            }

            console.log(`Found payment: ${payment._id}, current status: ${payment.status}, method: ${payment.payment_method}`);

            // For cash payments, just return current status without changing anything
            if (payment.payment_method === PaymentMethodEnum.CASH) {
                console.log(`Cash payment - returning current status: ${payment.status}`);
                return {
                    paymentNo: payment.payment_no || paymentIdentifier,
                    payment_status: payment.status,
                    appointment_id: payment.appointment_id || '',
                    last_verified_at: new Date()
                };
            }

            // For PayOS payments, check with PayOS API if we have order code
            if (payment.payment_method === PaymentMethodEnum.PAY_OS && payment.payos_order_code) {
                try {
                    console.log(`Checking PayOS status for order code: ${payment.payos_order_code}`);

                    // Get PayOS client instance
                    const PayOS = require('@payos/node');
                    const payosClient = new PayOS(
                        process.env.PAYOS_CLIENT_ID,
                        process.env.PAYOS_API_KEY,
                        process.env.PAYOS_CHECKSUM_KEY
                    );

                    // Query PayOS for payment information
                    const payosResponse = await payosClient.getPaymentLinkInformation(payment.payos_order_code);
                    console.log(`PayOS API response:`, JSON.stringify(payosResponse, null, 2));

                    // Update payment with latest PayOS status (without changing main status)
                    const updateData: any = {
                        payos_payment_status: payosResponse.status,
                        payos_payment_status_time: new Date(),
                        updated_at: new Date()
                    };

                    // Add additional PayOS data if available
                    if (payosResponse.transactions && payosResponse.transactions.length > 0) {
                        const transaction = payosResponse.transactions[0];
                        updateData.payos_payment_status_message = transaction.description;
                        updateData.payos_payment_status_code = transaction.counterAccountNumber;
                    }

                    await this.paymentSchema.findByIdAndUpdate(payment._id, updateData);

                    console.log(`PayOS verification complete - PayOS status: ${payosResponse.status}, Local status: ${payment.status}`);

                    // If PayOS confirms payment (PAID/SUCCESS) and local status not completed, update both payment and appointment
                    const payosStatusUpper = (payosResponse.status || '').toString().toUpperCase();
                    if ((payosStatusUpper === 'PAID' || payosStatusUpper === 'SUCCESS' || payosStatusUpper === 'COMPLETED') && payment.status !== PaymentStatusEnum.COMPLETED) {
                        // Mark payment as completed
                        await this.paymentSchema.findByIdAndUpdate(payment._id, {
                            status: PaymentStatusEnum.COMPLETED,
                            updated_at: new Date()
                        });

                        // Mark appointment as paid
                        try {
                            await this.appointmentSchema.findByIdAndUpdate(
                                payment.appointment_id,
                                { payment_status: AppointmentPaymentStatusEnum.PAID },
                                { new: true }
                            );
                        } catch (appErr) {
                            console.error('Failed to update appointment payment_status to PAID:', appErr);
                        }
                    }

                    return {
                        paymentNo: payment.payment_no || paymentIdentifier,
                        payment_status: payment.status, // Return local status, not PayOS status
                        appointment_id: payment.appointment_id || '',
                        payos_status: payosResponse.status,
                        last_verified_at: new Date()
                    };

                } catch (payosError: any) {
                    console.error(`PayOS API error for payment ${paymentIdentifier}:`, payosError.message);

                    // If PayOS API fails, return current local status
                    return {
                        paymentNo: payment.payment_no || paymentIdentifier,
                        payment_status: payment.status,
                        appointment_id: payment.appointment_id || '',
                        payos_status: 'API_ERROR',
                        last_verified_at: new Date()
                    };
                }
            }

            // For other payment methods or PayOS without order code, return current status
            console.log(`Returning current payment status: ${payment.status}`);
            return {
                paymentNo: payment.payment_no || paymentIdentifier,
                payment_status: payment.status,
                appointment_id: payment.appointment_id || '',
                last_verified_at: new Date()
            };

        } catch (error) {
            console.error(`Error verifying payment ${paymentIdentifier}:`, error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error verifying payment status');
        }
    }

    /**
     * Cancel payment
     * @param paymentNo Payment number to cancel
     * @returns Cancelled payment status
     */
    public async cancelPayment(paymentNo: string): Promise<{
        success: boolean;
        message: string;
    }> {
        try {
            const payment = await this.paymentSchema.findOne({
                $or: [
                    { payment_no: paymentNo },
                    { order_code: paymentNo }
                ],
                status: PaymentStatusEnum.PENDING
            });

            if (!payment) {
                throw new HttpException(HttpStatus.NotFound, 'Pending payment not found');
            }

            // Update payment status to failed
            payment.status = PaymentStatusEnum.FAILED;
            payment.updated_at = new Date();
            await payment.save();

            // Update appointment payment status to failed
            const appointment = await this.appointmentSchema.findByIdAndUpdate(
                payment.appointment_id,
                { payment_status: AppointmentPaymentStatusEnum.FAILED },
                { new: true }
            );

            // Send payment cancelled email
            try {
                if (appointment) {
                    await this.sendPaymentCancelledEmail(payment, appointment);
                }
            } catch (emailError) {
                console.error('Failed to send payment cancelled email:', emailError);
            }

            return {
                success: true,
                message: 'Payment cancelled successfully'
            };
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error cancelling payment');
        }
    }

    /**
     * Get samples for a payment
     * @param paymentId ID of the payment
     * @returns Array of samples associated with the payment
     */
    public async getPaymentSamples(paymentId: string): Promise<any[]> {
        try {
            const payment = await this.paymentSchema.findById(paymentId);
            if (!payment) {
                throw new HttpException(HttpStatus.NotFound, 'Payment not found');
            }

            if (!payment.sample_ids || payment.sample_ids.length === 0) {
                // If no sample IDs are stored in the payment, fetch all samples for the appointment
                return await this.sampleService.getSamplesByAppointmentId(payment.appointment_id || '');
            }

            // Fetch samples by their IDs
            const samples = [];
            for (const sampleId of payment.sample_ids) {
                try {
                    const sample = await this.sampleService.getSampleById(sampleId.toString());
                    samples.push(sample);
                } catch (error: any) {
                    console.error(`Error fetching sample ${sampleId}: ${error.message}`);
                    // Continue with the next sample
                }
            }

            return samples;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching samples for payment');
        }
    }

    public async findPaymentByOrderCode(orderCode: number) {
        return this.paymentSchema.findOne({ payos_order_code: orderCode });
    }

    /**
     * Send email notification for payment initiation
     */
    private async sendPaymentInitiatedEmail(payment: any, appointment: any, userId: string): Promise<void> {
        try {
            // Get user details
            const user = await this.userService.getUserById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Initiated';
            let message = `
                Your payment for ${service.name} has been initiated.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br><br>
            `;

            // Add specific instructions based on payment method
            if (payment.payment_method === PaymentMethodEnum.PAY_OS) {
                message += `
                    Please complete your payment by clicking on the checkout link that has been provided.
                    <br>
                    The payment link will expire in 15 minutes.
                `;
            } else if (payment.payment_method === PaymentMethodEnum.CASH) {
                message += `
                    Please prepare the exact amount for your appointment.
                    <br>
                    You will need to pay in cash when you arrive at our facility.
                `;
            }

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Initiated - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment initiated email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment initiated email:', error);
        }
    }

    /**
     * Send email notification for successful payment
     */
    private async sendPaymentSuccessEmail(payment: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await this.userService.getUserById(userId.toString());
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Successful';
            const message = `
                Your payment for ${service.name} has been successfully processed.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br>
                Payment Date: ${new Date().toLocaleString()}
                <br><br>
                Your appointment is now confirmed and our team will proceed with the next steps.
                <br><br>
                Thank you for choosing our services.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Successful - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment success email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment success email:', error);
        }
    }

    /**
     * Send email notification for failed payment
     */
    private async sendPaymentFailedEmail(payment: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await this.userService.getUserById(userId.toString());
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Failed';
            const message = `
                Your payment for ${service.name} could not be processed.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br><br>
                Please try again or contact our support team for assistance.
                <br><br>
                If you believe this is an error, please contact us immediately.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Failed - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment failed email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment failed email:', error);
        }
    }

    /**
     * Send email notification for cancelled payment
     */
    private async sendPaymentCancelledEmail(payment: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await this.userService.getUserById(userId.toString());
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details
            const service = await ServiceSchema.findById(appointment.service_id);
            if (!service) {
                console.error('Cannot send email: Service not found');
                return;
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Payment Cancelled';
            const message = `
                Your payment for ${service.name} has been cancelled.
                <br><br>
                <strong>Payment Details:</strong>
                <br>
                Payment Number: ${payment.payment_no}
                <br>
                Amount: ${payment.amount.toLocaleString()} VND
                <br>
                Payment Method: ${payment.payment_method}
                <br><br>
                If you would like to proceed with your appointment, please make a new payment.
                <br><br>
                If you did not cancel this payment, please contact our support team immediately.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Payment Cancelled - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Payment cancelled email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending payment cancelled email:', error);
        }
    }

    /**
     * Create payment for ADMINISTRATIVE appointment (government paid)
     */
    public async createAdministrativePayment(appointmentId: string, userId: string) {
        // Kiá»ƒm tra Ä‘Ã£ cÃ³ payment chÆ°a
        const existing = await this.paymentSchema.findOne({ appointment_id: appointmentId });
        if (existing) return existing;
        return this.paymentSchema.create({
            appointment_id: appointmentId,
            user_id: userId,
            amount: 0,
            method: PaymentMethodEnum.GOVERNMENT,
            status: PaymentStatusEnum.COMPLETED,
            created_at: new Date(),
            updated_at: new Date()
        });
    }
}


================================================
FILE: src/modules/payment/payment.util.ts
================================================
import PayOS from '@payos/node';
import dotenv from 'dotenv';
import crypto from 'crypto';

dotenv.config();

// PayOS credentials
const clientId = process.env.PAYOS_CLIENT_ID;
const apiKey = process.env.PAYOS_API_KEY;
const checksumKey = process.env.PAYOS_CHECKSUM_KEY;

// Validate credentials
if (!clientId || !apiKey || !checksumKey) {
    throw new Error('Missing PayOS configuration: CLIENT_ID, API_KEY, or CHECKSUM_KEY');
}

// Initialize PayOS client
const payosClient = new PayOS(clientId, apiKey, checksumKey);

/**
 * Create a payment link using PayOS
 */
export async function createPayosPayment(
    amount: number,
    orderCode?: string,
    description?: string,
    buyerName?: string,
    buyerEmail?: string,
    buyerPhone?: string
): Promise<{ checkoutUrl: string, orderCode: number }> {
    try {
        // Validate input
        if (!amount || amount < 1000) {
            throw new Error('Amount must be a positive integer >= 1000 VND');
        }
        if (!orderCode) {
            throw new Error('Order code is required');
        }
        if (!description) {
            throw new Error('Description is required');
        }
        // Giá»›i háº¡n description tá»‘i Ä‘a 25 kÃ½ tá»±
        const trimmedDescription = description.length > 25 ? description.substring(0, 25) : description;
        if (description.length > 25) {
            console.warn(`Description truncated to 25 characters: ${trimmedDescription}`);
        }

        // Convert order code to number
        const numericOrderCode = parseInt(orderCode.replace(/\D/g, ''), 10) || Math.floor(Date.now() / 1000);

        // Create payment data
        const paymentData = {
            amount: Math.floor(amount),
            orderCode: numericOrderCode,
            description: trimmedDescription,
            ...(buyerName && { buyerName }),
            ...(buyerEmail && { buyerEmail }),
            ...(buyerPhone && { buyerPhone }),
            cancelUrl: process.env.PAYOS_CANCEL_URL || '',
            returnUrl: process.env.PAYOS_RETURN_URL || '',
            items: [
                {
                    name: trimmedDescription,
                    quantity: 1,
                    price: Math.floor(amount),
                },
            ],
        };

        console.log('PayOS Request:', paymentData);

        // Get payment link
        const response = await payosClient.createPaymentLink(paymentData);

        console.log('PayOS Response:', response);

        if (response && response.checkoutUrl && response.orderCode) {
            return { checkoutUrl: response.checkoutUrl, orderCode: response.orderCode };
        }

        throw new Error('Invalid PayOS response: Missing checkoutUrl or orderCode');
    } catch (error: any) {
        console.error('PayOS Error:', {
            message: error.message,
            response: error.response?.data,
            code: error.code,
        });
        throw new Error(`Failed to create payment link: ${error.message}`);
    }
}

/**
 * Verify webhook signature - Fixed and simplified version
 */
export function verifyPayosWebhook(data: any, receivedSignature: string): boolean {
    try {
        // Validate inputs
        if (!checksumKey) {
            console.error('PayOS webhook verification: Missing checksum key');
            return false;
        }

        if (!receivedSignature) {
            console.error('PayOS webhook verification: Missing signature');
            return false;
        }

        // Create a copy of data without the signature field
        const { signature, ...dataWithoutSignature } = data;

        // Sort keys alphabetically and create consistent string representation
        const sortedKeys = Object.keys(dataWithoutSignature).sort();
        const sortedData: any = {};

        for (const key of sortedKeys) {
            sortedData[key] = dataWithoutSignature[key];
        }

        // Convert to JSON string for signature calculation
        const jsonString = JSON.stringify(sortedData);

        // Create HMAC signature using SHA256
        const hmac = crypto.createHmac('sha256', checksumKey);
        hmac.update(jsonString);
        const calculatedSignature = hmac.digest('hex');

        // If lengths differ, signature is definitely invalid â€“ avoid timingSafeEqual error
        if (calculatedSignature.length !== receivedSignature.length) {
            console.error('PayOS webhook verification failed: Signature length mismatch');
            return false;
        }

        // Compare signatures using secure comparison
        let isValid = false;
        try {
            isValid = crypto.timingSafeEqual(
                Buffer.from(calculatedSignature, 'hex'),
                Buffer.from(receivedSignature, 'hex')
            );
        } catch (cmpErr: any) {
            console.error('PayOS webhook verification error during comparison:', cmpErr.message);
            return false;
        }

        if (!isValid) {
            console.error('PayOS webhook verification failed: Signature mismatch');
            console.error('Data used for verification:', jsonString);
        } else {
            console.log('PayOS webhook signature verified successfully');
        }

        return isValid;

    } catch (error: any) {
        console.error('PayOS webhook verification error:', error.message);
        return false;
    }
}

/**
 * Generate signature for testing purposes
 */
export function generatePayosSignature(data: any): string {
    try {
        if (!checksumKey) {
            console.error('Missing checksum key for signature generation');
            return '';
        }

        // Remove any existing signature field
        const { signature: _, ...dataWithoutSignature } = data;

        // Sort keys alphabetically
        const sortedKeys = Object.keys(dataWithoutSignature).sort();
        const sortedData: any = {};

        for (const key of sortedKeys) {
            sortedData[key] = dataWithoutSignature[key];
        }

        // Convert to JSON string
        const jsonString = JSON.stringify(sortedData);

        // Create HMAC signature using SHA256
        const hmac = crypto.createHmac('sha256', checksumKey);
        hmac.update(jsonString);
        const generatedSignature = hmac.digest('hex');

        console.log('Generated PayOS signature for data:', jsonString);
        return generatedSignature;

    } catch (error: any) {
        console.error('Error generating PayOS signature:', error.message);
        return '';
    }
}

// Remove the old generateTestSignature function and replace with the new one
export { generatePayosSignature as generateTestSignature };


================================================
FILE: src/modules/payment/dtos/createAppointmentPayment.dto.ts
================================================
import { IsNotEmpty, IsString, IsEnum, IsArray, IsOptional, ArrayNotEmpty, IsNumber, Min } from 'class-validator';
import { PaymentMethodEnum } from '../payment.enum';
import { Schema } from 'mongoose';

/**
 * DTO táº¡o thanh toÃ¡n cho lá»‹ch háº¹n khÃ¡m
 * Äá»‹nh nghÄ©a dá»¯ liá»‡u cáº§n thiáº¿t Ä‘á»ƒ táº¡o má»™t giao dá»‹ch thanh toÃ¡n cho cuá»™c háº¹n xÃ©t nghiá»‡m DNA
 */
export class CreateAppointmentPaymentDto {
    // ID cá»§a lá»‹ch háº¹n cáº§n thanh toÃ¡n - Báº¯t buá»™c
    @IsNotEmpty({ message: 'ID lá»‹ch háº¹n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsString({ message: 'ID lá»‹ch háº¹n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    appointment_id!: string;

    // PhÆ°Æ¡ng thá»©c thanh toÃ¡n (CASH - tiá»n máº·t, PAY_OS - thanh toÃ¡n online)
    @IsNotEmpty({ message: 'PhÆ°Æ¡ng thá»©c thanh toÃ¡n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsEnum(PaymentMethodEnum, { message: 'PhÆ°Æ¡ng thá»©c thanh toÃ¡n khÃ´ng há»£p lá»‡' })
    payment_method!: PaymentMethodEnum;

    // Danh sÃ¡ch ID máº«u xÃ©t nghiá»‡m cáº§n thanh toÃ¡n - TÃ¹y chá»n
    // Náº¿u khÃ´ng cung cáº¥p, há»‡ thá»‘ng sáº½ tá»± Ä‘á»™ng láº¥y táº¥t cáº£ máº«u cá»§a lá»‹ch háº¹n
    @IsOptional()
    @IsArray({ message: 'Danh sÃ¡ch ID máº«u pháº£i lÃ  má»™t máº£ng' })
    @IsString({ each: true, message: 'Má»—i ID máº«u pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    sample_ids?: string[];

    // Sá»‘ tiá»n tÃ¹y chá»‰nh - TÃ¹y chá»n, náº¿u khÃ´ng cung cáº¥p sáº½ tÃ­nh tá»± Ä‘á»™ng
    @IsOptional()
    @IsNumber({}, { message: 'Sá»‘ tiá»n pháº£i lÃ  sá»‘' })
    @Min(1000, { message: 'Sá»‘ tiá»n tá»‘i thiá»ƒu lÃ  1,000 VND' })
    custom_amount?: number;

    // Ghi chÃº thanh toÃ¡n - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'Ghi chÃº pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    note?: string;

    // ThÃ´ng tin ngÆ°á»i thanh toÃ¡n - TÃ¹y chá»n cho PayOS
    @IsOptional()
    @IsString({ message: 'TÃªn ngÆ°á»i thanh toÃ¡n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    payer_name?: string;

    // Email ngÆ°á»i thanh toÃ¡n - TÃ¹y chá»n cho PayOS
    @IsOptional()
    @IsString({ message: 'Email ngÆ°á»i thanh toÃ¡n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    payer_email?: string;

    // Sá»‘ Ä‘iá»‡n thoáº¡i ngÆ°á»i thanh toÃ¡n - TÃ¹y chá»n cho PayOS
    @IsOptional()
    @IsString({ message: 'Sá»‘ Ä‘iá»‡n thoáº¡i ngÆ°á»i thanh toÃ¡n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    payer_phone?: string;
} 


================================================
FILE: src/modules/payment/dtos/createPayosPayment.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsOptional, Min, MaxLength, IsEmail, Matches } from 'class-validator';

/**
 * DTO táº¡o thanh toÃ¡n PayOS
 * Äá»‹nh nghÄ©a dá»¯ liá»‡u cáº§n thiáº¿t Ä‘á»ƒ táº¡o link thanh toÃ¡n online qua cá»•ng PayOS
 */
export class CreatePayosPaymentDto {
    constructor(
        amount: number,
        order_code: string,
        description: string,
        buyer_name?: string,
        buyer_email?: string,
        buyer_phone?: string,
        appointment_id?: string
    ) {
        this.amount = amount;
        this.order_code = order_code;
        this.description = description;
        this.buyer_name = buyer_name;
        this.buyer_email = buyer_email;
        this.buyer_phone = buyer_phone;
        this.appointment_id = appointment_id;
    }

    // Sá»‘ tiá»n thanh toÃ¡n - Báº¯t buá»™c, tá»‘i thiá»ƒu 1,000 VND theo quy Ä‘á»‹nh PayOS
    @IsNotEmpty({ message: 'Sá»‘ tiá»n thanh toÃ¡n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsNumber({}, { message: 'Sá»‘ tiá»n pháº£i lÃ  má»™t sá»‘ há»£p lá»‡' })
    @Min(1000, { message: 'Sá»‘ tiá»n tá»‘i thiá»ƒu lÃ  1,000 VND' })
    amount: number;

    // ID lá»‹ch háº¹n liÃªn quan - TÃ¹y chá»n, Ä‘á»ƒ liÃªn káº¿t thanh toÃ¡n vá»›i lá»‹ch háº¹n
    @IsOptional()
    @IsString({ message: 'ID lá»‹ch háº¹n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    appointment_id?: string;

    // MÃ£ Ä‘Æ¡n hÃ ng duy nháº¥t - Báº¯t buá»™c, Ä‘Æ°á»£c táº¡o tá»± Ä‘á»™ng bá»Ÿi há»‡ thá»‘ng
    @IsNotEmpty({ message: 'MÃ£ Ä‘Æ¡n hÃ ng khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsString({ message: 'MÃ£ Ä‘Æ¡n hÃ ng pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    @MaxLength(50, { message: 'MÃ£ Ä‘Æ¡n hÃ ng khÃ´ng Ä‘Æ°á»£c quÃ¡ 50 kÃ½ tá»±' })
    order_code: string;

    // MÃ´ táº£ giao dá»‹ch - Báº¯t buá»™c, hiá»ƒn thá»‹ cho ngÆ°á»i dÃ¹ng
    @IsNotEmpty({ message: 'MÃ´ táº£ giao dá»‹ch khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsString({ message: 'MÃ´ táº£ giao dá»‹ch pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    @MaxLength(25, { message: 'MÃ´ táº£ khÃ´ng Ä‘Æ°á»£c quÃ¡ 25 kÃ½ tá»± theo quy Ä‘á»‹nh PayOS' })
    description: string;

    // TÃªn ngÆ°á»i mua - TÃ¹y chá»n, hiá»ƒn thá»‹ trÃªn giao diá»‡n thanh toÃ¡n
    @IsOptional()
    @IsString({ message: 'TÃªn ngÆ°á»i mua pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    @MaxLength(100, { message: 'TÃªn ngÆ°á»i mua khÃ´ng Ä‘Æ°á»£c quÃ¡ 100 kÃ½ tá»±' })
    buyer_name?: string;

    // Email ngÆ°á»i mua - TÃ¹y chá»n, Ä‘á»ƒ gá»­i hÃ³a Ä‘Æ¡n Ä‘iá»‡n tá»­
    @IsOptional()
    @IsString({ message: 'Email pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    @IsEmail({}, { message: 'Email khÃ´ng Ä‘Ãºng Ä‘á»‹nh dáº¡ng' })
    buyer_email?: string;

    // Sá»‘ Ä‘iá»‡n thoáº¡i ngÆ°á»i mua - TÃ¹y chá»n, Ä‘á»ƒ liÃªn há»‡ xÃ¡c nháº­n
    @IsOptional()
    @IsString({ message: 'Sá»‘ Ä‘iá»‡n thoáº¡i pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    @Matches(/^[0-9+\-\s()]{10,15}$/, { message: 'Sá»‘ Ä‘iá»‡n thoáº¡i khÃ´ng Ä‘Ãºng Ä‘á»‹nh dáº¡ng' })
    buyer_phone?: string;
}


================================================
FILE: src/modules/payment/dtos/createSamplePayment.dto.ts
================================================
import { IsNumber, Min, IsNotEmpty, IsOptional, IsString, MaxLength } from 'class-validator';

/**
 * DTO táº¡o thanh toÃ¡n máº«u xÃ©t nghiá»‡m
 * Äá»‹nh nghÄ©a dá»¯ liá»‡u cáº§n thiáº¿t Ä‘á»ƒ táº¡o thanh toÃ¡n cho cÃ¡c máº«u xÃ©t nghiá»‡m riÃªng láº»
 */
export class CreateSamplePaymentDto {
    // Sá»‘ tiá»n thanh toÃ¡n - Báº¯t buá»™c, tá»‘i thiá»ƒu 1,000 VND
    @IsNotEmpty({ message: 'Sá»‘ tiá»n thanh toÃ¡n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsNumber({}, { message: 'Sá»‘ tiá»n pháº£i lÃ  má»™t sá»‘ há»£p lá»‡' })
    @Min(1000, { message: 'Sá»‘ tiá»n tá»‘i thiá»ƒu lÃ  1,000 VND' })
    amount: number;

    // ID máº«u xÃ©t nghiá»‡m - TÃ¹y chá»n, Ä‘á»ƒ liÃªn káº¿t thanh toÃ¡n vá»›i máº«u cá»¥ thá»ƒ
    @IsOptional()
    @IsString({ message: 'ID máº«u xÃ©t nghiá»‡m pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    sample_id?: string;

    // Ghi chÃº thanh toÃ¡n - TÃ¹y chá»n, mÃ´ táº£ thÃªm vá» thanh toÃ¡n
    @IsOptional()
    @IsString({ message: 'Ghi chÃº pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    @MaxLength(500, { message: 'Ghi chÃº khÃ´ng Ä‘Æ°á»£c quÃ¡ 500 kÃ½ tá»±' })
    note?: string;

    constructor(amount: number, sample_id?: string, note?: string) {
        this.amount = amount;
        this.sample_id = sample_id;
        this.note = note;
    }
} 


================================================
FILE: src/modules/payment/dtos/createWebhook.dto.ts
================================================
import { IsNotEmpty, IsOptional, IsString, IsNumber, IsDateString } from 'class-validator';

/**
 * DTO xá»­ lÃ½ webhook tá»« PayOS
 * Äá»‹nh nghÄ©a cáº¥u trÃºc dá»¯ liá»‡u nháº­n tá»« webhook PayOS khi cÃ³ sá»± thay Ä‘á»•i tráº¡ng thÃ¡i thanh toÃ¡n
 */
export class CreateWebhookDto {
    // MÃ£ sá»‘ thanh toÃ¡n - Báº¯t buá»™c pháº£i cÃ³ trong má»i webhook
    @IsNotEmpty({ message: 'MÃ£ thanh toÃ¡n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsString({ message: 'MÃ£ thanh toÃ¡n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    payment_no!: string;

    // Sá»‘ tiá»n thanh toÃ¡n - TÃ¹y chá»n, PayOS cÃ³ thá»ƒ gá»­i hoáº·c khÃ´ng
    @IsOptional()
    @IsString({ message: 'Sá»‘ tiá»n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    amount?: string;

    // Tráº¡ng thÃ¡i thanh toÃ¡n - Báº¯t buá»™c Ä‘á»ƒ biáº¿t káº¿t quáº£ thanh toÃ¡n
    @IsNotEmpty({ message: 'Tráº¡ng thÃ¡i thanh toÃ¡n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsString({ message: 'Tráº¡ng thÃ¡i thanh toÃ¡n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    status!: string;

    // Chá»¯ kÃ½ Ä‘iá»‡n tá»­ Ä‘á»ƒ xÃ¡c thá»±c webhook tá»« PayOS - Báº¯t buá»™c cho báº£o máº­t
    @IsNotEmpty({ message: 'Chá»¯ kÃ½ xÃ¡c thá»±c khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng' })
    @IsString({ message: 'Chá»¯ kÃ½ xÃ¡c thá»±c pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    signature!: string;

    // MÃ£ Ä‘Æ¡n hÃ ng sá»‘ tá»« PayOS - TÃ¹y chá»n
    @IsOptional()
    @IsNumber({}, { message: 'MÃ£ Ä‘Æ¡n hÃ ng pháº£i lÃ  sá»‘' })
    orderCode?: number;

    // MÃ´ táº£ giao dá»‹ch - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'MÃ´ táº£ pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    description?: string;

    // Sá»‘ tÃ i khoáº£n ngÆ°á»i thanh toÃ¡n - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'Sá»‘ tÃ i khoáº£n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    accountNumber?: string;

    // MÃ£ tham chiáº¿u giao dá»‹ch - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'MÃ£ tham chiáº¿u pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    reference?: string;

    // Thá»i gian thá»±c hiá»‡n giao dá»‹ch - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'Thá»i gian giao dá»‹ch pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    transactionDateTime?: string;

    // ÄÆ¡n vá»‹ tiá»n tá»‡ (VND, USD...) - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'ÄÆ¡n vá»‹ tiá»n tá»‡ pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    currency?: string;

    // ID liÃªn káº¿t thanh toÃ¡n tá»« PayOS - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'ID liÃªn káº¿t thanh toÃ¡n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    paymentLinkId?: string;

    // MÃ£ pháº£n há»“i tá»« PayOS - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'MÃ£ pháº£n há»“i pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    code?: string;

    // MÃ´ táº£ chi tiáº¿t pháº£n há»“i - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'MÃ´ táº£ pháº£n há»“i pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    desc?: string;

    // ID ngÃ¢n hÃ ng cá»§a tÃ i khoáº£n nháº­n - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'ID ngÃ¢n hÃ ng pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    counterAccountBankId?: string;

    // TÃªn ngÃ¢n hÃ ng cá»§a tÃ i khoáº£n nháº­n - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'TÃªn ngÃ¢n hÃ ng pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    counterAccountBankName?: string;

    // TÃªn chá»§ tÃ i khoáº£n nháº­n - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'TÃªn chá»§ tÃ i khoáº£n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    counterAccountName?: string;

    // Sá»‘ tÃ i khoáº£n nháº­n - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'Sá»‘ tÃ i khoáº£n nháº­n pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    counterAccountNumber?: string;

    // TÃªn tÃ i khoáº£n áº£o (náº¿u cÃ³) - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'TÃªn tÃ i khoáº£n áº£o pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    virtualAccountName?: string;

    // Sá»‘ tÃ i khoáº£n áº£o (náº¿u cÃ³) - TÃ¹y chá»n
    @IsOptional()
    @IsString({ message: 'Sá»‘ tÃ i khoáº£n áº£o pháº£i lÃ  chuá»—i kÃ½ tá»±' })
    virtualAccountNumber?: string;
}



================================================
FILE: src/modules/payment/swagger/payment-webhook.md
================================================
# PayOS Webhook Handling Documentation

## Overview
This document describes the process flow for handling PayOS payment webhooks in the system.

## Webhook Flow

1. **Webhook Received**
   - PayOS sends a webhook notification to our API endpoint (`/api/payment/webhook`)
   - The webhook contains payment status information, amount, payment number, and a signature

2. **Signature Verification**
   - The system verifies the webhook signature using HMAC-SHA256
   - If the signature is invalid, the request is rejected

3. **Payment Lookup**
   - The system looks up the payment using the payment number
   - Verifies that the payment exists and is in PENDING or PROCESSING status
   - Validates that the amount matches the expected amount

4. **Payment Status Update**
   - If payment status is SUCCESS:
     - Updates payment status to COMPLETED
     - Updates appointment status to CONFIRMED and payment_status to PAID
     - Creates or updates transactions for each sample
     - Sends a payment success email to the customer

   - If payment status is FAILED or other:
     - Updates payment status to FAILED
     - Updates appointment payment status to FAILED
     - Updates any existing transactions to FAILED status
     - Sends a payment failed email to the customer

5. **Response**
   - Returns a success response to PayOS to acknowledge receipt

## Transaction Handling

For successful payments, the system creates a transaction record for each sample associated with the payment. If no samples are found, a single transaction record is created as a fallback.

Each transaction includes:
- Payment ID
- Receipt number (formatted as `{payment_no}-{sample_id_prefix}`)
- Transaction date
- Sample ID (if available)
- PayOS transaction ID
- Payment status and timestamp
- Webhook received timestamp

## Error Handling

The system implements comprehensive error handling:
- Invalid signatures are rejected
- Missing payments are reported
- Amount mismatches are detected
- Transaction creation errors are logged but don't block the process
- Email sending errors are logged but don't block the process

## Testing Webhooks

To test the webhook functionality:
1. Create a test payment using the PayOS sandbox environment
2. Use a tool like Postman to send a simulated webhook to the endpoint
3. Verify that the payment and appointment statuses are updated correctly
4. Check that transaction records are created
5. Verify that the appropriate email is sent 


================================================
FILE: src/modules/payment/swagger/payment.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     # ================== ENUM SCHEMAS ==================
 *     PaymentStatus:
 *       type: string
 *       enum: [pending, processing, completed, cancelled, failed, refunded]
 *       description: |
 *         Tráº¡ng thÃ¡i thanh toÃ¡n trong há»‡ thá»‘ng:
 *         - pending: Äang chá» xá»­ lÃ½
 *         - processing: Äang Ä‘Æ°á»£c xá»­ lÃ½ bá»Ÿi cá»•ng thanh toÃ¡n
 *         - completed: HoÃ n thÃ nh thÃ nh cÃ´ng
 *         - cancelled: ÄÃ£ bá»‹ há»§y
 *         - failed: Tháº¥t báº¡i
 *         - refunded: ÄÃ£ hoÃ n tiá»n
 *       example: completed
 *     
 *     PaymentMethod:
 *       type: string
 *       enum: [CASH, PAY_OS]
 *       description: |
 *         PhÆ°Æ¡ng thá»©c thanh toÃ¡n Ä‘Æ°á»£c há»— trá»£:
 *         - CASH: Thanh toÃ¡n tiá»n máº·t táº¡i phÃ²ng khÃ¡m
 *         - PAY_OS: Thanh toÃ¡n online qua cá»•ng PayOS
 *       example: PAY_OS
 *     
 *     SampleType:
 *       type: string
 *       enum: [blood, saliva, hair, tissue]
 *       description: |
 *         Loáº¡i máº«u xÃ©t nghiá»‡m DNA:
 *         - blood: Máº«u mÃ¡u
 *         - saliva: Máº«u nÆ°á»›c bá»t
 *         - hair: Máº«u tÃ³c
 *         - tissue: Máº«u mÃ´
 *       example: blood
 *     
 *     SampleStatus:
 *       type: string
 *       enum: [pending, collected, processing, completed, failed]
 *       description: |
 *         Tráº¡ng thÃ¡i xá»­ lÃ½ máº«u xÃ©t nghiá»‡m:
 *         - pending: Chá» láº¥y máº«u
 *         - collected: ÄÃ£ láº¥y máº«u
 *         - processing: Äang xÃ©t nghiá»‡m
 *         - completed: HoÃ n thÃ nh xÃ©t nghiá»‡m
 *         - failed: XÃ©t nghiá»‡m tháº¥t báº¡i
 *       example: pending
 *     
 *     # ================== PAYMENT SCHEMAS ==================
 *     Payment:
 *       type: object
 *       description: Schema Ä‘áº§y Ä‘á»§ cá»§a má»™t thanh toÃ¡n trong há»‡ thá»‘ng
 *       properties:
 *         _id:
 *           type: string
 *           description: ID duy nháº¥t cá»§a thanh toÃ¡n trong MongoDB
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *         payment_no:
 *           type: string
 *           description: MÃ£ sá»‘ thanh toÃ¡n duy nháº¥t, dá»… Ä‘á»c cho ngÆ°á»i dÃ¹ng
 *           example: "PAY_123456789"
 *         appointment_id:
 *           type: string
 *           description: ID cá»§a lá»‹ch háº¹n liÃªn quan Ä‘áº¿n thanh toÃ¡n nÃ y
 *           example: "64a1b2c3d4e5f6789abcdef1"
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Danh sÃ¡ch ID cÃ¡c máº«u xÃ©t nghiá»‡m Ä‘Æ°á»£c thanh toÃ¡n
 *           example: ["64a1b2c3d4e5f6789abcdef2", "64a1b2c3d4e5f6789abcdef3"]
 *         amount:
 *           type: number
 *           description: Tá»•ng sá»‘ tiá»n thanh toÃ¡n (VND)
 *           minimum: 1000
 *           example: 500000
 *         payment_method:
 *           $ref: '#/components/schemas/PaymentMethod'
 *         status:
 *           $ref: '#/components/schemas/PaymentStatus'
 *         note:
 *           type: string
 *           description: Ghi chÃº cá»§a ngÆ°á»i thanh toÃ¡n
 *           example: "Thanh toÃ¡n xÃ©t nghiá»‡m DNA cÆ¡ báº£n"
 *         # PayOS specific fields - CÃ¡c trÆ°á»ng dÃ nh riÃªng cho PayOS
 *         payos_payment_id:
 *           type: string
 *           description: ID thanh toÃ¡n tá»« PayOS (náº¿u thanh toÃ¡n qua PayOS)
 *           example: "payos_12345_67890"
 *         payos_checkout_url:
 *           type: string
 *           description: Link thanh toÃ¡n PayOS cho ngÆ°á»i dÃ¹ng
 *           example: "https://pay.payos.vn/web/payment/123456"
 *         payos_web_id:
 *           type: string
 *           description: ID web thanh toÃ¡n PayOS
 *           example: "web_123456"
 *         payos_payment_status:
 *           type: string
 *           description: Tráº¡ng thÃ¡i thanh toÃ¡n tráº£ vá» tá»« PayOS
 *           enum: [PENDING, PAID, CANCELLED, EXPIRED]
 *           example: "PAID"
 *         payos_payment_status_time:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian cáº­p nháº­t tráº¡ng thÃ¡i tá»« PayOS
 *           example: "2024-01-01T10:30:00.000Z"
 *         payos_webhook_received_at:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian nháº­n webhook tá»« PayOS
 *           example: "2024-01-01T10:30:05.000Z"
 *         order_code:
 *           type: number
 *           description: MÃ£ Ä‘Æ¡n hÃ ng sá»‘ cho PayOS
 *           example: 123456789
 *         # Payer information - ThÃ´ng tin ngÆ°á»i thanh toÃ¡n
 *         payer_name:
 *           type: string
 *           description: TÃªn ngÆ°á»i thanh toÃ¡n
 *           example: "Nguyá»…n VÄƒn A"
 *         payer_email:
 *           type: string
 *           format: email
 *           description: Email ngÆ°á»i thanh toÃ¡n
 *           example: "nguyenvana@email.com"
 *         payer_phone:
 *           type: string
 *           description: Sá»‘ Ä‘iá»‡n thoáº¡i ngÆ°á»i thanh toÃ¡n
 *           example: "0987654321"
 *         # Timestamps - Thá»i gian
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian táº¡o thanh toÃ¡n
 *           example: "2024-01-01T10:00:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian cáº­p nháº­t gáº§n nháº¥t
 *           example: "2024-01-01T10:30:00.000Z"
 *     
 *     # ================== REQUEST SCHEMAS ==================
 *     CreateAppointmentPaymentRequest:
 *       type: object
 *       description: Schema yÃªu cáº§u táº¡o thanh toÃ¡n cho lá»‹ch háº¹n
 *       required:
 *         - appointment_id
 *         - payment_method
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID cá»§a lá»‹ch háº¹n cáº§n thanh toÃ¡n (báº¯t buá»™c)
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *         payment_method:
 *           $ref: '#/components/schemas/PaymentMethod'
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: |
 *             Danh sÃ¡ch ID máº«u xÃ©t nghiá»‡m cáº§n thanh toÃ¡n (tÃ¹y chá»n).
 *             Náº¿u khÃ´ng cung cáº¥p, há»‡ thá»‘ng sáº½ tá»± Ä‘á»™ng láº¥y táº¥t cáº£ máº«u cá»§a lá»‹ch háº¹n.
 *           example: ["64a1b2c3d4e5f6789abcdef1", "64a1b2c3d4e5f6789abcdef2"]
 *     PaymentWebhookRequest:
 *       type: object
 *       description: Schema webhook tá»« PayOS
 *       required:
 *         - payment_no
 *         - status
 *         - signature
 *       properties:
 *         payment_no:
 *           type: string
 *           description: MÃ£ sá»‘ thanh toÃ¡n (báº¯t buá»™c)
 *           example: "PAY_123456789"
 *         amount:
 *           type: string
 *           description: Sá»‘ tiá»n thanh toÃ¡n (tÃ¹y chá»n)
 *           example: "500000"
 *         status:
 *           type: string
 *           enum: [pending, paid, cancelled, expired]
 *           description: Tráº¡ng thÃ¡i thanh toÃ¡n tá»« PayOS (báº¯t buá»™c)
 *           example: "PAID"
 *         signature:
 *           type: string
 *           description: Chá»¯ kÃ½ HMAC-SHA256 Ä‘á»ƒ xÃ¡c thá»±c webhook (báº¯t buá»™c)
 *           example: "abc123def456..."
 *         orderCode:
 *           type: number
 *           description: MÃ£ Ä‘Æ¡n hÃ ng sá»‘ (tÃ¹y chá»n)
 *           example: 123456789
 *         description:
 *           type: string
 *           description: MÃ´ táº£ giao dá»‹ch (tÃ¹y chá»n)
 *           example: "Thanh toan xet nghiem DNA"
 *         # CÃ¡c trÆ°á»ng bá»• sung tá»« PayOS
 *         accountNumber:
 *           type: string
 *           description: Sá»‘ tÃ i khoáº£n thanh toÃ¡n
 *         reference:
 *           type: string
 *           description: MÃ£ tham chiáº¿u giao dá»‹ch
 *         transactionDateTime:
 *           type: string
 *           description: Thá»i gian thá»±c hiá»‡n giao dá»‹ch
 *         currency:
 *           type: string
 *           description: ÄÆ¡n vá»‹ tiá»n tá»‡
 *           example: "VND"
 *     
 *     # ================== RESPONSE SCHEMAS ==================
 *     PaymentResponse:
 *       type: object
 *       description: Schema pháº£n há»“i khi táº¡o/láº¥y thÃ´ng tin thanh toÃ¡n
 *       properties:
 *         id:
 *           type: string
 *           description: ID thanh toÃ¡n trong database
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *         payment_no:
 *           type: string
 *           description: MÃ£ sá»‘ thanh toÃ¡n
 *           example: "PAY_123456789"
 *         amount:
 *           type: number
 *           description: Sá»‘ tiá»n thanh toÃ¡n (VND)
 *           example: 500000
 *         status:
 *           $ref: '#/components/schemas/PaymentStatus'
 *         payment_method:
 *           $ref: '#/components/schemas/PaymentMethod'
 *         appointment_id:
 *           type: string
 *           description: ID lá»‹ch háº¹n liÃªn quan
 *           example: "64a1b2c3d4e5f6789abcdef1"
 *         payos_checkout_url:
 *           type: string
 *           description: Link thanh toÃ¡n PayOS (chá»‰ cÃ³ khi thanh toÃ¡n qua PayOS)
 *           example: "https://pay.payos.vn/web/payment/123456"
 *         note:
 *           type: string
 *           description: Ghi chÃº thanh toÃ¡n
 *           example: "Thanh toÃ¡n xÃ©t nghiá»‡m DNA cÆ¡ báº£n"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian táº¡o thanh toÃ¡n
 *           example: "2024-01-01T10:00:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian cáº­p nháº­t gáº§n nháº¥t
 *           example: "2024-01-01T10:30:00.000Z"
 *     
 *     PaymentVerificationResponse:
 *       type: object
 *       description: Schema pháº£n há»“i khi xÃ¡c minh tráº¡ng thÃ¡i thanh toÃ¡n
 *       properties:
 *         payment_status:
 *           $ref: '#/components/schemas/PaymentStatus'
 *         payment_info:
 *           $ref: '#/components/schemas/PaymentResponse'
 *         verification_time:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian thá»±c hiá»‡n xÃ¡c minh
 *           example: "2024-01-01T10:35:00.000Z"
 *         payos_status:
 *           type: string
 *           description: Tráº¡ng thÃ¡i tá»« PayOS API
 *           example: "PAID"
 *     
 *     # ================== SAMPLE SCHEMAS ==================
 *     SampleInfo:
 *       type: object
 *       description: Schema thÃ´ng tin máº«u xÃ©t nghiá»‡m
 *       properties:
 *         sample_id:
 *           type: string
 *           description: ID duy nháº¥t cá»§a máº«u xÃ©t nghiá»‡m
 *           example: "64a1b2c3d4e5f6789abcdef1"
 *         sample_code:
 *           type: string
 *           description: MÃ£ máº«u Ä‘á»ƒ theo dÃµi
 *           example: "DNA_SAMPLE_001"
 *         sample_type:
 *           $ref: '#/components/schemas/SampleType'
 *         test_type:
 *           type: string
 *           description: Loáº¡i xÃ©t nghiá»‡m DNA
 *           example: "Paternity Test"
 *         amount:
 *           type: number
 *           description: GiÃ¡ tiá»n cho máº«u nÃ y (VND)
 *           example: 250000
 *         status:
 *           $ref: '#/components/schemas/SampleStatus'
 *         patient_info:
 *           type: object
 *           description: ThÃ´ng tin bá»‡nh nhÃ¢n liÃªn quan
 *           properties:
 *             name:
 *               type: string
 *               description: TÃªn bá»‡nh nhÃ¢n
 *               example: "Nguyá»…n VÄƒn A"
 *             relationship:
 *               type: string
 *               description: Má»‘i quan há»‡ (Father, Mother, Child, etc.)
 *               example: "Father"
 *             age:
 *               type: number
 *               description: Tuá»•i bá»‡nh nhÃ¢n
 *               example: 35
 *             gender:
 *               type: string
 *               enum: [male, female, other]
 *               description: Giá»›i tÃ­nh
 *               example: "male"
 *         collected_at:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian láº¥y máº«u
 *           example: "2024-01-01T09:00:00.000Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian táº¡o record máº«u
 *           example: "2024-01-01T08:30:00.000Z"
 *     
 *     # ================== ERROR SCHEMAS ==================
 *     ErrorResponse:
 *       type: object
 *       description: Schema chuáº©n cho pháº£n há»“i lá»—i
 *       properties:
 *         success:
 *           type: boolean
 *           description: LuÃ´n false khi cÃ³ lá»—i
 *           example: false
 *         message:
 *           type: string
 *           description: ThÃ´ng bÃ¡o lá»—i chÃ­nh
 *           example: "Payment not found"
 *         error:
 *           type: string
 *           description: Chi tiáº¿t lá»—i hoáº·c mÃ£ lá»—i
 *           example: "No payment found with the provided ID"
 *         statusCode:
 *           type: integer
 *           description: HTTP status code
 *           example: 404
 *         timestamp:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian xáº£y ra lá»—i
 *           example: "2024-01-01T10:00:00.000Z"
 *     
 *     ValidationErrorResponse:
 *       type: object
 *       description: Schema lá»—i validation cho dá»¯ liá»‡u Ä‘áº§u vÃ o
 *       properties:
 *         success:
 *           type: boolean
 *           example: false
 *         message:
 *           type: string
 *           example: "Validation failed"
 *         errors:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               field:
 *                 type: string
 *                 description: TÃªn trÆ°á»ng bá»‹ lá»—i
 *                 example: "appointment_id"
 *               message:
 *                 type: string
 *                 description: ThÃ´ng bÃ¡o lá»—i cho trÆ°á»ng nÃ y
 *                 example: "ID lá»‹ch háº¹n khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng"
 *               value:
 *                 description: GiÃ¡ trá»‹ bá»‹ lá»—i
 *                 example: ""
 *         statusCode:
 *           type: integer
 *           example: 400
 *     
 *     # ================== SUCCESS RESPONSE WRAPPERS ==================
 *     SuccessResponse:
 *       type: object
 *       description: Schema wrapper cho pháº£n há»“i thÃ nh cÃ´ng
 *       properties:
 *         success:
 *           type: boolean
 *           description: LuÃ´n true khi thÃ nh cÃ´ng
 *           example: true
 *         data:
 *           description: Dá»¯ liá»‡u thá»±c táº¿ Ä‘Æ°á»£c tráº£ vá»
 *         message:
 *           type: string
 *           description: ThÃ´ng bÃ¡o thÃ nh cÃ´ng
 *           example: "Operation completed successfully"
 *         timestamp:
 *           type: string
 *           format: date-time
 *           description: Thá»i gian xá»­ lÃ½
 *           example: "2024-01-01T10:00:00.000Z"
 *     
 *     PaginatedResponse:
 *       type: object
 *       description: Schema cho pháº£n há»“i cÃ³ phÃ¢n trang
 *       properties:
 *         success:
 *           type: boolean
 *           example: true
 *         data:
 *           type: array
 *           description: Máº£ng dá»¯ liá»‡u cho trang hiá»‡n táº¡i
 *         pagination:
 *           type: object
 *           properties:
 *             current_page:
 *               type: integer
 *               description: Trang hiá»‡n táº¡i
 *               example: 1
 *             total_pages:
 *               type: integer
 *               description: Tá»•ng sá»‘ trang
 *               example: 5
 *             page_size:
 *               type: integer
 *               description: Sá»‘ item má»—i trang
 *               example: 10
 *             total_items:
 *               type: integer
 *               description: Tá»•ng sá»‘ item
 *               example: 47
 *             has_next:
 *               type: boolean
 *               description: CÃ³ trang tiáº¿p theo khÃ´ng
 *               example: true
 *             has_prev:
 *               type: boolean
 *               description: CÃ³ trang trÆ°á»›c khÃ´ng
 *               example: false
 *         message:
 *           type: string
 *           example: "Data retrieved successfully"
 */ 


================================================
FILE: src/modules/payment/swagger/payment.swagger.js
================================================
/**
 * @swagger
 * /api/payments/webhook/payos:
 *   post:
 *     tags:
 *       - payment
 *     summary: Webhook xá»­ lÃ½ callback tá»« PayOS
 *     description: |
 *       Endpoint nháº­n vÃ  xá»­ lÃ½ webhook tá»« cá»•ng thanh toÃ¡n PayOS khi cÃ³ thay Ä‘á»•i tráº¡ng thÃ¡i thanh toÃ¡n.
 *       
 *       **Quy trÃ¬nh xá»­ lÃ½ webhook:**
 *       1. XÃ¡c thá»±c chá»¯ kÃ½ webhook báº±ng HMAC-SHA256
 *       2. Kiá»ƒm tra thanh toÃ¡n tá»“n táº¡i vÃ  sá»‘ tiá»n khá»›p
 *       3. Cáº­p nháº­t tráº¡ng thÃ¡i thanh toÃ¡n vÃ  lá»‹ch háº¹n liÃªn quan
 *       4. Táº¡o hoáº·c cáº­p nháº­t giao dá»‹ch cho tá»«ng máº«u xÃ©t nghiá»‡m
 *       5. Gá»­i email thÃ´ng bÃ¡o dá»±a trÃªn tráº¡ng thÃ¡i thanh toÃ¡n
 *       
 *       **LÆ°u Ã½ báº£o máº­t:**
 *       - Endpoint nÃ y chá»‰ dÃ nh cho PayOS system
 *       - KhÃ´ng Ä‘Æ°á»£c gá»i trá»±c tiáº¿p tá»« client
 *       - YÃªu cáº§u chá»¯ kÃ½ há»£p lá»‡ tá»« PayOS
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/PaymentWebhookRequest'
 *     responses:
 *       '200':
 *         description: Webhook Ä‘Æ°á»£c xá»­ lÃ½ thÃ nh cÃ´ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Webhook processed successfully"
 *       '400':
 *         description: Dá»¯ liá»‡u webhook khÃ´ng há»£p lá»‡ (chá»¯ kÃ½ sai, khÃ´ng tÃ¬m tháº¥y thanh toÃ¡n, sá»‘ tiá»n khÃ´ng khá»›p)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '500':
 *         description: Lá»—i mÃ¡y chá»§ ná»™i bá»™
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/test-webhook-signature:
 *   post:
 *     tags:
 *       - payment
 *     summary: Táº¡o chá»¯ kÃ½ webhook test (chá»‰ development)
 *     description: |
 *       Endpoint há»— trá»£ developer test tÃ­ch há»£p webhook PayOS trong mÃ´i trÆ°á»ng development.
 *       
 *       **TÃ­nh nÄƒng:**
 *       - Táº¡o chá»¯ kÃ½ HMAC-SHA256 cho dá»¯ liá»‡u test
 *       - GiÃºp kiá»ƒm tra logic xá»­ lÃ½ webhook
 *       - Chá»‰ hoáº¡t Ä‘á»™ng trong mÃ´i trÆ°á»ng development
 *       
 *       **Háº¡n cháº¿:**
 *       - KhÃ´ng kháº£ dá»¥ng trÃªn production (tráº£ vá» 403 Forbidden)
 *       - Chá»‰ dÃ nh cho má»¥c Ä‘Ã­ch testing vÃ  debugging
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             description: Dá»¯ liá»‡u test Ä‘á»ƒ táº¡o chá»¯ kÃ½ webhook
 *             properties:
 *               payment_no:
 *                 type: string
 *                 example: "TEST_PAY_123456"
 *                 description: MÃ£ thanh toÃ¡n test
 *               amount:
 *                 type: number
 *                 example: 50000
 *                 description: Sá»‘ tiá»n test (VND)
 *               status:
 *                 type: string
 *                 enum: [PAID, CANCELLED, PENDING]
 *                 example: "PAID"
 *                 description: Tráº¡ng thÃ¡i thanh toÃ¡n test
 *     responses:
 *       '200':
 *         description: Chá»¯ kÃ½ test Ä‘Æ°á»£c táº¡o thÃ nh cÃ´ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     signature:
 *                       type: string
 *                       description: Chá»¯ kÃ½ HMAC-SHA256 Ä‘Æ°á»£c táº¡o
 *                     data:
 *                       type: object
 *                       description: Dá»¯ liá»‡u gá»‘c Ä‘Æ°á»£c kÃ½
 *                     signedData:
 *                       type: object
 *                       description: Dá»¯ liá»‡u kÃ¨m chá»¯ kÃ½ hoÃ n chá»‰nh
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Test signature generated successfully"
 *       '403':
 *         description: KhÃ´ng kháº£ dá»¥ng trÃªn production
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '400':
 *         description: KhÃ´ng cÃ³ dá»¯ liá»‡u test Ä‘Æ°á»£c cung cáº¥p
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/return/payos:
 *   get:
 *     tags:
 *       - payment
 *     summary: Xá»­ lÃ½ return URL tá»« PayOS
 *     description: |
 *       Endpoint xá»­ lÃ½ khi ngÆ°á»i dÃ¹ng hoÃ n thÃ nh thanh toÃ¡n vÃ  Ä‘Æ°á»£c PayOS redirect vá» website.
 *       
 *       **Quy trÃ¬nh xá»­ lÃ½:**
 *       1. Nháº­n orderCode tá»« query parameters
 *       2. TÃ¬m thanh toÃ¡n trong database theo orderCode
 *       3. Verify tráº¡ng thÃ¡i thanh toÃ¡n vá»›i PayOS API
 *       4. Redirect ngÆ°á»i dÃ¹ng Ä‘áº¿n frontend vá»›i thÃ´ng tin káº¿t quáº£
 *       
 *       **LÆ°u Ã½:**
 *       - Endpoint nÃ y Ä‘Æ°á»£c PayOS gá»i tá»± Ä‘á»™ng
 *       - KhÃ´ng nÃªn gá»i trá»±c tiáº¿p tá»« á»©ng dá»¥ng
 *       - LuÃ´n redirect vá» frontend vá»›i thÃ´ng tin thanh toÃ¡n
 *     parameters:
 *       - name: orderCode
 *         in: query
 *         required: true
 *         description: MÃ£ Ä‘Æ¡n hÃ ng tá»« PayOS
 *         schema:
 *           type: string
 *           example: "123456789"
 *       - name: code
 *         in: query
 *         description: MÃ£ káº¿t quáº£ tá»« PayOS
 *         schema:
 *           type: string
 *           example: "00"
 *       - name: id
 *         in: query
 *         description: ID giao dá»‹ch PayOS
 *         schema:
 *           type: string
 *           example: "payos_txn_123456"
 *     responses:
 *       '302':
 *         description: Redirect Ä‘áº¿n frontend vá»›i thÃ´ng tin káº¿t quáº£ thanh toÃ¡n
 *         headers:
 *           Location:
 *             description: URL frontend kÃ¨m thÃ´ng tin thanh toÃ¡n
 *             schema:
 *               type: string
 *               example: "https://frontend.com/payos?code=00&id=payos_123&orderCode=123456&status=completed"
 *       '400':
 *         description: Thiáº¿u orderCode trong query parameters
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Missing orderCode"
 *       '404':
 *         description: KhÃ´ng tÃ¬m tháº¥y thanh toÃ¡n vá»›i orderCode Ä‘Æ°á»£c cung cáº¥p
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Payment not found"
 */

/**
 * @swagger
 * /api/payments/appointment:
 *   post:
 *     tags:
 *       - payment
 *     summary: Táº¡o thanh toÃ¡n cho lá»‹ch háº¹n xÃ©t nghiá»‡m DNA
 *     description: |
 *       Táº¡o giao dá»‹ch thanh toÃ¡n cho má»™t lá»‹ch háº¹n xÃ©t nghiá»‡m DNA vá»›i cÃ¡c máº«u Ä‘Æ°á»£c chá»n.
 *       
 *       **TÃ­nh nÄƒng chÃ­nh:**
 *       - Há»— trá»£ thanh toÃ¡n tiá»n máº·t (CASH) vÃ  online (PAY_OS)
 *       - Tá»± Ä‘á»™ng tÃ­nh toÃ¡n tá»•ng tiá»n dá»±a trÃªn cÃ¡c máº«u xÃ©t nghiá»‡m
 *       - Há»— trá»£ thanh toÃ¡n má»™t pháº§n vá»›i custom_amount
 *       - Táº¡o link thanh toÃ¡n PayOS cho thanh toÃ¡n online
 *       - Tá»± Ä‘á»™ng láº¥y táº¥t cáº£ máº«u náº¿u khÃ´ng chá»‰ Ä‘á»‹nh sample_ids
 *       
 *       **Quy trÃ¬nh thanh toÃ¡n:**
 *       1. XÃ¡c thá»±c ngÆ°á»i dÃ¹ng vÃ  quyá»n truy cáº­p lá»‹ch háº¹n
 *       2. Láº¥y thÃ´ng tin máº«u xÃ©t nghiá»‡m vÃ  tÃ­nh toÃ¡n tá»•ng tiá»n
 *       3. Táº¡o payment record trong database
 *       4. Táº¡o link PayOS náº¿u chá»n thanh toÃ¡n online
 *       5. Tráº£ vá» thÃ´ng tin thanh toÃ¡n vÃ  link checkout
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateAppointmentPaymentRequest'
 *           examples:
 *             payos_payment:
 *               summary: Thanh toÃ¡n online qua PayOS
 *               value:
 *                 appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                 payment_method: "pay_os"
 *             cash_payment:
 *               summary: Thanh toÃ¡n tiá»n máº·t
 *               value:
 *                 appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                 payment_method: "cash"
 *             partial_payment:
 *               summary: Thanh toÃ¡n má»™t pháº§n vá»›i máº«u Ä‘Æ°á»£c chá»n
 *               value:
 *                 appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                 payment_method: "pay_os"
 *                 sample_ids: ["64a1b2c3d4e5f6789abcdef1", "64a1b2c3d4e5f6789abcdef2"]
 *     responses:
 *       '200':
 *         description: Thanh toÃ¡n Ä‘Æ°á»£c táº¡o thÃ nh cÃ´ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: '#/components/schemas/PaymentResponse'
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Appointment payment created successfully"
 *             examples:
 *               payos_success:
 *                 summary: ThÃ nh cÃ´ng táº¡o thanh toÃ¡n PayOS
 *                 value:
 *                   data:
 *                     id: "64a1b2c3d4e5f6789abcdef0"
 *                     payment_no: "PAY_123456789"
 *                     amount: 500000
 *                     status: "pending"
 *                     payment_method: "pay_os"
 *                     appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                     payos_checkout_url: "https://pay.payos.vn/web/payment/123456"
 *                     created_at: "2024-01-01T10:00:00.000Z"
 *                   success: true
 *                   message: "Appointment payment created successfully"
 *               cash_success:
 *                 summary: ThÃ nh cÃ´ng táº¡o thanh toÃ¡n tiá»n máº·t
 *                 value:
 *                   data:
 *                     id: "64a1b2c3d4e5f6789abcdef0"
 *                     payment_no: "PAY_123456789"
 *                     amount: 500000
 *                     status: "pending"
 *                     payment_method: "cash"
 *                     appointment_id: "64a1b2c3d4e5f6789abcdef0"
 *                     created_at: "2024-01-01T10:00:00.000Z"
 *                   success: true
 *                   message: "Appointment payment created successfully"
 *       '401':
 *         description: ChÆ°a xÃ¡c thá»±c ngÆ°á»i dÃ¹ng hoáº·c token khÃ´ng há»£p lá»‡
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '400':
 *         description: Dá»¯ liá»‡u Ä‘áº§u vÃ o khÃ´ng há»£p lá»‡ (thiáº¿u trÆ°á»ng báº¯t buá»™c, sai Ä‘á»‹nh dáº¡ng)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '404':
 *         description: KhÃ´ng tÃ¬m tháº¥y lá»‹ch háº¹n hoáº·c máº«u xÃ©t nghiá»‡m
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '403':
 *         description: KhÃ´ng cÃ³ quyá»n truy cáº­p lá»‹ch háº¹n nÃ y
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/{paymentNo}/verify:
 *   get:
 *     tags:
 *       - payment
 *     summary: XÃ¡c minh tráº¡ng thÃ¡i thanh toÃ¡n vá»›i PayOS
 *     description: |
 *       Kiá»ƒm tra vÃ  cáº­p nháº­t tráº¡ng thÃ¡i thanh toÃ¡n báº±ng cÃ¡ch gá»i API PayOS.
 *       
 *       **Quy trÃ¬nh xÃ¡c minh:**
 *       1. TÃ¬m thanh toÃ¡n trong database theo payment number
 *       2. Gá»i API PayOS Ä‘á»ƒ láº¥y tráº¡ng thÃ¡i má»›i nháº¥t
 *       3. So sÃ¡nh vÃ  cáº­p nháº­t tráº¡ng thÃ¡i trong database
 *       4. Cáº­p nháº­t tráº¡ng thÃ¡i lá»‹ch háº¹n náº¿u thanh toÃ¡n hoÃ n thÃ nh
 *       5. Tráº£ vá» thÃ´ng tin chi tiáº¿t thanh toÃ¡n
 *       
 *       **Sá»­ dá»¥ng khi:**
 *       - NgÆ°á»i dÃ¹ng muá»‘n kiá»ƒm tra tráº¡ng thÃ¡i thanh toÃ¡n thá»§ cÃ´ng
 *       - Äá»“ng bá»™ tráº¡ng thÃ¡i khi webhook bá»‹ miss
 *       - Troubleshooting váº¥n Ä‘á» thanh toÃ¡n
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: paymentNo
 *         in: path
 *         required: true
 *         description: MÃ£ sá»‘ thanh toÃ¡n cáº§n xÃ¡c minh
 *         schema:
 *           type: string
 *           example: "PAY_123456789"
 *     responses:
 *       '200':
 *         description: XÃ¡c minh thanh toÃ¡n hoÃ n táº¥t
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     payment_status:
 *                       type: string
 *                       enum: [pending, completed, cancelled, failed]
 *                       description: Tráº¡ng thÃ¡i thanh toÃ¡n sau khi xÃ¡c minh
 *                       example: "completed"
 *                     payment_info:
 *                       $ref: '#/components/schemas/PaymentResponse'
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Payment verification completed"
 *             examples:
 *               completed_payment:
 *                 summary: Thanh toÃ¡n Ä‘Ã£ hoÃ n thÃ nh
 *                 value:
 *                   data:
 *                     payment_status: "completed"
 *                     payment_info:
 *                       id: "64a1b2c3d4e5f6789abcdef0"
 *                       payment_no: "PAY_123456789"
 *                       amount: 500000
 *                       status: "completed"
 *                       payment_method: "pay_os"
 *                   success: true
 *                   message: "Payment verification completed"
 *               pending_payment:
 *                 summary: Thanh toÃ¡n Ä‘ang chá»
 *                 value:
 *                   data:
 *                     payment_status: "pending"
 *                     payment_info:
 *                       id: "64a1b2c3d4e5f6789abcdef0"
 *                       payment_no: "PAY_123456789"
 *                       amount: 500000
 *                       status: "pending"
 *                       payment_method: "pay_os"
 *                   success: true
 *                   message: "Payment verification completed"
 *       '404':
 *         description: KhÃ´ng tÃ¬m tháº¥y thanh toÃ¡n vá»›i mÃ£ sá»‘ Ä‘Æ°á»£c cung cáº¥p
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *       '500':
 *         description: Lá»—i khi gá»i API PayOS hoáº·c lá»—i mÃ¡y chá»§
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/{paymentNo}/cancel:
 *   post:
 *     tags:
 *       - payment
 *     summary: Há»§y thanh toÃ¡n Ä‘ang chá» xá»­ lÃ½
 *     description: |
 *       Há»§y má»™t giao dá»‹ch thanh toÃ¡n Ä‘ang á»Ÿ tráº¡ng thÃ¡i pending.
 *       
 *       **Quy táº¯c há»§y thanh toÃ¡n:**
 *       - Chá»‰ cÃ³ thá»ƒ há»§y thanh toÃ¡n cÃ³ tráº¡ng thÃ¡i 'pending'
 *       - Thanh toÃ¡n Ä‘Ã£ hoÃ n thÃ nh, tháº¥t báº¡i hoáº·c Ä‘Ã£ há»§y khÃ´ng thá»ƒ há»§y láº¡i
 *       - Thanh toÃ¡n PAY_OS sáº½ Ä‘Æ°á»£c há»§y trÃªn cá»•ng thanh toÃ¡n PayOS
 *       - Thanh toÃ¡n CASH cÃ³ thá»ƒ há»§y trá»±c tiáº¿p trong há»‡ thá»‘ng
 *       
 *       **Háº­u quáº£ khi há»§y:**
 *       - Tráº¡ng thÃ¡i thanh toÃ¡n chuyá»ƒn thÃ nh 'cancelled'
 *       - Tráº¡ng thÃ¡i lá»‹ch háº¹n cÃ³ thá»ƒ Ä‘Æ°á»£c cáº­p nháº­t
 *       - Link thanh toÃ¡n PayOS (náº¿u cÃ³) sáº½ khÃ´ng cÃ²n hiá»‡u lá»±c
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: paymentNo
 *         in: path
 *         required: true
 *         description: MÃ£ sá»‘ thanh toÃ¡n cáº§n há»§y
 *         schema:
 *           type: string
 *           example: "PAY_123456789"
 *     responses:
 *       '200':
 *         description: Há»§y thanh toÃ¡n thÃ nh cÃ´ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     cancelled:
 *                       type: boolean
 *                       example: true
 *                       description: XÃ¡c nháº­n thanh toÃ¡n Ä‘Ã£ Ä‘Æ°á»£c há»§y
 *                     payment_no:
 *                       type: string
 *                       example: "PAY_123456789"
 *                       description: MÃ£ sá»‘ thanh toÃ¡n Ä‘Ã£ há»§y
 *                     previous_status:
 *                       type: string
 *                       example: "pending"
 *                       description: Tráº¡ng thÃ¡i trÆ°á»›c khi há»§y
 *                     cancelled_at:
 *                       type: string
 *                       format: date-time
 *                       example: "2024-01-01T10:30:00.000Z"
 *                       description: Thá»i gian há»§y thanh toÃ¡n
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Payment cancelled successfully"
 *       '400':
 *         description: KhÃ´ng thá»ƒ há»§y thanh toÃ¡n (Ä‘Ã£ hoÃ n thÃ nh, Ä‘Ã£ há»§y, hoáº·c tháº¥t báº¡i)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *             examples:
 *               already_completed:
 *                 summary: Thanh toÃ¡n Ä‘Ã£ hoÃ n thÃ nh
 *                 value:
 *                   success: false
 *                   message: "Cannot cancel completed payment"
 *                   error: "Payment status: completed"
 *               already_cancelled:
 *                 summary: Thanh toÃ¡n Ä‘Ã£ bá»‹ há»§y
 *                 value:
 *                   success: false
 *                   message: "Payment already cancelled"
 *                   error: "Payment status: cancelled"
 *       '404':
 *         description: KhÃ´ng tÃ¬m tháº¥y thanh toÃ¡n vá»›i mÃ£ sá»‘ Ä‘Æ°á»£c cung cáº¥p
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */

/**
 * @swagger
 * /api/payments/success:
 *   get:
 *     tags:
 *       - payment
 *     summary: Xá»­ lÃ½ callback thÃ nh cÃ´ng tá»« PayOS
 *     description: |
 *       Endpoint xá»­ lÃ½ khi thanh toÃ¡n thÃ nh cÃ´ng vÃ  PayOS redirect ngÆ°á»i dÃ¹ng vá» website.
 *       
 *       **Quy trÃ¬nh xá»­ lÃ½ success callback:**
 *       1. Nháº­n orderCode vÃ  thÃ´ng tin thanh toÃ¡n tá»« query parameters
 *       2. Verify tráº¡ng thÃ¡i thanh toÃ¡n thá»±c táº¿ vá»›i PayOS API
 *       3. XÃ¡c Ä‘á»‹nh trang Ä‘Ã­ch dá»±a trÃªn káº¿t quáº£ verify:
 *          - Success: Redirect Ä‘áº¿n trang thÃ nh cÃ´ng
 *          - Pending: Redirect Ä‘áº¿n trang Ä‘ang xá»­ lÃ½
 *          - Failed: Redirect Ä‘áº¿n trang tháº¥t báº¡i
 *       
 *       **CÃ¡c trÆ°á»ng há»£p redirect:**
 *       - Thanh toÃ¡n hoÃ n thÃ nh â†’ Success page
 *       - Thanh toÃ¡n Ä‘ang chá» â†’ Pending page  
 *       - Thanh toÃ¡n tháº¥t báº¡i â†’ Failed page
 *       - Lá»—i xÃ¡c minh â†’ Error page
 *     parameters:
 *       - name: orderCode
 *         in: query
 *         required: true
 *         description: MÃ£ Ä‘Æ¡n hÃ ng tá»« PayOS callback
 *         schema:
 *           type: string
 *           example: "123456789"
 *       - name: amount
 *         in: query
 *         description: Sá»‘ tiá»n thanh toÃ¡n tá»« PayOS
 *         schema:
 *           type: string
 *           example: "500000"
 *       - name: status
 *         in: query
 *         description: Tráº¡ng thÃ¡i tá»« PayOS callback
 *         schema:
 *           type: string
 *           example: "PAID"
 *     responses:
 *       '302':
 *         description: Redirect Ä‘áº¿n trang káº¿t quáº£ phÃ¹ há»£p trÃªn frontend
 *         headers:
 *           Location:
 *             description: URL trang Ä‘Ã­ch vá»›i thÃ´ng tin thanh toÃ¡n
 *             schema:
 *               type: string
 *             examples:
 *               success_redirect:
 *                 summary: Redirect Ä‘áº¿n trang thÃ nh cÃ´ng
 *                 value: "https://frontend.com/payments/success?orderCode=123456&status=success"
 *               pending_redirect:
 *                 summary: Redirect Ä‘áº¿n trang Ä‘ang xá»­ lÃ½
 *                 value: "https://frontend.com/payments/pending?orderCode=123456"
 *               failed_redirect:
 *                 summary: Redirect Ä‘áº¿n trang tháº¥t báº¡i
 *                 value: "https://frontend.com/payments/failed?orderCode=123456&status=failed"
 */

/**
 * @swagger
 * /api/payments/failure:
 *   get:
 *     tags:
 *       - payment
 *     summary: Xá»­ lÃ½ callback tháº¥t báº¡i tá»« PayOS
 *     description: |
 *       Endpoint xá»­ lÃ½ khi thanh toÃ¡n tháº¥t báº¡i, bá»‹ há»§y hoáº·c gáº·p lá»—i vÃ  PayOS redirect vá».
 *       
 *       **Quy trÃ¬nh xá»­ lÃ½ failure callback:**
 *       1. Nháº­n orderCode tá»« query parameters (náº¿u cÃ³)
 *       2. Tá»± Ä‘á»™ng há»§y thanh toÃ¡n náº¿u orderCode Ä‘Æ°á»£c cung cáº¥p
 *       3. Log thÃ´ng tin lá»—i Ä‘á»ƒ phá»¥c vá»¥ debugging
 *       4. Redirect ngÆ°á»i dÃ¹ng Ä‘áº¿n trang thÃ´ng bÃ¡o lá»—i trÃªn frontend
 *       
 *       **CÃ¡c nguyÃªn nhÃ¢n tháº¥t báº¡i:**
 *       - NgÆ°á»i dÃ¹ng há»§y thanh toÃ¡n
 *       - Tháº»/tÃ i khoáº£n khÃ´ng Ä‘á»§ sá»‘ dÆ°
 *       - Lá»—i káº¿t ná»‘i vá»›i ngÃ¢n hÃ ng
 *       - Timeout trong quÃ¡ trÃ¬nh thanh toÃ¡n
 *       - Lá»—i há»‡ thá»‘ng PayOS
 *     parameters:
 *       - name: orderCode
 *         in: query
 *         description: MÃ£ Ä‘Æ¡n hÃ ng (náº¿u cÃ³ tá»« PayOS callback)
 *         schema:
 *           type: string
 *           example: "123456789"
 *       - name: code
 *         in: query
 *         description: MÃ£ lá»—i tá»« PayOS
 *         schema:
 *           type: string
 *           example: "CANCELLED"
 *       - name: desc
 *         in: query
 *         description: MÃ´ táº£ lá»—i tá»« PayOS
 *         schema:
 *           type: string
 *           example: "Payment cancelled by user"
 *     responses:
 *       '302':
 *         description: Redirect Ä‘áº¿n trang thÃ´ng bÃ¡o lá»—i trÃªn frontend
 *         headers:
 *           Location:
 *             description: URL trang lá»—i vá»›i thÃ´ng tin chi tiáº¿t
 *             schema:
 *               type: string
 *             examples:
 *               cancelled_redirect:
 *                 summary: Redirect khi ngÆ°á»i dÃ¹ng há»§y
 *                 value: "https://frontend.com/payments/failed?orderCode=123456&status=cancelled"
 *               error_redirect:
 *                 summary: Redirect khi cÃ³ lá»—i há»‡ thá»‘ng
 *                 value: "https://frontend.com/payments/failed?error=internal"
 *               unknown_redirect:
 *                 summary: Redirect khi khÃ´ng xÃ¡c Ä‘á»‹nh Ä‘Æ°á»£c lá»—i
 *                 value: "https://frontend.com/payments/failed?orderCode=unknown&status=cancelled"
 */

/**
 * @swagger
 * /api/payments/{paymentId}/samples:
 *   get:
 *     tags:
 *       - payment
 *     summary: Láº¥y danh sÃ¡ch máº«u xÃ©t nghiá»‡m cá»§a thanh toÃ¡n
 *     description: |
 *       Láº¥y thÃ´ng tin chi tiáº¿t cÃ¡c máº«u xÃ©t nghiá»‡m liÃªn quan Ä‘áº¿n má»™t thanh toÃ¡n cá»¥ thá»ƒ.
 *       
 *       **ThÃ´ng tin tráº£ vá» cho má»—i máº«u:**
 *       - ID vÃ  thÃ´ng tin cÆ¡ báº£n cá»§a máº«u
 *       - Loáº¡i máº«u xÃ©t nghiá»‡m (mÃ¡u, nÆ°á»›c bá»t, etc.)
 *       - Loáº¡i xÃ©t nghiá»‡m DNA Ä‘Æ°á»£c thá»±c hiá»‡n
 *       - GiÃ¡ tiá»n cho tá»«ng máº«u
 *       - Tráº¡ng thÃ¡i xá»­ lÃ½ máº«u hiá»‡n táº¡i
 *       - ThÃ´ng tin bá»‡nh nhÃ¢n liÃªn quan
 *       
 *       **Sá»­ dá»¥ng khi:**
 *       - Hiá»ƒn thá»‹ chi tiáº¿t hÃ³a Ä‘Æ¡n thanh toÃ¡n
 *       - Theo dÃµi tiáº¿n Ä‘á»™ xá»­ lÃ½ máº«u
 *       - Xuáº¥t bÃ¡o cÃ¡o thanh toÃ¡n chi tiáº¿t
 *       - XÃ¡c minh thÃ´ng tin trÆ°á»›c khi xá»­ lÃ½ máº«u
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - name: paymentId
 *         in: path
 *         required: true
 *         description: ID thanh toÃ¡n cáº§n láº¥y thÃ´ng tin máº«u
 *         schema:
 *           type: string
 *           example: "64a1b2c3d4e5f6789abcdef0"
 *     responses:
 *       '200':
 *         description: Láº¥y danh sÃ¡ch máº«u xÃ©t nghiá»‡m thÃ nh cÃ´ng
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       sample_id:
 *                         type: string
 *                         description: ID duy nháº¥t cá»§a máº«u xÃ©t nghiá»‡m
 *                         example: "64a1b2c3d4e5f6789abcdef1"
 *                       sample_code:
 *                         type: string
 *                         description: MÃ£ máº«u Ä‘á»ƒ theo dÃµi
 *                         example: "DNA_SAMPLE_001"
 *                       sample_type:
 *                         type: string
 *                         description: Loáº¡i máº«u xÃ©t nghiá»‡m
 *                         enum: [blood, saliva, hair, tissue]
 *                         example: "blood"
 *                       test_type:
 *                         type: string
 *                         description: Loáº¡i xÃ©t nghiá»‡m DNA
 *                         example: "Paternity Test"
 *                       amount:
 *                         type: number
 *                         description: GiÃ¡ tiá»n cho máº«u nÃ y (VND)
 *                         example: 250000
 *                       status:
 *                         type: string
 *                         description: Tráº¡ng thÃ¡i xá»­ lÃ½ máº«u
 *                         enum: [pending, processing, completed, failed]
 *                         example: "pending"
 *                       patient_info:
 *                         type: object
 *                         description: ThÃ´ng tin bá»‡nh nhÃ¢n liÃªn quan
 *                         properties:
 *                           name:
 *                             type: string
 *                             example: "Nguyá»…n VÄƒn A"
 *                           relationship:
 *                             type: string
 *                             example: "Father"
 *                       collected_at:
 *                         type: string
 *                         format: date-time
 *                         description: Thá»i gian láº¥y máº«u
 *                         example: "2024-01-01T09:00:00.000Z"
 *                       created_at:
 *                         type: string
 *                         format: date-time
 *                         description: Thá»i gian táº¡o record máº«u
 *                         example: "2024-01-01T08:30:00.000Z"
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Samples retrieved successfully"
 *             examples:
 *               paternity_test_samples:
 *                 summary: Máº«u xÃ©t nghiá»‡m huyáº¿t thá»‘ng
 *                 value:
 *                   data:
 *                     - sample_id: "64a1b2c3d4e5f6789abcdef1"
 *                       sample_code: "DNA_PAT_001_FATHER"
 *                       sample_type: "blood"
 *                       test_type: "Paternity Test"
 *                       amount: 250000
 *                       status: "pending"
 *                       patient_info:
 *                         name: "Nguyá»…n VÄƒn A"
 *                         relationship: "Father"
 *                       collected_at: "2024-01-01T09:00:00.000Z"
 *                     - sample_id: "64a1b2c3d4e5f6789abcdef2"
 *                       sample_code: "DNA_PAT_001_CHILD"
 *                       sample_type: "saliva"
 *                       test_type: "Paternity Test"
 *                       amount: 250000
 *                       status: "pending"
 *                       patient_info:
 *                         name: "Nguyá»…n VÄƒn B"
 *                         relationship: "Child"
 *                       collected_at: "2024-01-01T09:15:00.000Z"
 *                   success: true
 *                   message: "Samples retrieved successfully"
 *       '404':
 *         description: KhÃ´ng tÃ¬m tháº¥y thanh toÃ¡n hoáº·c khÃ´ng cÃ³ máº«u nÃ o liÃªn quan
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 *             examples:
 *               payment_not_found:
 *                 summary: KhÃ´ng tÃ¬m tháº¥y thanh toÃ¡n
 *                 value:
 *                   success: false
 *                   message: "Payment not found"
 *                   error: "No payment found with the provided ID"
 *               no_samples:
 *                 summary: Thanh toÃ¡n khÃ´ng cÃ³ máº«u
 *                 value:
 *                   success: false
 *                   message: "No samples found for this payment"
 *                   error: "Payment exists but no associated samples"
 *       '500':
 *         description: Lá»—i mÃ¡y chá»§ khi truy xuáº¥t thÃ´ng tin máº«u
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */ 


================================================
FILE: src/modules/payment/swagger/payment.tag.js
================================================
/**
 * @swagger
 * tags:
 *   - name: payment
 *     description: |
 *       **API Quáº£n lÃ½ Thanh toÃ¡n**
 *       
 *       Há»‡ thá»‘ng thanh toÃ¡n tÃ­ch há»£p vá»›i PayOS cho phÃ©p xá»­ lÃ½ cÃ¡c giao dá»‹ch thanh toÃ¡n
 *       cho dá»‹ch vá»¥ xÃ©t nghiá»‡m DNA. Bao gá»“m cÃ¡c tÃ­nh nÄƒng:
 *       
 *       - **Thanh toÃ¡n tiá»n máº·t:** Thanh toÃ¡n trá»±c tiáº¿p táº¡i phÃ²ng khÃ¡m
 *       - **Thanh toÃ¡n online:** TÃ­ch há»£p vá»›i cá»•ng PayOS
 *       - **Webhook processing:** Xá»­ lÃ½ callback tá»« PayOS
 *       - **XÃ¡c minh thanh toÃ¡n:** Kiá»ƒm tra tráº¡ng thÃ¡i vá»›i PayOS
 *       - **Quáº£n lÃ½ Ä‘Æ¡n hÃ ng:** Há»§y, hoÃ n tiá»n, theo dÃµi
 *       
 *       **Luá»“ng thanh toÃ¡n PayOS:**
 *       1. Táº¡o thanh toÃ¡n â†’ Nháº­n checkout URL
 *       2. NgÆ°á»i dÃ¹ng thanh toÃ¡n trÃªn PayOS
 *       3. PayOS gá»­i webhook â†’ Cáº­p nháº­t tráº¡ng thÃ¡i
 *       4. Redirect ngÆ°á»i dÃ¹ng vá» trang káº¿t quáº£
 *       
 *       **Báº£o máº­t:**
 *       - HMAC-SHA256 signature verification
 *       - JWT authentication cho API
 *       - Input validation vá»›i class-validator
 *     externalDocs:
 *       description: PayOS Documentation
 *       url: https://payos.vn/docs
 */ 


================================================
FILE: src/modules/refund/index.ts
================================================
import RefundSchema from './refund.model';
import { IRefund, RefundStatus, RefundMethod } from './refund.interface';
import { RefundStatusEnum, RefundMethodEnum } from './refund.enum';
import { RefundStatuses, RefundMethods } from './refund.constant';

export {
    RefundSchema,
    IRefund,
    RefundStatus,
    RefundMethod,
    RefundStatusEnum,
    RefundMethodEnum,
    RefundStatuses,
    RefundMethods
}; 


================================================
FILE: src/modules/refund/refund.constant.ts
================================================
import { RefundMethodEnum, RefundStatusEnum } from './refund.enum';

export const RefundStatuses = [
    '',
    RefundStatusEnum.PENDING,
    RefundStatusEnum.APPROVED,
    RefundStatusEnum.REJECTED,
    RefundStatusEnum.COMPLETED
];

export const RefundMethods = [
    '',
    RefundMethodEnum.CASH,
    RefundMethodEnum.BANK_TRANSFER,
    RefundMethodEnum.OTHER
]; 


================================================
FILE: src/modules/refund/refund.enum.ts
================================================
export enum RefundStatusEnum {
    PENDING = 'pending',
    APPROVED = 'approved',
    REJECTED = 'rejected',
    COMPLETED = 'completed'
}

export enum RefundMethodEnum {
    CASH = 'cash',
    BANK_TRANSFER = 'bank_transfer',
    OTHER = 'other'
} 


================================================
FILE: src/modules/refund/refund.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { RefundMethodEnum, RefundStatusEnum } from './refund.enum';

export type RefundStatus =
    RefundStatusEnum.PENDING |
    RefundStatusEnum.APPROVED |
    RefundStatusEnum.REJECTED |
    RefundStatusEnum.COMPLETED;

export type RefundMethod =
    RefundMethodEnum.CASH |
    RefundMethodEnum.BANK_TRANSFER |
    RefundMethodEnum.OTHER;

export interface IRefund extends Document {
    _id: string;
    payment_id: Schema.Types.ObjectId;
    requester_id: Schema.Types.ObjectId;
    approver_id?: Schema.Types.ObjectId;
    amount: number;
    reason: string;
    status: RefundStatus;
    refund_method: RefundMethod;
    refund_transaction_id?: string;
    refund_date?: Date;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/refund/refund.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { RefundMethods, RefundStatuses } from './refund.constant';
import { IRefund } from './refund.interface';

const RefundSchemaEntity: Schema<IRefund> = new Schema({
    payment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.PAYMENT, required: true, unique: true },
    requester_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    approver_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    amount: { type: Number, required: true },
    reason: { type: String, required: true },
    status: {
        type: String,
        enum: RefundStatuses,
        required: true
    },
    refund_method: {
        type: String,
        enum: RefundMethods,
        required: true
    },
    refund_transaction_id: { type: String },
    refund_date: { type: Date },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const RefundSchema = mongoose.model<IRefund & mongoose.Document>(
    COLLECTION_NAME.REFUND,
    RefundSchemaEntity
);

export default RefundSchema; 


================================================
FILE: src/modules/registration_form/index.ts
================================================
import RegistrationFormSchema from './registration_form.model';
import { IRegistrationForm } from './registration_form.interface';
import RegistrationFormController from './registration_form.controller';
import RegistrationFormService from './registration_form.service';
import RegistrationFormRepository from './registration_form.repository';
import RegistrationFormRoute from './registration_form.route';
import { CreateRegistrationFormDto, UpdateRegistrationFormDto } from './dtos';

export {
    RegistrationFormSchema,
    IRegistrationForm,
    RegistrationFormController,
    RegistrationFormService,
    RegistrationFormRepository,
    RegistrationFormRoute,
    CreateRegistrationFormDto,
    UpdateRegistrationFormDto
}; 


================================================
FILE: src/modules/registration_form/registration_form.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IRegistrationForm } from './registration_form.interface';
import RegistrationFormService from './registration_form.service';
import { CreateRegistrationFormDto } from './dtos/createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './dtos/updateRegistrationForm.dto';
import { UserRoleEnum } from '../user/user.enum';

export default class RegistrationFormController {
    private registrationFormService = new RegistrationFormService();

    /**
     * Create a new registration form (by laboratory technician)
     */
    public createRegistrationForm = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can create registration forms
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can create registration forms');
            }

            const formData: CreateRegistrationFormDto = req.body;
            const form = await this.registrationFormService.createRegistrationForm(formData, laboratoryTechnicianId);

            res.status(HttpStatus.Created).json(formatResponse<IRegistrationForm>(form));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Update an existing registration form (by laboratory technician)
     */
    public updateRegistrationForm = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;
            const formId = req.params.id;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can update registration forms
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can update registration forms');
            }

            const updateData: UpdateRegistrationFormDto = req.body;
            const updatedForm = await this.registrationFormService.updateRegistrationForm(formId, updateData, laboratoryTechnicianId);

            res.status(HttpStatus.Success).json(formatResponse<IRegistrationForm>(updatedForm));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get registration form by ID (accessible by laboratory technician, staff, manager, admin)
     */
    public getRegistrationFormById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only staff, laboratory technicians, managers, and admins can view registration forms
            if (![UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.MANAGER, UserRoleEnum.ADMIN].includes(userRole)) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to view registration forms');
            }

            const formId = req.params.id;
            const form = await this.registrationFormService.getRegistrationFormById(formId);

            res.status(HttpStatus.Success).json(formatResponse<IRegistrationForm>(form));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get registration form by sample ID (accessible by laboratory technician, staff, manager, admin)
     */
    public getRegistrationFormBySampleId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only staff, laboratory technicians, managers, and admins can view registration forms
            if (![UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.MANAGER, UserRoleEnum.ADMIN].includes(userRole)) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to view registration forms');
            }

            const sampleId = req.params.sampleId;
            const form = await this.registrationFormService.getRegistrationFormBySampleId(sampleId);

            res.status(HttpStatus.Success).json(formatResponse<IRegistrationForm>(form));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get all registration forms with pagination (accessible by laboratory technician, staff, manager, admin)
     */
    public getAllRegistrationForms = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only staff, laboratory technicians, managers, and admins can view registration forms
            if (![UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.MANAGER, UserRoleEnum.ADMIN].includes(userRole)) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have permission to view registration forms');
            }

            const page = parseInt(req.query.page as string) || 1;
            const limit = parseInt(req.query.limit as string) || 10;

            const result = await this.registrationFormService.getAllRegistrationForms(page, limit);

            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/registration_form/registration_form.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { SampleTypeEnum } from '../sample/sample.enum';
import { UserGenderEnum } from '../user/user.enum';

export interface IRegistrationForm extends Document {
    _id: string;
    sample_id: string | undefined;
    patient_name: string;
    gender: UserGenderEnum;
    phone_number: string;
    email: string;
    sample_type: SampleTypeEnum;
    relationship: string;
    collection_date: Date;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/registration_form/registration_form.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { UserGenders } from '../user/user.constant';
import { SampleTypes } from '../sample/sample.constant';
import { IRegistrationForm } from './registration_form.interface';

const RegistrationFormSchemaEntity: Schema<IRegistrationForm> = new Schema({
    sample_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SAMPLE },
    patient_name: { type: String, required: true },
    gender: {
        type: String,
        enum: UserGenders,
        required: true
    },
    phone_number: { type: String, required: true },
    email: { type: String, required: true },
    sample_type: {
        type: String,
        enum: SampleTypes,
        required: true
    },
    relationship: { type: String, required: true },
    collection_date: { type: Date, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const RegistrationFormSchema = mongoose.model<IRegistrationForm & mongoose.Document>(
    COLLECTION_NAME.REGISTRATION_FORM,
    RegistrationFormSchemaEntity
);

export default RegistrationFormSchema; 


================================================
FILE: src/modules/registration_form/registration_form.repository.ts
================================================
import RegistrationFormSchema from './registration_form.model';
import { IRegistrationForm } from './registration_form.interface';

export default class RegistrationFormRepository {
    public async create(data: Partial<IRegistrationForm>): Promise<IRegistrationForm> {
        return RegistrationFormSchema.create(data);
    }

    public async findOne(query: any): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findOne(query);
    }

    public async findById(id: string): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IRegistrationForm>, options: any = {}): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return RegistrationFormSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IRegistrationForm[]> {
        return RegistrationFormSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IRegistrationForm[]> {
        return RegistrationFormSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IRegistrationForm[]> {
        return RegistrationFormSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('sample_id');
    }

    public async findByIdWithPopulate(id: string): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findById(id)
            .populate('sample_id');
    }

    public async findBySampleId(sampleId: string): Promise<IRegistrationForm | null> {
        return RegistrationFormSchema.findOne({ sample_id: sampleId })
            .populate('sample_id');
    }
} 


================================================
FILE: src/modules/registration_form/registration_form.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import RegistrationFormController from './registration_form.controller';
import { CreateRegistrationFormDto } from './dtos/createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './dtos/updateRegistrationForm.dto';

export default class RegistrationFormRoute implements IRoute {
    public path = API_PATH.REGISTRATION_FORM;
    public router = Router();
    private registrationFormController = new RegistrationFormController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/registration-form -> Create a new registration form (laboratory technician only)
        this.router.post(
            `/`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(CreateRegistrationFormDto),
            this.registrationFormController.createRegistrationForm
        );

        // PUT: domain:/api/registration-form/:id -> Update an existing registration form (laboratory technician only)
        this.router.put(
            `/:id`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(UpdateRegistrationFormDto),
            this.registrationFormController.updateRegistrationForm
        );

        // GET: domain:/api/registration-form/:id -> Get registration form by ID (staff, laboratory technician, manager, admin)
        this.router.get(
            `/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.registrationFormController.getRegistrationFormById
        );

        // GET: domain:/api/registration-form/sample/:sampleId -> Get registration form by sample ID (staff, laboratory technician, manager, admin)
        this.router.get(
            `/sample/:sampleId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.registrationFormController.getRegistrationFormBySampleId
        );

        // GET: domain:/api/registration-form -> Get all registration forms with pagination (staff, laboratory technician, manager, admin)
        this.router.get(
            `/`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.registrationFormController.getAllRegistrationForms
        );
    }
} 


================================================
FILE: src/modules/registration_form/registration_form.service.ts
================================================
import mongoose from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IRegistrationForm } from './registration_form.interface';
import RegistrationFormRepository from './registration_form.repository';
import { CreateRegistrationFormDto } from './dtos/createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './dtos/updateRegistrationForm.dto';
import SampleService from '../sample/sample.service';
import { UserGenderEnum } from '../user/user.enum';
import { SampleTypeEnum } from '../sample/sample.enum';

export default class RegistrationFormService {
    private registrationFormRepository = new RegistrationFormRepository();
    private sampleService = new SampleService();

    /**
     * Create a new registration form
     */
    public async createRegistrationForm(formData: CreateRegistrationFormDto, laboratoryTechnicianId: string): Promise<IRegistrationForm> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(formData.sample_id)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Check if sample exists
            const sample = await this.sampleService.getSampleById(formData.sample_id);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Check if registration form already exists for this sample
            const existingForm = await this.registrationFormRepository.findBySampleId(formData.sample_id);
            if (existingForm) {
                throw new HttpException(
                    HttpStatus.Conflict,
                    'A registration form already exists for this sample'
                );
            }

            // Create the registration form
            const registrationForm = await this.registrationFormRepository.create({
                sample_id: formData.sample_id as any,
                patient_name: formData.patient_name,
                gender: formData.gender as UserGenderEnum,
                phone_number: formData.phone_number || '',
                email: formData.email || '',
                sample_type: formData.sample_type as SampleTypeEnum,
                relationship: formData.relationship,
                collection_date: new Date(formData.collection_date),
                created_at: new Date(),
                updated_at: new Date()
            });

            return registrationForm;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating registration form');
        }
    }

    /**
     * Update an existing registration form
     */
    public async updateRegistrationForm(formId: string, updateData: UpdateRegistrationFormDto, laboratoryTechnicianId: string): Promise<IRegistrationForm> {
        try {
            // Validate formId
            if (!mongoose.Types.ObjectId.isValid(formId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid registration form ID');
            }

            // Check if form exists
            const form = await this.registrationFormRepository.findById(formId);
            if (!form) {
                throw new HttpException(HttpStatus.NotFound, 'Registration form not found');
            }

            // Prepare update data
            const updateFields: Partial<IRegistrationForm> = {
                patient_name: updateData.patient_name,
                gender: updateData.gender as UserGenderEnum,
                phone_number: updateData.phone_number,
                email: updateData.email,
                sample_type: updateData.sample_type as SampleTypeEnum,
                relationship: updateData.relationship,
                updated_at: new Date()
            };

            // Convert collection_date to Date object if provided
            if (updateData.collection_date) {
                updateFields.collection_date = new Date(updateData.collection_date);
            }

            // Remove undefined fields
            Object.keys(updateFields).forEach(key => {
                if (updateFields[key as keyof Partial<IRegistrationForm>] === undefined) {
                    delete updateFields[key as keyof Partial<IRegistrationForm>];
                }
            });

            // Update the form
            const updatedForm = await this.registrationFormRepository.findByIdAndUpdate(
                formId,
                updateFields,
                { new: true }
            );

            if (!updatedForm) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update registration form');
            }

            return updatedForm;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating registration form');
        }
    }

    /**
     * Get registration form by ID
     */
    public async getRegistrationFormById(id: string): Promise<IRegistrationForm> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid registration form ID');
        }

        const form = await this.registrationFormRepository.findByIdWithPopulate(id);
        if (!form) {
            throw new HttpException(HttpStatus.NotFound, 'Registration form not found');
        }

        return form;
    }

    /**
     * Get registration form by sample ID
     */
    public async getRegistrationFormBySampleId(sampleId: string): Promise<IRegistrationForm> {
        if (!mongoose.Types.ObjectId.isValid(sampleId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
        }

        const form = await this.registrationFormRepository.findBySampleId(sampleId);
        if (!form) {
            throw new HttpException(HttpStatus.NotFound, 'Registration form not found for this sample');
        }

        return form;
    }

    /**
     * Get all registration forms with pagination
     */
    public async getAllRegistrationForms(page: number = 1, limit: number = 10): Promise<{ forms: IRegistrationForm[], total: number, page: number, limit: number }> {
        try {
            const skip = (page - 1) * limit;
            const forms = await this.registrationFormRepository.findWithPopulate({}, { created_at: -1 }, skip, limit);
            const total = await this.registrationFormRepository.countDocuments({});

            return {
                forms,
                total,
                page,
                limit
            };
        } catch (error) {
            throw new HttpException(HttpStatus.InternalServerError, 'Error fetching registration forms');
        }
    }
} 


================================================
FILE: src/modules/registration_form/dtos/createRegistrationForm.dto.ts
================================================
import { IsDateString, IsEnum, IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { SampleTypeEnum } from '../../sample/sample.enum';

export class CreateRegistrationFormDto {
    @IsNotEmpty({ message: 'Sample ID is required' })
    @IsMongoId({ message: 'Sample ID must be a valid MongoDB ID' })
    sample_id: string = '';

    @IsNotEmpty({ message: 'Patient name is required' })
    @IsString({ message: 'Patient name must be a string' })
    patient_name: string = '';

    @IsNotEmpty({ message: 'Gender is required' })
    @IsString({ message: 'Gender must be a string' })
    gender: string = '';

    @IsOptional()
    @IsString({ message: 'Phone number must be a string' })
    phone_number?: string;

    @IsOptional()
    @IsString({ message: 'Email must be a string' })
    email?: string;

    @IsNotEmpty({ message: 'Sample type is required' })
    @IsEnum(SampleTypeEnum, { message: 'Sample type must be a valid type' })
    sample_type: string = '';

    @IsNotEmpty({ message: 'Relationship is required' })
    @IsString({ message: 'Relationship must be a string' })
    relationship: string = '';

    @IsNotEmpty({ message: 'Collection date is required' })
    @IsDateString({}, { message: 'Collection date must be a valid date' })
    collection_date: string = '';
} 


================================================
FILE: src/modules/registration_form/dtos/index.ts
================================================
import { CreateRegistrationFormDto } from './createRegistrationForm.dto';
import { UpdateRegistrationFormDto } from './updateRegistrationForm.dto';

export {
    CreateRegistrationFormDto,
    UpdateRegistrationFormDto
}; 


================================================
FILE: src/modules/registration_form/dtos/updateRegistrationForm.dto.ts
================================================
import { IsDateString, IsEnum, IsOptional, IsString } from 'class-validator';
import { SampleTypeEnum } from '../../sample/sample.enum';

export class UpdateRegistrationFormDto {
    @IsOptional()
    @IsString({ message: 'Patient name must be a string' })
    patient_name?: string;

    @IsOptional()
    @IsString({ message: 'Gender must be a string' })
    gender?: string;

    @IsOptional()
    @IsString({ message: 'Phone number must be a string' })
    phone_number?: string;

    @IsOptional()
    @IsString({ message: 'Email must be a string' })
    email?: string;

    @IsOptional()
    @IsEnum(SampleTypeEnum, { message: 'Sample type must be a valid type' })
    sample_type?: string;

    @IsOptional()
    @IsString({ message: 'Relationship must be a string' })
    relationship?: string;

    @IsOptional()
    @IsDateString({}, { message: 'Collection date must be a valid date' })
    collection_date?: string;
} 


================================================
FILE: src/modules/registration_form/swagger/registrationForm.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateRegistrationFormDto:
 *       type: object
 *       required:
 *         - sample_id
 *         - patient_name
 *         - gender
 *         - sample_type
 *         - relationship
 *         - collection_date
 *       properties:
 *         sample_id:
 *           type: string
 *           description: ID of the sample associated with this registration form
 *           example: "60c72b2f9b1e8b3b4c8d6e26"
 *         patient_name:
 *           type: string
 *           description: Name of the patient
 *           example: "John Doe"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: Gender of the patient
 *           example: "male"
 *         phone_number:
 *           type: string
 *           description: Phone number of the patient
 *           example: "0123456789"
 *         email:
 *           type: string
 *           description: Email of the patient
 *           example: "john.doe@example.com"
 *         sample_type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample collected
 *           example: "saliva"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "father"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when the sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *
 *     UpdateRegistrationFormDto:
 *       type: object
 *       properties:
 *         patient_name:
 *           type: string
 *           description: Name of the patient
 *           example: "John Doe"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: Gender of the patient
 *           example: "male"
 *         phone_number:
 *           type: string
 *           description: Phone number of the patient
 *           example: "0123456789"
 *         email:
 *           type: string
 *           description: Email of the patient
 *           example: "john.doe@example.com"
 *         sample_type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample collected
 *           example: "saliva"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "father"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when the sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *
 *     RegistrationFormResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Registration Form ID
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *         sample_id:
 *           type: object
 *           description: Associated sample
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e26"
 *             type:
 *               type: string
 *               example: "saliva"
 *             status:
 *               type: string
 *               example: "received"
 *         patient_name:
 *           type: string
 *           description: Name of the patient
 *           example: "John Doe"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: Gender of the patient
 *           example: "male"
 *         phone_number:
 *           type: string
 *           description: Phone number of the patient
 *           example: "0123456789"
 *         email:
 *           type: string
 *           description: Email of the patient
 *           example: "john.doe@example.com"
 *         sample_type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample collected
 *           example: "saliva"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "father"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when the sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2025-05-27T09:12:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2025-05-27T09:13:00Z"
 */ 


================================================
FILE: src/modules/registration_form/swagger/registrationForm.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: registration-forms
 *   description: Registration Form management APIs
 */

/**
 * @swagger
 * /api/registration-form:
 *   post:
 *     tags:
 *       - registration-forms
 *     summary: Create a new registration form (Laboratory Technician only)
 *     description: Create a new registration form for a sample
 *     operationId: createRegistrationForm
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateRegistrationFormDto'
 *     responses:
 *       201:
 *         description: Registration form created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid input data or sample ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Laboratory technician access required
 *       404:
 *         description: Sample not found
 *       409:
 *         description: Registration form already exists for this sample
 *   get:
 *     tags:
 *       - registration-forms
 *     summary: Get all registration forms with pagination (Staff, Laboratory Technician, Manager, Admin)
 *     description: Retrieve a paginated list of registration forms
 *     operationId: getAllRegistrationForms
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: Registration forms retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 forms:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/RegistrationFormResponse'
 *                 total:
 *                   type: integer
 *                   example: 50
 *                 page:
 *                   type: integer
 *                   example: 1
 *                 limit:
 *                   type: integer
 *                   example: 10
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff, Laboratory technician, Manager, or Admin access required
 */

/**
 * @swagger
 * /api/registration-form/{id}:
 *   get:
 *     tags:
 *       - registration-forms
 *     summary: Get registration form by ID (Staff, Laboratory Technician, Manager, Admin)
 *     description: Retrieve detailed information about a specific registration form
 *     operationId: getRegistrationFormById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Registration Form ID
 *         example: "60c72b2f9b1e8b3b4c8d6e27"
 *     responses:
 *       200:
 *         description: Registration form details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid registration form ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff, Laboratory technician, Manager, or Admin access required
 *       404:
 *         description: Registration form not found
 *   put:
 *     tags:
 *       - registration-forms
 *     summary: Update an existing registration form (Laboratory Technician only)
 *     description: Update details of an existing registration form
 *     operationId: updateRegistrationForm
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Registration Form ID
 *         example: "60c72b2f9b1e8b3b4c8d6e27"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateRegistrationFormDto'
 *     responses:
 *       200:
 *         description: Registration form updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid input data or registration form ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Laboratory technician access required
 *       404:
 *         description: Registration form not found
 */

/**
 * @swagger
 * /api/registration-form/sample/{sampleId}:
 *   get:
 *     tags:
 *       - registration-forms
 *     summary: Get registration form by sample ID (Staff, Laboratory Technician, Manager, Admin)
 *     description: Retrieve registration form information for a specific sample
 *     operationId: getRegistrationFormBySampleId
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: sampleId
 *         required: true
 *         schema:
 *           type: string
 *         description: Sample ID
 *         example: "60c72b2f9b1e8b3b4c8d6e26"
 *     responses:
 *       200:
 *         description: Registration form details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/RegistrationFormResponse'
 *       400:
 *         description: Invalid sample ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff, Laboratory technician, Manager, or Admin access required
 *       404:
 *         description: Registration form not found for this sample
 */ 


================================================
FILE: src/modules/result/index.ts
================================================
import ResultSchema from './result.model';
import { IResult, ResultMatch, IResultData } from './result.interface';
import { ResultMatchEnum } from './result.enum';
import ResultController from './result.controller';
import ResultService from './result.service';
import ResultRepository from './result.repository';
import ResultRoute from './result.route';
import { CreateResultDto, UpdateResultDto, StartTestingDto } from './dtos';

export {
    ResultSchema,
    IResult,
    ResultMatch,
    IResultData,
    ResultMatchEnum,
    ResultController,
    ResultService,
    ResultRepository,
    ResultRoute,
    CreateResultDto,
    UpdateResultDto,
    StartTestingDto
}; 


================================================
FILE: src/modules/result/result.constant.ts
================================================
import { ResultMatchEnum } from './result.enum';

export const ResultMatches = [
    '',
    ResultMatchEnum.MATCH,
    ResultMatchEnum.NO_MATCH,
    ResultMatchEnum.INCONCLUSIVE
]; 


================================================
FILE: src/modules/result/result.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IResult } from './result.interface';
import ResultService from './result.service';
import { CreateResultDto } from './dtos/createResult.dto';
import { UpdateResultDto } from './dtos/updateResult.dto';
import { StartTestingDto } from './dtos/startTesting.dto';
import { UserRoleEnum } from '../user/user.enum';

export default class ResultController {
    private resultService = new ResultService();

    /**
     * Create a new test result (by laboratory technician)
     */
    public createResult = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can create results
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can create test results');
            }

            // Validate that sample_ids is provided and is an array
            if (!req.body.sample_ids || !Array.isArray(req.body.sample_ids) || req.body.sample_ids.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'At least one sample ID is required');
            }

            const resultData: CreateResultDto = req.body;
            const result = await this.resultService.createResult(resultData, laboratoryTechnicianId);

            res.status(HttpStatus.Created).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Update an existing test result (by laboratory technician)
     */
    public updateResult = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;
            const resultId = req.params.id;

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can update results
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can update test results');
            }

            const updateData: UpdateResultDto = req.body;
            const updatedResult = await this.resultService.updateResult(resultId, updateData, laboratoryTechnicianId);

            res.status(HttpStatus.Success).json(formatResponse<IResult>(updatedResult));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get result by ID (accessible by customer, staff, laboratory technician, manager, admin)
     */
    public getResultById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const resultId = req.params.id;
            const result = await this.resultService.getResultById(resultId);

            // If user is customer, check if they have access to this result
            if (req.user.role === UserRoleEnum.CUSTOMER &&
                result.customer_id?.toString() !== req.user.id) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have access to this result');
            }

            res.status(HttpStatus.Success).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get result by sample ID (accessible by customer, staff, laboratory technician, manager, admin)
     */
    public getResultBySampleId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const sampleId = req.params.sampleId;
            const result = await this.resultService.getResultBySampleId(sampleId);

            // If user is customer, check if they have access to this result
            if (req.user.role === UserRoleEnum.CUSTOMER &&
                result.customer_id?.toString() !== req.user.id) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have access to this result');
            }

            res.status(HttpStatus.Success).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get result by appointment ID (accessible by customer, staff, laboratory technician, manager, admin)
     */
    public getResultByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            const result = await this.resultService.getResultByAppointmentId(appointmentId);

            // If user is customer, check if they have access to this result
            if (req.user.role === UserRoleEnum.CUSTOMER &&
                result.customer_id?.toString() !== req.user.id) {
                throw new HttpException(HttpStatus.Forbidden, 'You do not have access to this result');
            }

            res.status(HttpStatus.Success).json(formatResponse<IResult>(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Start testing process for a sample or multiple samples (by laboratory technician)
     */
    public startTesting = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const laboratoryTechnicianId = req.user.id;
            const userRole = req.user.role;
            const sampleId = req.params.sampleId;

            console.log(`Starting testing process by user ${laboratoryTechnicianId} with role ${userRole}`);

            if (!laboratoryTechnicianId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only laboratory technicians can start testing
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only laboratory technicians can start testing');
            }

            const testingData: StartTestingDto = req.body;
            console.log('Testing data:', testingData);

            // If sample_ids are provided in the body, use them for batch processing
            if (testingData.sample_ids && testingData.sample_ids.length > 0) {
                console.log(`Batch processing ${testingData.sample_ids.length} samples`);

                // Process each sample ID
                const results = await Promise.all(
                    testingData.sample_ids.map(async (id) => {
                        try {
                            await this.resultService.startTesting(id, testingData, laboratoryTechnicianId);
                            return { id, success: true };
                        } catch (error: any) {
                            console.error(`Error processing sample ${id}:`, error);
                            return {
                                id,
                                success: false,
                                error: error instanceof HttpException ?
                                    error.message :
                                    'Failed to start testing for this sample'
                            };
                        }
                    })
                );

                // Count successes and failures
                const successful = results.filter(r => r.success).length;
                const failed = results.filter(r => !r.success).length;

                res.status(HttpStatus.Success).json(formatResponse({
                    message: `Testing process started for ${successful} samples, ${failed} failed`,
                    results
                }));
            } else if (sampleId) {
                // Single sample processing using the sample ID from the URL parameter
                await this.resultService.startTesting(sampleId, testingData, laboratoryTechnicianId);
                res.status(HttpStatus.Success).json(formatResponse({
                    message: 'Testing process started successfully',
                    sample_id: sampleId
                }));
            } else {
                // Neither sample_ids in body nor sampleId in URL parameters
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'No sample ID provided. Please provide a sample ID in the URL or sample_ids in the request body.'
                );
            }
        } catch (error) {
            console.error('Error in startTesting controller:', error);
            next(error);
        }
    };
} 


================================================
FILE: src/modules/result/result.enum.ts
================================================
export enum ResultMatchEnum {
    MATCH = 'match',
    NO_MATCH = 'no_match',
    INCONCLUSIVE = 'inconclusive'
} 


================================================
FILE: src/modules/result/result.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { ResultMatchEnum } from './result.enum';

export type ResultMatch =
    ResultMatchEnum.MATCH |
    ResultMatchEnum.NO_MATCH |
    ResultMatchEnum.INCONCLUSIVE;

export interface IResultData {
    [key: string]: any;
}

export interface IResult extends Document {
    _id: string;
    sample_ids: string[] | undefined;
    customer_id: string | undefined;
    appointment_id: string | undefined;
    laboratory_technician_id: string | undefined;
    is_match: boolean;
    result_data: IResultData | null;
    report_url: string | null;
    completed_at: Date | null;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/result/result.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IResult } from './result.interface';

const ResultSchemaEntity: Schema<IResult> = new Schema({
    sample_ids: { type: [Schema.Types.ObjectId], ref: COLLECTION_NAME.SAMPLE, required: true },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    laboratory_technician_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    is_match: { type: Boolean, required: true },
    result_data: { type: Schema.Types.Mixed },
    report_url: { type: String },
    completed_at: { type: Date },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const ResultSchema = mongoose.model<IResult & mongoose.Document>(
    COLLECTION_NAME.RESULT,
    ResultSchemaEntity
);

export default ResultSchema; 


================================================
FILE: src/modules/result/result.repository.ts
================================================
import mongoose from 'mongoose';
import { IResult } from './result.interface';
import ResultSchema from './result.model';

export default class ResultRepository {
    /**
     * Create a new result
     */
    public async create(resultData: Partial<IResult>): Promise<IResult> {
        const newResult = new ResultSchema(resultData);
        return await newResult.save();
    }

    /**
     * Find result by ID
     */
    public async findById(id: string): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return null;
        }
        return await ResultSchema.findById(id).exec();
    }

    /**
     * Find result by sample ID
     */
    public async findBySampleId(sampleId: string): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(sampleId)) {
            return null;
        }
        return await ResultSchema.findOne({ sample_ids: { $in: [sampleId] } }).exec();
    }

    /**
     * Find one result by query
     */
    public async findOne(query: any): Promise<IResult | null> {
        return await ResultSchema.findOne(query).exec();
    }

    /**
     * Find results by query
     */
    public async find(query: any): Promise<IResult[]> {
        return await ResultSchema.find(query).exec();
    }

    /**
     * Update result by ID
     */
    public async findByIdAndUpdate(id: string, updateData: Partial<IResult>, options?: any): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return null;
        }
        return await ResultSchema.findByIdAndUpdate(id, updateData, options).exec();
    }

    /**
     * Delete result by ID
     */
    public async findByIdAndDelete(id: string): Promise<IResult | null> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return null;
        }
        return await ResultSchema.findByIdAndDelete(id).exec();
    }

    public async countDocuments(query: any): Promise<number> {
        return ResultSchema.countDocuments(query);
    }

    public async findAll(query: any): Promise<IResult[]> {
        return ResultSchema.find(query)
            .populate('sample_ids')
            .populate('customer_id')
            .populate('appointment_id');
    }

    /**
     * Find result by appointment ID with populated fields
     */
    public async findByAppointmentId(appointmentId: string): Promise<IResult | null> {
        return ResultSchema.findOne({ appointment_id: appointmentId })
            .populate('sample_ids')
            .populate('customer_id')
            .populate('appointment_id')
            .populate('laboratory_technician_id');
    }
} 


================================================
FILE: src/modules/result/result.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import ResultController from './result.controller';
import { CreateResultDto } from './dtos/createResult.dto';
import { UpdateResultDto } from './dtos/updateResult.dto';
import { StartTestingDto } from './dtos/startTesting.dto';

export default class ResultRoute implements IRoute {
    public path = API_PATH.RESULT;
    public router = Router();
    private resultController = new ResultController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/result -> Create a new test result (laboratory technician only)
        this.router.post(
            `${API_PATH.RESULT}/`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            // validationMiddleware(CreateResultDto),
            this.resultController.createResult
        );

        // PUT: domain:/api/result/:id -> Update an existing test result (laboratory technician only)
        this.router.put(
            `${API_PATH.RESULT}/:id`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(UpdateResultDto),
            this.resultController.updateResult
        );

        // GET: domain:/api/result/:id -> Get result by ID (all authenticated users)
        this.router.get(
            `${API_PATH.RESULT}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.resultController.getResultById
        );

        // GET: domain:/api/result/sample/:sampleId -> Get result by sample ID (all authenticated users)
        this.router.get(
            `${API_PATH.RESULT}/sample/:sampleId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.resultController.getResultBySampleId
        );

        // GET: domain:/api/result/appointment/:appointmentId -> Get result by appointment ID (all authenticated users)
        this.router.get(
            `${API_PATH.RESULT}/appointment/:appointmentId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.resultController.getResultByAppointmentId
        );

        // PUT: domain:/api/result/sample/start-testing -> Start testing process for a single sample (laboratory technician only)
        // this.router.put(
        //     `${API_PATH.RESULT}/sample/start-testing`,
        //     authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
        //     validationMiddleware(StartTestingDto),
        //     this.resultController.startTesting
        // );

        // POST: domain:/api/result/samples/start-testing -> Start testing process for multiple samples (laboratory technician only)
        this.router.post(
            `${API_PATH.RESULT}/sample/start-testing`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(StartTestingDto),
            this.resultController.startTesting
        );
    }
} 


================================================
FILE: src/modules/result/result.service.ts
================================================
import mongoose from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IResult } from './result.interface';
import ResultRepository from './result.repository';
import { CreateResultDto } from './dtos/createResult.dto';
import { UpdateResultDto } from './dtos/updateResult.dto';
import { StartTestingDto } from './dtos/startTesting.dto';
import SampleService from '../sample/sample.service';
import { SampleStatusEnum } from '../sample/sample.enum';
import AppointmentService from '../appointment/appointment.service';
import { AppointmentStatusEnum, PaymentStatusEnum } from '../appointment/appointment.enum';
import { AppointmentLogService } from '../appointment_log';
import { AppointmentLogTypeEnum } from '../appointment_log/appointment_log.enum';
import ReportGeneratorService from './services/reportGenerator.service';
import { sendMail, createNotificationEmailTemplate } from '../../core/utils';
import { ISendMailDetail } from '../../core/interfaces';
import UserSchema from '../user/user.model';
import ServiceSchema from '../service/service.model';
import AppointmentSchema from '../appointment/appointment.model';
import { ServiceTypeEnum } from '../service/service.enum';

export default class ResultService {
    private resultRepository = new ResultRepository();
    private sampleService = new SampleService();
    private appointmentService = new AppointmentService();
    private appointmentLogService = new AppointmentLogService();
    private reportGeneratorService = new ReportGeneratorService();

    /**
     * Create a new test result
     */
    public async createResult(resultData: CreateResultDto, laboratoryTechnicianId: string): Promise<IResult> {
        try {
            // Validate IDs
            if (!resultData.sample_ids || resultData.sample_ids.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'At least one sample ID is required');
            }

            // Validate all sample IDs
            for (const sampleId of resultData.sample_ids) {
                if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                    throw new HttpException(HttpStatus.BadRequest, `Invalid sample ID format: ${sampleId}`);
                }
            }

            if (!mongoose.Types.ObjectId.isValid(resultData.appointment_id)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID format');
            }

            // Check if all samples exist
            for (const sampleId of resultData.sample_ids) {
                const sample = await this.sampleService.getSampleById(sampleId);
                if (!sample) {
                    throw new HttpException(HttpStatus.NotFound, `Sample not found: ${sampleId}`);
                }

                // Check if sample is in TESTING status
                if (sample.status !== SampleStatusEnum.TESTING) {
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        `Cannot create result for sample ${sampleId} that is not in testing status`
                    );
                }

                // Check if result already exists for this sample
                const existingResult = await this.resultRepository.findOne({
                    sample_ids: { $in: [sampleId] }
                });

                if (existingResult) {
                    throw new HttpException(
                        HttpStatus.Conflict,
                        `A result already exists for sample ${sampleId}`
                    );
                }
            }

            // Check if appointment exists
            let appointmentId = resultData.appointment_id;

            // Handle potential ObjectId conversion issues
            try {
                appointmentId = new mongoose.Types.ObjectId(resultData.appointment_id).toString();
            } catch (error) {
                console.error('Error converting appointment ID:', error);
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID format');
            }

            const appointment = await this.appointmentService.getAppointmentById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            // Láº¥y service Ä‘á»ƒ kiá»ƒm tra loáº¡i
            const service = await ServiceSchema.findById(appointment.service_id);
            let reportTemplate = 'default_report_template';
            let recipientEmail = undefined;
            if (service && service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                reportTemplate = 'administrative_report_template';
                // Æ¯u tiÃªn láº¥y email agency tá»« appointment, náº¿u khÃ´ng cÃ³ thÃ¬ láº¥y tá»« user
                recipientEmail = appointment.agency_contact_email;
                if (!recipientEmail) {
                    const user = await AppointmentSchema.findById(appointment.user_id);
                    recipientEmail = user?.email;
                }
            }

            let customerId: string;
            if (resultData.customer_id) {
                if (!mongoose.Types.ObjectId.isValid(resultData.customer_id)) {
                    throw new HttpException(HttpStatus.BadRequest, 'Invalid customer ID format');
                }
                customerId = resultData.customer_id;
                console.log(`Using provided customer_id: ${customerId}`);
            } else if (appointment.user_id) {
                // Handle different possible types of user_id
                if (typeof appointment.user_id === 'string') {
                    // If it's a string, use it directly
                    customerId = appointment.user_id;
                } else if (typeof appointment.user_id === 'object') {
                    // If it's an object (including ObjectId), convert to string
                    try {
                        // Try accessing properties safely with type assertions
                        const userIdObj = appointment.user_id as any;
                        if (userIdObj && userIdObj._id) {
                            customerId = userIdObj._id.toString();
                        } else {
                            // Direct ObjectId or similar
                            customerId = appointment.user_id || '';
                        }
                    } catch (err) {
                        console.error('Error extracting user_id:', err);
                        console.error('appointment.user_id:', appointment.user_id);
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            'Invalid user ID format in appointment'
                        );
                    }
                } else {
                    console.error('Invalid user_id format in appointment:', appointment.user_id);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'Invalid user ID format in appointment'
                    );
                }

                // Validate that we have a valid MongoDB ID
                if (!mongoose.Types.ObjectId.isValid(customerId)) {
                    console.error(`Invalid user_id extracted from appointment: ${customerId}`);
                    throw new HttpException(
                        HttpStatus.BadRequest,
                        'Invalid user ID format extracted from appointment'
                    );
                }

                console.log(`Using user_id from appointment: ${customerId}`);
            } else {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Customer ID not found in appointment'
                );
            }

            // Check if appointment has been paid for
            if (appointment.payment_status !== PaymentStatusEnum.PAID) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot create result for appointment that hasn't been paid for (payment status: ${appointment.payment_status})`
                );
            }

            // Check if appointment is in TESTING status
            if (appointment.status !== AppointmentStatusEnum.TESTING) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot create result for appointment that is not in testing status`
                );
            }

            try {
                // Log all IDs for debugging
                console.log('Creating result with:');
                console.log('sample_ids:', resultData.sample_ids);
                console.log('appointment_id:', appointmentId);
                console.log('customer_id:', customerId);
                console.log('laboratory_technician_id:', laboratoryTechnicianId);

                // Validate all IDs one more time
                if (!mongoose.Types.ObjectId.isValid(customerId)) {
                    throw new Error(`Invalid customer_id format: ${customerId}`);
                }

                if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                    throw new Error(`Invalid appointment_id format: ${appointmentId}`);
                }

                if (!mongoose.Types.ObjectId.isValid(laboratoryTechnicianId)) {
                    throw new Error(`Invalid laboratory_technician_id format: ${laboratoryTechnicianId}`);
                }

                for (const sampleId of resultData.sample_ids) {
                    if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                        throw new Error(`Invalid sample_id format: ${sampleId}`);
                    }
                }

                // Create the initial result
                const result = await this.resultRepository.create({
                    sample_ids: resultData.sample_ids.map(id => new mongoose.Types.ObjectId(id)) as any,
                    appointment_id: new mongoose.Types.ObjectId(appointmentId) as any,
                    customer_id: new mongoose.Types.ObjectId(customerId) as any,
                    laboratory_technician_id: new mongoose.Types.ObjectId(laboratoryTechnicianId) as any,
                    is_match: resultData.is_match,
                    result_data: resultData.result_data || {},
                    report_url: '',
                    completed_at: new Date(),
                    created_at: new Date(),
                    updated_at: new Date()
                });

                // Generate PDF report synchronously to ensure report_url is available
                try {
                    console.log('Generating PDF report...');
                    const reportUrl = await this.reportGeneratorService.generateReport(
                        result._id.toString(),
                        laboratoryTechnicianId,
                        reportTemplate
                    );

                    // Update the result with the report URL
                    await this.resultRepository.findByIdAndUpdate(
                        result._id.toString(),
                        { report_url: reportUrl },
                        { new: true }
                    );

                    // Update the result object to return to the client
                    result.report_url = reportUrl;
                    console.log(`PDF report generated successfully: ${reportUrl}`);
                } catch (error: any) {
                    console.error('Failed to generate PDF report:', error);

                    // If the error is related to AWS configuration, provide a clear message
                    if (error.message && (
                        error.message.includes('AWS credentials not configured') ||
                        error.message.includes('AWS S3 bucket not configured')
                    )) {
                        throw new HttpException(
                            HttpStatus.InternalServerError,
                            'AWS S3 is not properly configured. Please check your AWS credentials and bucket settings.'
                        );
                    }

                    // For other errors, continue with the process but report the error
                    throw new HttpException(
                        HttpStatus.InternalServerError,
                        `Failed to generate PDF report: ${error.message}`
                    );
                }

                // Update all samples status to COMPLETED
                for (const sampleId of resultData.sample_ids) {
                    await this.sampleService.updateSampleStatus(sampleId, SampleStatusEnum.COMPLETED);
                }

                // Update appointment status to COMPLETED
                await this.appointmentService.updateAppointmentStatus(
                    appointmentId,
                    AppointmentStatusEnum.COMPLETED
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.COMPLETED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for result creation:', logError);
                }

                // Send result notification email
                try {
                    await this.sendResultReadyEmail(result, appointment, recipientEmail);
                } catch (emailError) {
                    console.error('Failed to send result ready email:', emailError);
                }

                return result;
            } catch (createError: any) {
                console.error('Error creating result document:', createError);
                throw new HttpException(
                    HttpStatus.InternalServerError,
                    `Failed to create result: ${createError.message}`
                );
            }
        } catch (error: any) {
            console.error('Error in createResult:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(
                HttpStatus.InternalServerError,
                `Error creating result: ${error.message}`
            );
        }
    }

    /**
     * Generate PDF report for a test result
     * This is called automatically after result creation
     */
    private async generateResultReport(resultId: string, laboratoryTechnicianId: string): Promise<void> {
        try {
            // Generate the PDF report and get the URL
            const reportUrl = await this.reportGeneratorService.generateReport(resultId, laboratoryTechnicianId);

            // Update the result with the report URL
            await this.resultRepository.findByIdAndUpdate(
                resultId,
                { report_url: reportUrl },
                { new: true }
            );

            console.log(`PDF report generated successfully for result ${resultId}: ${reportUrl}`);
        } catch (error) {
            console.error(`Failed to generate PDF report for result ${resultId}:`, error);
            // We don't throw here as this is run asynchronously after the main transaction
        }
    }

    /**
     * Update an existing test result
     */
    public async updateResult(resultId: string, updateData: UpdateResultDto, laboratoryTechnicianId: string): Promise<IResult> {
        try {
            // Validate resultId
            if (!mongoose.Types.ObjectId.isValid(resultId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid result ID');
            }

            // Check if result exists
            const result = await this.resultRepository.findById(resultId);
            if (!result) {
                throw new HttpException(HttpStatus.NotFound, 'Result not found');
            }

            // Update the result
            const updatedResult = await this.resultRepository.findByIdAndUpdate(
                resultId,
                {
                    ...updateData,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedResult) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update result');
            }

            // If critical data changed (is_match or result_data), regenerate the PDF report
            if (updateData.is_match !== undefined || updateData.result_data) {
                // Generate PDF report asynchronously
                this.generateResultReport(resultId, laboratoryTechnicianId)
                    .catch(error => {
                        console.error('Failed to regenerate PDF report:', error);
                    });

                // Send result updated email
                try {
                    if (updatedResult.appointment_id) {
                        const appointment = await this.appointmentService.getAppointmentById(updatedResult.appointment_id.toString());
                        await this.sendResultUpdatedEmail(updatedResult, appointment);
                    } else {
                        console.error('Cannot send result updated email: appointment_id is undefined');
                    }
                } catch (emailError) {
                    console.error('Failed to send result updated email:', emailError);
                }
            }

            return updatedResult;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating result');
        }
    }

    /**
     * Get result by ID
     */
    public async getResultById(id: string): Promise<IResult> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid result ID');
        }

        const result = await this.resultRepository.findById(id);
        if (!result) {
            throw new HttpException(HttpStatus.NotFound, 'Result not found');
        }

        return result;
    }

    /**
     * Get result by sample ID
     */
    public async getResultBySampleId(sampleId: string): Promise<IResult> {
        try {
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            const result = await this.resultRepository.findOne({ sample_ids: { $in: [sampleId] } });

            if (!result) {
                throw new HttpException(HttpStatus.NotFound, 'Result not found for this sample');
            }

            return result;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving result');
        }
    }

    /**
     * Get result by appointment ID
     */
    public async getResultByAppointmentId(appointmentId: string): Promise<IResult> {
        if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
        }

        const result = await this.resultRepository.findByAppointmentId(appointmentId);
        if (!result) {
            throw new HttpException(HttpStatus.NotFound, 'Result not found for this appointment');
        }

        return result;
    }

    /**
     * Start testing process for a sample
     */
    public async startTesting(sampleId: string, testingData: StartTestingDto, laboratoryTechnicianId: string): Promise<void> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Check if sample exists
            const sample = await this.sampleService.getSampleById(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Extract appointment ID as string
            let appointmentId: string;
            if (typeof sample.appointment_id === 'object' && sample.appointment_id !== null) {
                appointmentId = sample.appointment_id || '';
            } else {
                appointmentId = String(sample.appointment_id) || '';
            }

            // Check if appointment exists and has been paid for
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, `Appointment not found with ID: ${appointmentId}`);
            }

            if (appointment.payment_status !== PaymentStatusEnum.PAID) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot start testing for appointment that hasn't been paid for (payment status: ${appointment.payment_status})`
                );
            }

            // Check if sample is in RECEIVED status
            if (sample.status !== SampleStatusEnum.RECEIVED) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot start testing for sample with status ${sample.status}`
                );
            }

            // Update sample status to TESTING
            await this.sampleService.updateSampleStatus(sampleId, SampleStatusEnum.TESTING);

            // Get appointment ID as string for updating
            const appointmentObjectId = appointment._id.toString();

            // Update appointment status to TESTING
            if (appointment.status !== AppointmentStatusEnum.TESTING) {
                await this.appointmentService.updateAppointmentStatus(
                    appointmentObjectId,
                    AppointmentStatusEnum.TESTING
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.TESTING
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for testing start:', logError);
                }

                // Send testing started email
                try {
                    await this.sendTestingStartedEmail(sample, appointment);
                } catch (emailError) {
                    console.error('Failed to send testing started email:', emailError);
                }
            }
        } catch (error) {
            console.error('Error in startTesting:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error starting testing process');
        }
    }

    /**
     * Send email notification when test result is ready
     */
    private async sendResultReadyEmail(result: IResult, appointment: any, recipientEmail?: string): Promise<void> {
        try {
            // Get user details
            let userId = result.customer_id;
            if (!userId && appointment && appointment.user_id) {
                userId = appointment.user_id;
            }

            if (!userId) {
                console.error('Cannot send email: User ID not found');
                return;
            }

            const user = await UserSchema.findById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details if available
            let serviceName = 'DNA Testing Service';
            if (appointment && appointment.service_id) {
                try {
                    const service = await mongoose.model('Service').findById(appointment.service_id);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                } catch (error) {
                    console.error('Error fetching service details:', error);
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Your Test Results Are Ready';
            const message = `
                Your test results for ${serviceName} are now ready.
                <br><br>
                <strong>Result Details:</strong>
                <br>
                Result ID: ${result._id}
                <br>
                Date Completed: ${result.completed_at ? new Date(result.completed_at).toLocaleString() : new Date().toLocaleString()}
                <br><br>
                ${result.is_match !== undefined ? `<strong>Result Match:</strong> ${result.is_match ? 'Positive' : 'Negative'}<br><br>` : ''}
                You can view your detailed results by logging into your account and accessing the Results section.
                ${result.report_url ? `<br><br>A detailed report has been generated and is available for viewing.` : ''}
                <br><br>
                If you have any questions about your results, please contact our medical team for assistance.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: recipientEmail || user.email,
                subject: 'Test Results Ready - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Result ready email sent to ${recipientEmail || user.email}`);
        } catch (error) {
            console.error('Error sending result ready email:', error);
        }
    }

    /**
     * Send email notification when test result is updated
     */
    private async sendResultUpdatedEmail(result: IResult, appointment: any): Promise<void> {
        try {
            // Get user details
            let userId = result.customer_id;
            if (!userId && appointment && appointment.user_id) {
                userId = appointment.user_id;
            }

            if (!userId) {
                console.error('Cannot send email: User ID not found');
                return;
            }

            const user = await UserSchema.findById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details if available
            let serviceName = 'DNA Testing Service';
            if (appointment && appointment.service_id) {
                try {
                    const service = await mongoose.model('Service').findById(appointment.service_id);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                } catch (error) {
                    console.error('Error fetching service details:', error);
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Your Test Results Have Been Updated';
            const message = `
                Your test results for ${serviceName} have been updated.
                <br><br>
                <strong>Result Details:</strong>
                <br>
                Result ID: ${result._id}
                <br>
                Last Updated: ${result.updated_at ? new Date(result.updated_at).toLocaleString() : new Date().toLocaleString()}
                <br><br>
                ${result.is_match !== undefined ? `<strong>Result Match:</strong> ${result.is_match ? 'Positive' : 'Negative'}<br><br>` : ''}
                Please log into your account to view the updated results.
                ${result.report_url ? `<br><br>An updated report has been generated and is available for viewing.` : ''}
                <br><br>
                If you have any questions about these changes, please contact our medical team for assistance.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Test Results Updated - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Result updated email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending result updated email:', error);
        }
    }

    /**
     * Send email notification when testing process starts
     */
    private async sendTestingStartedEmail(sample: any, appointment: any): Promise<void> {
        try {
            // Get user details from appointment
            const userId = appointment.user_id;
            if (!userId) {
                console.error('Cannot send email: User ID not found in appointment');
                return;
            }

            const user = await UserSchema.findById(userId);
            if (!user || !user.email) {
                console.error('Cannot send email: User not found or no email address');
                return;
            }

            // Get service details if available
            let serviceName = 'DNA Testing Service';
            if (appointment && appointment.service_id) {
                try {
                    const service = await mongoose.model('Service').findById(appointment.service_id);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                } catch (error) {
                    console.error('Error fetching service details:', error);
                }
            }

            const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || user.email;

            const title = 'Sample Testing Started';
            const message = `
                We are pleased to inform you that the laboratory has started processing your sample for ${serviceName}.
                <br><br>
                <strong>Testing Details:</strong>
                <br>
                Sample ID: ${sample._id}
                <br>
                Sample Type: ${sample.sample_type || 'DNA Sample'}
                <br>
                Testing Started: ${new Date().toLocaleString()}
                <br><br>
                The testing process typically takes 3-5 business days to complete. We will notify you as soon as your results are ready.
                <br><br>
                If you have any questions during this process, please don't hesitate to contact our customer support team.
            `;

            const emailDetails: ISendMailDetail = {
                toMail: user.email,
                subject: 'Sample Testing Started - Bloodline DNA Testing Service',
                html: createNotificationEmailTemplate(userName, title, message)
            };

            await sendMail(emailDetails);
            console.log(`Testing started email sent to ${user.email}`);
        } catch (error) {
            console.error('Error sending testing started email:', error);
        }
    }
} 


================================================
FILE: src/modules/result/dtos/createResult.dto.ts
================================================
import { IsArray, IsBoolean, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

export class ResultDataDto {
    [key: string]: any;
}

export class CreateResultDto {
    @IsNotEmpty({ message: 'Sample IDs are required' })
    @IsArray({ message: 'Sample IDs must be an array' })
    @IsMongoId({ each: true, message: 'Each Sample ID must be a valid MongoDB ID' })
    sample_ids: string[] = [];

    @IsNotEmpty({ message: 'Appointment ID is required' })
    @IsMongoId({ message: 'Appointment ID must be a valid MongoDB ID' })
    appointment_id: string = '';

    @IsOptional()
    @IsMongoId({ message: 'Customer ID must be a valid MongoDB ID' })
    customer_id?: string;

    @IsNotEmpty({ message: 'Is match status is required' })
    @IsBoolean({ message: 'Is match must be a boolean value' })
    is_match: boolean = false;

    @IsOptional()
    @ValidateNested()
    @Type(() => ResultDataDto)
    result_data?: Record<string, any>;

    @IsOptional()
    @IsString({ message: 'Report URL must be a string' })
    report_url?: string;
} 


================================================
FILE: src/modules/result/dtos/index.ts
================================================
import { CreateResultDto } from './createResult.dto';
import { UpdateResultDto } from './updateResult.dto';
import { StartTestingDto } from './startTesting.dto';

export {
    CreateResultDto,
    UpdateResultDto,
    StartTestingDto
}; 


================================================
FILE: src/modules/result/dtos/startTesting.dto.ts
================================================
import { IsArray, IsDateString, IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { Type } from 'class-transformer';

export class StartTestingDto {
    @IsNotEmpty({ message: 'Testing start date is required' })
    @IsDateString({}, { message: 'Testing start date must be a valid date' })
    testing_start_date: string = '';

    @IsOptional()
    @IsString({ message: 'Notes must be a string' })
    notes?: string;

    @IsOptional()
    @IsArray({ message: 'Sample IDs must be an array' })
    @IsMongoId({ each: true, message: 'Each sample ID must be a valid MongoDB ID' })
    @Type(() => String)
    sample_ids?: string[];
} 


================================================
FILE: src/modules/result/dtos/updateResult.dto.ts
================================================
import { IsBoolean, IsOptional, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

export class ResultDataDto {
    [key: string]: any;
}

export class UpdateResultDto {
    @IsOptional()
    @IsBoolean({ message: 'Is match must be a boolean value' })
    is_match?: boolean;

    @IsOptional()
    @ValidateNested()
    @Type(() => ResultDataDto)
    result_data?: Record<string, any>;

    @IsOptional()
    @IsString({ message: 'Report URL must be a string' })
    report_url?: string;
} 


================================================
FILE: src/modules/result/services/reportGenerator.service.ts
================================================
import { SampleService } from '../../sample';
import { AppointmentService } from '../../appointment';
import UserService from '../../user/user.service';
import ServiceService from '../../service/service.service';
import { TestResultReportData } from '../utils/pdfGenerator.util';
import ResultRepository from '../result.repository';
import { IResult } from '../result.interface';
import mongoose from 'mongoose';
import { HttpException } from '../../../core/exceptions';
import { HttpStatus } from '../../../core/enums';

export default class ReportGeneratorService {
    private sampleService = new SampleService();
    private appointmentService = new AppointmentService();
    private serviceService = new ServiceService();
    private userService = new UserService();
    private resultRepository = new ResultRepository();

    /**
     * Collect all data needed for the test result report
     */
    public async collectReportData(resultId: string, labTechnicianId: string): Promise<TestResultReportData> {
        // Validate resultId
        if (!mongoose.Types.ObjectId.isValid(resultId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid result ID');
        }

        // Get the result
        const result = await this.resultRepository.findById(resultId);
        if (!result) {
            throw new HttpException(HttpStatus.NotFound, 'Result not found');
        }

        // Check if there are any samples
        if (!result.sample_ids || result.sample_ids.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'No samples associated with this result');
        }

        // Get all samples with their data
        const samples = [];
        const sampleIds = result.sample_ids.map(id => id.toString());

        for (const sampleId of sampleIds) {
            const sample = await this.sampleService.getSampleById(sampleId);
            if (sample) {
                samples.push(sample);
            }
        }

        if (samples.length === 0) {
            throw new HttpException(HttpStatus.NotFound, 'No samples found');
        }

        // Get primary sample data (using the first sample for basic report data)
        const primarySample = samples[0];

        // Get appointment data
        const appointment = await this.appointmentService.getAppointmentById(result.appointment_id?.toString() || '');
        if (!appointment) {
            throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
        }

        // Get customer data
        const customer = await this.userService.getUserById(result.customer_id?.toString() || '');
        if (!customer) {
            throw new HttpException(HttpStatus.NotFound, 'Customer not found');
        }

        // Get lab technician data
        const labTechnician = await this.userService.getUserById(labTechnicianId);
        if (!labTechnician) {
            throw new HttpException(HttpStatus.NotFound, 'Laboratory technician not found');
        }

        // Get service data
        let serviceName = 'Unknown Service';

        try {
            if (appointment.service_id) {
                // Extract the service ID properly from the appointment
                let serviceId: string;

                // Handle different possible formats of service_id
                if (typeof appointment.service_id === 'object') {
                    if (appointment.service_id && (appointment.service_id as any)._id) {
                        serviceId = (appointment.service_id as any)._id.toString();
                    } else {
                        serviceId = (appointment.service_id as any).toString();
                    }
                } else {
                    serviceId = (appointment.service_id as any).toString();
                }

                // Now get the service with the extracted ID
                if (mongoose.Types.ObjectId.isValid(serviceId)) {
                    const service = await this.serviceService.getServiceById(serviceId);
                    if (service && service.name) {
                        serviceName = service.name;
                    }
                }
            }
        } catch (error) {
            console.error('Error getting service data:', error);
            // Continue with unknown service name
        }

        // Compile person information from samples
        const personsInfo = samples
            .filter(sample => sample.person_info)
            .map(sample => ({
                name: sample.person_info?.name || 'Unknown',
                relationship: sample.person_info?.relationship || 'Unknown',
                dob: sample.person_info?.dob || null,
                birthPlace: sample.person_info?.birth_place || 'Unknown',
                nationality: sample.person_info?.nationality || 'Unknown',
                identityDocument: sample.person_info?.identity_document || 'Unknown',
                sampleId: sample._id.toString(),
                imageUrl: sample.person_info?.image_url
            }));

        // Compile all data
        const reportData: TestResultReportData = {
            // Result data
            resultId: result._id.toString(),
            isMatch: result.is_match,
            resultData: result.result_data,
            completedAt: result.completed_at || new Date(),

            // Sample data
            sampleId: primarySample._id.toString(),
            sampleType: primarySample.type || 'Unknown',
            collectionMethod: primarySample.collection_method || 'Unknown',
            collectionDate: primarySample.collection_date || new Date(),

            // Additional data for multiple samples
            allSampleIds: sampleIds,
            personsInfo: personsInfo.length > 0 ? personsInfo : undefined,

            // Appointment data
            appointmentId: appointment._id.toString(),
            appointmentDate: appointment.appointment_date,
            serviceType: serviceName,

            // Customer data
            customerId: customer._id.toString(),
            customerName: `${customer.first_name} ${customer.last_name}`,
            customerGender: customer.gender || 'Not specified',
            customerDateOfBirth: customer.dob || new Date(),
            customerContactInfo: {
                email: customer.email || 'Not provided',
                phone: customer.phone_number || 'Not provided',
                address: customer.address || 'Not provided'
            },

            // Laboratory technician data
            labTechnicianId: labTechnician._id.toString(),
            labTechnicianName: `${labTechnician.first_name} ${labTechnician.last_name}`
        };

        return reportData;
    }

    /**
     * Generate a PDF report for a test result using the PDF generator
     * @param resultId ID of the result to generate a report for
     * @param labTechnicianId ID of the laboratory technician generating the report
     * @returns URL of the generated PDF
     */
    public async generateReport(resultId: string, labTechnicianId: string, reportTemplate?: string): Promise<string> {
        try {
            // Import the PDF generator dynamically to avoid circular dependencies
            const { generateTestResultPDF } = await import('../utils/pdfGenerator.util');

            // Collect all necessary data
            const reportData = await this.collectReportData(resultId, labTechnicianId);

            // Generate the PDF and get the URL
            const pdfUrl = await generateTestResultPDF(reportData, reportTemplate);

            // Update the result with the report URL
            await this.resultRepository.findByIdAndUpdate(
                resultId,
                { report_url: pdfUrl, updated_at: new Date() },
                { new: true }
            );

            return pdfUrl;
        } catch (error) {
            console.error('Failed to generate report:', error);
            throw new HttpException(
                HttpStatus.InternalServerError,
                'Failed to generate PDF report'
            );
        }
    }
} 


================================================
FILE: src/modules/result/swagger/result.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateResultDto:
 *       type: object
 *       required:
 *         - sample_ids
 *         - appointment_id
 *         - is_match
 *       properties:
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: IDs of the samples being tested
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment associated with the test
 *           example: "60c72b2f9b1e8b3b4c8d6e25"
 *         is_match:
 *           type: boolean
 *           description: Whether the DNA test resulted in a match
 *           example: true
 *         result_data:
 *           type: object
 *           description: Additional result data specific to the test type
 *           example: 
 *             probability: 99.99
 *             confidence_interval: "99.9% - 100%"
 *             markers_tested: 24
 *             markers_matched: 24
 *             dna_match_percentage: 99.99
 *             confidence_level: "High"
 *         report_url:
 *           type: string
 *           description: URL to the detailed test report
 *           example: "https://example.com/reports/dna-test-123456.pdf"
 *
 *     UpdateResultDto:
 *       type: object
 *       properties:
 *         is_match:
 *           type: boolean
 *           description: Whether the DNA test resulted in a match
 *           example: true
 *         result_data:
 *           type: object
 *           description: Additional result data specific to the test type
 *           example: 
 *             probability: 99.99
 *             confidence_interval: "99.9% - 100%"
 *             markers_tested: 24
 *             markers_matched: 24
 *         report_url:
 *           type: string
 *           description: URL to the detailed test report
 *           example: "https://example.com/reports/dna-test-123456.pdf"
 *
 *     StartTestingDto:
 *       type: object
 *       required:
 *         - testing_start_date
 *       properties:
 *         testing_start_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the testing process started
 *           example: "2025-06-01T09:00:00Z"
 *         notes:
 *           type: string
 *           description: Optional notes about the testing process
 *           example: "Sample appears to be in good condition"
 *
 *     ResultResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Result ID
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *         sample_ids:
 *           type: array
 *           description: Associated samples
 *           items:
 *             type: object
 *             properties:
 *               _id:
 *                 type: string
 *                 example: "60c72b2f9b1e8b3b4c8d6e26"
 *               type:
 *                 type: string
 *                 example: "saliva"
 *               status:
 *                 type: string
 *                 example: "completed"
 *               person_info:
 *                 type: object
 *                 properties:
 *                   name:
 *                     type: string
 *                     example: "Nguyá»…n VÄƒn A"
 *                   relationship:
 *                     type: string
 *                     example: "Cha giáº£ Ä‘á»‹nh"
 *                   dob:
 *                     type: string
 *                     format: date-time
 *                     example: "1978-04-19T00:00:00Z"
 *         customer_id:
 *           type: object
 *           description: Customer who ordered the test
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e24"
 *             first_name:
 *               type: string
 *               example: "John"
 *             last_name:
 *               type: string
 *               example: "Doe"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e25"
 *             status:
 *               type: string
 *               example: "completed"
 *         laboratory_technician_id:
 *           type: object
 *           description: Laboratory technician who performed the test
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e28"
 *             first_name:
 *               type: string
 *               example: "Jane"
 *             last_name:
 *               type: string
 *               example: "Smith"
 *         is_match:
 *           type: boolean
 *           description: Whether the DNA test resulted in a match
 *           example: true
 *         result_data:
 *           type: object
 *           description: Additional result data specific to the test type
 *           example: 
 *             probability: 99.99
 *             confidence_interval: "99.9% - 100%"
 *             markers_tested: 24
 *             markers_matched: 24
 *         report_url:
 *           type: string
 *           description: URL to the detailed test report
 *           example: "https://example.com/reports/dna-test-123456.pdf"
 *         completed_at:
 *           type: string
 *           format: date-time
 *           description: Date and time when the test was completed
 *           example: "2025-06-03T14:30:00Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2025-06-01T09:00:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2025-06-03T14:30:00Z"
 */ 


================================================
FILE: src/modules/result/swagger/result.swagger.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     ResultData:
 *       type: object
 *       properties:
 *         probability:
 *           type: number
 *           description: Probability of match in percentage
 *           example: 99.99
 *         confidence_interval:
 *           type: string
 *           description: Confidence interval for the result
 *           example: "99.9% - 100%"
 *         markers_tested:
 *           type: number
 *           description: Number of markers tested
 *           example: 24
 *         markers_matched:
 *           type: number
 *           description: Number of markers that matched
 *           example: 24
 *         dna_match_percentage:
 *           type: number
 *           description: DNA match percentage
 *           example: 99.99
 *         confidence_level:
 *           type: string
 *           description: Confidence level classification
 *           example: "high"
 *     
 *     CreateResult:
 *       type: object
 *       required:
 *         - sample_ids
 *         - appointment_id
 *         - customer_id
 *         - is_match
 *       properties:
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: IDs of the samples being tested
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment
 *           example: 5f8d0e0e9d3b9a0017c1a7a2
 *         customer_id:
 *           type: string
 *           description: ID of the customer
 *           example: 5f8d0e0e9d3b9a0017c1a7a3
 *         is_match:
 *           type: boolean
 *           description: Whether the test result is a match
 *           example: true
 *         result_data:
 *           $ref: '#/components/schemas/ResultData'
 *       description: >
 *         Create a new test result. 
 *         A PDF report will be automatically generated and the report_url field will be populated.
 *         The PDF will include customer information, sample details, and test results.
 * 
 *     UpdateResult:
 *       type: object
 *       properties:
 *         is_match:
 *           type: boolean
 *           description: Whether the test result is a match
 *           example: true
 *         result_data:
 *           $ref: '#/components/schemas/ResultData'
 *       description: >
 *         Update a test result. 
 *         If is_match or result_data is changed, a new PDF report will be generated automatically.
 * 
 *     Result:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Result ID
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: IDs of the samples
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment
 *         customer_id:
 *           type: string
 *           description: ID of the customer
 *         laboratory_technician_id:
 *           type: string
 *           description: ID of the laboratory technician who performed the test
 *         is_match:
 *           type: boolean
 *           description: Whether the test result is a match
 *         result_data:
 *           $ref: '#/components/schemas/ResultData'
 *         report_url:
 *           type: string
 *           description: URL to the PDF report of the test result
 *           example: https://medical-test-results.s3.us-east-1.amazonaws.com/test-results/5f8d0e0e9d3b9a0017c1a7a3/5f8d0e0e9d3b9a0017c1a7a4-20231025.pdf
 *         completed_at:
 *           type: string
 *           format: date-time
 *           description: When the test was completed
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: When the result was created
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: When the result was last updated
 * 
 *     StartTesting:
 *       type: object
 *       required:
 *         - testing_start_date
 *       properties:
 *         testing_start_date:
 *           type: string
 *           format: date-time
 *           description: Date when the testing process started
 *           example: "2023-10-25T10:00:00.000Z"
 *         notes:
 *           type: string
 *           description: Notes about the testing process
 *           example: "Starting DNA testing process"
 *         sample_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Array of sample IDs to start testing (for batch processing)
 *           example: ["60c72b2f9b1e8b3b4c8d6e26", "60c72b2f9b1e8b3b4c8d6e27"]
 */

/**
 * @swagger
 * /api/result:
 *   post:
 *     summary: Create a new test result (Lab only)
 *     description: >
 *       Create a new test result with automatic PDF report generation.
 *       The report will include detailed information about the test and results.
 *       Only laboratory technicians can create test results.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateResult'
 *     responses:
 *       201:
 *         description: Result created successfully, PDF generation started
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *                 message:
 *                   type: string
 *                   example: Result created successfully. PDF report will be generated and available shortly.
 *       400:
 *         description: Invalid request data
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden, only laboratory technicians can create results
 * 
 * /api/result/{id}:
 *   get:
 *     summary: Get result by ID (All authenticated users)
 *     description: Get a test result by its ID. Includes PDF report URL.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Result ID
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *       404:
 *         description: Result not found
 * 
 *   put:
 *     summary: Update a test result (Lab only)
 *     description: >
 *       Update a test result. If the is_match or result_data fields are changed,
 *       a new PDF report will be automatically generated.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Result ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateResult'
 *     responses:
 *       200:
 *         description: Result updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *                 message:
 *                   type: string
 *                   example: Result updated successfully. If test data was changed, a new PDF report will be generated.
 *       404:
 *         description: Result not found
 * 
 * /api/result/sample/start-testing:
 *   post:
 *     summary: Start testing process for multiple samples (batch processing) (Lab only)
 *     description: >
 *       Mark multiple samples as being tested in a single request. 
 *       Updates each sample status to TESTING and their associated appointment statuses to TESTING.
 *       Only laboratory technicians can start testing.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/StartTesting'
 *     responses:
 *       200:
 *         description: Testing process started for multiple samples
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Testing process started for 2 samples, 0 failed
 *                 results:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                         description: Sample ID
 *                         example: 60c72b2f9b1e8b3b4c8d6e26
 *                       success:
 *                         type: boolean
 *                         description: Whether testing started successfully for this sample
 *                         example: true
 *                       error:
 *                         type: string
 *                         description: Error message if testing failed for this sample
 *                         example: Sample not found
 *       400:
 *         description: No sample IDs provided or invalid request
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden, only laboratory technicians can start testing
 * 
 * /api/result/sample/{sampleId}:
 *   get:
 *     summary: Get result by sample ID (All authenticated users)
 *     description: Get a test result by its associated sample ID. Searches for the sample ID in the sample_ids array. Includes PDF report URL.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: sampleId
 *         required: true
 *         schema:
 *           type: string
 *         description: Sample ID
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *       404:
 *         description: Result not found for this sample
 * 
 * /api/result/appointment/{appointmentId}:
 *   get:
 *     summary: Get result by appointment ID (All authenticated users)
 *     description: Get a test result by its associated appointment ID. Includes PDF report URL.
 *     tags:
 *       - results
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   $ref: '#/components/schemas/Result'
 *       404:
 *         description: Result not found for this appointment
 */ 


================================================
FILE: src/modules/result/utils/pdfGenerator.util.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import PDFDocument from 'pdfkit';
import moment from 'moment';
import axios from 'axios';
import * as AWS from 'aws-sdk';
import { v4 as uuidv4 } from 'uuid';
import dotenv from 'dotenv';
import { HttpException } from '../../../core/exceptions';
import { HttpStatus } from '../../../core/enums';

dotenv.config();

const s3 = new AWS.S3({
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    region: process.env.AWS_REGION
});

// Path to default Times-Roman font available in PDFKit
// PDFKit includes these fonts: 'Courier', 'Courier-Bold', 'Courier-Oblique', 'Courier-BoldOblique',
// 'Helvetica', 'Helvetica-Bold', 'Helvetica-Oblique', 'Helvetica-BoldOblique',
// 'Times-Roman', 'Times-Bold', 'Times-Italic', 'Times-BoldItalic'

/**
 * Information about persons related to the sample
 */
export interface PersonInfo {
    name: string;
    relationship: string;
    dob: Date | null;
    birthPlace: string;
    nationality: string;
    identityDocument: string;
    sampleId: string;
    imageUrl?: string; // URL to the person's image
}

/**
 * Interface for data required to generate a test result PDF
 */
export interface TestResultReportData {
    // Test result data
    resultId: string;
    isMatch: boolean;
    resultData: any;
    completedAt: Date;

    // Sample data
    sampleId: string;
    sampleType: string;
    collectionMethod: string;
    collectionDate: Date;

    // Additional data for multiple samples
    allSampleIds?: string[];
    personsInfo?: PersonInfo[];

    // Appointment data
    appointmentId: string;
    appointmentDate: Date;
    serviceType: string;

    // Customer data
    customerId: string;
    customerName: string;
    customerGender: string;
    customerDateOfBirth: Date;
    customerContactInfo: {
        email: string;
        phone: string;
        address: string;
    };

    // Laboratory technician data
    labTechnicianId: string;
    labTechnicianName: string;
}

/**
 * Generate a PDF report for a test result in Vietnamese
 */
export async function generateTestResultPDF(data: TestResultReportData, template?: string): Promise<string> {
    // Validate AWS environment variables
    if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY || !process.env.AWS_REGION) {
        throw new HttpException(
            HttpStatus.InternalServerError,
            'AWS credentials not configured. Please set AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_REGION environment variables.'
        );
    }

    if (!process.env.AWS_S3_BUCKET_NAME) {
        throw new HttpException(
            HttpStatus.InternalServerError,
            'AWS S3 bucket not configured. Please set AWS_S3_BUCKET_NAME environment variable.'
        );
    }

    const tempFilePath = path.join(__dirname, `temp-report-${uuidv4()}.pdf`);

    try {
        // Create PDF document with improved margins for professional presentation
        const doc = new PDFDocument({
            margin: 50,
            size: 'A4',
            info: {
                Title: `Test Results Report - ${data.resultId}`,
                Author: 'Healthcare System',
                Subject: 'Medical Test Results',
                Keywords: 'test, medical, results'
            },
            autoFirstPage: true
        });
        const writeStream = fs.createWriteStream(tempFilePath);

        // Pipe the PDF to the file
        doc.pipe(writeStream);

        // === ADMINISTRATIVE PDF CUSTOMIZATION ===
        if (template === 'administrative_report_template') {
            // Watermark
            doc.fontSize(60).fillColor('#eeeeee').opacity(0.3).text('ADMINISTRATIVE', 100, 300);
            doc.opacity(1);
            // Header
            doc.fontSize(18).fillColor('#cc0000').text('ADMINISTRATIVE DNA TEST REPORT', { align: 'center' });
            doc.moveDown(0.5);
            // Sá»‘ hiá»‡u vá»¥ viá»‡c
            if ((data as any).caseNumber) {
                doc.fontSize(12).fillColor('#333333').text(`Case Number: ${(data as any).caseNumber}`, { align: 'right' });
            }
            // ThÃªm section xÃ¡c nháº­n cá»§a cÆ¡ quan
            doc.moveDown(2);
        } else {
            // Add decorative line for header
            doc.lineWidth(1)
                .moveTo(50, 110)
                .lineTo(550, 110)
                .stroke('#0066cc');
            // Add header with better styling - using ASCII instead of Unicode
            doc.fontSize(22).fillColor('#0066cc').text('TEST RESULTS REPORT', { align: 'center' });
            doc.moveDown(0.5);
        }

        // Add report identification with improved formatting - using ASCII instead of Unicode
        const dateStr = moment().locale('vi').format('DD/MM/YYYY');
        doc.fontSize(11).fillColor('#666666').text(`Report ID: ${data.resultId}`, { align: 'right' });
        doc.text(`Date created: ${dateStr}`, { align: 'right' });
        doc.moveDown(2);

        // Add customer information with better styling
        doc.roundedRect(50, doc.y, 500, 140, 5).fillAndStroke('#f6f6f6', '#dddddd');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('CUSTOMER INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        doc.text(`Full name: ${convertToASCII(data.customerName)}`, 70);
        doc.text(`Gender: ${convertToASCII(translateGender(data.customerGender))}`);
        doc.text(`Date of birth: ${moment(data.customerDateOfBirth).format('DD/MM/YYYY')}`);
        doc.text(`Phone: ${data.customerContactInfo.phone}`);
        doc.text(`Email: ${data.customerContactInfo.email}`);
        doc.text(`Address: ${data.customerContactInfo.address}`);
        doc.moveDown(1);
        doc.y += 10;

        // Display information about persons related to the sample if available
        if (data.personsInfo && data.personsInfo.length > 0) {
            doc.addPage();
            doc.fontSize(18).fillColor('#0066cc').text('RELATED PERSONS INFORMATION', { align: 'center' });
            doc.moveDown(1);

            // Display information for each person
            for (let i = 0; i < data.personsInfo.length; i++) {
                const person = data.personsInfo[i];

                doc.roundedRect(50, doc.y, 500, 220, 5).fillAndStroke('#f0f7ff', '#bbddff');
                doc.y += 10;

                doc.fontSize(14).fillColor('#0066cc').text(`PERSON ${i + 1}`, 70, doc.y);
                doc.moveDown(0.2);

                // Add person image if available
                if (person.imageUrl) {
                    try {
                        // Download the image from the URL
                        const response = await axios.get(person.imageUrl, {
                            responseType: 'arraybuffer'
                        });

                        // Create a buffer from the response data
                        const imageBuffer = Buffer.from(response.data, 'binary');

                        // Calculate image position (right side of the person info)
                        const imageX = 400;
                        const imageY = doc.y;

                        // Add the image to the PDF with a maximum width/height of 100px
                        doc.image(imageBuffer, imageX, imageY, {
                            fit: [100, 100],
                            align: 'right'
                        });
                    } catch (error) {
                        console.error(`Error adding person image for ${person.name}:`, error);
                        // Continue without the image if there's an error
                    }
                }

                doc.fontSize(10).fillColor('#333333');
                doc.text(`Full name: ${person.name}`, 70);
                doc.text(`Relationship: ${convertToASCII(person.relationship)}`);
                if (person.dob) {
                    doc.text(`Date of birth: ${moment(person.dob).format('DD/MM/YYYY')}`);
                }
                doc.text(`Place of birth: ${convertToASCII(person.birthPlace)}`);
                doc.text(`Nationality: ${convertToASCII(person.nationality)}`);
                if (person.identityDocument) {
                    doc.text(`Identity document: ${person.identityDocument}`);
                }
                doc.text(`Sample ID: ${person.sampleId}`);

                doc.moveDown(1);
                doc.y += 20;

                // Add new page if there are more people and not enough space
                if (i < data.personsInfo.length - 1 && doc.y > 650) {
                    doc.addPage();
                }
            }
        }

        // Add sample information with styled section
        doc.addPage();
        doc.roundedRect(50, doc.y, 500, 110, 5).fillAndStroke('#f0f7ff', '#bbddff');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('SAMPLE INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        // Display information about additional samples if available
        if (data.allSampleIds && data.allSampleIds.length > 1) {
            doc.moveDown(0.2);
            doc.text(`Number of samples: ${data.allSampleIds.length}`, 70);

            // Display list of sample IDs (maximum 5 samples to avoid excessive length)
            const displaySampleIds = data.allSampleIds.slice(0, 5);
            const remainingSamples = data.allSampleIds.length - 5;

            doc.text(`Sample ID list: ${displaySampleIds.join(', ')}${remainingSamples > 0 ? ` and ${remainingSamples} other samples` : ''}`, 70);
        }
        doc.text(`Sample type: ${convertToASCII(translateSampleType(data.sampleType))}`);
        doc.text(`Collection method: ${convertToASCII(translateCollectionMethod(data.collectionMethod))}`);
        doc.text(`Collection date: ${moment(data.collectionDate).format('DD/MM/YYYY')}`);

        doc.moveDown(1);
        doc.y += 10;

        // Add appointment information with styled section
        doc.roundedRect(50, doc.y, 500, 90, 5).fillAndStroke('#f5f0ff', '#ccbbff');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('APPOINTMENT INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        doc.text(`Appointment ID: ${data.appointmentId}`, 70);
        doc.text(`Appointment date: ${moment(data.appointmentDate).format('DD/MM/YYYY')}`);
        doc.text(`Service type: ${convertToASCII(translateServiceType(data.serviceType))}`);
        doc.moveDown(1);
        doc.y += 10;

        // Add test results with prominent styling
        doc.addPage();

        // Add decorative line for results page
        doc.lineWidth(2)
            .moveTo(50, 70)
            .lineTo(550, 70)
            .stroke('#0066cc');

        doc.fontSize(20).fillColor('#0066cc').text('TEST RESULTS', { align: 'center' });
        doc.moveDown(1);

        // Display match results prominently with improved visual indicator
        const resultBoxHeight = 60;
        const resultBoxY = doc.y;

        doc.roundedRect(150, resultBoxY, 300, resultBoxHeight, 10)
            .fillAndStroke(data.isMatch ? '#e6ffe6' : '#ffe6e6', data.isMatch ? '#00cc00' : '#cc0000');

        doc.fontSize(18).fillColor(data.isMatch ? '#006600' : '#990000');
        doc.text(`Result: ${data.isMatch ? 'MATCH' : 'NO MATCH'}`, 150, resultBoxY + 20, {
            align: 'center',
            width: 300
        });

        doc.y = resultBoxY + resultBoxHeight + 20;

        // Add detailed results with improved formatting
        if (data.resultData) {
            doc.fontSize(16).fillColor('#0066cc').text('Detailed test results:', { underline: true });
            doc.moveDown(0.5);

            // Get keys from result data
            const details = data.resultData;
            const keys = Object.keys(details);

            // Create table-like structure for results
            const startY = doc.y;
            let currentY = startY;

            // Draw table header
            doc.rect(50, currentY, 500, 30).fillAndStroke('#0066cc', '#0066cc');
            doc.fillColor('#ffffff').fontSize(14).text('Parameter', 70, currentY + 8);
            doc.text('Value', 350, currentY + 8);
            currentY += 30;

            // Add each result data point in alternating color rows
            keys.forEach((key, index) => {
                const isEvenRow = index % 2 === 0;
                const rowColor = isEvenRow ? '#f2f2f2' : '#ffffff';

                doc.rect(50, currentY, 500, 25).fill(rowColor);

                const formattedKey = convertToASCII(translateResultKey(key));
                doc.fillColor('#333333').fontSize(12)
                    .text(formattedKey, 70, currentY + 6);
                doc.text(`${details[key]}`, 350, currentY + 6);

                currentY += 25;
            });

            // Draw border around entire table
            doc.rect(50, startY, 500, currentY - startY).stroke('#cccccc');
        }

        doc.moveDown(1.5);

        // Add laboratory technician information with styled section
        doc.roundedRect(50, doc.y, 500, 80, 5).fillAndStroke('#f0f7ff', '#bbddff');
        doc.y += 10;
        doc.fontSize(16).fillColor('#0066cc').text('LABORATORY INFORMATION', 70, doc.y);
        doc.moveDown(0.5);
        doc.fontSize(12).fillColor('#333333');
        doc.text(`Laboratory technician: ${data.labTechnicianName}`, 70);
        doc.text(`Completion date: ${moment(data.completedAt).format('DD/MM/YYYY')}`);
        doc.moveDown(1.5);

        // Add signature line with improved styling
        doc.y += 20;
        doc.fontSize(12).fillColor('#333333').text('Signature', 70);
        doc.lineCap('butt')
            .moveTo(70, doc.y + 40)
            .lineTo(250, doc.y + 40)
            .stroke('#333333');
        doc.text('Laboratory technician', 70, doc.y + 45);

        // Add placeholder for company seal
        doc.circle(400, doc.y + 30, 40).stroke('#999999');
        doc.fontSize(10).fillColor('#999999').text('Official', 380, doc.y + 25);
        doc.text('seal', 385, doc.y + 38);

        // Add footer with disclaimer but no page numbering
        const footerY = doc.page.height - 50;
        doc.lineWidth(0.5)
            .moveTo(50, footerY - 15)
            .lineTo(550, footerY - 15)
            .stroke('#cccccc');

        doc.fontSize(10).fillColor('#666666').text(
            'This report is automatically generated and valid without signature. ' +
            'Results should be interpreted by qualified medical professionals.',
            50, footerY, { width: 500, align: 'center' }
        );

        // Finalize PDF
        doc.end();

        // Wait for file to be written
        await new Promise<void>((resolve) => {
            writeStream.on('finish', () => {
                resolve();
            });
        });

        // Upload to S3
        try {
            const fileContent = fs.readFileSync(tempFilePath);
            const timestamp = moment().format('YYYYMMDD-HHmmss');
            const fileName = `test-results/${data.customerId}/${data.resultId}-${timestamp}.pdf`;

            console.log(`Uploading PDF to S3 with filename: ${fileName}`);
            console.log(`Using bucket: ${process.env.AWS_S3_BUCKET_NAME}`);

            // Upload to S3
            const params = {
                Bucket: process.env.AWS_S3_BUCKET_NAME,
                Key: fileName,
                Body: fileContent,
                ContentType: 'application/pdf',
                // TODO: Uncomment this when we have a way to handle the ACL
                // ACL: 'public-read' 
            };

            console.log('Starting S3 upload...');
            const uploadResult = await s3.upload(params).promise();
            console.log('S3 upload completed successfully:', uploadResult.Location);

            // Delete temporary file
            fs.unlinkSync(tempFilePath);

            // Cuá»‘i file, náº¿u lÃ  ADMINISTRATIVE, thÃªm section xÃ¡c nháº­n cá»§a cÆ¡ quan
            if (template === 'administrative_report_template') {
                doc.addPage();
                doc.fontSize(14).fillColor('#cc0000').text('AGENCY CONFIRMATION', { align: 'center' });
                doc.moveDown(1);
                doc.fontSize(12).fillColor('#333333').text('This report is issued for administrative/legal purposes.');
                doc.moveDown(1);
                doc.text('Agency Representative: ___________________________');
                doc.moveDown(0.5);
                doc.text('Position: _______________________________________');
                doc.moveDown(0.5);
                doc.text('Date: ___________________   Signature: ___________________');
            }

            return uploadResult.Location;
        } catch (error: any) {
            throw new HttpException(
                HttpStatus.InternalServerError,
                `Error processing PDF: ${error.message}`
            );
        }
    } catch (error: any) {
        // Clean up temporary file if it exists
        if (fs.existsSync(tempFilePath)) {
            try {
                fs.unlinkSync(tempFilePath);
            } catch (unlinkError) {
                console.error('Error deleting temporary file:', unlinkError);
            }
        }

        console.error('Error generating or uploading PDF:', error);
        throw new HttpException(
            HttpStatus.InternalServerError,
            `Failed to generate or upload PDF report: ${error.message}`
        );
    }
}

/**
 * Function to convert Vietnamese Unicode characters to ASCII
 */
function convertToASCII(text: string): string {
    return text
        .replace(/[Ã Ã¡áº¡áº£Ã£Ã¢áº§áº¥áº­áº©áº«Äƒáº±áº¯áº·áº³áºµ]/g, 'a')
        .replace(/[Ã¨Ã©áº¹áº»áº½Ãªá»áº¿á»‡á»ƒá»…]/g, 'e')
        .replace(/[Ã¬Ã­á»‹á»‰Ä©]/g, 'i')
        .replace(/[Ã²Ã³á»á»ÃµÃ´á»“á»‘á»™á»•á»—Æ¡á»á»›á»£á»Ÿá»¡]/g, 'o')
        .replace(/[Ã¹Ãºá»¥á»§Å©Æ°á»«á»©á»±á»­á»¯]/g, 'u')
        .replace(/[á»³Ã½á»µá»·á»¹]/g, 'y')
        .replace(/Ä‘/g, 'd')
        .replace(/[Ã€Ãáº áº¢ÃƒÃ‚áº¦áº¤áº¬áº¨áºªÄ‚áº°áº®áº¶áº²áº´]/g, 'A')
        .replace(/[ÃˆÃ‰áº¸áººáº¼ÃŠá»€áº¾á»†á»‚á»„]/g, 'E')
        .replace(/[ÃŒÃá»Šá»ˆÄ¨]/g, 'I')
        .replace(/[Ã’Ã“á»Œá»ŽÃ•Ã”á»’á»á»˜á»”á»–Æ á»œá»šá»¢á»žá» ]/g, 'O')
        .replace(/[Ã™Ãšá»¤á»¦Å¨Æ¯á»ªá»¨á»°á»¬á»®]/g, 'U')
        .replace(/[á»²Ãá»´á»¶á»¸]/g, 'Y')
        .replace(/Ä/g, 'D');
}

/**
 * Helper functions to translate terms to Vietnamese
 */
function translateGender(gender: string): string {
    const genderMap: Record<string, string> = {
        'male': 'Nam',
        'female': 'Ná»¯',
        'other': 'KhÃ¡c'
    };
    return genderMap[gender.toLowerCase()] || gender;
}

function translateSampleType(sampleType: string): string {
    const sampleTypeMap: Record<string, string> = {
        'blood': 'MÃ¡u',
        'urine': 'NÆ°á»›c tiá»ƒu',
        'hair': 'TÃ³c',
        'saliva': 'NÆ°á»›c bá»t',
        'tissue': 'MÃ´',
        'swab': 'TÄƒm bÃ´ng'
    };
    return sampleTypeMap[sampleType.toLowerCase()] || sampleType;
}

function translateCollectionMethod(method: string): string {
    const methodMap: Record<string, string> = {
        'venipuncture': 'Láº¥y mÃ¡u tÄ©nh máº¡ch',
        'finger prick': 'Láº¥y mÃ¡u Ä‘áº§u ngÃ³n tay',
        'swab collection': 'Thu tháº­p báº±ng tÄƒm bÃ´ng',
        'clean catch': 'Thu tháº­p sáº¡ch',
        'self': 'Tá»± thu tháº­p'
    };
    return methodMap[method.toLowerCase()] || method;
}

function translateServiceType(serviceType: string): string {
    const serviceTypeMap: Record<string, string> = {
        'general checkup': 'KhÃ¡m tá»•ng quÃ¡t',
        'blood test': 'XÃ©t nghiá»‡m mÃ¡u',
        'genetic test': 'XÃ©t nghiá»‡m di truyá»n',
        'allergy test': 'XÃ©t nghiá»‡m dá»‹ á»©ng',
        'covid test': 'XÃ©t nghiá»‡m COVID',
        'dna test': 'XÃ©t nghiá»‡m ADN',
        'DNA Paternity Test': 'XÃ©t nghiá»‡m ADN xÃ¡c Ä‘á»‹nh huyáº¿t thá»‘ng'
    };
    return serviceTypeMap[serviceType.toLowerCase()] || serviceType;
}

function translateResultKey(key: string): string {
    // Convert snake_case to readable format and translate
    const formattedKey = key
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

    const resultKeyMap: Record<string, string> = {
        'Blood Pressure': 'Huyáº¿t Ã¡p',
        'Heart Rate': 'Nhá»‹p tim',
        'Glucose Level': 'Má»©c Ä‘Æ°á»ng huyáº¿t',
        'Cholesterol': 'Cholesterol',
        'Hemoglobin': 'Hemoglobin',
        'White Blood Cell Count': 'Sá»‘ lÆ°á»£ng báº¡ch cáº§u',
        'Red Blood Cell Count': 'Sá»‘ lÆ°á»£ng há»“ng cáº§u',
        'Platelet Count': 'Sá»‘ lÆ°á»£ng tiá»ƒu cáº§u',
        'Dna Match': 'Khá»›p ADN',
        'Match Percentage': 'Tá»· lá»‡ khá»›p',
        'Match Score': 'Äiá»ƒm khá»›p',
        'Confidence Level': 'Má»©c Ä‘á»™ tin cáº­y'
    };

    return resultKeyMap[formattedKey] || formattedKey;
}         


================================================
FILE: src/modules/review/index.ts
================================================
import ReviewSchema from './review.model';
import { IReview } from './review.interface';
import ReviewController from './review.controller';
import ReviewService from './review.service';
import ReviewRoute from './review.route';

export {
    ReviewSchema,
    IReview,
    ReviewController,
    ReviewService,
    ReviewRoute
}; 


================================================
FILE: src/modules/review/review.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { IReview } from './review.interface';
import ReviewService from './review.service'
import { CreateReviewDto, UpdateReviewDto } from './dtos';
import { UserRoleEnum } from '../user';
import { SearchPaginationResponseModel } from '../../core/models';

export default class ReviewController {
    private reviewService = new ReviewService();

    /**
     * Create a review
     */
    public createReview = async (req: Request, res: Response, next: NextFunction) => {
        try {
            if (!req.user) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }
            const reviewData: CreateReviewDto = req.body;
            // Set customer_id from the logged-in user
            const customer_id = req.user.id;
            const review = await this.reviewService.createReview(req.user, { customer_id, ...reviewData, });
            res.status(HttpStatus.Created).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }
    /**
     * Get reviews by appointment ID
     */
    public getReviewsByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            const reviews = await this.reviewService.getReviewsByAppointmentId(appointmentId);
            res.status(HttpStatus.Success).json(formatResponse<IReview[]>(reviews));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get review by ID
     */
    public getReviewById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const reviewId = req.params.id;
            const review = await this.reviewService.getReviewById(reviewId);
            res.status(HttpStatus.Success).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Update review
     */
    public updateReview = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const reviewId = req.params.id;
            const updateData: UpdateReviewDto = req.body;
            const customer_id = req.user.id;
            const review = await this.reviewService.updateReview(updateData, reviewId, customer_id);
            res.status(HttpStatus.Success).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Delete review
     */
    public deleteReview = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const reviewId = req.params.id;
            const review = await this.reviewService.deleteReview(reviewId);
            res.status(HttpStatus.Success).json(formatResponse<IReview>(review));
        } catch (error) {
            next(error);
        }
    }





}


================================================
FILE: src/modules/review/review.interface.ts
================================================
import { Document, Schema } from 'mongoose';

export interface IReview extends Document {
    _id: string;
    rating: number;
    comment: string;
    appointment_id: string | undefined;
    customer_id: string | undefined;
    created_at: Date;
    updated_at: Date;
    is_deleted: boolean;
} 


================================================
FILE: src/modules/review/review.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { IReview } from './review.interface';

const ReviewSchemaEntity: Schema<IReview> = new Schema({
    rating: { type: Number, required: true },
    comment: { type: String, required: true },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const ReviewSchema = mongoose.model<IReview & mongoose.Document>(
    COLLECTION_NAME.REVIEW,
    ReviewSchemaEntity
);

export default ReviewSchema; 


================================================
FILE: src/modules/review/review.repository.ts
================================================
import ReviewSchema from './review.model';
import { IReview } from './review.interface';
import { Types } from 'mongoose';

export const createReview = async (reviewData: Partial<IReview>) => {
    return await ReviewSchema.create(reviewData);
};

export const getReviewsByAppointment = async (appointmentId: string) => {
    return await ReviewSchema.find({ appointment_id: appointmentId, is_deleted: { $ne: true } });
};

export const getReviewById = async (id: string) => {
    return await ReviewSchema.findById(id);
};

export const updateReview = async (id: string, updateData: Partial<IReview>, customer_id: string) => {
    return await ReviewSchema.findOneAndUpdate(
        { _id: id, customer_id },
        updateData,
        { new: true }
    );
};

export const deleteReview = async (id: string) => {
    return await ReviewSchema.findByIdAndUpdate(id, { is_deleted: true }, { new: true });
};



================================================
FILE: src/modules/review/review.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import ReviewController from './review.controller';
import { CreateReviewDto, UpdateReviewDto } from './dtos';

export default class ReviewRoute implements IRoute {
    public path = API_PATH.REVIEW;
    public router = Router();
    private reviewController = new ReviewController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/review -> Create a review
        this.router.post(
            `${this.path}`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(CreateReviewDto),
            this.reviewController.createReview
        );

        // GET: domain:/api/review/appointment/:appointmentId -> Get reviews by appointment ID
        this.router.get(
            `${this.path}/appointment/:appointmentId`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            this.reviewController.getReviewsByAppointmentId
        );

        // GET: domain:/api/review/:id -> Get review by ID
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            this.reviewController.getReviewById
        );

        // PUT: domain:/api/review/:id -> Update review 
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(UpdateReviewDto),
            this.reviewController.updateReview
        );

        // DELETE: domain:/api/review/:id -> Delete review
        this.router.delete(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            this.reviewController.deleteReview
        );
    }
}


================================================
FILE: src/modules/review/review.service.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { SearchPaginationResponseModel } from '../../core/models';
import * as reviewRepository from './review.repository';
import { IReview } from './review.interface';
import { AppointmentSchema } from '../appointment';
import { ResultSchema } from '../result';
import { CreateReviewDto, UpdateReviewDto } from './dtos'
import UserSchema from '../user/user.model';
import { UserRoleEnum } from '../user/user.enum';
import ServiceSchema from '../service/service.model';
import { ServiceTypeEnum } from '../service/service.enum';

export default class ReviewService {
    private readonly reviewRepository: typeof reviewRepository;
    private readonly appointmentSchema: typeof AppointmentSchema;
    private readonly userSchema: typeof UserSchema;
    private readonly resultSchema: typeof ResultSchema;


    constructor() {
        this.reviewRepository = reviewRepository;
        this.appointmentSchema = AppointmentSchema;
        this.userSchema = UserSchema;
        this.resultSchema = ResultSchema;
    }

    /**
     * Create a review
     */
    public async createReview(user: any, reviewData: any): Promise<IReview> {
        try {
            // Check if a result exists for the appointment and customer
            const result = await this.resultSchema.findOne({
                appointment_id: reviewData.appointment_id,
                customer_id: reviewData.customer_id
            });
            if (!result) {
                throw new HttpException(HttpStatus.NotFound, 'Result not found');
            }

            const service = await ServiceSchema.findById(reviewData.service_id);
            if (service && service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                if (user.role !== UserRoleEnum.ADMIN && user.role !== UserRoleEnum.MANAGER) {
                    throw new Error('Only ADMIN or MANAGER can review ADMINISTRATIVE services');
                }
            }

            // Create the review
            const review = await this.reviewRepository.createReview(reviewData);
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating review');
        }
    }

    /**
     * Get reviews by appointment ID
     */
    public async getReviewsByAppointmentId(appointmentId: string): Promise<IReview[]> {
        try {
            const reviews = await this.reviewRepository.getReviewsByAppointment(appointmentId);
            return reviews;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting reviews');
        }
    }

    /**
     * Get review by ID
     */
    public async getReviewById(id: string): Promise<IReview> {
        try {
            const review = await this.reviewRepository.getReviewById(id);
            if (!review) {
                throw new HttpException(HttpStatus.NotFound, 'Review not found');
            }
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting review');
        }
    }

    /**
     * Update review
     */
    public async updateReview(updateData: UpdateReviewDto, id: string, customer_id: string): Promise<IReview> {
        try {
            const review = await this.reviewRepository.updateReview(id, updateData, customer_id);
            if (!review) {
                throw new HttpException(HttpStatus.NotFound, 'Review not found');
            }
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating review');
        }
    }

    /**
     * Delete review
     */
    public async deleteReview(id: string): Promise<IReview> {
        try {
            const review = await this.reviewRepository.deleteReview(id);
            if (!review) {
                throw new HttpException(HttpStatus.NotFound, 'Review not found');
            }
            return review;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error deleting review');
        }
    }

}


================================================
FILE: src/modules/review/dtos/createReview.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsOptional } from 'class-validator';

export class CreateReviewDto {
    @IsNotEmpty()
    @IsNumber()
    rating: number = 0;

    @IsNotEmpty()
    @IsString()
    comment: string = '';

    @IsNotEmpty()
    @IsString()
    appointment_id: string = '';

    @IsOptional()
    @IsString()
    customer_id?: string;
}


================================================
FILE: src/modules/review/dtos/index.ts
================================================
import { CreateReviewDto } from './createReview.dto';
import { UpdateReviewDto } from './updateReview.dto';

export { CreateReviewDto, UpdateReviewDto };


================================================
FILE: src/modules/review/dtos/updateReview.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class UpdateReviewDto {

    @IsNotEmpty()
    @IsNumber()
    rating: number = 0;

    @IsNotEmpty()
    @IsString()
    comment: string = '';

    @IsNotEmpty()
    @IsString()
    appointment_id: string = '';
};



================================================
FILE: src/modules/review/swagger/review.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Review:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Review ID
 *         rating:
 *           type: number
 *           description: Rating given by the user
 *         comment:
 *           type: string
 *           description: Review comment
 *         appointment_id:
 *           type: string
 *           description: Appointment ID being reviewed
 *         customer_id:
 *           type: string
 *           description: Customer (user) ID who wrote the review
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 *         is_deleted:
 *           type: boolean
 *           default: false
 *       required:
 *         - rating
 *         - comment
 *         - appointment_id
 *     CreateReviewDto:
 *       type: object
 *       properties:
 *         rating:
 *           type: number
 *           example: 5
 *         comment:
 *           type: string
 *           example: \"Excellent service\"
 *         appointment_id:
 *           type: string
 *           example: \"60f7c0b8b4d1c80015b4e8a1\"
 *       required:
 *         - rating
 *         - comment
 *         - appointment_id
 *     UpdateReviewDto:
 *       type: object
 *       properties:
 *         rating:
 *           type: number
 *           example: 4
 *         comment:
 *           type: string
 *           example: \"Updated comment\"
 *         appointment_id:
 *           type: string
 *           example: \"60f7c0b8b4d1c80015b4e8a1\"
 *       required:
 *         - rating
 *         - comment
 *         - appointment_id
 */


================================================
FILE: src/modules/review/swagger/review.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: Review
 *   description: Endpoints for managing reviews for appointments
 */

/**
 * @swagger
 * /api/review:
 *   post:
 *     summary: Create a new review for an appointment
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateReviewDto'
 *     responses:
 *       201:
 *         description: Review created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Result not found for appointment and user
 *       400:
 *         description: Invalid input
 *
 * /api/review/appointment/{appointmentId}:
 *   get:
 *     summary: Get all reviews for a specific appointment
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the appointment
 *     responses:
 *       200:
 *         description: List of reviews for the appointment
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Review'
 *       404:
 *         description: Appointment not found
 *
 * /api/review/{id}:
 *   get:
 *     summary: Get a review by its ID
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the review
 *     responses:
 *       200:
 *         description: Review found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Review not found
 *   put:
 *     summary: Update a review by its ID
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the review
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateReviewDto'
 *     responses:
 *       200:
 *         description: Review updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Review not found
 *   delete:
 *     summary: Delete a review by its ID
 *     tags: [Review]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the review
 *     responses:
 *       200:
 *         description: Review deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Review'
 *       404:
 *         description: Review not found
 */


================================================
FILE: src/modules/sample/index.ts
================================================
import SampleSchema from './sample.model';
import { ISample, SampleType, SampleStatus, CollectionMethod } from './sample.interface';
import { SampleTypeEnum, SampleStatusEnum, CollectionMethodEnum } from './sample.enum';
import { SampleTypes, SampleStatuses, CollectionMethods } from './sample.constant';
import SampleController from './sample.controller';
import SampleService from './sample.service';
import SampleRepository from './sample.repository';
import SampleRoute from './sample.route';
import { SubmitSampleDto, ReceiveSampleDto } from './dtos';

export {
    SampleSchema,
    ISample,
    SampleType,
    SampleStatus,
    CollectionMethod,
    SampleTypeEnum,
    SampleStatusEnum,
    CollectionMethodEnum,
    SampleTypes,
    SampleStatuses,
    CollectionMethods,
    SampleController,
    SampleService,
    SampleRepository,
    SampleRoute,
    SubmitSampleDto,
    ReceiveSampleDto
}; 


================================================
FILE: src/modules/sample/sample.constant.ts
================================================
import { CollectionMethodEnum, SampleStatusEnum, SampleTypeEnum } from './sample.enum';

export const SampleTypes = [
    '',
    SampleTypeEnum.SALIVA,
    SampleTypeEnum.BLOOD,
    SampleTypeEnum.HAIR,
    SampleTypeEnum.OTHER
];

export const SampleStatuses = [
    '',
    SampleStatusEnum.PENDING,
    SampleStatusEnum.RECEIVED,
    SampleStatusEnum.TESTING,
    SampleStatusEnum.COMPLETED,
    SampleStatusEnum.INVALID
];

export const CollectionMethods = [
    '',
    CollectionMethodEnum.SELF,
    CollectionMethodEnum.FACILITY,
    CollectionMethodEnum.HOME
]; 


================================================
FILE: src/modules/sample/sample.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { ISample } from './sample.interface';
import SampleService from './sample.service';
import { SubmitSampleDto } from './dtos/submitSample.dto';
import { ReceiveSampleDto } from './dtos/receiveSample.dto';
import { UserRoleEnum } from '../user/user.enum';
import { AddSampleDto } from './dtos/addSample.dto';
import { AddSampleWithMultiplePersonInfoDto } from './dtos/addSampleWithMultiplePersonInfo.dto';
import { BatchSubmitSamplesDto } from './dtos/batchSubmitSamples.dto';
import { BatchReceiveSamplesDto } from './dtos/batchReceiveSamples.dto';
import { SearchSamplesDto } from './dtos/searchSamples.dto';
import { uploadFileToS3 } from '../../core/utils';
import { SampleStatusEnum, SampleTypeEnum } from './sample.enum';
import { CollectSampleDto } from './dtos/collect-sample.dto';
export default class SampleController {
    private sampleService = new SampleService();

    /**
     * Submit a sample (by customer)
     */
    public submitSample = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const sampleId = req.params.id;
            const submitData: SubmitSampleDto = req.body;

            const updatedSample = await this.sampleService.submitSample(
                sampleId,
                submitData.collection_date ?? new Date().toISOString(),
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample>(updatedSample));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Receive a sample (by staff)
     */
    public receiveSample = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            const userRole = req.user.role;

            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only staff can receive samples
            if (userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(HttpStatus.Forbidden, 'Only staff can receive samples');
            }

            const sampleId = req.params.id;
            const receiveData: ReceiveSampleDto = req.body;

            const updatedSample = await this.sampleService.receiveSample(
                sampleId,
                receiveData.received_date,
                staffId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample>(updatedSample));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get sample by ID
     */
    public getSampleById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const sampleId = req.params.id;
            const sample = await this.sampleService.getSampleById(sampleId);

            res.status(HttpStatus.Success).json(formatResponse<ISample>(sample));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get samples by appointment ID
     */
    public getSamplesByAppointmentId = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const appointmentId = req.params.appointmentId;
            const samples = await this.sampleService.getSamplesByAppointmentId(appointmentId);

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get samples ready for testing (samples with status RECEIVED)
     * This is used by laboratory technicians to find samples that are ready to be tested
     */
    public getSamplesReadyForTesting = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only laboratory technicians can access this endpoint
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(
                    HttpStatus.Forbidden,
                    'Only laboratory technicians can access samples ready for testing'
                );
            }

            // Get pagination parameters from query string
            const page = req.query.page ? parseInt(req.query.page as string) : 1;
            const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;

            const result = await this.sampleService.getSamplesReadyForTesting(page, limit);

            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Search samples by various criteria
     * This allows laboratory technicians to search for samples by different parameters
     */
    public searchSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only laboratory technicians and staff can search samples
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN && userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(
                    HttpStatus.Forbidden,
                    'Only laboratory technicians and staff can search samples'
                );
            }

            // Extract and safely convert query parameters
            let status, type, appointmentId, kitCode, personName, startDate, endDate, page, limit;

            try {
                // Handle status parameter
                if (req.query.status) {
                    status = String(req.query.status) as SampleStatusEnum;
                }

                // Handle type parameter
                if (req.query.type) {
                    type = String(req.query.type) as SampleTypeEnum;
                }

                // Handle appointmentId parameter
                if (req.query.appointmentId) {
                    appointmentId = String(req.query.appointmentId);
                }

                // Handle kitCode parameter
                if (req.query.kitCode) {
                    kitCode = String(req.query.kitCode);
                }

                // Handle personName parameter
                if (req.query.personName) {
                    personName = String(req.query.personName);
                }

                // Handle date parameters
                if (req.query.startDate) {
                    startDate = new Date(String(req.query.startDate));
                    if (isNaN(startDate.getTime())) {
                        startDate = undefined;
                    }
                }

                if (req.query.endDate) {
                    endDate = new Date(String(req.query.endDate));
                    if (isNaN(endDate.getTime())) {
                        endDate = undefined;
                    }
                }

                // Handle pagination parameters
                if (req.query.page) {
                    page = parseInt(String(req.query.page));
                    if (isNaN(page) || page < 1) {
                        page = 1;
                    }
                } else {
                    page = 1;
                }

                if (req.query.limit) {
                    limit = parseInt(String(req.query.limit));
                    if (isNaN(limit) || limit < 1) {
                        limit = 10;
                    }
                } else {
                    limit = 10;
                }
            } catch (error) {
                console.error('Error parsing search parameters:', error);
                // Continue with defaults if parsing fails
            }

            // Prepare search options
            const searchOptions = {
                status,
                type,
                appointmentId,
                kitCode,
                personName,
                startDate,
                endDate,
                page,
                limit
            };

            console.log('Search options in controller:', searchOptions);

            // Search samples
            const result = await this.sampleService.searchSamples(searchOptions);

            // Return formatted response
            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get all samples with RECEIVED status for laboratory technicians
     * This endpoint returns all samples ready for testing with pagination
     */
    public getAllSamplesForTesting = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;

            // Only laboratory technicians can access this endpoint
            if (userRole !== UserRoleEnum.LABORATORY_TECHNICIAN) {
                throw new HttpException(
                    HttpStatus.Forbidden,
                    'Only laboratory technicians can access samples for testing'
                );
            }

            // Get pagination parameters from query string
            const page = req.query.page ? parseInt(req.query.page as string) : 1;
            const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;

            const result = await this.sampleService.getSamplesForTesting(page, limit);

            res.status(HttpStatus.Success).json(formatResponse(result));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Add a sample to an existing appointment
     * @param req Request
     * @param res Response
     */
    public addSampleToAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Táº¡o DTO tá»« request body
            const addSampleData: AddSampleDto = req.body;

            // Náº¿u khÃ´ng cÃ³ kit_id, há»‡ thá»‘ng sáº½ tá»± Ä‘á»™ng gÃ¡n kit cÃ³ sáºµn
            const samples = await this.sampleService.addSampleToAppointment(userId, addSampleData);

            res.status(HttpStatus.Created).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Add samples with multiple person information
     * Each sample type corresponds to a person_info entry in the person_info_list array
     * @param req Request
     * @param res Response
     */
    public addSamplesWithMultiplePersonInfo = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;

            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Create DTO from request body
            const addSampleData: AddSampleWithMultiplePersonInfoDto = req.body;

            // Validate that sample_types and person_info_list have the same length
            if (addSampleData.sample_types.length !== addSampleData.person_info_list.length) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'The number of sample types must match the number of person info entries'
                );
            }

            // Convert to AddSampleDto and set person_info_list
            const convertedData: AddSampleDto = {
                appointment_id: addSampleData.appointment_id,
                kit_id: addSampleData.kit_id,
                sample_types: addSampleData.sample_types,
                notes: addSampleData.notes,
                person_info_list: addSampleData.person_info_list
            };

            // Call the service to add samples
            const samples = await this.sampleService.addSampleToAppointment(userId, convertedData);

            res.status(HttpStatus.Created).json(formatResponse<ISample[]>(samples));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Batch submit multiple samples (by customer)
     * @param req Request
     * @param res Response
     * @param next NextFunction
     */
    public batchSubmitSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            const batchSubmitData: BatchSubmitSamplesDto = req.body;

            const updatedSamples = await this.sampleService.batchSubmitSamples(
                batchSubmitData.sample_ids,
                batchSubmitData.collection_date,
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(updatedSamples));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Batch receive multiple samples (by staff)
     * @param req Request
     * @param res Response
     * @param next NextFunction
     */
    public batchReceiveSamples = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user.id;
            const userRole = req.user.role;

            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Only staff can receive samples
            if (userRole !== UserRoleEnum.STAFF) {
                throw new HttpException(HttpStatus.Forbidden, 'Only staff can receive samples');
            }

            const batchReceiveData: BatchReceiveSamplesDto = req.body;

            const updatedSamples = await this.sampleService.batchReceiveSamples(
                batchReceiveData.sample_ids,
                batchReceiveData.received_date,
                staffId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(updatedSamples));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Upload an image for a person in a sample
     * @param req Request
     * @param res Response
     * @param next NextFunction
     */
    public uploadPersonImage = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.user.id;
            if (!userId) {
                throw new HttpException(HttpStatus.Unauthorized, 'User not authenticated');
            }

            // Get the sample ID from the request body or query parameters
            let sample_id = req.body.sample_id;

            // For multipart/form-data, sample_id might be in req.body as a string
            console.log("Request body:", req.body);
            console.log("Request file:", req.file);

            if (!sample_id) {
                throw new HttpException(HttpStatus.BadRequest, 'Sample ID is required');
            }

            // Check if file was uploaded
            if (!req.file) {
                throw new HttpException(HttpStatus.BadRequest, 'No file uploaded');
            }

            // Get the image URL - either from the file location (already uploaded to S3) or upload it
            let imageUrl = (req.file as any).location || req.file.path;

            // If the file path is not a URL (not already uploaded to S3), upload it
            if (!imageUrl || (!imageUrl.startsWith('http://') && !imageUrl.startsWith('https://'))) {
                imageUrl = await uploadFileToS3(req.file, sample_id);
            }

            console.log("File uploaded successfully to:", imageUrl);

            // Update the person's image URL in the sample
            const updatedSample = await this.sampleService.updatePersonImage(
                sample_id,
                imageUrl,
                userId
            );

            res.status(HttpStatus.Success).json(formatResponse({
                sample: updatedSample,
                // image_url: imageUrl
            }));
        } catch (error) {
            console.error("Error in uploadPersonImage controller:", error);
            next(error);
        }
    };

    /**
     * Collect sample at facility
     * @route POST /samples/collect
     */
    public collectSampleAtFacility = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const staffId = req.user?.id;
            if (!staffId) {
                throw new HttpException(HttpStatus.Unauthorized, 'Staff not authenticated');
            }

            const collectSampleData: CollectSampleDto = req.body;

            const result = await this.sampleService.collectSampleAtFacility(
                collectSampleData,
                staffId
            );

            res.status(HttpStatus.Success).json(formatResponse<ISample[]>(result));
        } catch (error) {
            next(error);
        }
    };
} 


================================================
FILE: src/modules/sample/sample.enum.ts
================================================
export enum SampleTypeEnum {
    SALIVA = 'saliva',
    BLOOD = 'blood',
    HAIR = 'hair',
    OTHER = 'other'
}

export enum SampleStatusEnum {
    PENDING = 'pending',
    RECEIVED = 'received',
    TESTING = 'testing',
    COMPLETED = 'completed',
    INVALID = 'invalid'
}

export enum CollectionMethodEnum {
    SELF = 'self',
    FACILITY = 'facility',
    HOME = 'home'
} 



================================================
FILE: src/modules/sample/sample.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { SampleStatusEnum, SampleTypeEnum } from './sample.enum';
import { CollectionMethodEnum } from './sample.enum';

export type SampleType =
    SampleTypeEnum.SALIVA |
    SampleTypeEnum.BLOOD |
    SampleTypeEnum.HAIR |
    SampleTypeEnum.OTHER;

export type SampleStatus =
    SampleStatusEnum.PENDING |
    SampleStatusEnum.RECEIVED |
    SampleStatusEnum.TESTING |
    SampleStatusEnum.COMPLETED |
    SampleStatusEnum.INVALID;

export type CollectionMethod =
    CollectionMethodEnum.SELF |
    CollectionMethodEnum.FACILITY |
    CollectionMethodEnum.HOME;

export interface IPersonInfo {
    name: string;
    dob?: Date;
    relationship?: string;
    birth_place?: string;
    nationality?: string;
    identity_document?: string;
    image_url?: string;
}

export interface ISample extends Document {
    _id: string;
    appointment_id: string | undefined;
    kit_id: string | undefined;
    type: SampleType | null;
    collection_method: CollectionMethod;
    collection_date: Date;
    received_date?: Date;
    status: SampleStatus;
    person_info?: IPersonInfo;
    person_info_list?: IPersonInfo[];
    created_at: Date;
    updated_at: Date;
    created_by?: string;
    updated_by?: string;
} 


================================================
FILE: src/modules/sample/sample.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { SampleStatuses, SampleTypes, CollectionMethods } from './sample.constant';
import { ISample } from './sample.interface';

const PersonInfoSchema = new Schema({
    name: { type: String, required: true },
    dob: { type: Date },
    relationship: { type: String },
    birth_place: { type: String },
    nationality: { type: String },
    identity_document: { type: String },
    image_url: { type: String }
}, { _id: false });

const SampleSchemaEntity: Schema<ISample> = new Schema({
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT, required: true },
    kit_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.KIT, required: true },
    type: {
        type: String,
        enum: SampleTypes,
        required: true
    },
    collection_method: {
        type: String,
        enum: CollectionMethods,
        required: true
    },
    collection_date: { type: Date, required: true },
    received_date: { type: Date },
    status: {
        type: String,
        enum: SampleStatuses,
        required: true
    },
    person_info: { type: PersonInfoSchema },
    person_info_list: { type: [PersonInfoSchema] },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    created_by: { type: String },
    updated_by: { type: String }
});

const SampleSchema = mongoose.model<ISample & mongoose.Document>(COLLECTION_NAME.SAMPLE, SampleSchemaEntity);
export default SampleSchema; 


================================================
FILE: src/modules/sample/sample.repository.ts
================================================
import SampleSchema from './sample.model';
import { ISample } from './sample.interface';

export default class SampleRepository {
    public async create(data: Partial<ISample>): Promise<ISample> {
        return SampleSchema.create(data);
    }

    public async findOne(query: any): Promise<ISample | null> {
        return SampleSchema.findOne(query);
    }

    public async findById(id: string): Promise<ISample | null> {
        return SampleSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<ISample>, options: any = {}): Promise<ISample | null> {
        return SampleSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return SampleSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISample[]> {
        return SampleSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<ISample[]> {
        return SampleSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISample[]> {
        return SampleSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }

    public async findByIdWithPopulate(id: string): Promise<ISample | null> {
        return SampleSchema.findById(id)
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }

    /**
     * Find samples by appointment ID with populated data
     */
    public async findByAppointmentId(appointmentId: string): Promise<ISample[]> {
        return SampleSchema.find({ appointment_id: appointmentId })
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id payment_status created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }

    /**
     * Find multiple samples by their IDs with populated data
     * @param ids Array of sample IDs to find
     */
    public async findManyByIds(ids: string[]): Promise<ISample[]> {
        return SampleSchema.find({ _id: { $in: ids } })
            .populate('appointment_id', '_id user_id service_id status appointment_date type collection_address staff_id slot_id created_at updated_at')
            .populate('kit_id', '_id code status created_at updated_at');
    }
} 


================================================
FILE: src/modules/sample/sample.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware, uploadSingleFile } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import SampleController from './sample.controller';
import { SubmitSampleDto } from './dtos/submitSample.dto';
import { ReceiveSampleDto } from './dtos/receiveSample.dto';
import { AddSampleDto } from './dtos/addSample.dto';
import { AddSampleWithMultiplePersonInfoDto } from './dtos/addSampleWithMultiplePersonInfo.dto';
import { BatchSubmitSamplesDto } from './dtos/batchSubmitSamples.dto';
import { BatchReceiveSamplesDto } from './dtos/batchReceiveSamples.dto';
import { UploadPersonImageDto } from './dtos/uploadPersonImage.dto';
import { SearchSamplesDto } from './dtos/searchSamples.dto';
import { CollectSampleDto } from './dtos/collect-sample.dto';

export default class SampleRoute implements IRoute {
    public path = API_PATH.SAMPLE;
    public router = Router();
    private sampleController = new SampleController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // GET: domain:/api/sample/search -> Search samples by various criteria
        this.router.get(
            `${API_PATH.SAMPLE}/search`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.sampleController.searchSamples
        );

        // GET: domain:/api/sample/testing/ready -> Get samples ready for testing (RECEIVED status)
        this.router.get(
            `${API_PATH.SAMPLE}/testing/ready`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.sampleController.getSamplesReadyForTesting
        );

        // GET: domain:/api/sample/testing/all -> Get all samples with TESTING status without pagination
        this.router.get(
            `${API_PATH.SAMPLE}/testing/all`,
            authMiddleWare([UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.sampleController.getAllSamplesForTesting
        );

        // GET: domain:/api/sample/appointment/:appointmentId -> Get samples by appointment ID
        this.router.get(
            `${API_PATH.SAMPLE}/appointment/:appointmentId`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.sampleController.getSamplesByAppointmentId
        );

        // GET: domain:/api/sample/:id -> Get sample by ID
        this.router.get(
            `${API_PATH.SAMPLE}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.CUSTOMER]),
            this.sampleController.getSampleById
        );

        // PUT: domain:/api/sample/:id/submit -> Submit a sample (by customer)
        this.router.put(
            `${API_PATH.SAMPLE}/:id/submit`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(SubmitSampleDto),
            this.sampleController.submitSample
        );

        // PUT: domain:/api/sample/:id/receive -> Receive a sample (by staff)
        this.router.put(
            `${API_PATH.SAMPLE}/:id/receive`,
            authMiddleWare([UserRoleEnum.STAFF]),
            validationMiddleware(ReceiveSampleDto),
            this.sampleController.receiveSample
        );

        // POST: domain:/api/sample/add-to-appointment -> Add a sample to an existing appointment
        this.router.post(
            `${API_PATH.SAMPLE}/add-to-appointment`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER]),
            validationMiddleware(AddSampleWithMultiplePersonInfoDto),
            this.sampleController.addSamplesWithMultiplePersonInfo
        );

        // POST: domain:/api/sample/add-multiple-person-samples -> Add samples with multiple person information
        // this.router.post(
        //     `${API_PATH.SAMPLE}/add-multiple-person-samples`,
        //     authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER]),
        //     validationMiddleware(AddSampleWithMultiplePersonInfoDto),
        //     this.sampleController.addSamplesWithMultiplePersonInfo
        // );

        // POST: domain:/api/sample/batch-submit -> Batch submit multiple samples (by customer)
        this.router.post(
            `${API_PATH.SAMPLE}/batch-submit`,
            authMiddleWare([UserRoleEnum.CUSTOMER]),
            validationMiddleware(BatchSubmitSamplesDto),
            this.sampleController.batchSubmitSamples
        );

        // POST: domain:/api/sample/batch-receive -> Batch receive multiple samples (by staff)
        this.router.post(
            `${API_PATH.SAMPLE}/batch-receive`,
            authMiddleWare([UserRoleEnum.STAFF]),
            validationMiddleware(BatchReceiveSamplesDto),
            this.sampleController.batchReceiveSamples
        );

        // POST: domain:/api/sample/upload-person-image -> Upload person image for a sample
        this.router.post(
            `${API_PATH.SAMPLE}/upload-person-image`,
            authMiddleWare([UserRoleEnum.CUSTOMER, UserRoleEnum.STAFF]),
            uploadSingleFile('image'),
            this.sampleController.uploadPersonImage
        );

        // POST: domain:/api/samples/collect -> Collect sample at facility
        this.router.post(
            `${this.path}/collect`,
            authMiddleWare([UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            validationMiddleware(CollectSampleDto),
            this.sampleController.collectSampleAtFacility
        );
    }
} 


================================================
FILE: src/modules/sample/sample.service.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IPersonInfo, ISample } from './sample.interface';
import { SampleStatusEnum, SampleTypeEnum, CollectionMethodEnum } from './sample.enum';
import SampleRepository from './sample.repository';
import { AppointmentLogService } from '../appointment_log';
import { AppointmentLogTypeEnum } from '../appointment_log/appointment_log.enum';
import AppointmentService from '../appointment/appointment.service';
import { AppointmentStatusEnum } from '../appointment/appointment.enum';
import KitService from '../kit/kit.service';
import { KitStatusEnum } from '../kit/kit.enum';
import { SampleSelectionDto } from '../appointment/dtos/createAppointment.dto';
import { TypeEnum } from '../appointment/appointment.enum';
import { AddSampleDto } from './dtos/addSample.dto';
import { SearchPaginationResponseModel } from "../../core/models";
import { CollectSampleDto } from './dtos/collect-sample.dto';
import AppointmentSchema from '../appointment/appointment.model';
import ServiceSchema from '../service/service.model';
import { ServiceTypeEnum } from '../service/service.enum';

/**
 * Helper function to compare MongoDB ObjectIds or strings
 * @param id1 First ID
 * @param id2 Second ID
 * @returns True if the IDs are equal
 */
function areIdsEqual(id1: any, id2: any): boolean {
    if (!id1 || !id2) return false;

    // Convert both to strings and remove any quotes
    const str1 = String(id1).replace(/^"|"$/g, '').trim();
    const str2 = String(id2).replace(/^"|"$/g, '').trim();

    // Try direct string comparison first
    if (str1 === str2) return true;

    // If that fails, try comparing the last 24 chars (MongoDB ObjectId length)
    if (str1.length >= 24 && str2.length >= 24) {
        return str1.slice(-24) === str2.slice(-24); // Compare the last 24 characters of the strings
    }

    return false;
}

/**
 * Helper function to extract user ID from an appointment object that might have populated user_id
 * @param appointment The appointment object
 * @returns The extracted user ID as a string
 */
function extractUserIdFromAppointment(appointment: any): string {
    if (!appointment || !appointment.user_id) {
        throw new Error('User ID not found in appointment');
    }

    // If user_id is an object (populated)
    if (typeof appointment.user_id === 'object' && appointment.user_id !== null) {
        const userObj = appointment.user_id;

        // If populated with _id field
        if (userObj._id) {
            return userObj._id.toString();
        }

        // If populated with id field
        if (userObj.id) {
            return userObj.id.toString();
        }

        // If it's another type of object, try to convert to string
        return String(appointment.user_id);
    }

    // If user_id is a primitive (string or ObjectId)
    return String(appointment.user_id);
}

/**
 * Helper function to extract appointment ID from a sample object that might have populated appointment_id
 * @param sample The sample object
 * @returns The extracted appointment ID as a string
 */
function extractAppointmentIdFromSample(sample: any): string {
    if (!sample || !sample.appointment_id) {
        throw new Error('Appointment ID not found in sample');
    }

    // If appointment_id is an object (populated)
    if (typeof sample.appointment_id === 'object' && sample.appointment_id !== null) {
        const appointmentObj = sample.appointment_id;

        // If populated with _id field
        if (appointmentObj._id) {
            return appointmentObj._id.toString();
        }

        // If it's another type of object, try to convert to string
        return String(sample.appointment_id);
    }

    // If appointment_id is a primitive (string or ObjectId)
    return String(sample.appointment_id);
}

/**
 * Helper function to extract kit ID from a sample object that might have populated kit_id
 * @param sample The sample object
 * @returns The extracted kit ID as a string
 */
function extractKitIdFromSample(sample: any): string {
    if (!sample || !sample.kit_id) {
        throw new Error('Kit ID not found in sample');
    }

    // If kit_id is an object (populated)
    if (typeof sample.kit_id === 'object' && sample.kit_id !== null) {
        const kitObj = sample.kit_id;

        // If populated with _id field
        if (kitObj._id) {
            return kitObj._id.toString();
        }

        // If it's another type of object, try to convert to string
        return String(sample.kit_id);
    }

    // If kit_id is a primitive (string or ObjectId)
    return String(sample.kit_id);
}

export default class SampleService {
    private readonly sampleRepository: SampleRepository;
    private readonly appointmentLogService: AppointmentLogService;
    private readonly kitService: KitService;
    private readonly appointmentService: AppointmentService;

    constructor() {
        this.sampleRepository = new SampleRepository();
        this.appointmentLogService = new AppointmentLogService();
        this.kitService = new KitService();
        this.appointmentService = new AppointmentService();
    }

    /**
     * Submit a sample (by customer)
     */
    public async submitSample(sampleId: string, collectionDate: string, userId: string): Promise<ISample> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.sampleRepository.findByIdWithPopulate(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Log for debugging
            console.log('Original sample object:', JSON.stringify(sample, null, 2));

            // Extract appointment_id using the helper function
            const appointmentId = extractAppointmentIdFromSample(sample);
            console.log('Extracted appointment ID:', appointmentId);

            // Verify that the sample belongs to the user making the request
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Log for debugging
            console.log('Sample appointment_id:', sample.appointment_id, 'type:', typeof sample.appointment_id);
            console.log('Appointment:', JSON.stringify(appointment, null, 2));
            console.log('User ID passed to service:', userId);
            console.log('User ID type:', typeof userId);

            // Extract user_id using the helper function
            const appointmentUserId = extractUserIdFromAppointment(appointment);

            console.log(`Comparing appointment user ID: ${appointmentUserId} with current user ID: ${userId}`);
            console.log('Equal using === ?', appointmentUserId === userId);
            console.log('Equal using areIdsEqual?', areIdsEqual(appointmentUserId, userId));

            if (!areIdsEqual(appointmentUserId, userId)) {
                throw new HttpException(HttpStatus.Forbidden, 'You are not authorized to submit this sample');
            }

            // Verify that the sample is in PENDING status
            if (sample.status !== SampleStatusEnum.PENDING) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot submit sample with status ${sample.status}`
                );
            }

            // Update sample with collection date
            const updateData: any = {
                updated_at: new Date()
            };

            // Chá»‰ cáº­p nháº­t collection_date náº¿u ngÆ°á»i dÃ¹ng cung cáº¥p giÃ¡ trá»‹ má»›i
            if (collectionDate) {
                updateData.collection_date = new Date(collectionDate);
            }

            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                updateData,
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample');
            }

            // Update appointment status to SAMPLE_COLLECTED if not already
            if (appointment.status !== AppointmentStatusEnum.SAMPLE_COLLECTED) {
                await this.appointmentService.updateAppointmentStatus(
                    appointment._id.toString(),
                    AppointmentStatusEnum.SAMPLE_COLLECTED
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.SAMPLE_COLLECTED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for sample submission:', logError);
                }
            }

            // Update kit status to USED if not already
            try {
                // Extract kit_id using the helper function
                const kitId = extractKitIdFromSample(sample);
                console.log('Extracted kit ID:', kitId);

                const kit = await this.kitService.getKitById(kitId);
                console.log('Kit retrieved:', JSON.stringify(kit, null, 2));

                if (kit.status !== KitStatusEnum.USED) {
                    await this.kitService.changeKitStatus(kitId, KitStatusEnum.USED);
                }
            } catch (kitError) {
                console.error('Error updating kit status:', kitError);
                // Don't fail the sample submission if kit update fails
            }

            return updatedSample;
        } catch (error) {
            console.error('Error in submitSample:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error submitting sample: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error submitting sample');
        }
    }

    /**
     * Receive a sample (by staff)
     */
    public async receiveSample(sampleId: string, receivedDate: string, staffId: string): Promise<ISample> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.sampleRepository.findByIdWithPopulate(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            // Log for debugging
            console.log('Original sample object:', JSON.stringify(sample, null, 2));

            // Extract appointment_id using the helper function
            const appointmentId = extractAppointmentIdFromSample(sample);
            console.log('Extracted appointment ID:', appointmentId);

            // Verify that the sample is in PENDING status
            if (sample.status !== SampleStatusEnum.PENDING) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Cannot receive sample with status ${sample.status}`
                );
            }

            // Verify that the sample has been collected
            if (!sample.collection_date) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Sample must be collected before it can be received'
                );
            }

            // Update sample with received date and status
            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                {
                    received_date: new Date(receivedDate),
                    status: SampleStatusEnum.RECEIVED,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample');
            }

            // Update appointment status to SAMPLE_RECEIVED
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Log for debugging
            console.log('Sample appointment_id:', sample.appointment_id, 'type:', typeof sample.appointment_id);
            console.log('Appointment:', JSON.stringify(appointment, null, 2));
            console.log('Staff ID passed to service:', staffId);

            // Xá»­ lÃ½ vÃ  ghi log thÃ´ng tin appointment Ä‘á»ƒ debug
            if (appointment.user_id) {
                if (typeof appointment.user_id === 'object') {
                    const userObj = appointment.user_id as any;
                    console.log('User ID in appointment is an object:', userObj);
                } else {
                    console.log('User ID in appointment is a primitive:', appointment.user_id);
                }
            }

            if (appointment.status !== AppointmentStatusEnum.SAMPLE_RECEIVED) {
                await this.appointmentService.updateAppointmentStatus(
                    appointment._id.toString(),
                    AppointmentStatusEnum.SAMPLE_RECEIVED
                );

                // Log the status change
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.SAMPLE_RECEIVED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for sample reception:', logError);
                }
            }

            // Log kit_id debugging information
            try {
                const kitId = extractKitIdFromSample(sample);
                console.log('Sample kit_id:', sample.kit_id, 'type:', typeof sample.kit_id);
                console.log('Extracted kit ID:', kitId);

                const kit = await this.kitService.getKitById(kitId);
                console.log('Kit status:', kit.status);
            } catch (kitError) {
                console.error('Error retrieving kit information:', kitError);
                // Just log the error, don't fail the sample reception
            }

            return updatedSample;
        } catch (error) {
            console.error('Error in receiveSample:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error receiving sample: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error receiving sample');
        }
    }

    /**
     * Get sample by ID
     */
    public async getSampleById(id: string): Promise<ISample> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
        }

        const sample = await this.sampleRepository.findByIdWithPopulate(id);
        if (!sample) {
            throw new HttpException(HttpStatus.NotFound, 'Sample not found');
        }

        // Log sample details for debugging
        console.log('Retrieved sample:', {
            _id: sample._id,
            appointment_id: typeof sample.appointment_id === 'object' ?
                (sample.appointment_id as any)?._id : sample.appointment_id,
            kit_id: typeof sample.kit_id === 'object' ?
                (sample.kit_id as any)?._id : sample.kit_id,
            type: sample.type,
            status: sample.status
        });

        return sample;
    }

    /**
     * Update sample status
     */
    public async updateSampleStatus(sampleId: string, status: SampleStatusEnum): Promise<ISample> {
        try {
            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.getSampleById(sampleId);

            // Update sample status
            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                {
                    status: status,
                    updated_at: new Date()
                },
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample status');
            }

            return updatedSample;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating sample status');
        }
    }

    /**
     * Get samples by appointment ID
     */
    public async getSamplesByAppointmentId(appointmentId: string): Promise<ISample[]> {
        try {
            // Validate appointmentId
            if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            console.log('Finding samples for appointment ID:', appointmentId);

            // Verify that the appointment exists
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Extract the ID to ensure we're using a consistent format
            const appointmentIdStr = appointment._id.toString();
            console.log('Found appointment:', appointmentIdStr);

            // Find samples associated with the appointment
            const samples = await this.sampleRepository.findByAppointmentId(appointmentIdStr);
            console.log(`Found ${samples.length} samples for appointment ${appointmentIdStr}`);

            return samples;
        } catch (error) {
            console.error('Error in getSamplesByAppointmentId:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving samples for appointment');
        }
    }

    /**
     * Create samples for an appointment
     * @param appointmentId The ID of the appointment
     * @param sampleTypes Array of sample types to create
     * @param collectionMethod The collection method (SELF, FACILITY, HOME)
     * @deprecated Use addSampleToAppointment instead
     */
    public async createSamplesForAppointment(
        appointmentId: string,
        sampleTypes: SampleSelectionDto[],
        collectionMethod: TypeEnum
    ): Promise<ISample[]> {
        console.warn('DEPRECATED: createSamplesForAppointment is deprecated. Use addSampleToAppointment instead.');
        try {
            if (!mongoose.Types.ObjectId.isValid(appointmentId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            // If no sample types provided, use default SALIVA
            if (!sampleTypes || sampleTypes.length === 0) {
                console.log(`No sample types provided for appointment ${appointmentId}, using default SALIVA`);
                sampleTypes = [{ type: SampleTypeEnum.SALIVA }];
            } else {
                console.log(`Creating ${sampleTypes.length} samples for appointment ${appointmentId}:`,
                    sampleTypes.map(s => s.type).join(', '));
            }

            // Get available kits for the samples
            const kitService = this.kitService;
            const availableKits = await kitService.getAvailableKits();
            console.log(`Found ${availableKits.length} available kits`);

            if (availableKits.length < sampleTypes.length) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    `Not enough available kits. Need ${sampleTypes.length} but only ${availableKits.length} available.`
                );
            }

            // Get appointment data for logging
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);

            // Create samples with assigned kits
            const samples: ISample[] = [];
            const assignedKits: string[] = [];

            for (let i = 0; i < sampleTypes.length; i++) {
                const kit = availableKits[i];

                // First, assign the kit to the appointment
                try {
                    await kitService.changeKitStatus(kit._id.toString(), KitStatusEnum.ASSIGNED);
                    assignedKits.push(kit._id.toString());
                    console.log(`Kit ${kit.code || kit._id} assigned to appointment ${appointmentId}`);
                } catch (kitError) {
                    console.error(`Failed to assign kit ${kit._id} to appointment:`, kitError);
                    // If kit assignment fails, try to revert any previously assigned kits
                    for (const assignedKitId of assignedKits) {
                        try {
                            await kitService.changeKitStatus(assignedKitId, KitStatusEnum.AVAILABLE);
                        } catch (revertError) {
                            console.error(`Failed to revert kit ${assignedKitId} status:`, revertError);
                        }
                    }
                    throw new HttpException(HttpStatus.InternalServerError, 'Failed to assign kits to appointment');
                }

                // Then create the sample with the assigned kit
                try {
                    const sample = await this.sampleRepository.create({
                        appointment_id: appointmentId as any,
                        kit_id: kit._id.toString() as any,
                        type: sampleTypes[i].type,
                        collection_method: collectionMethod as unknown as CollectionMethodEnum,
                        collection_date: new Date(),
                        status: SampleStatusEnum.PENDING,
                        created_at: new Date(),
                        updated_at: new Date()
                    });

                    console.log(`Sample created with ID ${sample._id}, type ${sample.type}`);
                    samples.push(sample);
                } catch (sampleError) {
                    console.error(`Failed to create sample for kit ${kit._id}:`, sampleError);
                    // If sample creation fails, try to revert kit status
                    try {
                        await kitService.changeKitStatus(kit._id.toString(), KitStatusEnum.AVAILABLE);
                    } catch (revertError) {
                        console.error(`Failed to revert kit ${kit._id} status:`, revertError);
                    }
                    throw new HttpException(HttpStatus.InternalServerError, 'Failed to create sample');
                }
            }

            // Log the sample creation event
            try {
                await this.appointmentLogService.logSampleCreation(appointment, samples);
                console.log(`Successfully logged sample creation for appointment ${appointmentId}`);
            } catch (logError) {
                console.error('Failed to create log for sample creation:', logError);
                // Don't fail the sample creation if logging fails
            }

            return samples;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            console.error('Error in createSamplesForAppointment:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Error creating samples for appointment');
        }
    }

    /**
     * Add a sample to an existing appointment
     * @param userId ID of the user adding the sample
     * @param addSampleData Data for adding a sample
     */
    public async addSampleToAppointment(userId: string, addSampleData: AddSampleDto): Promise<ISample[]> {
        try {
            // Validate appointmentId
            if (!mongoose.Types.ObjectId.isValid(addSampleData.appointment_id)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid appointment ID');
            }

            // Get the appointment
            const appointment = await this.appointmentService.getAppointmentById(addSampleData.appointment_id);
            if (!appointment) {
                throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
            }

            // Check if the appointment belongs to the user
            const appointmentUserId = extractUserIdFromAppointment(appointment);
            if (!areIdsEqual(appointmentUserId, userId)) {
                throw new HttpException(HttpStatus.Forbidden, 'You are not authorized to add samples to this appointment');
            }

            // Validate that there are at least 2 sample types
            if (!addSampleData.sample_types || addSampleData.sample_types.length < 2) {
                throw new HttpException(HttpStatus.BadRequest, 'At least 2 sample types are required');
            }

            // Check if person_info_list is provided and matches the length of sample_types
            if (addSampleData.person_info_list &&
                addSampleData.person_info_list.length !== addSampleData.sample_types.length) {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'The number of person_info entries must match the number of sample types'
                );
            }

            const samples: ISample[] = [];

            // Kiá»ƒm tra appointment
            const appointmentSchema = await AppointmentSchema.findById(addSampleData.appointment_id);
            if (!appointmentSchema) throw new Error('Appointment not found');
            // Láº¥y service Ä‘á»ƒ kiá»ƒm tra loáº¡i
            const service = await ServiceSchema.findById(appointmentSchema.service_id);
            if (service && service.type === ServiceTypeEnum.ADMINISTRATIVE) {
                if (addSampleData.collection_method !== 'FACILITY') {
                    throw new Error('ADMINISTRATIVE chá»‰ cho phÃ©p thu máº«u táº¡i cÆ¡ sá»Ÿ (FACILITY)');
                }
            }

            // Process each sample type
            for (let i = 0; i < addSampleData.sample_types.length; i++) {
                const sampleType = addSampleData.sample_types[i];

                // Get an available kit
                let kitId = addSampleData.kit_id;
                if (!kitId || i > 0) {
                    // Only use the specified kit for the first sample, get new kits for the rest
                    const availableKits = await this.kitService.getAvailableKits();
                    if (!availableKits || availableKits.length === 0) {
                        throw new HttpException(HttpStatus.BadRequest, 'No available kits found');
                    }
                    kitId = availableKits[0]._id.toString();
                }

                // Update the kit status to ASSIGNED
                await this.kitService.changeKitStatus(kitId, KitStatusEnum.ASSIGNED);

                // Create the sample
                const sampleData: any = {
                    appointment_id: addSampleData.appointment_id,
                    kit_id: kitId,
                    type: sampleType,
                    collection_method: CollectionMethodEnum.SELF, // Default to self collection
                    collection_date: new Date(),
                    status: SampleStatusEnum.PENDING,
                };

                // Set person_info from the corresponding entry in person_info_list if available
                if (addSampleData.person_info_list && addSampleData.person_info_list[i]) {
                    sampleData.person_info = addSampleData.person_info_list[i];
                } else if (addSampleData.person_info) {
                    // Fall back to the single person_info if available
                    sampleData.person_info = addSampleData.person_info;
                }

                const sample = await this.sampleRepository.create(sampleData);
                samples.push(sample);
            }

            // Log the sample addition
            await this.appointmentLogService.logSampleCreation(appointment, samples);

            // Change appointment status to SAMPLE_ASSIGNED if not already
            if (appointment.status !== AppointmentStatusEnum.SAMPLE_ASSIGNED) {
                await this.appointmentService.updateAppointmentStatus(
                    addSampleData.appointment_id,
                    AppointmentStatusEnum.SAMPLE_ASSIGNED
                );
                // Optionally, log the status change if you have a log method for this
                try {
                    await this.appointmentLogService.logStatusChange(
                        appointment,
                        AppointmentLogTypeEnum.SAMPLE_ASSIGNED
                    );
                } catch (logError) {
                    console.error('Failed to create appointment log for SAMPLE_ASSIGNED:', logError);
                }
            }

            return samples;
        } catch (error) {
            if (error instanceof HttpException) {
                throw error;
            }
            console.error('Error in addSampleToAppointment:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to add samples to appointment');
        }
    }

    /**
     * Submit multiple samples at once (by customer)
     * @param sampleIds Array of sample IDs to submit
     * @param collectionDate Optional collection date for all samples
     * @param userId ID of the user submitting the samples
     */
    public async batchSubmitSamples(sampleIds: string[], collectionDate: string | undefined, userId: string): Promise<ISample[]> {
        try {
            if (!sampleIds || sampleIds.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'No sample IDs provided');
            }

            // Validate all sample IDs
            for (const sampleId of sampleIds) {
                if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                    throw new HttpException(HttpStatus.BadRequest, `Invalid sample ID: ${sampleId}`);
                }
            }

            // Find all samples
            const samples = await this.sampleRepository.findManyByIds(sampleIds);
            if (samples.length !== sampleIds.length) {
                throw new HttpException(HttpStatus.NotFound, 'One or more samples not found');
            }

            // Group samples by appointment ID for efficient processing
            const samplesByAppointment = new Map<string, ISample[]>();

            for (const sample of samples) {
                const appointmentId = extractAppointmentIdFromSample(sample);

                if (!samplesByAppointment.has(appointmentId)) {
                    samplesByAppointment.set(appointmentId, []);
                }

                samplesByAppointment.get(appointmentId)!.push(sample);
            }

            // Verify authorization and validate samples for each appointment
            for (const [appointmentId, appointmentSamples] of samplesByAppointment.entries()) {
                // Verify that the samples belong to the user making the request
                const appointment = await this.appointmentService.getAppointmentById(appointmentId);
                const appointmentUserId = extractUserIdFromAppointment(appointment);

                if (!areIdsEqual(appointmentUserId, userId)) {
                    throw new HttpException(HttpStatus.Forbidden,
                        `You are not authorized to submit samples for appointment ${appointmentId}`);
                }

                // Verify that all samples are in PENDING status
                for (const sample of appointmentSamples) {
                    if (sample.status !== SampleStatusEnum.PENDING) {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Cannot submit sample ${sample._id} with status ${sample.status}`
                        );
                    }
                }
            }

            // Update all samples
            const updatedSamples: ISample[] = [];
            const updateData: any = {
                updated_at: new Date()
            };

            // Only update collection_date if provided
            if (collectionDate) {
                updateData.collection_date = new Date(collectionDate);
            }

            // Update each sample
            for (const sampleId of sampleIds) {
                const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                    sampleId,
                    updateData,
                    { new: true }
                );

                if (!updatedSample) {
                    throw new HttpException(HttpStatus.InternalServerError, `Failed to update sample ${sampleId}`);
                }

                updatedSamples.push(updatedSample);
            }

            // Update appointment status and kit status for each appointment
            for (const [appointmentId, appointmentSamples] of samplesByAppointment.entries()) {
                const appointment = await this.appointmentService.getAppointmentById(appointmentId);

                // Update appointment status to SAMPLE_COLLECTED if not already
                if (appointment.status !== AppointmentStatusEnum.SAMPLE_COLLECTED) {
                    await this.appointmentService.updateAppointmentStatus(
                        appointmentId,
                        AppointmentStatusEnum.SAMPLE_COLLECTED
                    );

                    // Log the status change
                    try {
                        await this.appointmentLogService.logStatusChange(
                            appointment,
                            AppointmentLogTypeEnum.SAMPLE_COLLECTED
                        );
                    } catch (logError) {
                        console.error('Failed to create appointment log for batch sample submission:', logError);
                    }
                }

                // Update kit status to USED for each sample
                for (const sample of appointmentSamples) {
                    try {
                        const kitId = extractKitIdFromSample(sample);
                        const kit = await this.kitService.getKitById(kitId);

                        if (kit.status !== KitStatusEnum.USED) {
                            await this.kitService.changeKitStatus(kitId, KitStatusEnum.USED);
                        }
                    } catch (kitError) {
                        console.error(`Error updating kit status for sample ${sample._id}:`, kitError);
                        // Don't fail the batch submission if kit update fails
                    }
                }
            }

            return updatedSamples;
        } catch (error) {
            console.error('Error in batchSubmitSamples:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error submitting samples: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error submitting samples');
        }
    }

    /**
     * Receive multiple samples at once (by staff)
     * @param sampleIds Array of sample IDs to receive
     * @param receivedDate Received date for all samples
     * @param staffId ID of the staff receiving the samples
     */
    public async batchReceiveSamples(sampleIds: string[], receivedDate: string, staffId: string): Promise<ISample[]> {
        try {
            if (!sampleIds || sampleIds.length === 0) {
                throw new HttpException(HttpStatus.BadRequest, 'No sample IDs provided');
            }

            // Validate all sample IDs
            for (const sampleId of sampleIds) {
                if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                    throw new HttpException(HttpStatus.BadRequest, `Invalid sample ID: ${sampleId}`);
                }
            }

            // Find all samples
            const samples = await this.sampleRepository.findManyByIds(sampleIds);
            if (samples.length !== sampleIds.length) {
                throw new HttpException(HttpStatus.NotFound, 'One or more samples not found');
            }

            // Group samples by appointment ID for efficient processing
            const samplesByAppointment = new Map<string, ISample[]>();

            for (const sample of samples) {
                const appointmentId = extractAppointmentIdFromSample(sample);

                if (!samplesByAppointment.has(appointmentId)) {
                    samplesByAppointment.set(appointmentId, []);
                }

                samplesByAppointment.get(appointmentId)!.push(sample);
            }

            // Validate samples for each appointment
            for (const appointmentSamples of samplesByAppointment.values()) {
                // Verify that all samples are in PENDING status and have been collected
                for (const sample of appointmentSamples) {
                    if (sample.status !== SampleStatusEnum.PENDING) {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Cannot receive sample ${sample._id} with status ${sample.status}`
                        );
                    }

                    if (!sample.collection_date) {
                        throw new HttpException(
                            HttpStatus.BadRequest,
                            `Sample ${sample._id} must be collected before it can be received`
                        );
                    }
                }
            }

            // Update all samples
            const updatedSamples: ISample[] = [];
            const receivedDate_obj = new Date(receivedDate);

            // Update each sample
            for (const sampleId of sampleIds) {
                const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                    sampleId,
                    {
                        received_date: receivedDate_obj,
                        status: SampleStatusEnum.RECEIVED,
                        updated_at: new Date()
                    },
                    { new: true }
                );

                if (!updatedSample) {
                    throw new HttpException(HttpStatus.InternalServerError, `Failed to update sample ${sampleId}`);
                }

                updatedSamples.push(updatedSample);
            }

            // Update appointment status for each appointment
            for (const [appointmentId, _] of samplesByAppointment.entries()) {
                const appointment = await this.appointmentService.getAppointmentById(appointmentId);

                // Update appointment status to SAMPLE_RECEIVED if not already
                if (appointment.status !== AppointmentStatusEnum.SAMPLE_RECEIVED) {
                    await this.appointmentService.updateAppointmentStatus(
                        appointmentId,
                        AppointmentStatusEnum.SAMPLE_RECEIVED
                    );

                    // Log the status change
                    try {
                        await this.appointmentLogService.logStatusChange(
                            appointment,
                            AppointmentLogTypeEnum.SAMPLE_RECEIVED
                        );
                    } catch (logError) {
                        console.error('Failed to create appointment log for batch sample reception:', logError);
                    }
                }
            }

            return updatedSamples;
        } catch (error) {
            console.error('Error in batchReceiveSamples:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error receiving samples: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error receiving samples');
        }
    }

    /**
     * Update a person's image URL in a sample
     * @param sampleId ID of the sample
     * @param imageUrl URL of the uploaded image
     * @param userId ID of the user making the request
     */
    public async updatePersonImage(
        sampleId: string,
        imageUrl: string,
        userId: string
    ): Promise<ISample> {
        try {
            console.log("updatePersonImage called with:", { sampleId, imageUrl, userId });

            // Validate sampleId
            if (!mongoose.Types.ObjectId.isValid(sampleId)) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid sample ID');
            }

            // Find the sample
            const sample = await this.sampleRepository.findByIdWithPopulate(sampleId);
            if (!sample) {
                throw new HttpException(HttpStatus.NotFound, 'Sample not found');
            }

            console.log("Sample found:", {
                id: sample._id,
                hasSinglePersonInfo: !!sample.person_info,
                hasPersonInfoList: !!sample.person_info_list,
                personInfoListLength: sample.person_info_list?.length
            });

            // Extract appointment_id using the helper function
            const appointmentId = extractAppointmentIdFromSample(sample);

            // Verify that the sample belongs to the user making the request
            const appointment = await this.appointmentService.getAppointmentById(appointmentId);
            const appointmentUserId = extractUserIdFromAppointment(appointment);

            if (!areIdsEqual(appointmentUserId, userId)) {
                throw new HttpException(HttpStatus.Forbidden, 'You are not authorized to update this sample');
            }

            // Always update the single person_info object
            if (!sample.person_info) {
                sample.person_info = { name: 'Unknown', image_url: imageUrl };
            } else {
                sample.person_info.image_url = imageUrl;
            }

            // Update the sample
            const updatedSample = await this.sampleRepository.findByIdAndUpdate(
                sampleId,
                { person_info: sample.person_info, updated_at: new Date() },
                { new: true }
            );

            if (!updatedSample) {
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to update sample');
            }

            return updatedSample;
        } catch (error) {
            console.error('Error in updatePersonImage:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            if (error instanceof Error) {
                throw new HttpException(HttpStatus.InternalServerError, `Error updating person image: ${error.message}`);
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error updating person image');
        }
    }

    /**
     * Get samples ready for testing (samples with status RECEIVED)
     * This is used by laboratory technicians to find samples that are ready to be tested
     */
    public async getSamplesReadyForTesting(page: number = 1, limit: number = 10): Promise<SearchPaginationResponseModel<ISample>> {
        try {
            const skip = (page - 1) * limit;

            // Find samples with status RECEIVED
            const query = { status: SampleStatusEnum.RECEIVED };

            // Get total count for pagination
            const total = await this.sampleRepository.countDocuments(query);

            // Find samples with pagination and populate related fields
            const samples = await this.sampleRepository.findWithPopulate(
                query,
                { received_date: -1 }, // Sort by received date, newest first
                skip,
                limit
            );

            // Calculate total pages
            const pages = Math.ceil(total / limit);

            return new SearchPaginationResponseModel<ISample>(
                samples,
                {
                    totalItems: total,
                    totalPages: pages,
                    pageNum: page,
                    pageSize: limit
                }
            );
        } catch (error) {
            console.error('Error in getSamplesReadyForTesting:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving samples ready for testing');
        }
    }

    /**
     * Get all samples with RECEIVED status
     * This endpoint is used by laboratory technicians to view all samples that need testing
     */
    public async getSamplesForTesting(page: number = 1, limit: number = 10): Promise<SearchPaginationResponseModel<ISample>> {
        try {
            const skip = (page - 1) * limit;

            const query = { status: SampleStatusEnum.TESTING };

            // Get total count for pagination
            const total = await this.sampleRepository.countDocuments(query);

            // Find samples with pagination and populate related fields
            const samples = await this.sampleRepository.findWithPopulate(
                query,
                { received_date: -1 }, // Sort by received date, newest first
                skip,
                limit
            );

            // Calculate total pages
            const pages = Math.ceil(total / limit);

            return new SearchPaginationResponseModel<ISample>(
                samples,
                {
                    totalItems: total,
                    totalPages: pages,
                    pageNum: page,
                    pageSize: limit
                }
            );
        } catch (error) {
            console.error('Error in getSamplesForTesting:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error retrieving samples for testing');
        }
    }

    /**
     * Search samples by various criteria
     * This allows laboratory technicians to search for samples by different parameters
     */
    public async searchSamples(
        options: {
            status?: SampleStatusEnum,
            type?: SampleTypeEnum,
            appointmentId?: string,
            kitCode?: string,
            personName?: string,
            startDate?: Date,
            endDate?: Date,
            page?: number,
            limit?: number
        }
    ): Promise<SearchPaginationResponseModel<ISample>> {
        try {
            // Extract options with default values and validation
            const {
                status,
                type,
                appointmentId,
                kitCode,
                personName,
                startDate,
                endDate
            } = options;

            // Ensure page and limit are valid numbers with defaults
            const page = options.page && options.page > 0 ? Math.floor(options.page) : 1;
            const limit = options.limit && options.limit > 0 ? Math.floor(options.limit) : 10;
            const skip = (page - 1) * limit;

            console.log('Search options in service:', {
                status, type, appointmentId, kitCode, personName,
                startDate, endDate, page, limit, skip
            });

            // Build query object
            const query: any = {};

            // Add status filter if provided and valid
            if (status) {
                // Check if status is a valid enum value
                try {
                    // Simple string check instead of using Object.values
                    const validStatuses = ['pending', 'received', 'testing', 'completed', 'invalid'];
                    if (validStatuses.includes(status.toLowerCase())) {
                        query.status = status;
                    }
                } catch (err) {
                    console.log('Error validating status:', err);
                }
            }

            // Add type filter if provided and valid
            if (type) {
                // Check if type is a valid enum value
                try {
                    // Simple string check instead of using Object.values
                    const validTypes = ['saliva', 'blood', 'hair', 'other'];
                    if (validTypes.includes(type.toLowerCase())) {
                        query.type = type;
                    }
                } catch (err) {
                    console.log('Error validating type:', err);
                }
            }

            // Add appointment ID filter if provided and valid
            if (appointmentId && mongoose.Types.ObjectId.isValid(appointmentId)) {
                query.appointment_id = new mongoose.Types.ObjectId(appointmentId);
            }

            // Add date range filter if either start or end date is provided
            if (startDate instanceof Date || endDate instanceof Date) {
                query.updated_at = {};

                // Add start date filter if valid
                if (startDate instanceof Date && !isNaN(startDate.getTime())) {
                    query.updated_at.$gte = startDate;
                }

                // Add end date filter if valid
                if (endDate instanceof Date && !isNaN(endDate.getTime())) {
                    query.updated_at.$lte = endDate;
                }

                // If no valid date filters were added, remove the empty updated_at filter
                if (Object.keys(query.updated_at).length === 0) {
                    delete query.updated_at;
                }
            }

            console.log('MongoDB query:', JSON.stringify(query, null, 2));

            // Get total count for pagination
            const total = await this.sampleRepository.countDocuments(query);

            // Find samples with pagination and populate related fields
            let samples = await this.sampleRepository.findWithPopulate(
                query,
                { updated_at: -1 }, // Sort by updated date, newest first
                skip,
                limit
            );

            // In-memory filtering for properties that can't be filtered in the database query
            let filteredTotal = total;

            // Filter by kit code if provided
            if (kitCode && kitCode.trim() !== '') {
                samples = samples.filter(sample => {
                    const kit = sample.kit_id as any;
                    return kit &&
                        kit.code &&
                        typeof kit.code === 'string' &&
                        kit.code.toLowerCase().includes(kitCode.toLowerCase());
                });
                filteredTotal = samples.length;
            }

            // Filter by person name if provided
            if (personName && personName.trim() !== '') {
                samples = samples.filter(sample => {
                    // Check in single person_info
                    if (sample.person_info &&
                        sample.person_info.name &&
                        typeof sample.person_info.name === 'string') {
                        return sample.person_info.name.toLowerCase().includes(personName.toLowerCase());
                    }

                    // Check in person_info_list
                    if (sample.person_info_list &&
                        Array.isArray(sample.person_info_list) &&
                        sample.person_info_list.length > 0) {
                        return sample.person_info_list.some(person =>
                            person &&
                            person.name &&
                            typeof person.name === 'string' &&
                            person.name.toLowerCase().includes(personName.toLowerCase())
                        );
                    }

                    return false;
                });
                filteredTotal = samples.length;
            }

            // Calculate total pages based on filtered total
            const pages = Math.ceil(filteredTotal / limit);

            // Return paginated results using SearchPaginationResponseModel
            return new SearchPaginationResponseModel<ISample>(
                samples.slice(0, limit), // Ensure we don't return more than the limit
                {
                    totalItems: filteredTotal,
                    totalPages: pages > 0 ? pages : 1, // Ensure at least 1 page even if no results
                    pageNum: page,
                    pageSize: limit
                }
            );
        } catch (error) {
            console.error('Error in searchSamples service:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error searching samples');
        }
    }

    /**
     * Collect sample at facility
     */
    public async collectSampleAtFacility(model: CollectSampleDto, staff_id: string): Promise<ISample[]> {
        const appointment = await this.appointmentService.getAppointmentById(model.appointment_id);
        if (!appointment) {
            throw new HttpException(HttpStatus.NotFound, 'Appointment not found');
        }

        if (appointment.status !== AppointmentStatusEnum.CONFIRMED) {
            throw new HttpException(HttpStatus.BadRequest, 'Appointment must be confirmed before collecting sample');
        }

        // Validate that number of sample types matches number of person info entries
        if (model.type.length !== model.person_info.length) {
            throw new HttpException(HttpStatus.BadRequest, 'Number of sample types must match number of person information entries');
        }

        // Get available kits
        const availableKits = await this.kitService.getAvailableKits();
        if (availableKits.length < model.type.length) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `Not enough available kits. Need ${model.type.length} but only ${availableKits.length} available.`
            );
        }

        const samples: ISample[] = [];

        // Create a sample for each type and person info
        for (let i = 0; i < model.type.length; i++) {
            // Get an available kit
            const kit = availableKits[i];

            // Update kit status to ASSIGNED
            await this.kitService.changeKitStatus(kit._id.toString(), KitStatusEnum.ASSIGNED);

            // Validate the collection date is valid before creating the sample
            if (model.collection_date && isNaN(new Date(model.collection_date).getTime())) {
                throw new HttpException(HttpStatus.BadRequest, 'collection_date must be a valid ISO 8601 date string');
            }

            const sampleData: Partial<ISample> = {
                appointment_id: model.appointment_id,
                kit_id: kit._id.toString(),
                type: model.type[i],
                collection_method: CollectionMethodEnum.FACILITY,
                collection_date: model.collection_date ? new Date(model.collection_date) : new Date(),
                status: SampleStatusEnum.PENDING,
                person_info: model.person_info[i] as IPersonInfo,
                created_at: new Date(),
                updated_at: new Date(),
                created_by: staff_id,
                updated_by: staff_id
            };

            const sample = await this.sampleRepository.create(sampleData);
            samples.push(sample);
        }

        // Update appointment status to SAMPLE_COLLECTED
        await this.appointmentService.updateAppointmentStatus(
            model.appointment_id,
            AppointmentStatusEnum.SAMPLE_COLLECTED
        );

        return samples;
    }
} 


================================================
FILE: src/modules/sample/dtos/addSample.dto.ts
================================================
import { IsDate, IsEnum, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested, ArrayMinSize, ArrayMaxSize, IsUrl } from 'class-validator';
import { SampleTypeEnum } from '../sample.enum';
import { Type } from 'class-transformer';

export class PersonInfoDto {
    @IsNotEmpty()
    @IsString()
    name: string = '';

    @IsOptional()
    @IsDate()
    @Type(() => Date)
    dob?: Date;

    @IsOptional()
    @IsString()
    relationship?: string;

    @IsOptional()
    @IsString()
    birth_place?: string;

    @IsOptional()
    @IsString()
    nationality?: string;

    @IsOptional()
    @IsString()
    identity_document?: string;

    @IsOptional()
    @IsString()
    image_url?: string;
}

export class AddSampleDto {
    @IsMongoId()
    appointment_id: string = '';

    @IsMongoId()
    @IsOptional()
    kit_id?: string;

    @IsEnum(SampleTypeEnum, { each: true })
    sample_types: SampleTypeEnum[] = [SampleTypeEnum.SALIVA];

    @IsString()
    @IsOptional()
    notes?: string;

    @IsOptional()
    @ValidateNested()
    @Type(() => PersonInfoDto)
    person_info?: PersonInfoDto;

    @IsOptional()
    @ValidateNested({ each: true })
    @Type(() => PersonInfoDto)
    person_info_list?: PersonInfoDto[];

    @IsOptional()
    @IsString()
    collection_method?: string;
} 


================================================
FILE: src/modules/sample/dtos/addSampleForFacility.dto.ts
================================================



================================================
FILE: src/modules/sample/dtos/addSampleWithMultiplePersonInfo.dto.ts
================================================
import { IsEnum, IsMongoId, IsNotEmpty, IsOptional, IsString, ValidateNested, ArrayMinSize, ArrayMaxSize, IsArray } from 'class-validator';
import { SampleTypeEnum } from '../sample.enum';
import { Type } from 'class-transformer';
import { PersonInfoDto } from './addSample.dto';

export class AddSampleWithMultiplePersonInfoDto {
    @IsMongoId()
    appointment_id: string = '';

    @IsMongoId()
    @IsOptional()
    kit_id?: string;

    @IsArray()
    @IsEnum(SampleTypeEnum, { each: true })
    @ArrayMinSize(2)
    sample_types: SampleTypeEnum[] = [];

    @IsString()
    @IsOptional()
    notes?: string;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PersonInfoDto)
    @ArrayMinSize(2)
    person_info_list: PersonInfoDto[] = [];
} 


================================================
FILE: src/modules/sample/dtos/batchReceiveSamples.dto.ts
================================================
import { IsArray, IsDateString, IsNotEmpty, IsString } from 'class-validator';

export class BatchReceiveSamplesDto {
    @IsArray()
    @IsString({ each: true })
    sample_ids: string[] = [];

    @IsNotEmpty()
    @IsDateString()
    received_date: string = '';
} 


================================================
FILE: src/modules/sample/dtos/batchSubmitSamples.dto.ts
================================================
import { IsArray, IsDateString, IsOptional, IsString } from 'class-validator';

export class BatchSubmitSamplesDto {
    @IsArray()
    @IsString({ each: true })
    sample_ids: string[] = [];

    @IsOptional()
    @IsDateString()
    collection_date?: string;
} 


================================================
FILE: src/modules/sample/dtos/collect-sample.dto.ts
================================================
import { IsArray, IsDateString, IsEnum, IsNotEmpty, IsString, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { SampleTypeEnum } from '../sample.enum';

export class PersonInfoDto {
    @IsNotEmpty()
    @IsString()
    name!: string;

    @IsString()
    gender?: string;

    @IsString()
    phone_number?: string;

    @IsDateString()
    dob?: string;

    @IsString()
    relationship?: string;

    @IsString()
    birth_place?: string;

    @IsString()
    nationality?: string;

    @IsString()
    identity_document?: string;
}

export class CollectSampleDto {
    @IsNotEmpty()
    @IsString()
    appointment_id!: string;

    @IsArray()
    @IsEnum(SampleTypeEnum, { each: true })
    type!: SampleTypeEnum[];

    @Type(() => Date)
    collection_date?: Date;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PersonInfoDto)
    person_info!: PersonInfoDto[];
} 


================================================
FILE: src/modules/sample/dtos/index.ts
================================================
export * from './addSample.dto';
export * from './submitSample.dto';
export * from './receiveSample.dto';
export * from './addSampleWithMultiplePersonInfo.dto';
export * from './batchSubmitSamples.dto';
export * from './batchReceiveSamples.dto';
export * from './uploadPersonImage.dto'; 


================================================
FILE: src/modules/sample/dtos/receiveSample.dto.ts
================================================
import { IsDateString, IsNotEmpty } from 'class-validator';

export class ReceiveSampleDto {
    @IsNotEmpty({ message: 'Received date is required' })
    @IsDateString({}, { message: 'Received date must be a valid date' })
    received_date: string = '';
} 


================================================
FILE: src/modules/sample/dtos/searchSamples.dto.ts
================================================
import { IsDateString, IsEnum, IsMongoId, IsNumber, IsOptional, IsString, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { SampleStatusEnum, SampleTypeEnum } from '../sample.enum';

export class SearchSamplesDto {
    @IsOptional()
    @IsEnum(SampleStatusEnum, { message: 'Status must be a valid sample status' })
    status?: SampleStatusEnum;

    @IsOptional()
    @IsEnum(SampleTypeEnum, { message: 'Type must be a valid sample type' })
    type?: SampleTypeEnum;

    @IsOptional()
    @IsMongoId({ message: 'Appointment ID must be a valid MongoDB ID' })
    appointmentId?: string;

    @IsOptional()
    @IsString({ message: 'Kit code must be a string' })
    kitCode?: string;

    @IsOptional()
    @IsString({ message: 'Person name must be a string' })
    personName?: string;

    @IsOptional()
    @IsDateString({}, { message: 'Start date must be a valid date string' })
    startDate?: string;

    @IsOptional()
    @IsDateString({}, { message: 'End date must be a valid date string' })
    endDate?: string;

    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Page must be a number' })
    @Min(1, { message: 'Page must be at least 1' })
    page?: number = 1;

    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Limit must be a number' })
    @Min(1, { message: 'Limit must be at least 1' })
    limit?: number = 10;
} 


================================================
FILE: src/modules/sample/dtos/submitSample.dto.ts
================================================
import { IsDateString, IsOptional } from 'class-validator';

export class SubmitSampleDto {
    @IsOptional()
    @IsDateString({}, { message: 'Collection date must be a valid date' })
    collection_date?: string;
} 


================================================
FILE: src/modules/sample/dtos/uploadPersonImage.dto.ts
================================================
import { IsMongoId, IsNotEmpty } from 'class-validator';

export class UploadPersonImageDto {
    @IsNotEmpty()
    @IsMongoId()
    sample_id: string = '';
} 


================================================
FILE: src/modules/sample/swagger/sample.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     PersonInfoDto:
 *       type: object
 *       required:
 *         - name
 *       properties:
 *         name:
 *           type: string
 *           description: Full name of the person
 *           example: "Nguyá»…n VÄƒn A"
 *         dob:
 *           type: string
 *           format: date-time
 *           description: Date of birth
 *           example: "1978-04-19T00:00:00Z"
 *         relationship:
 *           type: string
 *           description: Relationship to the test subject
 *           example: "Cha giáº£ Ä‘á»‹nh"
 *         birth_place:
 *           type: string
 *           description: Place of birth
 *           example: "Thanh An"
 *         nationality:
 *           type: string
 *           description: Nationality
 *           example: "HÃ  Lan"
 *         identity_document:
 *           type: string
 *           description: Identity document number (ID card, passport, etc.)
 *           example: "NX2JHP9F9"
 *         image_url:
 *           type: string
 *           description: URL to the person's image
 *           example: "https://dna-test-samples.s3.ap-southeast-1.amazonaws.com/sample/60c72b2f9b1e8b3b4c8d6e27/1234567890.jpg"
 *
 *     UploadPersonImageDto:
 *       type: object
 *       required:
 *         - sample_id
 *       properties:
 *         sample_id:
 *           type: string
 *           description: ID of the sample
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *
 *     SubmitSampleDto:
 *       type: object
 *       properties:
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the sample was collected (optional - if not provided, the existing collection date will be used)
 *           example: "2025-05-28T10:00:00Z"
 *
 *     ReceiveSampleDto:
 *       type: object
 *       required:
 *         - received_date
 *       properties:
 *         received_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the sample was received by the facility
 *           example: "2025-05-29T09:00:00Z"
 *
 *     BatchSubmitSamplesDto:
 *       type: object
 *       required:
 *         - sample_ids
 *       properties:
 *         sample_ids:
 *           type: array
 *           description: Array of sample IDs to submit
 *           items:
 *             type: string
 *           example: ["60c72b2f9b1e8b3b4c8d6e27", "60c72b2f9b1e8b3b4c8d6e28"]
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the samples were collected (optional - if not provided, the existing collection dates will be used)
 *           example: "2025-05-28T10:00:00Z"
 *
 *     BatchReceiveSamplesDto:
 *       type: object
 *       required:
 *         - sample_ids
 *         - received_date
 *       properties:
 *         sample_ids:
 *           type: array
 *           description: Array of sample IDs to receive
 *           items:
 *             type: string
 *           example: ["60c72b2f9b1e8b3b4c8d6e27", "60c72b2f9b1e8b3b4c8d6e28"]
 *         received_date:
 *           type: string
 *           format: date-time
 *           description: Date and time when the samples were received by the facility
 *           example: "2025-05-29T09:00:00Z"
 *
 *     SampleResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Sample ID
 *           example: "60c72b2f9b1e8b3b4c8d6e27"
 *         appointment_id:
 *           type: object
 *           description: Associated appointment
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e24"
 *             user_id:
 *               type: object
 *               properties:
 *                 _id:
 *                   type: string
 *                   example: "60c72b2f9b1e8b3b4c8d6e23"
 *                 first_name:
 *                   type: string
 *                   example: "John"
 *                 last_name:
 *                   type: string
 *                   example: "Doe"
 *             service_id:
 *               type: object
 *               properties:
 *                 _id:
 *                   type: string
 *                   example: "60c72b2f9b1e8b3b4c8d6e22"
 *                 name:
 *                   type: string
 *                   example: "DNA Paternity Test"
 *         kit_id:
 *           type: object
 *           description: Associated kit
 *           properties:
 *             _id:
 *               type: string
 *               example: "60c72b2f9b1e8b3b4c8d6e26"
 *             code:
 *               type: string
 *               example: "KIT-20250527-001"
 *         type:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *           description: Type of sample
 *           example: "saliva"
 *         collection_method:
 *           type: string
 *           enum: [self, facility, home]
 *           description: Method of collection
 *           example: "self"
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date when sample was collected
 *           example: "2025-05-28T10:00:00Z"
 *         received_date:
 *           type: string
 *           format: date-time
 *           description: Date when sample was received by the facility
 *           example: "2025-05-29T09:00:00Z"
 *         status:
 *           type: string
 *           enum: [pending, received, testing, completed, invalid]
 *           description: Current sample status
 *           example: "pending"
 *         person_info:
 *           $ref: '#/components/schemas/PersonInfoDto'
 *         person_info_list:
 *           type: array
 *           description: List of person information associated with each sample type
 *           items:
 *             $ref: '#/components/schemas/PersonInfoDto'
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2025-05-27T09:12:00Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2025-05-27T09:13:00Z"
 *
 *     AddSampleDto:
 *       type: object
 *       required:
 *         - appointment_id
 *         - sample_types
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment to add the sample to
 *           example: "60d0fe4f5311236168a109ca"
 *         kit_id:
 *           type: string
 *           description: ID of the kit to use (optional - if not provided, an available kit will be assigned)
 *           example: "60d0fe4f5311236168a109cb"
 *         sample_types:
 *           type: array
 *           description: Types of samples to add (must provide at least two)
 *           items:
 *             type: string
 *             enum: [saliva, blood, hair, other]
 *           example: ["saliva", "saliva"]
 *         notes:
 *           type: string
 *           description: Additional notes about the sample
 *           example: "Morning sample"
 *         person_info:
 *           $ref: '#/components/schemas/PersonInfoDto'
 *         person_info_list:
 *           type: array
 *           description: List of person information corresponding to each sample type
 *           items:
 *             $ref: '#/components/schemas/PersonInfoDto'
 *
 *     PersonInfo:
 *       type: object
 *       required:
 *         - name
 *       properties:
 *         name:
 *           type: string
 *           description: Full name of the person
 *         gender:
 *           type: string
 *           description: Gender of the person
 *         phone_number:
 *           type: string
 *           description: Phone number of the person
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *         relationship:
 *           type: string
 *           description: Relationship to the patient
 *         birth_place:
 *           type: string
 *           description: Place of birth
 *         nationality:
 *           type: string
 *           description: Nationality
 *         identity_document:
 *           type: string
 *           description: Identity document number
 *
 *     CollectSampleRequest:
 *       type: object
 *       required:
 *         - appointment_id
 *         - type
 *         - collection_date
 *         - person_info
 *       properties:
 *         appointment_id:
 *           type: string
 *           description: ID of the appointment
 *         type:
 *           type: array
 *           items:
 *             type: string
 *             enum: [SALIVA, BLOOD, HAIR, OTHER]
 *           description: Types of samples to collect
 *         collection_date:
 *           type: string
 *           format: date-time
 *           description: Date and time of sample collection
 *         person_info:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/PersonInfo'
 *           description: Information for each person providing a sample
 *
 *     CollectSampleResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *           example: true
 *         message:
 *           type: string
 *           example: Samples collected successfully
 *         data:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               _id:
 *                 type: string
 *                 description: Sample ID
 *               appointment_id:
 *                 type: string
 *                 description: ID of the appointment
 *               type:
 *                 type: string
 *                 enum: [SALIVA, BLOOD, HAIR, OTHER]
 *                 description: Type of sample
 *               collection_method:
 *                 type: string
 *                 enum: [FACILITY]
 *                 description: Method of collection
 *               collection_date:
 *                 type: string
 *                 format: date-time
 *                 description: Date and time of collection
 *               status:
 *                 type: string
 *                 enum: [PENDING]
 *                 description: Status of the sample
 *               person_info:
 *                 $ref: '#/components/schemas/PersonInfo'
 *               created_at:
 *                 type: string
 *                 format: date-time
 *                 description: Creation timestamp
 *               updated_at:
 *                 type: string
 *                 format: date-time
 *                 description: Last update timestamp
 */ 


================================================
FILE: src/modules/sample/swagger/sample.swagger.js
================================================
/**
 * @swagger
 * /api/sample/{id}:
 *   get:
 *     tags:
 *       - samples
 *     summary: Get sample by ID (All authenticated users)
 *     description: Retrieve detailed information about a specific sample
 *     operationId: getSampleById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Sample ID
 *         example: "60c72b2f9b1e8b3b4c8d6e27"
 *     responses:
 *       200:
 *         description: Sample details retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Invalid sample ID format
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Invalid sample ID"
 *                 error:
 *                   type: string
 *                   example: "Bad Request"
 *                 statusCode:
 *                   type: integer
 *                   example: 400
 *       401:
 *         description: Unauthorized - Authentication required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Unauthorized"
 *                 error:
 *                   type: string
 *                   example: "Unauthorized"
 *                 statusCode:
 *                   type: integer
 *                   example: 401
 *       403:
 *         description: Forbidden - User cannot access this sample
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "You are not authorized to access this sample"
 *                 error:
 *                   type: string
 *                   example: "Forbidden"
 *                 statusCode:
 *                   type: integer
 *                   example: 403
 *       404:
 *         description: Sample not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Sample not found"
 *                 error:
 *                   type: string
 *                   example: "Not Found"
 *                 statusCode:
 *                   type: integer
 *                   example: 404
 */
/**
 * @swagger
 * /api/sample/appointment/{appointmentId}:
 *   get:
 *     tags:
 *       - samples
 *     summary: Get samples by appointment ID (All authenticated users)
 *     description: Retrieve all samples associated with a specific appointment
 *     operationId: getSamplesByAppointmentId
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: appointmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Appointment ID
 *         example: "60d0fe4f5311236168a109ce"
 *     responses:
 *       200:
 *         description: Samples retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Invalid appointment ID format
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Invalid appointment ID"
 *                 error:
 *                   type: string
 *                   example: "Bad Request"
 *                 statusCode:
 *                   type: integer
 *                   example: 400
 *       401:
 *         description: Unauthorized - Authentication required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Unauthorized"
 *                 error:
 *                   type: string
 *                   example: "Unauthorized"
 *                 statusCode:
 *                   type: integer
 *                   example: 401
 *       404:
 *         description: Appointment not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Appointment not found"
 *                 error:
 *                   type: string
 *                   example: "Not Found"
 *                 statusCode:
 *                   type: integer
 *                   example: 404
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal server error"
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *                 statusCode:
 *                   type: integer
 *                   example: 500
 */

/**
 * @swagger
 * /api/sample/add-to-appointment:
 *   post:
 *     tags:
 *       - samples
 *     summary: Add samples with multiple person information (Customer only or Other Authenticated Users)
 *     description: Add samples to an existing appointment where each sample type corresponds to a specific person_info entry
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - appointment_id
 *               - sample_types
 *               - person_info_list
 *             properties:
 *               appointment_id:
 *                 type: string
 *                 description: ID of the appointment to add samples to
 *                 example: "60d0fe4f5311236168a109ca"
 *               kit_id:
 *                 type: string
 *                 description: ID of the kit to use for the first sample (optional - if not provided, an available kit will be assigned)
 *                 example: "60d0fe4f5311236168a109cb"
 *               sample_types:
 *                 type: array
 *                 description: Types of samples to add (must provide at least two)
 *                 items:
 *                   type: string
 *                   enum: [saliva, blood, hair, other]
 *                 example: ["saliva", "saliva"]
 *               notes:
 *                 type: string
 *                 description: Additional notes about the samples
 *                 example: "Morning samples"
 *               person_info_list:
 *                 type: array
 *                 description: List of person information corresponding to each sample type (must match the length of sample_types)
 *                 items:
 *                   $ref: '#/components/schemas/PersonInfoDto'
 *                 example: [
 *                   {
 *                     "name": "Nguyá»…n VÄƒn A",
 *                     "dob": "1978-04-19T00:00:00Z",
 *                     "relationship": "Cha giáº£ Ä‘á»‹nh",
 *                     "birth_place": "Thanh An",
 *                     "nationality": "HÃ  Lan",
 *                     "identity_document": "NX2JHP9F9"
 *                   },
 *                   {
 *                     "name": "Nguyá»…n VÄƒn B",
 *                     "dob": "2010-03-15T00:00:00Z",
 *                     "relationship": "Con giáº£ Ä‘á»‹nh",
 *                     "birth_place": "HÃ  Ná»™i",
 *                     "nationality": "Viá»‡t Nam",
 *                     "identity_document": "CH7382HF2"
 *                   }
 *                 ]
 *     responses:
 *       201:
 *         description: Samples added successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Bad request - Invalid input data, not enough available kits, or mismatched sample_types and person_info_list lengths
 *       401:
 *         description: Unauthorized - User not authenticated
 *       403:
 *         description: Forbidden - User not authorized to add samples to this appointment
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/batch-submit:
 *   post:
 *     tags:
 *       - samples
 *     summary: Submit multiple samples at once (Customer only)
 *     description: Customer submits multiple samples in a single request
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/BatchSubmitSamplesDto'
 *     responses:
 *       200:
 *         description: Samples submitted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Bad request - Invalid input data or sample status
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Customer access required or not your samples
 *       404:
 *         description: One or more samples not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/batch-receive:
 *   post:
 *     tags:
 *       - samples
 *     summary: Receive multiple samples at once (Staff only)
 *     description: Staff confirms receipt of multiple samples in a single request
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/BatchReceiveSamplesDto'
 *     responses:
 *       200:
 *         description: Samples received successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/SampleResponse'
 *       400:
 *         description: Bad request - Invalid input data or sample status
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Staff access required
 *       404:
 *         description: One or more samples not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/upload-person-image:
 *   post:
 *     tags:
 *       - samples
 *     summary: Upload a person's image (Customer only)
 *     description: Upload an image for a person associated with a sample
 *     security:
 *       - Bearer: []
 *     consumes:
 *       - multipart/form-data
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - sample_id
 *               - image
 *             properties:
 *               sample_id:
 *                 type: string
 *                 description: ID of the sample
 *                 example: "60c72b2f9b1e8b3b4c8d6e27"
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: Image file to upload (jpg, jpeg, png, gif)
 *     responses:
 *       200:
 *         description: Image uploaded successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     sample:
 *                       $ref: '#/components/schemas/SampleResponse'
 *                     image_url:
 *                       type: string
 *                       description: URL of the uploaded image
 *                       example: "https://dna-test-samples.s3.ap-southeast-1.amazonaws.com/sample/60c72b2f9b1e8b3b4c8d6e27/1234567890.jpg"
 *       400:
 *         description: Bad request - Invalid input data or no file uploaded
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - User not authorized to update this sample
 *       404:
 *         description: Sample not found
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/testing/ready:
 *   get:
 *     summary: Get samples ready for testing (Lab only)
 *     description: Retrieve samples with RECEIVED status that are ready for laboratory testing. Only accessible by laboratory technicians.
 *     tags:
 *       - samples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of samples ready for testing
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Sample'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         totalItems:
 *                           type: integer
 *                           example: 25
 *                         pageNum:
 *                           type: integer
 *                           example: 1
 *                         pageSize:
 *                           type: integer
 *                           example: 10
 *                         totalPages:
 *                           type: integer
 *                           example: 3
 *       403:
 *         description: Forbidden - Only laboratory technicians can access this endpoint
 *       500:
 *         description: Internal server error
 * 
 * /api/sample/testing/all:
 *   get:
 *     summary: Get all samples with TESTING status (Lab only)
 *     description: Retrieve all samples with TESTING status that are ready for laboratory testing, with pagination. Only accessible by laboratory technicians.
 *     tags:
 *       - samples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of all samples with TESTING status
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Sample'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         totalItems:
 *                           type: integer
 *                           example: 25
 *                         pageNum:
 *                           type: integer
 *                           example: 1
 *                         pageSize:
 *                           type: integer
 *                           example: 10
 *                         totalPages:
 *                           type: integer
 *                           example: 3
 *       403:
 *         description: Forbidden - Only laboratory technicians can access this endpoint
 *       500:
 *         description: Internal server error
 * 
 * /api/sample/search:
 *   get:
 *     summary: Search samples by various criteria (Lab, Staff only)
 *     description: Search for samples using different filters. Accessible by laboratory technicians and staff.
 *     tags:
 *       - samples
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [pending, received, testing, completed, invalid]
 *         description: Filter by sample status
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [saliva, blood, hair, other]
 *         description: Filter by sample type
 *       - in: query
 *         name: appointmentId
 *         schema:
 *           type: string
 *         description: Filter by appointment ID
 *       - in: query
 *         name: kitCode
 *         schema:
 *           type: string
 *         description: Filter by kit code
 *       - in: query
 *         name: personName
 *         schema:
 *           type: string
 *         description: Filter by person name
 *       - in: query
 *         name: startDate
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date
 *       - in: query
 *         name: endDate
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of samples matching the search criteria
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     pageData:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Sample'
 *                     pageInfo:
 *                       type: object
 *                       properties:
 *                         totalItems:
 *                           type: integer
 *                           example: 25
 *                         pageNum:
 *                           type: integer
 *                           example: 1
 *                         pageSize:
 *                           type: integer
 *                           example: 10
 *                         totalPages:
 *                           type: integer
 *                           example: 3
 *       403:
 *         description: Forbidden - Only laboratory technicians and staff can access this endpoint
 *       500:
 *         description: Internal server error
 */

/**
 * @swagger
 * /api/sample/collect:
 *   post:
 *     tags: [samples]
 *     summary: Collect sample at facility (Staff only)
 *     description: Staff collects a sample at the medical facility and records the information
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - appointment_id
 *               - type
 *               - person_info
 *             properties:
 *               appointment_id:
 *                 type: string
 *                 description: ID of the appointment
 *                 example: "60d21b4667d0d8992e610c85"
 *               type:
 *                 type: array
 *                 description: Types of samples collected
 *                 items:
 *                   type: string
 *                   enum: [blood, saliva, hair, other]
 *                 example: ["blood", "saliva"]
 *               person_info:
 *                 type: array
 *                 description: Information about the persons from whom samples were collected
 *                 items:
 *                   type: object
 *                   properties:
 *                     name:
 *                       type: string
 *                       description: Full name of the person
 *                       example: "ThÃ­ch TÃ¢m PhÃºc"
 *                     dob:
 *                       type: string
 *                       format: date
 *                       description: Date of birth
 *                       example: "1983-03-08"
 *                     relationship:
 *                       type: string
 *                       description: Relationship to the primary patient
 *                       example: "Self"
 *                     gender:
 *                       type: string
 *                       description: Gender of the person
 *                       example: "Male"
 *                     phone_number:
 *                       type: string
 *                       description: Phone number of the person
 *                       example: "0909090909"
 *                     birth_place:
 *                       type: string
 *                       description: Birth place of the person
 *                       example: "Vietnam"
 *                     nationality:
 *                       type: string
 *                       description: Nationality of the person
 *                       example: "Vietnamese"
 *                     identity_document:
 *                       type: string
 *                       description: ID document number
 *                       example: "1234567890"
 *                 example:
 *                   - name: "ThÃ­ch TÃ¢m PhÃºc"
 *                     dob: "1983-03-08"
 *                     relationship: "Self"
 *                     gender: "Male"
 *                     phone_number: "0909090909"
 *                     birth_place: "Vietnam"
 *                     nationality: "Vietnamese"
 *                     identity_document: "1234567890"
 *                   - name: "Nguyá»…n Äan Huy"
 *                     dob: "2003-10-15"
 *                     relationship: "Self"
 *                     gender: "Male"
 *                     phone_number: "0909090909"
 *                     birth_place: "Vietnam"
 *                     nationality: "Vietnamese"
 *                     identity_document: "1234567890"
 *     responses:
 *       201:
 *         description: Sample collected successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Sample collected successfully
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         example: "60d21b4667d0d8992e610c86"
 *                       appointment_id:
 *                         type: string
 *                         example: "60d21b4667d0d8992e610c85"
 *                       type:
 *                         type: string
 *                         example: "BLOOD"
 *                       collection_method:
 *                         type: string
 *                         example: "FACILITY"
 *                       collection_date:
 *                         type: string
 *                         format: date-time
 *                         example: "2023-06-15T10:30:00Z"
 *                       status:
 *                         type: string
 *                         example: "PENDING"
 *                       person_info:
 *                         type: object
 *                         properties:
 *                           name:
 *                             type: string
 *                             example: "John Doe"
 *                           dob:
 *                             type: string
 *                             format: date
 *                             example: "1990-01-15"
 *                           relationship:
 *                             type: string
 *                             example: "Self"
 *       400:
 *         description: Bad request
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: Appointment must be confirmed before collecting sample
 *       401:
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: Staff not authenticated
 *       404:
 *         description: Appointment not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: Appointment not found
 */ 


================================================
FILE: src/modules/sample/swagger/sample.tag.js
================================================
/**
 * @swagger
 * tags:
 *   name: samples
 *   description: Sample management APIs
 */ 


================================================
FILE: src/modules/service/index.ts
================================================
import ServiceSchema from './service.model';
import { IService, ServiceType, SampleMethod } from './service.interface';
import { ServiceTypeEnum, SampleMethodEnum } from './service.enum';
import { ServiceTypes, SampleMethods } from './service.constant';
import ServiceRoute from './service.route';

export { ServiceSchema, IService, ServiceType, SampleMethod, ServiceTypeEnum, SampleMethodEnum, ServiceTypes, SampleMethods, ServiceRoute }; 


================================================
FILE: src/modules/service/service.constant.ts
================================================
import { SampleMethodEnum, ServiceTypeEnum } from './service.enum';

export const ServiceTypes = ['', ServiceTypeEnum.CIVIL, ServiceTypeEnum.ADMINISTRATIVE];
export const SampleMethods = ['', SampleMethodEnum.SELF_COLLECTED, SampleMethodEnum.FACILITY_COLLECTED, SampleMethodEnum.HOME_COLLECTED]; 


================================================
FILE: src/modules/service/service.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import ServiceService from './service.service';
import CreateServiceDto from './dtos/createService.dto';
import { IService } from './service.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';

export default class ServiceController {
    private serviceService = new ServiceService();

    public createService = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: CreateServiceDto = req.body;
            const file = req.file;
            const service = await this.serviceService.createService(model, file);
            res.status(HttpStatus.Created).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    public getServices = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getServices(req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IService>>(services));
        } catch (error) {
            next(error);
        }
    }

    public getServiceById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const service = await this.serviceService.getServiceById(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    public getServiceBySlug = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const service = await this.serviceService.getServiceBySlug(req.params.slug);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    public getChildServices = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getChildServices(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<IService[]>(services));
        } catch (error) {
            next(error);
        }
    }

    public updateService = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const file = req.file;
            const service = await this.serviceService.updateService(req.params.id, req.body, file);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service as IService));
        } catch (error) {
            next(error);
        }
    }

    public deleteService = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.serviceService.deleteService(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<string>('Delete service successfully'));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Láº¥y danh sÃ¡ch dá»‹ch vá»¥ dá»±a trÃªn thÃ´ng tin cuá»™c háº¹n
     */
    public getServicesByAppointment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getServicesByAppointment(req.query);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IService>>(services));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Äáº¿m sá»‘ lÆ°á»£ng dá»‹ch vá»¥ theo loáº¡i
     */
    public countServicesByType = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const statistics = await this.serviceService.countServicesByType(req.query);
            res.status(HttpStatus.Success).json(formatResponse(statistics));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Thay Ä‘á»•i tráº¡ng thÃ¡i hoáº¡t Ä‘á»™ng cá»§a dá»‹ch vá»¥
     */
    public changeServiceStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const { is_active } = req.body;

            if (is_active === undefined) {
                res.status(HttpStatus.BadRequest).json(
                    formatResponse<string>('is_active field is required')
                );
                return;
            }

            const service = await this.serviceService.changeServiceStatus(id, is_active);
            res.status(HttpStatus.Success).json(formatResponse<IService>(service));
        } catch (error) {
            next(error);
        }
    }

    /**
     * Get all services with images
     */
    public getServicesWithImages = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const services = await this.serviceService.getServicesWithImages();
            res.status(HttpStatus.Success).json(formatResponse<IService[]>(services));
        } catch (error) {
            next(error);
        }
    }
}



================================================
FILE: src/modules/service/service.enum.ts
================================================
export enum ServiceTypeEnum {
    CIVIL = 'civil',
    ADMINISTRATIVE = 'administrative',
}

export enum SampleMethodEnum {
    SELF_COLLECTED = 'self_collected',
    FACILITY_COLLECTED = 'facility_collected',
    HOME_COLLECTED = 'home_collected',
} 


================================================
FILE: src/modules/service/service.interface.ts
================================================
import { Document } from 'mongoose';
import { SampleMethodEnum, ServiceTypeEnum } from './service.enum';

export type ServiceType = ServiceTypeEnum.CIVIL | ServiceTypeEnum.ADMINISTRATIVE;
export type SampleMethod = SampleMethodEnum.SELF_COLLECTED | SampleMethodEnum.FACILITY_COLLECTED | SampleMethodEnum.HOME_COLLECTED;

export interface IService extends Document {
    _id: string;
    name: string;
    slug: string;
    description: string;
    parent_service_id?: string | null;
    type: ServiceType;
    // sample_method: SampleMethod;
    estimated_time: number; // in hours
    price: number;
    image_url?: string;
    is_active: boolean;
    is_deleted: boolean;
    created_at?: Date;
    updated_at?: Date;
    average_rating?: number;
    review_count?: number;
} 


================================================
FILE: src/modules/service/service.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { SampleMethods, ServiceTypes } from './service.constant';
import { IService } from './service.interface';

const ServiceSchemaEntity: Schema<IService> = new Schema({
    name: { type: String, required: true },
    slug: { type: String, required: true, unique: true },
    description: { type: String, required: true },
    parent_service_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SERVICE },
    type: {
        type: String,
        enum: ServiceTypes,
        required: true
    },
    // sample_method: {
    //     type: String,
    //     enum: SampleMethods,
    //     required: true
    // },
    estimated_time: { type: Number, required: true }, // in hours
    price: { type: Number, required: true },
    image_url: { type: String },
    is_active: { type: Boolean, default: true },
    is_deleted: { type: Boolean, default: false },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
});

const ServiceSchema = mongoose.model<IService & mongoose.Document>(COLLECTION_NAME.SERVICE, ServiceSchemaEntity);
export default ServiceSchema; 


================================================
FILE: src/modules/service/service.repository.ts
================================================
import ServiceSchema from './service.model';
import { IService, SampleMethod, ServiceType } from './service.interface';

export default class ServiceRepository {
    public async createService(data: Partial<IService>): Promise<IService> {
        return ServiceSchema.create(data);
    }

    public async findOne(query: any): Promise<IService | null> {
        return ServiceSchema.findOne(query);
    }

    public async findById(id: string): Promise<IService | null> {
        return ServiceSchema.findById(id).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    // Find service by slug
    public async findBySlug(slug: string): Promise<IService | null> {
        return ServiceSchema.findOne({
            slug,
            is_deleted: false
        }).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    // find by id and populate parent service
    public async findByIdAndPopulateParentService(id: string): Promise<IService | null> {
        return ServiceSchema.findById(id).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    public async findByIdAndUpdate(id: string, update: Partial<IService>, options: any = {}): Promise<IService | null> {
        return ServiceSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return ServiceSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IService[]> {
        return ServiceSchema.find(query).sort(sort).skip(skip).limit(limit).populate({
            path: 'parent_service_id',
            select: 'name slug'
        });
    }

    public async findAll(query: any): Promise<IService[]> {
        return ServiceSchema.find(query);
    }

    // find child services
    public async findChildServices(query: any): Promise<IService[]> {
        return ServiceSchema.find({
            ...query,
            is_deleted: false,
            is_active: true
        }).populate({
            path: 'parent_service_id',
            select: 'name slug'
        }).select('name description price estimated_time type image_url slug');
    }
}



================================================
FILE: src/modules/service/service.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware, uploadSingleFile } from '../../core/middleware';
import ServiceController from './service.controller';
import CreateServiceDto from './dtos/createService.dto';
import UpdateServiceDto from './dtos/updateService.dto';
import { SampleMethods, ServiceTypes } from './service.constant'
import { UserRoleEnum } from '../user/user.enum';

export default class ServiceRoute implements IRoute {
    public path = API_PATH.SERVICE;
    public router = Router();
    private serviceController = new ServiceController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/service/create -> Create service
        this.router.post(
            API_PATH.CREATE_SERVICE,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            uploadSingleFile('service_image'),
            validationMiddleware(CreateServiceDto),
            this.serviceController.createService);

        // GET: domain:/api/service/search -> Get all services
        this.router.get(
            API_PATH.SEARCH_SERVICE,
            authMiddleWare([], true),
            this.serviceController.getServices);

        // GET: domain:/api/service/statistics -> Äáº¿m sá»‘ lÆ°á»£ng dá»‹ch vá»¥ theo loáº¡i
        this.router.get(
            `${this.path}/statistics`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.serviceController.countServicesByType
        );

        // GET: domain:/api/service/appointments -> Láº¥y cÃ¡c dá»‹ch vá»¥ dá»±a trÃªn thÃ´ng tin cuá»™c háº¹n
        this.router.get(
            `${this.path}/appointments`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF]),
            this.serviceController.getServicesByAppointment
        );

        // GET: domain:/api/service/:id -> Get service by id
        this.router.get(
            API_PATH.GET_SERVICE_BY_ID,
            authMiddleWare([], true),
            this.serviceController.getServiceById);

        // GET: domain:/api/service/slug/:slug -> Get service by slug
        this.router.get(
            `${this.path}/slug/:slug`,
            authMiddleWare([], true),
            this.serviceController.getServiceBySlug);

        // GET: domain:/api/service/:id/child -> Get child services by id
        this.router.get(
            `${this.path}/:id/child`,
            authMiddleWare([], true),
            this.serviceController.getChildServices);

        // PUT: domain:/api/service/:id -> Update service by id
        this.router.put(
            API_PATH.UPDATE_SERVICE,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            uploadSingleFile('service_image'),
            validationMiddleware(UpdateServiceDto),
            this.serviceController.updateService);

        // PATCH: domain:/api/service/:id/status -> Thay Ä‘á»•i tráº¡ng thÃ¡i hoáº¡t Ä‘á»™ng cá»§a dá»‹ch vá»¥
        this.router.patch(
            `${this.path}/:id/status`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.serviceController.changeServiceStatus);

        // DELETE: domain:/api/service/:id -> Delete service by id
        this.router.delete(
            API_PATH.DELETE_SERVICE,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.serviceController.deleteService);

        // GET: domain:/api/service/services-with-images -> Get all services with images
        this.router.get(
            `${this.path}/services-with-images`,
            authMiddleWare([], true),
            this.serviceController.getServicesWithImages
        );
    }
}



================================================
FILE: src/modules/service/service.service.ts
================================================
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { IService, SampleMethod, ServiceType } from "./service.interface";
import CreateServiceDto from "./dtos/createService.dto";
import UpdateServiceDto from "./dtos/updateService.dto";
import { isEmptyObject } from "../../core/utils";
import { SampleMethodEnum, ServiceTypeEnum } from "./service.enum";
import AppointmentSchema from '../appointment/appointment.model';
import ServiceRepository from './service.repository';
import { uploadFileToS3 } from "../../core/utils/s3Upload";
import { s3Folders } from "../../core/utils/aws.config";
import ReviewSchema from '../review/review.model';
import { UserRoleEnum } from '../user/user.enum';

export default class ServiceService {
    private appointmentSchema = AppointmentSchema;
    private serviceRepository = new ServiceRepository();

    /**
     * Generate a slug from a string
     * @param name The string to generate a slug from
     * @returns A URL-friendly slug
     */
    /**
     * Generate a slug from a string
     * @param name The string to generate a slug from
     * @returns A URL-friendly slug
     */
    private generateSlug(name: string): string {
        if (!name) return '';

        // First normalize Vietnamese characters
        let slug = name
            .toLowerCase()
            .trim()
            .replace(/[Ã Ã¡áº¡áº£Ã£Ã¢áº§áº¥áº­áº©áº«Äƒáº±áº¯áº·áº³áºµ]/g, 'a')
            .replace(/[Ã¨Ã©áº¹áº»áº½Ãªá»áº¿á»‡á»ƒá»…]/g, 'e')
            .replace(/[Ã¬Ã­á»‹á»‰Ä©]/g, 'i')
            .replace(/[Ã²Ã³á»á»ÃµÃ´á»“á»‘á»™á»•á»—Æ¡á»á»›á»£á»Ÿá»¡]/g, 'o')
            .replace(/[Ã¹Ãºá»¥á»§Å©Æ°á»«á»©á»±á»­á»¯]/g, 'u')
            .replace(/[á»³Ã½á»µá»·á»¹]/g, 'y')
            .replace(/Ä‘/g, 'd');

        // Then handle spaces and special characters
        slug = slug
            .replace(/[^\w\s-]/g, '') // XÃ³a cÃ¡c kÃ½ tá»± khÃ´ng pháº£i lÃ  tá»« ngoáº¡i trá»« khoáº£ng tráº¯ng vÃ  dáº¥u gáº¡ch ná»‘i
            .replace(/[\s_]+/g, '-') // Thay tháº¿ khoáº£ng tráº¯ng vÃ  dáº¥u gáº¡ch dÆ°á»›i báº±ng dáº¥u gáº¡ch ná»‘i
            .replace(/-+/g, '-') // XÃ³a cÃ¡c dáº¥u gáº¡ch ná»‘i liÃªn tiáº¿p
            .replace(/^-+|-+$/g, ''); // XÃ³a cÃ¡c dáº¥u gáº¡ch ná»‘i á»Ÿ Ä‘áº§u vÃ  cuá»‘i chuá»—i

        return slug;
    }

    /**
     * Ensure a slug is unique by adding a suffix if necessary
     * @param baseSlug The base slug to check
     * @returns A unique slug
     */
    private async ensureUniqueSlug(baseSlug: string): Promise<string> {
        if (!baseSlug) return '';

        let slug = baseSlug;
        let counter = 1;
        let existingService = await this.serviceRepository.findOne({ slug, is_deleted: false });

        // Keep checking and incrementing counter until we find a unique slug
        while (existingService) {
            slug = `${baseSlug}-${counter}`;
            counter++;
            existingService = await this.serviceRepository.findOne({ slug, is_deleted: false });
        }

        return slug;
    }

    public async createService(model: CreateServiceDto, file?: Express.Multer.File): Promise<IService> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        // Convert string values to appropriate types (needed for multipart/form-data)
        if (typeof model.price === 'string') {
            model.price = parseFloat(model.price);
        }

        if (typeof model.estimated_time === 'string') {
            model.estimated_time = parseFloat(model.estimated_time);
        }

        // Handle empty string for parent_service_id
        if (model.parent_service_id === '') {
            model.parent_service_id = null as any;
        }

        // XÃ¡c thá»±c tÃªn dá»‹ch vá»¥
        if (!model.name || model.name.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service name is required');
        }

        // XÃ¡c thá»±c mÃ´ táº£
        if (!model.description || model.description.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service description is required');
        }

        // XÃ¡c thá»±c giÃ¡
        if (isNaN(model.price) || model.price <= 0) {
            throw new HttpException(HttpStatus.BadRequest, 'Service price must be a valid number greater than 0');
        }

        // XÃ¡c thá»±c thá»i gian Æ°á»›c tÃ­nh
        if (isNaN(model.estimated_time) || model.estimated_time <= 0) {
            throw new HttpException(HttpStatus.BadRequest, 'Estimated time must be a valid number greater than 0');
        }

        // XÃ¡c thá»±c loáº¡i dá»‹ch vá»¥
        if (!Object.values(ServiceTypeEnum).includes(model.type as ServiceTypeEnum)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid service type');
        }

        // XÃ¡c thá»±c parent_service_id
        if (model.parent_service_id && model.parent_service_id.trim() !== '') {
            const parentService = await this.serviceRepository.findByIdAndPopulateParentService(model.parent_service_id);
            if (!parentService) {
                throw new HttpException(HttpStatus.BadRequest, 'Parent service not found');
            }
        }

        // // XÃ¡c thá»±c phÆ°Æ¡ng thá»©c láº¥y máº«u
        // if (!Object.values(SampleMethodEnum).includes(model.sample_method as SampleMethodEnum)) {
        //     throw new HttpException(HttpStatus.BadRequest, 'Invalid sample method');
        // }

        // kiá»ƒm tra tÃªn dá»‹ch vá»¥ cÃ³ bá»‹ trÃ¹ng khÃ´ng
        const existingService = await this.serviceRepository.findOne({ name: model.name, is_deleted: false });
        if (existingService) {
            throw new HttpException(HttpStatus.Conflict, 'Service with this name already exists');
        }

        // Generate slug if not provided
        if (!model.slug) {
            model.slug = await this.ensureUniqueSlug(this.generateSlug(model.name));
        } else {
            // If slug is provided, ensure it's URL-friendly
            model.slug = this.generateSlug(model.slug);
            // Check if the slug is unique
            model.slug = await this.ensureUniqueSlug(model.slug);
        }

        let newService = {
            ...model,
            is_active: true,
            created_at: new Date(),
            updated_at: new Date(),
        };

        // If there's a file, upload the image (for any service type)
        if (file) {
            try {
                // Create the service first to get the ID
                const createdService = await this.serviceRepository.createService(newService);

                // Upload image to S3
                const imageUrl = await uploadFileToS3(file, createdService._id, s3Folders.personImages);

                // Update service with image URL
                const updatedService = await this.serviceRepository.findByIdAndUpdate(
                    createdService._id,
                    { image_url: imageUrl },
                    { new: true }
                );

                return updatedService || createdService;
            } catch (error) {
                console.error('Error uploading image during service creation:', error);
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload image');
            }
        }

        return this.serviceRepository.createService(newService);
    }

    /**
     * Láº¥y danh sÃ¡ch dá»‹ch vá»¥ vá»›i cÃ¡c bá»™ lá»c tÃ¹y chá»n vÃ  phÃ¢n trang
     */
    public async getServices(queryParams: any = {}, user?: any): Promise<SearchPaginationResponseModel<IService & { average_rating?: number, review_count?: number }>> {
        try {
            const query: any = { is_deleted: false };

            // Xá»­ lÃ½ vÃ  lÃ m sáº¡ch cÃ¡c tham sá»‘ truy váº¥n
            const cleanParams = this.processQueryParams(queryParams);

            // Xá»­ lÃ½ cÃ¡c tham sá»‘ phÃ¢n trang
            const page = cleanParams.pageNum ? parseInt(cleanParams.pageNum) : 1; // trang hiá»‡n táº¡i
            const limit = cleanParams.pageSize ? parseInt(cleanParams.pageSize) : 10; // sá»‘ lÆ°á»£ng báº£n ghi trÃªn má»—i trang
            const skip = (page - 1) * limit; // sá»‘ báº£n ghi bá»‹ bá» qua

            // Xá»­ lÃ½ sáº¯p xáº¿p
            const sortField = cleanParams.sort_by || 'created_at'; // trÆ°á»ng sáº¯p xáº¿p máº·c Ä‘á»‹nh lÃ  created_at
            const sortOrder = cleanParams.sort_order === 'asc' ? 1 : -1; // thá»© tá»± sáº¯p xáº¿p máº·c Ä‘á»‹nh lÃ  tÄƒng dáº§n
            const sortOptions: any = {}; // khá»Ÿi táº¡o má»™t Ä‘á»‘i tÆ°á»£ng Ä‘á»ƒ lÆ°u trá»¯ cÃ¡c tÃ¹y chá»n sáº¯p xáº¿p
            sortOptions[sortField] = sortOrder; // thÃªm tÃ¹y chá»n sáº¯p xáº¿p vÃ o Ä‘á»‘i tÆ°á»£ng

            // Xá»­ lÃ½ cÃ¡c tham sá»‘ lá»c
            if (cleanParams.type) {
                query.type = new RegExp(`^${cleanParams.type}$`, 'i'); // tÃ¬m kiáº¿m theo loáº¡i dá»‹ch vá»¥ vá»›i tÃ¹y chá»n khÃ´ng phÃ¢n biá»‡t chá»¯ hoa vÃ  chá»¯ thÆ°á»ng
            }

            // if (cleanParams.sample_method) {
            //     query.sample_method = new RegExp(`^${cleanParams.sample_method}$`, 'i'); // tÃ¬m kiáº¿m theo phÆ°Æ¡ng thá»©c láº¥y máº«u vá»›i tÃ¹y chá»n khÃ´ng phÃ¢n biá»‡t chá»¯ hoa vÃ  chá»¯ thÆ°á»ng
            // }

            if (cleanParams.is_active !== undefined) {
                query.is_active = cleanParams.is_active;
            }

            if (cleanParams.min_price !== undefined || cleanParams.max_price !== undefined) {
                query.price = {};
                if (cleanParams.min_price !== undefined) {
                    query.price.$gte = cleanParams.min_price; // giÃ¡ >= min_price
                }
                if (cleanParams.max_price !== undefined) {
                    query.price.$lte = cleanParams.max_price; // giÃ¡ <= max_price
                }
            }

            // Lá»c dá»¯ liá»‡u theo thá»i gian táº¡o
            if (cleanParams.start_date || cleanParams.end_date) {
                query.created_at = {};
                if (cleanParams.start_date) {
                    query.created_at.$gte = new Date(cleanParams.start_date); // ngÃ y táº¡o >= start_date
                }
                if (cleanParams.end_date) {
                    const endDate = new Date(cleanParams.end_date);
                    endDate.setHours(23, 59, 59, 999); // set thá»i gian cuá»‘i ngÃ y lÃ  23:59:59.999
                    query.created_at.$lte = endDate; // ngÃ y táº¡o <= end_date
                }
            }

            // TÃ¬m kiáº¿m theo tá»« khÃ³a (náº¿u cÃ³)
            if (cleanParams.keyword) {
                const keyword = cleanParams.keyword.toLowerCase();
                query.$or = [
                    { name: { $regex: keyword, $options: 'i' } }, // tÃ¬m kiáº¿m theo tÃªn dá»‹ch vá»¥ vá»›i tÃ¹y chá»n khÃ´ng phÃ¢n biá»‡t chá»¯ hoa vÃ  chá»¯ thÆ°á»ng
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            // Äáº¿m tá»•ng sá»‘ báº£n ghi phÃ¹ há»£p vá»›i Ä‘iá»u kiá»‡n tÃ¬m kiáº¿m
            const totalItems = await this.serviceRepository.countDocuments(query);

            // Láº¥y dá»¯ liá»‡u vá»›i phÃ¢n trang vÃ  sáº¯p xáº¿p
            const items = await this.serviceRepository.find(query, sortOptions, skip, limit);

            // For each service, get average_rating and review_count
            const itemsWithStats = await Promise.all(items.map(async (service) => {
                const { average_rating, review_count } = await this.getServiceReviewStats(service._id);
                return { ...service.toObject(), average_rating, review_count };
            }));

            // TÃ­nh toÃ¡n thÃ´ng tin phÃ¢n trang
            const totalPages = Math.ceil(totalItems / limit);
            // Tráº£ vá» káº¿t quáº£ theo Ä‘á»‹nh dáº¡ng SearchPaginationResponseModel
            return {
                pageData: itemsWithStats,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: page,
                    pageSize: limit,
                }
            };
        } catch (error) {
            console.error('Error in getServices:', error);
            throw error;
        }
    }

    /**
     * Táº¡o query tá»« cÃ¡c tham sá»‘ truyá»n vÃ o
     */
    private processQueryParams(params: any): {
        type?: string;
        // sample_method?: string;
        is_active?: boolean;
        min_price?: number;
        max_price?: number;
        pageNum?: string;
        pageSize?: string;
        keyword?: string;
        sort_by?: string;
        sort_order?: string;
        start_date?: string;
        end_date?: string;
    } {
        const processedParams: Record<string, any> = {}; // khá»Ÿi táº¡o má»™t Ä‘á»‘i tÆ°á»£ng Ä‘á»ƒ lÆ°u trá»¯ cÃ¡c tham sá»‘ Ä‘Ã£ xá»­ lÃ½

        // Duyá»‡t qua tá»«ng key cá»§a params
        Object.keys(params).forEach(key => {
            const trimmedKey = key.trim(); // loáº¡i bá» khoáº£ng tráº¯ng á»Ÿ Ä‘áº§u vÃ  cuá»‘i cá»§a key
            const normalizedKey = trimmedKey.replace(/-/g, '_'); // thay tháº¿ dáº¥u gáº¡ch ngang báº±ng dáº¥u gáº¡ch dÆ°á»›i
            processedParams[normalizedKey] = params[key]; // lÆ°u trá»¯ giÃ¡ trá»‹ cá»§a key vÃ o processedParams
        });

        // XÃ¡c thá»±c cÃ¡c trÆ°á»ng sáº¯p xáº¿p há»£p lá»‡ Ä‘á»ƒ trÃ¡nh lá»—i injection
        const allowedSortFields = ['name', 'price', 'created_at', 'estimated_time'];
        const sortBy = processedParams.sort_by?.toLowerCase();

        return {
            type: processedParams.type?.toLowerCase(),
            // sample_method: processedParams.sample_method?.toLowerCase(),
            is_active: processedParams.is_active === 'true',
            min_price: processedParams.min_price ? parseFloat(processedParams.min_price) : undefined,
            max_price: processedParams.max_price ? parseFloat(processedParams.max_price) : undefined,
            pageNum: processedParams.pageNum || '1',
            pageSize: processedParams.pageSize || '10',
            keyword: processedParams.keyword,
            sort_by: allowedSortFields.includes(sortBy) ? sortBy : 'created_at',
            sort_order: processedParams.sort_order === 'asc' ? 'asc' : 'desc',
            start_date: processedParams.start_date,
            end_date: processedParams.end_date
        };
    }

    /**
     * Cáº­p nháº­t dá»‹ch vá»¥
     */
    public async updateService(id: string, model: Partial<UpdateServiceDto>, file?: Express.Multer.File): Promise<IService | undefined> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const existingService = await this.serviceRepository.findById(id);
        if (!existingService) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        // Convert string values to appropriate types (needed for multipart/form-data)
        if (typeof model.price === 'string') {
            model.price = parseFloat(model.price);
        }

        if (typeof model.estimated_time === 'string') {
            model.estimated_time = parseFloat(model.estimated_time);
        }

        // Handle empty string for parent_service_id
        if (model.parent_service_id === '') {
            model.parent_service_id = null as any;
        }

        // Validate name if provided
        if (model.name && model.name.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service name cannot be empty');
        }

        // Validate description if provided
        if (model.description && model.description.trim() === '') {
            throw new HttpException(HttpStatus.BadRequest, 'Service description cannot be empty');
        }

        // Validate price if provided
        if (model.price !== undefined && (isNaN(model.price) || model.price <= 0)) {
            throw new HttpException(HttpStatus.BadRequest, 'Service price must be a valid number greater than 0');
        }

        // Validate estimated time if provided
        if (model.estimated_time !== undefined && (isNaN(model.estimated_time) || model.estimated_time <= 0)) {
            throw new HttpException(HttpStatus.BadRequest, 'Estimated time must be a valid number greater than 0');
        }

        // Validate service type if provided
        if (model.type && !Object.values(ServiceTypeEnum).includes(model.type as ServiceTypeEnum)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid service type');
        }

        // Validate parent service ID if provided
        if (model.parent_service_id && model.parent_service_id.trim() !== '') {
            const parentService = await this.serviceRepository.findById(model.parent_service_id);
            if (!parentService) {
                throw new HttpException(HttpStatus.BadRequest, 'Parent service not found');
            }
        }

        // // Validate sample method if provided
        // if (model.sample_method && !Object.values(SampleMethodEnum).includes(model.sample_method as SampleMethodEnum)) {
        //     throw new HttpException(HttpStatus.BadRequest, 'Invalid sample method');
        // }

        // Check for name uniqueness if name is being updated
        if (model.name && model.name !== existingService.name) {
            const serviceWithSameName = await this.serviceRepository.findOne({
                name: model.name,
                is_deleted: false,
                _id: { $ne: id } // Exclude the current service
            });
            if (serviceWithSameName) {
                throw new HttpException(HttpStatus.Conflict, 'Service with this name already exists');
            }
        }

        // Update slug if name is changed or slug is provided
        if ((model.name && model.name !== existingService.name) || model.slug) {
            const baseSlug = model.slug ? this.generateSlug(model.slug) : this.generateSlug(model.name || existingService.name);

            // Only check for uniqueness if the slug is different from the current one
            if (baseSlug !== existingService.slug) {
                model.slug = await this.ensureUniqueSlug(baseSlug);
            } else {
                model.slug = baseSlug;
            }
        }

        // Handle file upload if provided
        if (file) {
            try {
                const imageUrl = await uploadFileToS3(file, id, s3Folders.personImages);
                model.image_url = imageUrl;
            } catch (error) {
                console.error('Error uploading image during service update:', error);
                throw new HttpException(HttpStatus.InternalServerError, 'Failed to upload image');
            }
        }

        const updateData = {
            ...model,
            updated_at: new Date()
        };

        const updatedService = await this.serviceRepository.findByIdAndUpdate(
            id,
            updateData,
            { new: true }
        );

        if (!updatedService) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        return updatedService;
    }

    /**
     * XÃ³a dá»‹ch vá»¥ (soft delete - chá»‰ vÃ´ hiá»‡u hÃ³a)
     */
    public async deleteService(id: string): Promise<IService> {
        const service = await this.serviceRepository.findByIdAndUpdate(
            id,
            { is_deleted: true, is_active: false, updated_at: new Date() },
            { new: true }
        );

        if (!service) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        return service;
    }

    /**
     * TÃ¬m dá»‹ch vá»¥ theo ID
     */
    public async getServiceById(id: string): Promise<IService & { average_rating?: number, review_count?: number }> {
        const service = await this.serviceRepository.findById(id);
        if (!service) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }
        // Calculate average rating and review count
        const { average_rating, review_count } = await this.getServiceReviewStats(service._id);
        return { ...service.toObject(), average_rating, review_count };
    }

    /**
     * TÃ¬m kiáº¿m dá»‹ch vá»¥ theo loáº¡i
     */
    public async getServicesByType(type: ServiceType): Promise<IService[]> {
        return this.serviceRepository.findAll({ type, is_active: true });
    }

    /**
     * Láº¥y dá»‹ch vá»¥ theo phÆ°Æ¡ng thá»©c láº¥y máº«u
     */
    public async getServicesBySampleMethod(sampleMethod: SampleMethod): Promise<IService[]> {
        return this.serviceRepository.findAll({ sample_method: sampleMethod, is_active: true });
    }

    /**
     * Láº¥y danh sÃ¡ch dá»‹ch vá»¥ con cá»§a má»™t dá»‹ch vá»¥ cha
     */
    public async getChildServices(parentServiceId: string): Promise<IService[]> {
        const parentService = await this.serviceRepository.findChildServices({ parent_service_id: parentServiceId });
        if (!parentService) {
            throw new HttpException(HttpStatus.NotFound, 'Parent service not found');
        }
        return parentService;
    }

    /**
     * Láº¥y danh sÃ¡ch dá»‹ch vá»¥ dá»±a trÃªn thÃ´ng tin cuá»™c háº¹n
     */
    public async getServicesByAppointment(queryParams: any = {}): Promise<SearchPaginationResponseModel<IService>> {
        try {
            // Xá»­ lÃ½ vÃ  lÃ m sáº¡ch cÃ¡c tham sá»‘ truy váº¥n
            const cleanParams = this.processAppointmentParams(queryParams);

            // Xá»­ lÃ½ cÃ¡c tham sá»‘ phÃ¢n trang
            const page = cleanParams.pageNum ? parseInt(cleanParams.pageNum) : 1;
            const limit = cleanParams.pageSize ? parseInt(cleanParams.pageSize) : 10;
            const skip = (page - 1) * limit;

            // Táº¡o query Ä‘á»ƒ tÃ¬m kiáº¿m cÃ¡c appointment phÃ¹ há»£p
            const appointmentQuery: any = {};

            // Lá»c theo tráº¡ng thÃ¡i cuá»™c háº¹n
            if (cleanParams.status) {
                appointmentQuery.status = cleanParams.status;
            }

            // Lá»c theo ngÃ y háº¹n
            if (cleanParams.start_appointment_date || cleanParams.end_appointment_date) {
                appointmentQuery.appointment_date = {};
                if (cleanParams.start_appointment_date) {
                    appointmentQuery.appointment_date.$gte = new Date(cleanParams.start_appointment_date);
                }
                if (cleanParams.end_appointment_date) {
                    const endDate = new Date(cleanParams.end_appointment_date);
                    endDate.setHours(23, 59, 59, 999);
                    appointmentQuery.appointment_date.$lte = endDate;
                }
            }

            // Lá»c theo loáº¡i cuá»™c háº¹n (SELF, FACILITY, HOME)
            if (cleanParams.appointment_type) {
                appointmentQuery.type = cleanParams.appointment_type;
            }

            // Lá»c theo khÃ¡ch hÃ ng
            if (cleanParams.customer_id) {
                appointmentQuery.user_id = cleanParams.customer_id;
            }

            // Lá»c theo nhÃ¢n viÃªn
            if (cleanParams.staff_id) {
                appointmentQuery.staff_id = cleanParams.staff_id;
            }

            // Lá»c theo Ä‘á»‹a chá»‰ lÃ m xÃ©t nghiá»‡m (náº¿u lÃ  táº¡i nhÃ )
            if (cleanParams.collection_address) {
                appointmentQuery.collection_address = { $regex: cleanParams.collection_address, $options: 'i' };
            }

            console.log('Appointment query:', appointmentQuery);

            // TÃ¬m cÃ¡c appointment phÃ¹ há»£p vÃ  chá»‰ láº¥y service_id
            const appointments = await this.appointmentSchema.find(appointmentQuery).select('service_id');
            console.log('Found appointments:', appointments.length);

            // Láº¥y danh sÃ¡ch cÃ¡c service_id tá»« cÃ¡c appointment
            const serviceIds = appointments.map(app => app.service_id);

            // Loáº¡i bá» cÃ¡c giÃ¡ trá»‹ trÃ¹ng láº·p vÃ  giÃ¡ trá»‹ null/undefined
            const uniqueServiceIds = [...new Set(serviceIds.filter(id => id))];
            console.log('Unique service IDs:', uniqueServiceIds.length);

            // Náº¿u khÃ´ng cÃ³ service_id nÃ o, tráº£ vá» danh sÃ¡ch trá»‘ng
            if (uniqueServiceIds.length === 0) {
                return {
                    pageData: [],
                    pageInfo: {
                        totalItems: 0,
                        totalPages: 0,
                        pageNum: page,
                        pageSize: limit,
                    }
                };
            }

            // Táº¡o query Ä‘á»ƒ tÃ¬m cÃ¡c service tÆ°Æ¡ng á»©ng
            const serviceQuery: any = {
                _id: { $in: uniqueServiceIds },
                is_deleted: false
            };

            // Xá»­ lÃ½ lá»c bá»• sung cho service
            if (cleanParams.is_active !== undefined) {
                serviceQuery.is_active = cleanParams.is_active;
            }

            if (cleanParams.type) {
                serviceQuery.type = cleanParams.type;
            }

            if (cleanParams.sample_method) {
                serviceQuery.sample_method = cleanParams.sample_method;
            }

            if (cleanParams.min_price !== undefined || cleanParams.max_price !== undefined) {
                serviceQuery.price = {};
                if (cleanParams.min_price !== undefined) {
                    serviceQuery.price.$gte = cleanParams.min_price;
                }
                if (cleanParams.max_price !== undefined) {
                    serviceQuery.price.$lte = cleanParams.max_price;
                }
            }

            // TÃ¬m kiáº¿m theo tá»« khÃ³a trÃªn service (náº¿u cÃ³)
            if (cleanParams.keyword) {
                const keyword = cleanParams.keyword.toLowerCase();
                serviceQuery.$or = [
                    { name: { $regex: keyword, $options: 'i' } },
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            console.log('Service query:', serviceQuery);

            // Äáº¿m tá»•ng sá»‘ dá»‹ch vá»¥ phÃ¹ há»£p
            const totalItems = await this.serviceRepository.countDocuments(serviceQuery);
            console.log('Total matching services:', totalItems);

            // Xá»­ lÃ½ sáº¯p xáº¿p
            const sortField = cleanParams.sort_by || 'created_at';
            const sortOrder = cleanParams.sort_order === 'asc' ? 1 : -1;
            const sortOptions: any = {};
            sortOptions[sortField] = sortOrder;

            // Láº¥y danh sÃ¡ch dá»‹ch vá»¥ vá»›i phÃ¢n trang
            const services = await this.serviceRepository.find(serviceQuery, sortOptions, skip, limit);

            console.log('Retrieved services:', services.length);

            // TÃ­nh toÃ¡n thÃ´ng tin phÃ¢n trang
            const totalPages = Math.ceil(totalItems / limit);

            // Tráº£ vá» káº¿t quáº£
            return {
                pageData: services,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: page,
                    pageSize: limit,
                }
            };
        } catch (error) {
            console.error('Error in getServicesByAppointment:', error);
            throw error;
        }
    }

    /**
     * Xá»­ lÃ½ tham sá»‘ truy váº¥n cho API service-appointment
     */
    private processAppointmentParams(params: any): {
        status?: string;
        start_appointment_date?: string;
        end_appointment_date?: string;
        appointment_type?: string;
        customer_id?: string;
        staff_id?: string;
        collection_address?: string;
        is_active?: boolean;
        type?: string;
        sample_method?: string;
        min_price?: number;
        max_price?: number;
        pageNum?: string;
        pageSize?: string;
        keyword?: string;
        sort_by?: string;
        sort_order?: string;
    } {
        const processedParams: Record<string, any> = {};

        // Duyá»‡t qua tá»«ng key cá»§a params
        Object.keys(params).forEach(key => {
            const trimmedKey = key.trim();
            const normalizedKey = trimmedKey.replace(/-/g, '_');
            processedParams[normalizedKey] = params[key];
        });

        // XÃ¡c thá»±c cÃ¡c trÆ°á»ng sáº¯p xáº¿p há»£p lá»‡
        const allowedSortFields = ['name', 'price', 'created_at', 'estimated_time'];
        const sortBy = processedParams.sort_by?.toLowerCase();

        return {
            status: processedParams.status,
            start_appointment_date: processedParams.start_appointment_date,
            end_appointment_date: processedParams.end_appointment_date,
            appointment_type: processedParams.appointment_type,
            customer_id: processedParams.customer_id,
            staff_id: processedParams.staff_id,
            collection_address: processedParams.collection_address,
            is_active: processedParams.is_active === 'true',
            type: processedParams.type?.toLowerCase(),
            sample_method: processedParams.sample_method?.toLowerCase(),
            min_price: processedParams.min_price ? parseFloat(processedParams.min_price) : undefined,
            max_price: processedParams.max_price ? parseFloat(processedParams.max_price) : undefined,
            pageNum: processedParams.pageNum || '1',
            pageSize: processedParams.pageSize || '10',
            keyword: processedParams.keyword,
            sort_by: allowedSortFields.includes(sortBy) ? sortBy : 'created_at',
            sort_order: processedParams.sort_order === 'asc' ? 'asc' : 'desc',
        };
    }

    /**
     * Äáº¿m sá»‘ lÆ°á»£ng dá»‹ch vá»¥ theo loáº¡i
     */
    public async countServicesByType(queryParams: any = {}): Promise<{
        total: number;
        byType: Record<string, number>;
        byStatus: Record<string, number>;
        bySampleMethod: Record<string, number>;
    }> {
        try {
            // Xá»­ lÃ½ tham sá»‘ truy váº¥n
            const cleanParams = this.processQueryParams(queryParams);

            // XÃ¢y dá»±ng query cÆ¡ báº£n
            const baseQuery: any = { is_deleted: false };

            // ThÃªm cÃ¡c Ä‘iá»u kiá»‡n lá»c náº¿u cÃ³
            if (cleanParams.is_active !== undefined) {
                baseQuery.is_active = cleanParams.is_active;
            }

            if (cleanParams.keyword) {
                const keyword = cleanParams.keyword.toLowerCase();
                baseQuery.$or = [
                    { name: { $regex: keyword, $options: 'i' } },
                    { description: { $regex: keyword, $options: 'i' } }
                ];
            }

            // Ghi log query Ä‘á»ƒ debug
            console.log('Base query for counting:', baseQuery);

            // Äáº¿m tá»•ng sá»‘ dá»‹ch vá»¥
            const total = await this.serviceRepository.countDocuments(baseQuery);
            console.log('Total services:', total);

            // Khá»Ÿi táº¡o cÃ¡c objects káº¿t quáº£ vá»›i giÃ¡ trá»‹ máº·c Ä‘á»‹nh
            const byType: Record<string, number> = {
                [ServiceTypeEnum.CIVIL]: 0,
                [ServiceTypeEnum.ADMINISTRATIVE]: 0
            };

            const bySampleMethod: Record<string, number> = {
                [SampleMethodEnum.SELF_COLLECTED]: 0,
                [SampleMethodEnum.FACILITY_COLLECTED]: 0,
                [SampleMethodEnum.HOME_COLLECTED]: 0
            };

            const byStatus = {
                active: 0,
                inactive: 0
            };

            // Náº¿u khÃ´ng cÃ³ dá»‹ch vá»¥ nÃ o, tráº£ vá» káº¿t quáº£ vá»›i cÃ¡c giÃ¡ trá»‹ máº·c Ä‘á»‹nh
            if (total === 0) {
                return {
                    total: 0,
                    byType,
                    byStatus,
                    bySampleMethod
                };
            }

            // Äáº¿m theo loáº¡i dá»‹ch vá»¥
            const typeCountsPromise = Promise.all([
                this.serviceRepository.countDocuments({ ...baseQuery, type: ServiceTypeEnum.CIVIL }),
                this.serviceRepository.countDocuments({ ...baseQuery, type: ServiceTypeEnum.ADMINISTRATIVE })
            ]);

            // Äáº¿m theo tráº¡ng thÃ¡i (luÃ´n Ä‘áº¿m cáº£ active vÃ  inactive, báº¥t ká»ƒ giÃ¡ trá»‹ is_active trong query)
            const activeQuery = { ...baseQuery, is_active: true };
            const inactiveQuery = { ...baseQuery, is_active: false };

            // XÃ³a Ä‘iá»u kiá»‡n is_active khá»i query Ä‘á»ƒ Ä‘áº¿m táº¥t cáº£ tráº¡ng thÃ¡i
            if (activeQuery.is_active !== undefined) delete activeQuery.is_active;
            if (inactiveQuery.is_active !== undefined) delete inactiveQuery.is_active;

            const statusCountsPromise = Promise.all([
                this.serviceRepository.countDocuments({ ...activeQuery, is_active: true }),
                this.serviceRepository.countDocuments({ ...inactiveQuery, is_active: false })
            ]);

            // Äáº¿m theo phÆ°Æ¡ng thá»©c láº¥y máº«u
            const sampleMethodCountsPromise = Promise.all([
                this.serviceRepository.countDocuments({ ...baseQuery, sample_method: SampleMethodEnum.SELF_COLLECTED }),
                this.serviceRepository.countDocuments({ ...baseQuery, sample_method: SampleMethodEnum.FACILITY_COLLECTED }),
                this.serviceRepository.countDocuments({ ...baseQuery, sample_method: SampleMethodEnum.HOME_COLLECTED })
            ]);

            // Äá»£i táº¥t cáº£ cÃ¡c truy váº¥n hoÃ n thÃ nh
            const [typeCounts, statusCounts, sampleMethodCounts] = await Promise.all([
                typeCountsPromise,
                statusCountsPromise,
                sampleMethodCountsPromise
            ]);

            // Cáº­p nháº­t káº¿t quáº£
            byType[ServiceTypeEnum.CIVIL] = typeCounts[0];
            byType[ServiceTypeEnum.ADMINISTRATIVE] = typeCounts[1];

            byStatus.active = statusCounts[0];
            byStatus.inactive = statusCounts[1];

            bySampleMethod[SampleMethodEnum.SELF_COLLECTED] = sampleMethodCounts[0];
            bySampleMethod[SampleMethodEnum.FACILITY_COLLECTED] = sampleMethodCounts[1];
            bySampleMethod[SampleMethodEnum.HOME_COLLECTED] = sampleMethodCounts[2];

            console.log('Count statistics:', {
                total,
                byType,
                byStatus,
                bySampleMethod
            });

            return {
                total,
                byType,
                byStatus,
                bySampleMethod
            };
        } catch (error) {
            console.error('Error in countServicesByType:', error);
            throw error;
        }
    }

    /**
     * Thay Ä‘á»•i tráº¡ng thÃ¡i hoáº¡t Ä‘á»™ng cá»§a dá»‹ch vá»¥
     */
    public async changeServiceStatus(id: string, isActive: boolean): Promise<IService> {
        // Kiá»ƒm tra dá»‹ch vá»¥ cÃ³ tá»“n táº¡i khÃ´ng
        const service = await this.serviceRepository.findById(id);
        if (!service) {
            throw new HttpException(HttpStatus.NotFound, 'Service not found');
        }

        // Kiá»ƒm tra náº¿u dá»‹ch vá»¥ Ä‘Ã£ bá»‹ xÃ³a
        if (service.is_deleted) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot change status of a deleted service');
        }

        // Náº¿u tráº¡ng thÃ¡i    khÃ´ng thay Ä‘á»•i, tráº£ vá» dá»‹ch vá»¥ hiá»‡n táº¡i
        if (service.is_active === isActive) {
            return service;
        }

        // Cáº­p nháº­t tráº¡ng thÃ¡i
        const updatedService = await this.serviceRepository.findByIdAndUpdate(
            id,
            {
                is_active: isActive,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedService) {
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to update service status');
        }

        return updatedService;
    }

    /**
     * Get all services with images
     * @returns Array of services with images
     */
    public async getServicesWithImages(): Promise<IService[]> {
        try {
            // Find all services that have an image_url
            const services = await this.serviceRepository.findAll({
                image_url: { $exists: true, $ne: null },
                is_deleted: false,
                is_active: true
            });

            return services;
        } catch (error) {
            console.error('Error getting services with images:', error);
            throw new HttpException(HttpStatus.InternalServerError, 'Failed to get services with images');
        }
    }

    /**
     * Get a service by its slug
     * @param slug The slug of the service to retrieve
     * @returns The service with the specified slug
     */
    public async getServiceBySlug(slug: string): Promise<IService & { average_rating?: number, review_count?: number }> {
        const service = await this.serviceRepository.findBySlug(slug);
        if (!service) {
            throw new HttpException(HttpStatus.NotFound, `Service with slug '${slug}' not found`);
        }
        const { average_rating, review_count } = await this.getServiceReviewStats(service._id);
        return { ...service.toObject(), average_rating, review_count };
    }

    private async getServiceReviewStats(serviceId: string) {
        // Find all appointments for this service
        const appointments = await this.appointmentSchema.find({ service_id: serviceId }, '_id');
        const appointmentIds = appointments.map(a => a._id);
        if (appointmentIds.length === 0) return { average_rating: 0, review_count: 0 };
        // Aggregate reviews for these appointments
        const result = await ReviewSchema.aggregate([
            { $match: { appointment_id: { $in: appointmentIds }, is_deleted: { $ne: true } } },
            { $group: { _id: null, average_rating: { $avg: '$rating' }, review_count: { $sum: 1 } } }
        ]);
        if (result.length === 0) return { average_rating: 0, review_count: 0 };
        return { average_rating: result[0].average_rating, review_count: result[0].review_count };
    }
}


================================================
FILE: src/modules/service/dtos/createService.dto.ts
================================================
import { IsNotEmpty, IsNumber, IsOptional, IsString } from "class-validator";
import { IService, SampleMethod, ServiceType } from "../service.interface";
import { Type, Transform } from "class-transformer";

export default class CreateServiceDto {
    constructor(
        name: string,
        description: string,
        parent_service_id: string | null,
        price: number,
        type: ServiceType,
        // sample_method: SampleMethod,
        estimated_time: number,
        image_url?: string,
        slug?: string,
    ) {
        this.name = name;
        this.description = description;
        this.parent_service_id = parent_service_id;
        this.price = price;
        this.type = type;
        // this.sample_method = sample_method;
        this.estimated_time = estimated_time;
        this.image_url = image_url;
        this.slug = slug || '';
    }

    @IsString()
    @IsNotEmpty()
    public name: string;

    @IsString()
    @IsOptional()
    public slug: string;

    @IsString()
    @IsNotEmpty()
    public description: string;

    @IsString()
    @IsOptional()
    public parent_service_id: string | null;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    public price: number;

    @IsString()
    @IsNotEmpty()
    public type: ServiceType;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    public estimated_time: number;

    @IsString()
    @IsOptional()
    public image_url?: string;
}



================================================
FILE: src/modules/service/dtos/updateService.dto.ts
================================================
import { SampleMethod, ServiceType } from "../service.interface";
import { IsString, IsNotEmpty, IsOptional, IsNumber, IsEnum } from "class-validator";
import { ServiceTypeEnum, SampleMethodEnum } from "../service.enum";
import { Type } from "class-transformer";

export default class UpdateServiceDto {
    constructor(
        name: string,
        description: string,
        parent_service_id: string | null,
        price: number,
        type: ServiceType,
        // sample_method: SampleMethod,
        estimated_time: number,
        image_url?: string,
        slug?: string,
    ) {
        this.name = name;
        this.description = description;
        this.parent_service_id = parent_service_id;
        this.price = price;
        this.type = type;
        // this.sample_method = sample_method;
        this.estimated_time = estimated_time;
        this.image_url = image_url;
        this.slug = slug;
    }

    @IsString()
    @IsNotEmpty()
    name: string;

    @IsString()
    @IsOptional()
    slug?: string;

    @IsString()
    @IsNotEmpty()
    description: string;

    @IsString()
    @IsOptional()
    parent_service_id: string | null;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    price: number;

    @IsEnum(ServiceTypeEnum)
    @IsNotEmpty()
    type: ServiceType;

    @IsNumber()
    @IsNotEmpty()
    @Type(() => Number)
    estimated_time: number;

    @IsString()
    @IsOptional()
    image_url?: string;
}




================================================
FILE: src/modules/service/swagger/service.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     CreateServiceDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - price
 *         - type
 *         - sample_method
 *         - estimated_time
 *       properties:
 *         name:
 *           type: string
 *           description: service name
 *           example: "DNA Test"
 *         slug:
 *           type: string
 *           description: URL-friendly identifier (generated automatically if not provided)
 *           example: "dna-test"
 *         description:
 *           type: string
 *           description: service description
 *           example: "Dá»‹ch vá»¥ xÃ©t nghiá»‡m ADN Ä‘á»ƒ xÃ¡c Ä‘á»‹nh má»‘i quan há»‡ huyáº¿t thá»‘ng giá»¯a cha/máº¹ vÃ  con"
 *         parent_service_id:
 *           type: string
 *           description: ID cá»§a dá»‹ch vá»¥ cha (náº¿u cÃ³)
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         price:
 *           type: number
 *           description: GiÃ¡ dá»‹ch vá»¥
 *           example: 3500000
 *         type:
 *           type: string
 *           enum: [civil, administrative]
 *           description: Loáº¡i dá»‹ch vá»¥
 *           example: "civil"
 *         sample_method:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *           description: sample method
 *           example: "facility_collected"
 *         estimated_time:
 *           type: number
 *           description: estimated time
 *           example: 72
 *         image_url:
 *           type: string
 *           description: URL cá»§a hÃ¬nh áº£nh dá»‹ch vá»¥
 *           example: "https://wdp392-generate-pdf.s3-ap-southeast-2.amazonaws.com/person-sample-images/123456/image.jpg"
 *
 *     UpdateServiceDto:
 *       type: object
 *       required:
 *         - name
 *         - description
 *         - price
 *         - type
 *         - sample_method
 *         - estimated_time
 *       properties:
 *         name:
 *           type: string
 *           description: TÃªn dá»‹ch vá»¥
 *           example: "XÃ©t nghiá»‡m ADN xÃ¡c Ä‘á»‹nh huyáº¿t thá»‘ng"
 *         slug:
 *           type: string
 *           description: URL-friendly identifier (updated automatically if not provided)
 *           example: "xet-nghiem-adn-xac-dinh-huyet-thong"
 *         description:
 *           type: string
 *           description: MÃ´ táº£ chi tiáº¿t vá» dá»‹ch vá»¥
 *           example: "Dá»‹ch vá»¥ xÃ©t nghiá»‡m ADN Ä‘á»ƒ xÃ¡c Ä‘á»‹nh má»‘i quan há»‡ huyáº¿t thá»‘ng giá»¯a cha/máº¹ vÃ  con"
 *         parent_service_id:
 *           type: string
 *           description: ID cá»§a dá»‹ch vá»¥ cha (náº¿u cÃ³)
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         price:
 *           type: number
 *           description: GiÃ¡ dá»‹ch vá»¥
 *           example: 3500000
 *         type:
 *           type: string
 *           enum: [civil, administrative]
 *           description: Loáº¡i dá»‹ch vá»¥
 *           example: "civil"
 *         sample_method:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *           description: PhÆ°Æ¡ng thá»©c thu tháº­p máº«u
 *           example: "facility_collected"
 *         estimated_time:
 *           type: number
 *           description: Thá»i gian Æ°á»›c tÃ­nh Ä‘á»ƒ hoÃ n thÃ nh dá»‹ch vá»¥ (tÃ­nh báº±ng giá»)
 *           example: 72
 *         image_url:
 *           type: string
 *           description: URL cá»§a hÃ¬nh áº£nh dá»‹ch vá»¥
 *           example: "https://wdp392-generate-pdf.s3-ap-southeast-2.amazonaws.com/person-sample-images/123456/image.jpg"
 *
 *     ServiceResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: ID dá»‹ch vá»¥
 *           example: "60d5ec9af682fbd12a0f4a3d"
 *         name:
 *           type: string
 *           description: TÃªn dá»‹ch vá»¥
 *           example: "XÃ©t nghiá»‡m ADN xÃ¡c Ä‘á»‹nh huyáº¿t thá»‘ng"
 *         slug:
 *           type: string
 *           description: URL-friendly identifier for the service
 *           example: "xet-nghiem-adn-xac-dinh-huyet-thong"
 *         description:
 *           type: string
 *           description: MÃ´ táº£ chi tiáº¿t vá» dá»‹ch vá»¥
 *           example: "Dá»‹ch vá»¥ xÃ©t nghiá»‡m ADN Ä‘á»ƒ xÃ¡c Ä‘á»‹nh má»‘i quan há»‡ huyáº¿t thá»‘ng giá»¯a cha/máº¹ vÃ  con"
 *         parent_service_id:
 *           type: string
 *           description: ID cá»§a dá»‹ch vá»¥ cha (náº¿u cÃ³)
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         price:
 *           type: number
 *           description: GiÃ¡ dá»‹ch vá»¥
 *           example: 3500000
 *         type:
 *           type: string
 *           enum: [civil, administrative]
 *           description: Loáº¡i dá»‹ch vá»¥
 *           example: "civil"
 *         sample_method:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *           description: PhÆ°Æ¡ng thá»©c thu tháº­p máº«u
 *           example: "facility_collected"
 *         estimated_time:
 *           type: number
 *           description: Thá»i gian Æ°á»›c tÃ­nh Ä‘á»ƒ hoÃ n thÃ nh dá»‹ch vá»¥ (tÃ­nh báº±ng giá»)
 *           example: 72
 *         image_url:
 *           type: string
 *           description: URL cá»§a hÃ¬nh áº£nh dá»‹ch vá»¥
 *           example: "https://wdp392-generate-pdf.s3-ap-southeast-2.amazonaws.com/person-sample-images/123456/image.jpg"
 *         is_active:
 *           type: boolean
 *           description: Tráº¡ng thÃ¡i hoáº¡t Ä‘á»™ng cá»§a dá»‹ch vá»¥
 *           example: true
 *         is_deleted:
 *           type: boolean
 *           description: Tráº¡ng thÃ¡i xÃ³a cá»§a dá»‹ch vá»¥
 *           example: false
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: NgÃ y táº¡o
 *           example: "2023-07-15T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: NgÃ y cáº­p nháº­t gáº§n nháº¥t
 *           example: "2023-07-16T14:20:00.000Z"
 *
 *     ServicePaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/ServiceResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Tá»•ng sá»‘ dá»‹ch vá»¥
 *               example: 45
 *             totalPages:
 *               type: integer
 *               description: Tá»•ng sá»‘ trang
 *               example: 5
 *             pageNum:
 *               type: integer
 *               description: Sá»‘ trang hiá»‡n táº¡i
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Sá»‘ lÆ°á»£ng dá»‹ch vá»¥ má»—i trang
 *               example: 10
 *
 *     ServiceStatisticsResponse:
 *       type: object
 *       properties:
 *         total:
 *           type: integer
 *           description: Tá»•ng sá»‘ dá»‹ch vá»¥
 *           example: 45
 *         byType:
 *           type: object
 *           description: Sá»‘ lÆ°á»£ng dá»‹ch vá»¥ theo loáº¡i
 *           properties:
 *             civil:
 *               type: integer
 *               example: 30
 *             administrative:
 *               type: integer
 *               example: 15
 *         byStatus:
 *           type: object
 *           description: Sá»‘ lÆ°á»£ng dá»‹ch vá»¥ theo tráº¡ng thÃ¡i
 *           properties:
 *             active:
 *               type: integer
 *               example: 40
 *             inactive:
 *               type: integer
 *               example: 5
 *         bySampleMethod:
 *           type: object
 *           description: Sá»‘ lÆ°á»£ng dá»‹ch vá»¥ theo phÆ°Æ¡ng thá»©c thu tháº­p máº«u
 *           properties:
 *             self_collected:
 *               type: integer
 *               example: 15
 *             facility_collected:
 *               type: integer
 *               example: 20
 *             home_collected:
 *               type: integer
 *               example: 10
 */



================================================
FILE: src/modules/service/swagger/service.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: services
 *   description: Service management
 */

/**
 * @swagger
 * /api/service/create:
 *   post:
 *     tags:
 *       - services
 *     summary: Create a new service (Only Admin, Manager)
 *     description: Create a new DNA testing service in the system. You can upload an image for any service type.
 *     operationId: createService
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: Service name
 *               slug:
 *                 type: string
 *                 description: URL-friendly identifier (generated automatically if not provided)
 *               description:
 *                 type: string
 *                 description: Service description
 *               parent_service_id:
 *                 type: string
 *                 description: ID of parent service (if this is a child service)
 *               price:
 *                 type: number
 *                 description: Service price
 *               type:
 *                 type: string
 *                 enum: [civil, administrative]
 *                 description: Service type
 *               sample_method:
 *                 type: string
 *                 enum: [self_collected, facility_collected, home_collected]
 *                 description: Sample collection method
 *               estimated_time:
 *                 type: number
 *                 description: Estimated time in hours
 *               service_image:
 *                 type: string
 *                 format: binary
 *                 description: Image for the service
 *             required:
 *               - name
 *               - description
 *               - price
 *               - type
 *               - sample_method
 *               - estimated_time
 *     responses:
 *       201:
 *         description: Create service successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/search:
 *   get:
 *     tags:
 *       - services
 *     summary: Search and filter services (All roles)
 *     description: Search services with pagination and filtering by multiple criteria
 *     operationId: getServices
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: Filter by service type (civil, administrative)
 *       - in: query
 *         name: sample_method
 *         schema:
 *           type: string
 *         description: Filter by sample collection method (self_collected, facility_collected, home_collected)
 *       - in: query
 *         name: is_active
 *         schema:
 *           type: boolean
 *         description: Filter by active status
 *       - in: query
 *         name: min_price
 *         schema:
 *           type: number
 *         description: Minimum price
 *       - in: query
 *         name: max_price
 *         schema:
 *           type: number
 *         description: Maximum price
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of services per page
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by name or description
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           default: created_at
 *         description: Sort by field (name, price, created_at, estimated_time)
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           default: desc
 *         description: Sort order (asc, desc)
 *       - in: query
 *         name: start_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by created date (start)
 *       - in: query
 *         name: end_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by created date (end)
 *     responses:
 *       200:
 *         description: List of services with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServicePaginationResponse'
 *       401:   
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/slug/{slug}:
 *   get:
 *     tags:
 *       - services
 *     summary: Get service by slug (All roles)
 *     description: Retrieve detailed information of a service by its slug (URL-friendly identifier)
 *     operationId: getServiceBySlug
 *     parameters:
 *       - in: path
 *         name: slug
 *         required: true
 *         schema:
 *           type: string
 *         description: Service slug
 *     responses:
 *       200:
 *         description: Detailed service information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 */

/**
 * @swagger     
 * /api/service/{id}:
 *   get:
 *     tags:
 *       - services
 *     summary: Get service information by ID (All roles)
 *     description: Retrieve detailed information of a service by ID
 *     operationId: getServiceById
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     responses:
 *       200:
 *         description: Detailed service information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 *
 *   put:
 *     tags:
 *       - services
 *     summary: Update service (Only Admin, Manager)
 *     description: Update service information. You can upload or update an image for any service.
 *     operationId: updateService
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: Service name
 *               slug:
 *                 type: string
 *                 description: URL-friendly identifier (updated automatically if not provided)
 *               description:
 *                 type: string
 *                 description: Service description
 *               parent_service_id:
 *                 type: string
 *                 description: ID of parent service (if this is a child service)
 *               price:
 *                 type: number
 *                 description: Service price
 *               type:
 *                 type: string
 *                 enum: [civil, administrative]
 *                 description: Service type
 *               sample_method:
 *                 type: string
 *                 enum: [self_collected, facility_collected, home_collected]
 *                 description: Sample collection method
 *               estimated_time:
 *                 type: number
 *                 description: Estimated time in hours
 *               service_image:
 *                 type: string
 *                 format: binary
 *                 description: Image for the service
 *             required:
 *               - name
 *               - description
 *               - price
 *               - type
 *               - sample_method
 *               - estimated_time
 *     responses:
 *       200:
 *         description: Update service successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 *
 *   delete:
 *     tags:
 *       - services
 *     summary: Delete service (Only Admin, Manager)
 *     description: Delete service (soft delete)
 *     operationId: deleteService
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     responses:
 *       200:
 *         description: Delete service successfully
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 */

/**
 * @swagger
 * /api/service/{id}/child:
 *   get:
 *     tags:
 *       - services
 *     summary: Get list of child services (All roles)
 *     description: Get all child services of a parent service
 *     operationId: getChildServices
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Parent service ID
 *     responses:
 *       200:
 *         description: List of child services
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/ServiceResponse'
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Parent service not found
 */

/**
 * @swagger
 * /api/service/appointments:
 *   get:
 *     tags:
 *       - services
 *     summary: Get services by appointment criteria (Admin, Manager, Staff)
 *     description: Filter services based on appointment related information
 *     operationId: getServicesByAppointment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *         description: Filter by appointment status
 *       - in: query
 *         name: start_appointment_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by appointment date (start)
 *       - in: query
 *         name: end_appointment_date
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by appointment date (end)
 *       - in: query
 *         name: appointment_type
 *         schema:
 *           type: string
 *         description: Filter by appointment type (self, facility, home)
 *       - in: query
 *         name: customer_id
 *         schema:
 *           type: string
 *         description: Filter by customer ID
 *       - in: query
 *         name: staff_id
 *         schema:
 *           type: string
 *         description: Filter by staff ID
 *       - in: query
 *         name: collection_address
 *         schema:
 *           type: string
 *         description: Filter by collection address
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Number of services per page
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of services per page
 *     responses:
 *       200:
 *         description: List of services by appointment criteria
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServicePaginationResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/statistics:
 *   get:
 *     tags:
 *       - services
 *     summary: Service statistics (Admin, Manager)
 *     description: Count services by type, status and sample collection method
 *     operationId: countServicesByType
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: is_active
 *         schema:
 *           type: boolean
 *         description: Filter by active status
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by name or description
 *     responses:
 *       200:
 *         description: Service statistics
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceStatisticsResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/service/{id}/status:
 *   patch:
 *     tags:
 *       - services
 *     summary: Change service status (Admin, Manager)
 *     description: Activate or deactivate a service
 *     operationId: changeServiceStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Service ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               is_active:
 *                 type: boolean
 *                 description: New active status
 *             required:
 *               - is_active
 *     responses:
 *       200:
 *         description: Change service status successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ServiceResponse'
 *       400:
 *         description: Invalid input data or service has been deleted
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Service not found
 */


================================================
FILE: src/modules/slot/index.ts
================================================
import SlotSchema from './slot.model';
import { ISlot, SlotStatus } from './slot.interface';
import { SlotStatusEnum } from './slot.enum';
import { SlotStatuses } from './slot.constant';
import SlotRoute from './slot.route';

export {
    SlotSchema,
    ISlot,
    SlotStatus,
    SlotStatusEnum,
    SlotStatuses,
    SlotRoute
}; 


================================================
FILE: src/modules/slot/slot.constant.ts
================================================
import { SlotStatusEnum } from './slot.enum';

export const SlotStatuses = [
    '',
    SlotStatusEnum.AVAILABLE,
    SlotStatusEnum.BOOKED,
    SlotStatusEnum.UNAVAILABLE
]; 


================================================
FILE: src/modules/slot/slot.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { formatResponse } from '../../core/utils';
import { UpdateSlotDto } from './dtos/updateSlot.dto';
import SlotService from './slot.service';
import { CreateSlotDto } from './dtos/createSlot.dto';
import { ISlot } from './slot.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { UserRoleEnum } from '../user/user.enum';

export default class SlotController {
    private slotService = new SlotService();

    /**
     * Táº¡o má»™t slot má»›i
     */
    public createSlot = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotData: CreateSlotDto = req.body;
            const slot = await this.slotService.createSlot(slotData);
            res.status(HttpStatus.Created).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Táº¡o nhiá»u slot cÃ¹ng lÃºc theo máº«u
     */
    // public createMultipleSlots = async (req: Request, res: Response, next: NextFunction) => {
    //     try {
    //         const slotsData: CreateMultipleSlotsDto = req.body;
    //         const result = await this.slotService.createMultipleSlots(slotsData);
    //         res.status(HttpStatus.Created).json({
    //             success: true,
    //             data: result
    //         });
    //     } catch (error) {
    //         next(error);
    //     }
    // };

    /**
     * TÃ¬m kiáº¿m slots vá»›i cÃ¡c bá»™ lá»c
     */
    public getSlots = async (req: Request, res: Response, next: NextFunction) => {
        try {
            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            const slots = await this.slotService.getSlots(req.query, userRole, userId);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Láº¥y slot theo ID
     */
    public getSlotById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotId = req.params.id;

            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            // Get requested staff ID if any
            const requestedStaffId = req.query.staff_profile_id as string;

            const slot = await this.slotService.getSlotById(slotId, userRole, userId, requestedStaffId);
            res.status(HttpStatus.Success).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Cáº­p nháº­t thÃ´ng tin slot
     */
    public updateSlot = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotId = req.params.id;
            const slotData: UpdateSlotDto = req.body;
            const slot = await this.slotService.updateSlot(slotId, slotData);
            res.status(HttpStatus.Success).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Thay Ä‘á»•i tráº¡ng thÃ¡i slot
     */
    public changeSlotStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const slotId = req.params.id;
            const { status } = req.body;

            if (!status) {
                throw new HttpException(HttpStatus.BadRequest, 'Status is required');
            }

            const slot = await this.slotService.changeSlotStatus(slotId, status);
            res.status(HttpStatus.Success).json(formatResponse<ISlot>(slot));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Láº¥y slots cá»§a má»™t nhÃ¢n viÃªn
     */
    public getSlotsByUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userId = req.params.id;

            if (!userId) {
                throw new HttpException(HttpStatus.BadRequest, 'User ID is required');
            }

            // Get requesting user role and ID
            const requestingUserRole = req.user?.role;
            const requestingUserId = req.user?.id;

            const slots = await this.slotService.getSlotsByUser(
                userId,
                req.query,
                requestingUserRole,
                requestingUserId
            );

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Láº¥y slots theo phÃ²ng ban
     */
    public getSlotsByDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const departmentId = req.params.departmentId;
            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            // Staff role is not allowed to filter by staff_profile_ids
            if (userRole === UserRoleEnum.STAFF && req.query.staff_profile_ids) {
                throw new HttpException(HttpStatus.Forbidden, 'Staff role is not allowed to filter by staff_profile_id');
            }

            const slots = await this.slotService.getSlotsByDepartment(departmentId, req.query, userRole, userId);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Láº¥y slots theo dá»‹ch vá»¥
     */
    // public getSlotsByService = async (req: Request, res: Response, next: NextFunction) => {
    //     try {
    //         const serviceId = req.params.serviceId;
    //         const slots = await this.slotService.getSlotsByService(serviceId, req.query);
    //         res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(slots));
    //     } catch (error) {
    //         next(error);
    //     }
    // };


    /**
     * Láº¥y thá»‘ng kÃª performance cá»§a phÃ²ng ban
     */
    public getDepartmentPerformance = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const departmentId = req.params.departmentId;
            const { date_from, date_to } = req.query;
            const performanceStats = await this.slotService.getDepartmentPerformance(departmentId, { date_from, date_to });
            res.status(HttpStatus.Success).json(formatResponse(performanceStats));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Láº¥y danh sÃ¡ch slots cÃ³ sáºµn Ä‘á»ƒ Ä‘áº·t lá»‹ch
     */
    public getAvailableSlots = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { start_date, end_date, type, staff_profile_ids } = req.query;

            if (!start_date) {
                throw new HttpException(HttpStatus.BadRequest, 'start_date is required');
            }

            // Get user role and ID from the authenticated request
            const userRole = req.user?.role;
            const userId = req.user?.id;

            // Staff role is not allowed to filter by staff_profile_ids
            if (userRole === UserRoleEnum.STAFF && staff_profile_ids) {
                throw new HttpException(HttpStatus.Forbidden, 'Staff role is not allowed to filter by staff_profile_id');
            }

            const availableSlots = await this.slotService.getAvailableSlots({
                start_date: start_date as string,
                end_date: end_date as string,
                type: type as string,
                staff_profile_ids: staff_profile_ids as string | string[]
            }, userRole, userId);

            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<ISlot>>(availableSlots));
        } catch (error) {
            next(error);
        }
    };
}


================================================
FILE: src/modules/slot/slot.enum.ts
================================================
export enum SlotStatusEnum {
    AVAILABLE = 'available',
    BOOKED = 'booked',
    UNAVAILABLE = 'unavailable'
} 


================================================
FILE: src/modules/slot/slot.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { SlotStatusEnum } from './slot.enum';

export type SlotStatus =
    SlotStatusEnum.AVAILABLE |
    SlotStatusEnum.BOOKED |
    SlotStatusEnum.UNAVAILABLE;

export interface TimePoint {
    hour: number;
    minute: number;
}

export interface ITimeSlot {
    year: number;
    month: number;
    day: number;
    start_time: TimePoint;
    end_time: TimePoint;
}

export interface ISlot extends Document {
    _id: string | undefined;
    service_id?: string | undefined;
    staff_profile_ids: string[] | undefined;
    appointment_id?: string | undefined;
    appointment_limit: number; //max appointment per slot
    assigned_count?: number; // current count of appointments assigned to this slot
    time_slots?: ITimeSlot[];
    status: SlotStatus | string;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/slot/slot.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { SlotStatuses } from './slot.constant';
import { ISlot } from './slot.interface';
import type { ITimeSlot, TimePoint } from './slot.interface';

const TimePointSchema: Schema<TimePoint> = new Schema({
    hour: { type: Number, required: true },
    minute: { type: Number, required: true }
}, { _id: false });

const TimeSlotSchema: Schema<ITimeSlot> = new Schema({
    year: { type: Number, required: true },
    month: { type: Number, required: true },
    day: { type: Number, required: true },
    start_time: { type: TimePointSchema, required: true },
    end_time: { type: TimePointSchema, required: true }
});

const SlotSchemaEntity: Schema<ISlot> = new Schema({
    staff_profile_ids: { type: [Schema.Types.ObjectId], ref: COLLECTION_NAME.STAFF_PROFILE, required: true },
    appointment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.APPOINTMENT },
    appointment_limit: { type: Number, required: true, default: 1 },
    assigned_count: { type: Number, default: 0 },
    time_slots: { type: [TimeSlotSchema], required: true },
    status: {
        type: String,
        enum: SlotStatuses,
        required: true
    },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const SlotSchema = mongoose.model<ISlot & mongoose.Document>(
    COLLECTION_NAME.SLOT,
    SlotSchemaEntity
);

export default SlotSchema; 


================================================
FILE: src/modules/slot/slot.repository.ts
================================================
import SlotSchema from './slot.model';
import { ISlot } from './slot.interface';

export default class SlotRepository {
    public async createSlot(data: Partial<ISlot>): Promise<ISlot> {
        return SlotSchema.create(data);
    }

    public async findOne(query: any): Promise<ISlot | null> {
        return SlotSchema.findOne(query);
    }

    public async findById(id: string): Promise<ISlot | null> {
        return SlotSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<ISlot>, options: any = {}): Promise<ISlot | null> {
        return SlotSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return SlotSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISlot[]> {
        return SlotSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<ISlot[]> {
        return SlotSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<ISlot[]> {
        return SlotSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate({
                path: 'staff_profile_ids',
                select: 'employee_id job_title _id',
                populate: {
                    path: 'user_id',
                    select: '_id first_name last_name'
                }
            })
    }

    public async findByIdWithPopulate(id: string): Promise<ISlot | null> {
        return SlotSchema.findById(id)
            .populate({
                path: 'staff_profile_ids',
                select: 'employee_id job_title id',
                populate: {
                    path: 'user_id',
                    select: 'first_name last_name id'
                }
            })
    }
}



================================================
FILE: src/modules/slot/slot.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import { UserRoleEnum } from '../user/user.enum';
import SlotController from './slot.controller';
import { CreateSlotDto } from './dtos/createSlot.dto';
import { UpdateSlotDto } from './dtos/updateSlot.dto';

export default class SlotRoute implements IRoute {
    public path = API_PATH.SLOT;
    public router = Router();
    private slotController = new SlotController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain:/api/slot/create -> Create a single slot
        this.router.post(
            `${API_PATH.CREATE_SLOT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(CreateSlotDto),
            this.slotController.createSlot
        );

        // POST: domain:/api/slot/create-multiple -> Create multiple slots
        // this.router.post(
        //     `${this.path}/create-multiple`,
        //     authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
        //     validationMiddleware(CreateMultipleSlotsDto),
        //     this.slotController.createMultipleSlots
        // );

        // GET: domain:/api/slot/search -> Search slots with filters
        this.router.get(
            `${API_PATH.SEARCH_SLOT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN]),
            this.slotController.getSlots
        );

        // GET: domain:/api/slot/available -> Get available slots for booking
        this.router.get(
            `${API_PATH.AVAILABLE_SLOT}`,
            authMiddleWare([], true),
            this.slotController.getAvailableSlots
        );

        // GET: domain:/api/slot/staff/:staffProfileId -> Get slots by staff
        this.router.get(
            `${API_PATH.GET_SLOT_BY_STAFF}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.slotController.getSlotsByUser
        );

        // GET: domain:/api/slot/department/:departmentId -> Get slots by department
        this.router.get(
            `${API_PATH.GET_SLOT_BY_DEPARTMENT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.slotController.getSlotsByDepartment
        );

        // GET: domain:/api/slot/:id -> Get slot by id
        this.router.get(
            `${API_PATH.GET_SLOT_BY_ID}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
            this.slotController.getSlotById
        );

        // GET: domain:/api/slot/service/:serviceId -> Get slots by service
        // this.router.get(
        //     `${API_PATH.GET_SLOT_BY_SERVICE}`,
        //     authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.LABORATORY_TECHNICIAN, UserRoleEnum.STAFF]),
        //     this.slotController.getSlotsByService
        // );

        // PUT: domain:/api/slot/:id -> Update slot
        this.router.put(
            `${API_PATH.UPDATE_SLOT}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateSlotDto),
            this.slotController.updateSlot
        );

        // PATCH: domain:/api/slot/:id/status -> Change slot status
        this.router.patch(
            `${API_PATH.CHANGE_SLOT_STATUS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.slotController.changeSlotStatus
        );

        // GET: domain:/api/department/:departmentId/statistics -> Get department performance statistics
        this.router.get(
            `${API_PATH.DEPARTMENT_STATISTICS}`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.slotController.getDepartmentPerformance
        );
    }
}



================================================
FILE: src/modules/slot/slot.service.ts
================================================
import mongoose, { Schema } from "mongoose";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
// import { IError } from "../../core/interfaces";
import { SearchPaginationResponseModel } from "../../core/models";
import SlotSchema from "./slot.model";
import StaffProfileSchema from "../staff_profile/staff_profile.model";
import { StaffStatusEnum } from "../staff_profile/staff_profile.enum";
import { SlotStatusEnum } from "./slot.enum";
import { ISlot } from "./slot.interface";
import { UpdateSlotDto } from "./dtos/updateSlot.dto";
import { CreateSlotDto } from "./dtos/createSlot.dto";
import { UserRoleEnum } from "../user/user.enum";
import ServiceSchema from "../service/service.model";
import { ServiceTypeEnum, SampleMethodEnum } from "../service/service.enum";
import SlotRepository from "./slot.repository";
import UserSchema from "../user/user.model";

export default class SlotService {
    private slotSchema = SlotSchema;
    private staffProfileSchema = StaffProfileSchema;
    private serviceSchema = ServiceSchema;
    private slotRepository = new SlotRepository();
    private userSchema = UserSchema;
    // private errorResults: IError[] = [];

    /**
     * Táº¡o nhiá»u slot cÃ¹ng lÃºc theo máº«u
     */
    // public async createMultipleSlots(model: CreateMultipleSlotsDto): Promise<{
    //     created: number,
    //     skipped: number
    // }> {
    //     // Kiá»ƒm tra staff_profile_id há»£p lá»‡
    //     const staffProfile = await this.staffProfileSchema.findById(model.staff_profile_id);
    //     if (!staffProfile) {
    //         this.errorResults.push({
    //             message: 'Staff profile not found',
    //             field: 'staff_profile_id'
    //         });
    //     }

    //     if (staffProfile && staffProfile.status !== StaffStatusEnum.ACTIVE) {
    //         this.errorResults.push({
    //             message: 'Staff is not active',
    //             field: 'staff_profile_id'
    //         });
    //     }

    //     // Kiá»ƒm tra time_slots há»£p lá»‡
    //     for (const timeSlot of model.time_slots) {
    //         const startTime = timeSlot.start_hour * 60 + timeSlot.start_minute; // convert start time to minutes
    //         const endTime = timeSlot.end_hour * 60 + timeSlot.end_minute; // convert end time to minutes

    //         if (endTime <= startTime) {
    //             this.errorResults.push({
    //                 message: `Invalid time slot: ${timeSlot.start_hour}:${timeSlot.start_minute} - ${timeSlot.end_hour}:${timeSlot.end_minute}. End time must be after start time.`,
    //                 field: 'time_slots'
    //             });
    //         }
    //     }

    //     // Táº¡o danh sÃ¡ch slots dá»±a trÃªn pattern
    //     const slotTimes: { start: Date, end: Date }[] = []; // create an array of objects with start and end dates

    //     // Táº¡o slots theo pattern
    //     if (model.pattern === SlotPattern.DAILY) {
    //         // Táº¡o slot má»—i ngÃ y trong khoáº£ng tá»« start_date Ä‘áº¿n end_date
    //         for (let d = new Date(model.start_date); d <= new Date(model.end_date); d.setDate(d.getDate() + 1)) { //loop through each day in the range
    //             for (const time of model.time_slots) { // sá»­ dá»¥ng time_slots Ä‘á»ƒ táº¡o slot cho tá»«ng ngÃ y
    //                 const startDate = new Date(d); // táº¡o ngÃ y báº¯t Ä‘áº§u cho slot
    //                 startDate.setHours(time.start_hour, time.start_minute, 0, 0); // set the start time of the slot

    //                 const endDate = new Date(d); // táº¡o ngÃ y káº¿t thÃºc cho slot
    //                 endDate.setHours(time.end_hour, time.end_minute, 0, 0); // set the end time of the slot

    //                 // xá»­ lÃ½ time_slots qua Ä‘Ãªm
    //                 // Náº¿u thá»i gian káº¿t thÃºc nhá» hÆ¡n thá»i gian báº¯t Ä‘áº§u, thÃªm 1 ngÃ y vÃ o thá»i gian káº¿t thÃºc
    //                 if (endDate < startDate) {
    //                     endDate.setDate(endDate.getDate() + 1);
    //                 }

    //                 slotTimes.push({ start: startDate, end: endDate }); // thÃªm slot vÃ o danh sÃ¡ch
    //             }
    //         }
    //     } else if (model.pattern === SlotPattern.WEEKLY) {
    //         // Táº¡o slot hÃ ng tuáº§n cho cÃ¡c ngÃ y Ä‘Æ°á»£c chá»n
    //         for (let d = new Date(model.start_date); d <= new Date(model.end_date); d.setDate(d.getDate() + 1)) { //loop through each day in the range
    //             // Kiá»ƒm tra ngÃ y trong tuáº§n cÃ³ Ä‘Æ°á»£c chá»n khÃ´ng
    //             if (model.days_of_week.includes(d.getDay())) {
    //                 for (const time of model.time_slots) { // sá»­ dá»¥ng time_slots Ä‘á»ƒ táº¡o slot cho tá»«ng ngÃ y
    //                     const startDate = new Date(d); // táº¡o ngÃ y báº¯t Ä‘áº§u cho slot
    //                     startDate.setHours(time.start_hour, time.start_minute, 0, 0); // set the start time of the slot

    //                     const endDate = new Date(d);
    //                     endDate.setHours(time.end_hour, time.end_minute, 0, 0); // set the end time of the slot

    //                     // xá»­ lÃ½ time_slots qua Ä‘Ãªm
    //                     // Náº¿u thá»i gian káº¿t thÃºc nhá» hÆ¡n thá»i gian báº¯t Ä‘áº§u, thÃªm 1 ngÃ y vÃ o thá»i gian káº¿t thÃºc
    //                     if (endDate < startDate) {
    //                         endDate.setDate(endDate.getDate() + 1);
    //                     }

    //                     slotTimes.push({ start: startDate, end: endDate }); // thÃªm slot vÃ o danh sÃ¡ch
    //                 }
    //             }
    //         }
    //     }

    //     // Kiá»ƒm tra trÃ¹ng láº·p vÃ  táº¡o slot
    //     let created = 0;
    //     let skipped = 0;

    //     for (const time of slotTimes) {
    //         // Kiá»ƒm tra slot Ä‘Ã£ tá»“n táº¡i chÆ°a
    //         const existingSlot = await this.slotSchema.findOne({
    //             staff_profile_id: model.staff_profile_id,
    //             $or: [
    //                 {
    //                     start_time: { $lt: time.end }, // start_time nhá» hÆ¡n end_time
    //                     end_time: { $gt: time.start } // end_time lá»›n hÆ¡n start_time
    //                 }
    //             ]
    //         });

    //         if (existingSlot) { // náº¿u slot Ä‘Ã£ tá»“n táº¡i
    //             skipped++; // tÄƒng sá»‘ lÆ°á»£ng slot bá»‹ bá» qua
    //             continue; // tiáº¿p tá»¥c vÃ²ng láº·p
    //         }

    //         // kiá»ƒm tra time_slots, days_of_week cÃ³ pháº£i lÃ  Array khÃ´ng
    //         if (!Array.isArray(model.time_slots) && !Array.isArray(model.days_of_week)) {
    //             this.errorResults.push({
    //                 message: 'time_slots and days_of_week must be an array',
    //                 field: 'time_slots'
    //             });
    //         }

    //         // Táº¡o slot má»›i
    //         await this.slotSchema.create({
    //             staff_profile_id: model.staff_profile_id,
    //             service_id: model.service_id,
    //             pattern: model.pattern || SlotPattern.DAILY,
    //             start_time: time.start,
    //             end_time: time.end,
    //             appointment_limit: model.appointment_limit || 1,
    //             days_of_week: model.days_of_week || [],
    //             time_slots: model.time_slots || [],
    //             status: SlotStatusEnum.AVAILABLE,
    //             created_at: new Date(),
    //             updated_at: new Date()
    //         });

    //         created++; // TÄƒng sá»‘ lÆ°á»£ng slot Ä‘Ã£ táº¡o thÃ nh cÃ´ng Ä‘á»ƒ tráº£ vá» cho ngÆ°á»i dÃ¹ng
    //     }

    //     return { created, skipped }; // tráº£ vá» sá»‘ lÆ°á»£ng slot Ä‘Ã£ táº¡o thÃ nh cÃ´ng vÃ  sá»‘ lÆ°á»£ng slot bá»‹ bá» qua
    // }

    /**
     * Get slots by department with role-based filtering
     * @param departmentId Department ID
     * @param queryParams Query parameters
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @returns Paginated list of slots for the department
     */
    public async getSlotsByDepartment(
        departmentId: string,
        queryParams: any = {},
        userRole?: string,
        userId?: string
    ): Promise<SearchPaginationResponseModel<ISlot>> {
        if (!mongoose.Types.ObjectId.isValid(departmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Department ID is invalid');
        }

        // Find all staff profiles in the department
        const staffProfiles = await this.staffProfileSchema.find({
            department_id: departmentId,
            status: StaffStatusEnum.ACTIVE
        });

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // For staff users, check if they belong to the requested department
        if (userRole === UserRoleEnum.STAFF && userId) {
            const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });

            if (!staffProfile) {
                return {
                    pageData: [],
                    pageInfo: {
                        totalItems: 0,
                        totalPages: 0,
                        pageNum: 1,
                        pageSize: 10
                    }
                };
            }

            // Check if staff belongs to the requested department
            if (staffProfile.department_id?.toString() !== departmentId) {
                // Staff can only see slots from their own department
                throw new HttpException(HttpStatus.Forbidden, 'You can only view slots from your own department');
            }
        }

        // Add department_id to query params
        const enrichedQueryParams = {
            ...queryParams,
            department_id: departmentId
        };

        // Use the getSlots method with role-based filtering
        return this.getSlots(enrichedQueryParams, userRole, userId);
    }

    /**
     * Cáº­p nháº­t slot
     */
    public async updateSlot(id: string, model: UpdateSlotDto): Promise<ISlot> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid slot ID');
        }

        const slot = await this.slotRepository.findById(id);
        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        if (!model.time_slots || model.time_slots.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'time_slots are required');
        }

        for (const timeSlot of model.time_slots) {
            // kiá»ƒm tra xem time_slots cÃ³ há»£p lá»‡ hay khÃ´ng
            if (!timeSlot.year || !timeSlot.month || !timeSlot.day ||
                !timeSlot.start_time || !timeSlot.end_time ||
                timeSlot.start_time.hour === undefined || timeSlot.start_time.minute === undefined ||
                timeSlot.end_time.hour === undefined || timeSlot.end_time.minute === undefined) {
                throw new HttpException(HttpStatus.BadRequest, 'All time slot fields are required');
            }

            // kiá»ƒm tra xem hour vÃ  minute cÃ³ há»£p lá»‡ hay khÃ´ng
            if (timeSlot.start_time.hour < 0 || timeSlot.start_time.hour > 23 ||
                timeSlot.end_time.hour < 0 || timeSlot.end_time.hour > 23 ||
                timeSlot.start_time.minute < 0 || timeSlot.start_time.minute > 59 ||
                timeSlot.end_time.minute < 0 || timeSlot.end_time.minute > 59) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid hour or minute values');
            }

            // chuyá»ƒn Ä‘á»•i sang phÃºt Ä‘á»ƒ dá»… so sÃ¡nh
            const startTimeInMinutes = timeSlot.start_time.hour * 60 + timeSlot.start_time.minute;
            const endTimeInMinutes = timeSlot.end_time.hour * 60 + timeSlot.end_time.minute;

            // kiá»ƒm tra xem thá»i gian káº¿t thÃºc cÃ³ sau thá»i gian báº¯t Ä‘áº§u hay khÃ´ng
            if (endTimeInMinutes <= startTimeInMinutes) {
                throw new HttpException(HttpStatus.BadRequest, 'End time must be after start time');
            }

            // kiá»ƒm tra xem ngÃ y cÃ³ há»£p lá»‡ hay khÃ´ng
            const date = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            if (isNaN(date.getTime()) || date.getDate() !== timeSlot.day) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid date');
            }
        }

        // kiá»ƒm tra xem staff_profile_ids cÃ³ há»£p lá»‡ hay khÃ´ng
        const staffProfiles = await this.staffProfileSchema.find({
            _id: { $in: model.staff_profile_ids }, // $in is used in array to filter the some of the values
            status: StaffStatusEnum.ACTIVE
        });

        if (staffProfiles.length === 0) {
            throw new HttpException(HttpStatus.NotFound, 'No active staff profiles found');
        }

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // kiá»ƒm tra xem slot cÃ³ bá»‹ trÃ¹ng láº·p vá»›i slot khÃ¡c hay khÃ´ng, Bá»Ž QUA Náº¾U TRÃ™NG Vá»šI CHÃNH NÃ“
        for (const timeSlot of model.time_slots) {
            const overlappingSlots = await this.slotRepository.findOne({
                _id: { $ne: id }, // khÃ´ng tÃ­nh chÃ­nh nÃ³ - $ne is not equal to
                staff_profile_ids: { $in: model.staff_profile_ids },
                time_slots: {
                    $elemMatch: { // $elemMatch Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ tÃ¬m kiáº¿m pháº§n tá»­ trong máº£ng
                        year: timeSlot.year,
                        month: timeSlot.month,
                        day: timeSlot.day,
                        $or: [
                            {
                                // thá»i gian báº¯t Ä‘áº§u náº±m trong slot hiá»‡n táº¡i
                                "start_time.hour": { $lt: timeSlot.end_time.hour }, // start_time.hour < end_time.hour
                                "end_time.hour": { $gt: timeSlot.start_time.hour } // end_time.hour > start_time.hour
                            },
                            {
                                // cÃ¹ng giá», kiá»ƒm tra phÃºt
                                "start_time.hour": timeSlot.start_time.hour,
                                "start_time.minute": { $lt: timeSlot.end_time.minute }
                            },
                            {
                                // Same hour, check minutes
                                "end_time.hour": timeSlot.end_time.hour,
                                "end_time.minute": { $gt: timeSlot.start_time.minute }
                            }
                        ]
                    }
                }
            });

            // kiá»ƒm tra xem slot cÃ³ bá»‹ trÃ¹ng láº·p vá»›i slot khÃ¡c hay khÃ´ng, Bá»Ž QUA Náº¾U TRÃ™NG Vá»šI CHÃNH NÃ“
            if (overlappingSlots) {
                throw new HttpException(HttpStatus.Conflict, 'Slot overlaps with an existing slot');
            }
        }

        // kiá»ƒm tra xem staff_profile_ids cÃ³ há»£p lá»‡ hay khÃ´ng
        if (model.staff_profile_ids.length !== staffProfileIds.length) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid staff profile IDs');
        }

        // cáº­p nháº­t slot
        const updatedSlot = await this.slotRepository.findByIdAndUpdate(
            id,
            {
                staff_profile_ids: staffProfileIds,
                time_slots: model.time_slots as any, // Ã©p kiá»ƒu sang any Ä‘á»ƒ kháº¯c phá»¥c lá»—i kiá»ƒu dá»¯ liá»‡u
                appointment_limit: model.appointment_limit,
                status: model.status,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedSlot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found after update');
        }

        return updatedSlot;
    }

    private processQueryParams(queryParams: any): any {
        const { pageNum = 1, pageSize = 10, ...rest } = queryParams;
        return {
            pageNum: parseInt(pageNum),
            pageSize: parseInt(pageSize),
            ...rest
        };
    }

    /**
     * Táº¡o má»™t slot má»›i
     */
    public async createSlot(model: CreateSlotDto): Promise<ISlot> {
        if (!model.time_slots || model.time_slots.length === 0) {
            throw new HttpException(HttpStatus.BadRequest, 'time_slots are required');
        }

        // Validate time slots
        for (const timeSlot of model.time_slots) {
            // kiá»ƒm tra xem táº¥t cáº£ cÃ¡c trÆ°á»ng báº¯t buá»™c cÃ³ tá»“n táº¡i hay khÃ´ng
            if (!timeSlot.year || !timeSlot.month || !timeSlot.day ||
                !timeSlot.start_time || !timeSlot.end_time ||
                timeSlot.start_time.hour === undefined || timeSlot.start_time.minute === undefined ||
                timeSlot.end_time.hour === undefined || timeSlot.end_time.minute === undefined) {
                throw new HttpException(HttpStatus.BadRequest, 'All time slot fields are required');
            }

            // kiá»ƒm tra xem hour vÃ  minute cÃ³ há»£p lá»‡ hay khÃ´ng
            if (timeSlot.start_time.hour < 0 || timeSlot.start_time.hour > 23 ||
                timeSlot.end_time.hour < 0 || timeSlot.end_time.hour > 23 ||
                timeSlot.start_time.minute < 0 || timeSlot.start_time.minute > 59 ||
                timeSlot.end_time.minute < 0 || timeSlot.end_time.minute > 59) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid hour or minute values');
            }

            // chuyá»ƒn Ä‘á»•i sang phÃºt Ä‘á»ƒ dá»… so sÃ¡nh
            const startTimeInMinutes = timeSlot.start_time.hour * 60 + timeSlot.start_time.minute;
            const endTimeInMinutes = timeSlot.end_time.hour * 60 + timeSlot.end_time.minute;

            // kiá»ƒm tra xem thá»i gian káº¿t thÃºc cÃ³ sau thá»i gian báº¯t Ä‘áº§u hay khÃ´ng
            if (endTimeInMinutes <= startTimeInMinutes) {
                throw new HttpException(HttpStatus.BadRequest, 'End time must be after start time');
            }

            // kiá»ƒm tra xem ngÃ y cÃ³ há»£p lá»‡ hay khÃ´ng
            const date = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            if (isNaN(date.getTime()) || date.getDate() !== timeSlot.day) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid date');
            }
        }

        // kiá»ƒm tra xem staff_profile_ids cÃ³ há»£p lá»‡ hay khÃ´ng
        const staffProfiles = await this.staffProfileSchema.find({
            _id: { $in: model.staff_profile_ids || [] },
            status: StaffStatusEnum.ACTIVE
        });

        if (staffProfiles.length === 0) {
            throw new HttpException(HttpStatus.NotFound, 'No active staff profiles found');
        }

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // kiá»ƒm tra xem slot cÃ³ bá»‹ trÃ¹ng láº·p vá»›i slot khÃ¡c hay khÃ´ng, Bá»Ž QUA Náº¾U TRÃ™NG Vá»šI CHÃNH NÃ“
        for (const timeSlot of model.time_slots) {
            // táº¡o ngÃ y báº¯t Ä‘áº§u
            const startDate = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            startDate.setHours(timeSlot.start_time.hour, timeSlot.start_time.minute, 0, 0);

            // táº¡o ngÃ y káº¿t thÃºc
            const endDate = new Date(timeSlot.year, timeSlot.month - 1, timeSlot.day);
            endDate.setHours(timeSlot.end_time.hour, timeSlot.end_time.minute, 0, 0);

            // kiá»ƒm tra xem slot cÃ³ bá»‹ trÃ¹ng láº·p vá»›i slot khÃ¡c hay khÃ´ng, Bá»Ž QUA Náº¾U TRÃ™NG Vá»šI CHÃNH NÃ“
            const overlappingSlots = await this.slotSchema.find({
                staff_profile_ids: { $in: staffProfileIds }, // $in is used in array to filter the some of the values
                time_slots: {
                    $elemMatch: { // $elemMatch Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ tÃ¬m kiáº¿m pháº§n tá»­ trong máº£ng
                        year: timeSlot.year,
                        month: timeSlot.month,
                        day: timeSlot.day,
                        $or: [
                            {
                                // thá»i gian báº¯t Ä‘áº§u náº±m trong slot hiá»‡n táº¡i
                                "start_time.hour": { $lt: timeSlot.end_time.hour }, // start_time.hour < end_time.hour
                                "end_time.hour": { $gt: timeSlot.start_time.hour } // end_time.hour > start_time.hour
                            },
                            {
                                // cÃ¹ng giá», kiá»ƒm tra phÃºt
                                "start_time.hour": timeSlot.start_time.hour,
                                "start_time.minute": { $lt: timeSlot.end_time.minute } // start_time.minute < end_time.minute
                            },
                            {
                                // cÃ¹ng giá», kiá»ƒm tra phÃºt
                                "end_time.hour": timeSlot.end_time.hour,
                                "end_time.minute": { $gt: timeSlot.start_time.minute } // end_time.minute > start_time.minute
                            }
                        ]
                    }
                }
            });

            if (overlappingSlots.length > 0) {
                throw new HttpException(HttpStatus.Conflict, 'Slot overlaps with an existing slot');
            }
        }

        // táº¡o slot má»›i
        const newSlot = await this.slotSchema.create({
            staff_profile_ids: staffProfileIds,
            time_slots: model.time_slots,
            appointment_limit: model.appointment_limit,
            status: SlotStatusEnum.AVAILABLE,
            created_at: new Date(),
            updated_at: new Date()
        });

        return newSlot;
    }

    /**
     * Get slots with filters
     * @param queryParams Query parameters for filtering
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @returns Paginated list of slots
     */
    public async getSlots(queryParams: any = {}, userRole?: string, userId?: string): Promise<SearchPaginationResponseModel<ISlot>> {
        try {
            const {
                pageNum = 1,
                pageSize = 10,
                staff_profile_ids,
                department_id,
                appointment_id,
                status,
                date_from,
                date_to,
                sort_by = 'start_time',
                sort_order = 1,
            } = queryParams;

            const skip = (pageNum - 1) * pageSize;

            const query: any = {};

            // LÆ°u trá»¯ staff_profile_ids Ä‘Æ°á»£c yÃªu cáº§u Ä‘á»ƒ lá»c trong pháº£n há»“i sau
            let requestedStaffIds: string[] = [];

            // Xá»­ lÃ½ lá»c staff_profile_ids dá»±a trÃªn vai trÃ² cá»§a ngÆ°á»i dÃ¹ng
            if (userRole === UserRoleEnum.STAFF) {
                if (staff_profile_ids) {
                    // Vai trÃ² STAFF khÃ´ng Ä‘Æ°á»£c phÃ©p lá»c báº±ng staff_profile_ids
                    throw new HttpException(HttpStatus.Forbidden, 'Staff role is not allowed to filter by staff_profile_id');
                }

                // STAFF chá»‰ cÃ³ thá»ƒ xem slot mÃ  há» Ä‘Æ°á»£c giao
                if (userId) {
                    const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });
                    if (staffProfile) {
                        query.staff_profile_ids = { $in: [staffProfile._id] }; // $in is used in array to filter the some of the values
                        requestedStaffIds = [staffProfile._id.toString()];
                    } else {
                        // Náº¿u staff profile khÃ´ng Ä‘Æ°á»£c tÃ¬m tháº¥y, tráº£ vá» káº¿t quáº£ trá»‘ng
                        return {
                            pageData: [],
                            pageInfo: {
                                totalItems: 0,
                                totalPages: 0,
                                pageNum: Number(pageNum),
                                pageSize: Number(pageSize)
                            }
                        };
                    }
                }
            } else if (userRole === UserRoleEnum.ADMIN || userRole === UserRoleEnum.MANAGER) {
                // Admin/Manager cÃ³ thá»ƒ lá»c báº±ng staff_profile_ids náº¿u Ä‘Æ°á»£c cung cáº¥p
                if (staff_profile_ids) {
                    // Chuyá»ƒn Ä‘á»•i thÃ nh máº£ng náº¿u Ä‘Ã³ lÃ  ID duy nháº¥t
                    const staffIdsArray: any[] = Array.isArray(staff_profile_ids)
                        ? staff_profile_ids
                        : [staff_profile_ids]; // Ã©p kiá»ƒu sang máº£ng

                    // Chuyá»ƒn Ä‘á»•i táº¥t cáº£ cÃ¡c ID thÃ nh chuá»—i Ä‘á»ƒ so sÃ¡nh
                    requestedStaffIds = staffIdsArray.map(id => id.toString());

                    // Sá»­ dá»¥ng cÃ¡c giÃ¡ trá»‹ gá»‘c cho truy váº¥n
                    query.staff_profile_ids = { $in: staffIdsArray };
                }
                // NgÆ°á»£c láº¡i, há» cÃ³ thá»ƒ xem táº¥t cáº£ cÃ¡c slot (khÃ´ng Ã¡p dá»¥ng báº¥t ká»³ lá»c nÃ o)
            }

            // Lá»c theo department_id
            if (department_id) {
                const staffProfiles = await this.staffProfileSchema.find({
                    department_id,
                    status: StaffStatusEnum.ACTIVE
                });
                const staffProfileIds = staffProfiles.map(profile => profile._id.toString());

                // Náº¿u staff_profile_ids Ä‘Ã£ Ä‘Æ°á»£c thiáº¿t láº­p, sá»­ dá»¥ng $and Ä‘á»ƒ káº¿t há»£p cÃ¡c bá»™ lá»c
                if (query.staff_profile_ids) {
                    query.$and = [
                        { staff_profile_ids: query.staff_profile_ids },
                        { staff_profile_ids: { $in: staffProfileIds } }
                    ];

                    // Lá»c requestedStaffIds Ä‘á»ƒ chá»‰ bao gá»“m nhÃ¢n viÃªn tá»« phÃ²ng ban nÃ y
                    if (requestedStaffIds.length > 0) {
                        requestedStaffIds = requestedStaffIds.filter(id =>
                            staffProfileIds.includes(id)
                        );
                    } else {
                        requestedStaffIds = staffProfileIds;
                    }

                    delete query.staff_profile_ids; // XÃ³a bá»™ lá»c gá»‘c vÃ¬ chÃºng ta Ä‘ang sá»­ dá»¥ng $and
                } else {
                    query.staff_profile_ids = { $in: staffProfileIds };
                    requestedStaffIds = staffProfileIds;
                }
            }

            if (appointment_id) {
                query.appointment_id = appointment_id;
            }

            if (status) {
                query.status = status;
            }

            // Lá»c theo khoáº£ng ngÃ y
            if (date_from || date_to) {
                // TÃ¬m cÃ¡c slot mÃ  báº¥t ká»³ thá»i gian_slot nÃ o náº±m trong khoáº£ng ngÃ y
                const dateConditions = [];

                if (date_from) {
                    // Parse date_from in yyyy-mm-dd format
                    let startDate: Date;
                    if (typeof date_from === 'string' && date_from.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const [year, month, day] = date_from.split('-').map(Number);
                        startDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
                    } else {
                        startDate = new Date(date_from);
                    }

                    if (isNaN(startDate.getTime())) {
                        throw new HttpException(HttpStatus.BadRequest, 'Invalid date_from format. Use YYYY-MM-DD format.');
                    }

                    const startYear = startDate.getFullYear();
                    const startMonth = startDate.getMonth() + 1; // JavaScript months are 0-based
                    const startDay = startDate.getDate();

                    dateConditions.push({
                        $or: [
                            { 'time_slots.year': { $gt: startYear } },
                            {
                                'time_slots.year': startYear,
                                'time_slots.month': { $gt: startMonth }
                            },
                            {
                                'time_slots.year': startYear,
                                'time_slots.month': startMonth,
                                'time_slots.day': { $gte: startDay }
                            }
                        ]
                    });
                }

                if (date_to) {
                    // Parse date_to in yyyy-mm-dd format
                    let endDate: Date;
                    if (typeof date_to === 'string' && date_to.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const [year, month, day] = date_to.split('-').map(Number);
                        endDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
                    } else {
                        endDate = new Date(date_to);
                    }

                    if (isNaN(endDate.getTime())) {
                        throw new HttpException(HttpStatus.BadRequest, 'Invalid date_to format. Use YYYY-MM-DD format.');
                    }

                    const endYear = endDate.getFullYear();
                    const endMonth = endDate.getMonth() + 1;
                    const endDay = endDate.getDate();

                    dateConditions.push({
                        $or: [
                            { 'time_slots.year': { $lt: endYear } },
                            {
                                'time_slots.year': endYear,
                                'time_slots.month': { $lt: endMonth }
                            },
                            {
                                'time_slots.year': endYear,
                                'time_slots.month': endMonth,
                                'time_slots.day': { $lte: endDay }
                            }
                        ]
                    });
                }

                // Náº¿u cÃ³ Ä‘iá»u kiá»‡n ngÃ y, sá»­ dá»¥ng $and Ä‘á»ƒ káº¿t há»£p cÃ¡c Ä‘iá»u kiá»‡n => táº¡o ra Ä‘iá»u kiá»‡n ngÃ y
                if (dateConditions.length > 0) {
                    if (query.$and) {
                        query.$and.push({ $and: dateConditions });
                    } else {
                        query.$and = dateConditions;
                    }
                }
            }

            console.log('Slot search query:', JSON.stringify(query, null, 2));

            const totalItems = await this.slotSchema.countDocuments(query);

            const slots = await this.slotSchema
                .find(query)
                .sort({ [sort_by]: sort_order })
                .skip(skip)
                .limit(Number(pageSize))
                .populate({
                    path: 'staff_profile_ids',
                    select: 'employee_id job_title department_id',
                    populate: {
                        path: 'user_id',
                        select: 'first_name last_name email'
                    }
                })
                .populate({
                    path: 'appointment_id',
                    select: 'code status'
                });

            // Xá»­ lÃ½ káº¿t quáº£ dá»±a trÃªn vai trÃ² cá»§a ngÆ°á»i dÃ¹ng vÃ  tham sá»‘ lá»c
            const processedSlots = slots.map(slot => {
                const slotObj = slot.toObject();

                // Náº¿u lá»c theo staff_profile_ids, chá»‰ hiá»ƒn thá»‹ nhá»¯ng nhÃ¢n viÃªn Ä‘Æ°á»£c yÃªu cáº§u trong pháº£n há»“i
                if (staff_profile_ids && Array.isArray(slotObj.staff_profile_ids)) {
                    // Lá»c staff_profile_ids Ä‘á»ƒ chá»‰ bao gá»“m nhá»¯ng nhÃ¢n viÃªn Ä‘Æ°á»£c yÃªu cáº§u
                    slotObj.staff_profile_ids = slotObj.staff_profile_ids.filter((profile: any) => {
                        return profile._id && requestedStaffIds.includes(profile._id.toString());
                    }) as any;
                }
                // Äá»‘i vá»›i danh sÃ¡ch xem (khÃ´ng lá»c theo staff_profile_id cá»¥ thá»ƒ), áº©n staff_profile_ids cho vai trÃ² STAFF
                else if (!staff_profile_ids && userRole === UserRoleEnum.STAFF) {
                    slotObj.staff_profile_ids = [];  // Thay tháº¿ báº±ng máº£ng trá»‘ng
                }

                return slotObj;
            });

            const totalPages = Math.ceil(totalItems / pageSize);

            return {
                pageData: processedSlots,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum: Number(pageNum),
                    pageSize: Number(pageSize)
                }
            };
        } catch (error) {
            console.error('Error in getSlots:', error);
            throw error;
        }
    }

    /**
     * Get slot by ID with role-based access control
     * @param id Slot ID
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @param requestedStaffId Optional specific staff ID to filter in the response
     * @returns Slot with appropriate staff information based on user role
     */
    public async getSlotById(
        id: string,
        userRole?: string,
        userId?: string,
        requestedStaffId?: string
    ): Promise<ISlot> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid slot ID');
        }

        const slot = await this.slotRepository.findByIdWithPopulate(id);

        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        // Process the slot based on user role
        const slotObj = slot.toObject();

        // Náº¿u yÃªu cáº§u má»™t nhÃ¢n viÃªn cá»¥ thá»ƒ vÃ  ngÆ°á»i dÃ¹ng khÃ´ng pháº£i lÃ  STAFF hoáº·c lÃ  nhÃ¢n viÃªn Ä‘Æ°á»£c yÃªu cáº§u
        if (requestedStaffId && (userRole !== UserRoleEnum.STAFF ||
            (userId && await this.isUserMatchingStaffId(userId, requestedStaffId)))) {
            // Lá»c Ä‘á»ƒ chá»‰ hiá»ƒn thá»‹ thÃ´ng tin nhÃ¢n viÃªn Ä‘Æ°á»£c yÃªu cáº§u
            if (Array.isArray(slotObj.staff_profile_ids)) {
                slotObj.staff_profile_ids = slotObj.staff_profile_ids.filter((profile: any) => {
                    return profile._id && profile._id.toString() === requestedStaffId;
                });
            }
        }
        // Äá»‘i vá»›i vai trÃ² STAFF, chá»‰ hiá»ƒn thá»‹ thÃ´ng tin cá»§a chÃ­nh há» trong staff_profile_ids
        else if (userRole === UserRoleEnum.STAFF && userId && Array.isArray(slotObj.staff_profile_ids)) {
            const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });

            if (staffProfile) {
                // Kiá»ƒm tra xem nhÃ¢n viÃªn nÃ y cÃ³ Ä‘Æ°á»£c giao slot hay khÃ´ng
                const isAssigned = slotObj.staff_profile_ids.some((profile: any) => {
                    return profile._id && profile._id.toString() === staffProfile._id.toString();
                });

                if (isAssigned) {
                    // Chá»‰ giá»¯ láº¡i thÃ´ng tin nhÃ¢n viÃªn nÃ y trong danh sÃ¡ch
                    const staffProfileData = slotObj.staff_profile_ids.find((profile: any) =>
                        profile._id && profile._id.toString() === staffProfile._id.toString()
                    );

                    slotObj.staff_profile_ids = staffProfileData ? [staffProfileData] : [];
                } else {
                    // NhÃ¢n viÃªn khÃ´ng Ä‘Æ°á»£c giao slot, áº©n táº¥t cáº£ thÃ´ng tin nhÃ¢n viÃªn
                    slotObj.staff_profile_ids = [];
                }
            } else {
                // Staff profile not found, hide all staff info
                slotObj.staff_profile_ids = [];
            }
        }

        return slotObj as ISlot;
    }

    /**
     * Check if the given user ID matches the given staff profile ID
     * @param userId User ID to check
     * @param staffProfileId Staff profile ID to check against
     * @returns True if the user is associated with the staff profile
     */
    private async isUserMatchingStaffId(userId: string, staffProfileId: string): Promise<boolean> {
        if (!mongoose.Types.ObjectId.isValid(staffProfileId)) {
            return false;
        }

        const staffProfile = await this.staffProfileSchema.findById(staffProfileId);
        if (!staffProfile) {
            return false;
        }

        return staffProfile.user_id?.toString() === userId;
    }

    /**
     * Thay Ä‘á»•i tráº¡ng thÃ¡i slot
     */
    public async changeSlotStatus(id: string, status: string): Promise<ISlot> {
        if (!mongoose.Types.ObjectId.isValid(id)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid slot ID');
        }

        const slot = await this.slotRepository.findById(id);
        if (!slot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        // KhÃ´ng cho phÃ©p thay Ä‘á»•i tráº¡ng thÃ¡i náº¿u slot Ä‘Ã£ BOOKED (cÃ³ trong db) vÃ  param status khÃ´ng pháº£i lÃ  BOOKED
        if (slot && slot.status === SlotStatusEnum.BOOKED && status !== SlotStatusEnum.BOOKED) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot change status of a booked slot');
        }

        // Chá»‰ cháº¥p nháº­n cÃ¡c tráº¡ng thÃ¡i há»£p lá»‡
        if (![SlotStatusEnum.AVAILABLE, SlotStatusEnum.UNAVAILABLE, SlotStatusEnum.BOOKED].includes(status as any)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid status value');
        }

        const updatedSlot = await this.slotSchema.findByIdAndUpdate(
            id,
            {
                status: status,
                updated_at: new Date()
            },
            { new: true }
        ).populate({
            path: 'staff_profile_ids',
            select: 'employee_id job_title',
            populate: {
                path: 'user_id',
                select: 'first_name last_name'
            }
        });

        if (!updatedSlot) {
            throw new HttpException(HttpStatus.NotFound, 'Slot not found');
        }

        return updatedSlot as ISlot;
    }

    /**
     * Get slots by user (staff) with role-based access control
     * @param userId User ID to get slots for
     * @param queryParams Query parameters
     * @param requestingUserRole Role of the requesting user
     * @param requestingUserId ID of the requesting user
     * @returns Paginated list of slots for the user
     */
    public async getSlotsByUser(
        userId: string,
        queryParams: any = {},
        requestingUserRole?: string,
        requestingUserId?: string
    ): Promise<SearchPaginationResponseModel<ISlot>> {
        if (!mongoose.Types.ObjectId.isValid(userId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid user ID');
        }

        // Find user
        const user = await this.userSchema.findById(userId);

        if (!user) {
            throw new HttpException(HttpStatus.NotFound, 'User not found');
        }

        if (user.status !== true) {
            throw new HttpException(HttpStatus.BadRequest, 'User is not active');
        }

        // Find staff profile
        const staffProfile = await this.staffProfileSchema.findOne({ user_id: userId });

        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found for this user');
        }

        // Check permissions - staff can only view their own slots
        if (requestingUserRole === UserRoleEnum.STAFF) {
            if (requestingUserId !== userId) {
                throw new HttpException(HttpStatus.Forbidden, 'As a staff member, you can only view your own slots');
            }
        }

        // Add staff_profile_id to query params
        const enrichedQueryParams = {
            ...queryParams,
            staff_profile_ids: [staffProfile._id.toString()]
        };

        // Use the getSlots method with role override to ensure we see all slots for this staff
        // We pass ADMIN as the role to bypass staff-specific filtering in getSlots
        return this.getSlots(enrichedQueryParams, UserRoleEnum.ADMIN);
    }

    /**
     * Láº¥y thá»‘ng kÃª performance cá»§a phÃ²ng ban
     */
    public async getDepartmentPerformance(departmentId: string, queryParams: any): Promise<any> {
        if (!mongoose.Types.ObjectId.isValid(departmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid department ID');
        }

        // Láº¥y táº¥t cáº£ nhÃ¢n viÃªn thuá»™c phÃ²ng ban vÃ  tráº¡ng thÃ¡i ACTIVE
        const staffProfiles = await this.staffProfileSchema.find({
            department_id: departmentId,
            status: StaffStatusEnum.ACTIVE
        });

        const staffProfileIds = staffProfiles.map(profile => profile._id);

        // Process query parameters
        const { date_from, date_to } = queryParams;
        const query: any = { staff_profile_ids: { $in: staffProfileIds } };

        // Filter by date range
        if (date_from || date_to) {
            query.start_time = {};
            if (date_from) {
                query.start_time.$gte = new Date(date_from);
            }
            if (date_to) {
                const endDate = new Date(date_to);
                endDate.setHours(23, 59, 59, 999);
                query.start_time.$lte = endDate;
            }
        }

        // Count total slots
        const totalSlots = await this.slotSchema.countDocuments(query);

        // Count booked slots
        const bookedSlots = await this.slotSchema.countDocuments({
            ...query,
            status: SlotStatusEnum.BOOKED
        });

        // Calculate booking rate (sá»‘ lÆ°á»£ng slot Ä‘Ã£ Ä‘Æ°á»£c Ä‘áº·t / tá»•ng sá»‘ slot)
        const bookingRate = totalSlots > 0 ? (bookedSlots / totalSlots) * 100 : 0;

        return {
            totalStaff: staffProfiles.length,
            totalSlots,
            bookedSlots,
            bookingRate
        };
    }

    /**
     * Get available slots for booking with role-based filtering
     * @param params Search parameters
     * @param userRole Role of the requesting user
     * @param userId ID of the requesting user
     * @returns Paginated list of available slots
     */
    public async getAvailableSlots(
        params: {
            start_date: string;
            end_date?: string;
            type?: string;
            staff_profile_ids?: string | string[];
        },
        userRole?: string,
        userId?: string
    ): Promise<SearchPaginationResponseModel<ISlot>> {
        const { start_date, end_date, type, staff_profile_ids } = params;

        // Validate start_date
        if (!start_date) {
            throw new HttpException(HttpStatus.BadRequest, 'start_date is required');
        }

        // Parse start_date in yyyy-mm-dd format
        let startDate: Date;
        if (start_date.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Parse yyyy-mm-dd format
            const [year, month, day] = start_date.split('-').map(Number);
            startDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
        } else {
            startDate = new Date(start_date);
        }

        if (isNaN(startDate.getTime())) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid start_date format. Use YYYY-MM-DD format.');
        }

        // Set default end_date if not provided
        let endDate: Date;
        if (end_date) {
            // Parse end_date in yyyy-mm-dd format if it matches the pattern
            if (end_date.match(/^\d{4}-\d{2}-\d{2}$/)) {
                const [year, month, day] = end_date.split('-').map(Number);
                endDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date
            } else {
                endDate = new Date(end_date);
            }

            if (isNaN(endDate.getTime())) {
                throw new HttpException(HttpStatus.BadRequest, 'Invalid end_date format. Use YYYY-MM-DD format.');
            }
        } else {
            endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 7); // Default to 7 days from start date
        }

        // Create query with all parameters
        const queryParams: Record<string, any> = {
            status: SlotStatusEnum.AVAILABLE,
            date_from: startDate.toISOString().split('T')[0], // Format as YYYY-MM-DD
            date_to: endDate.toISOString().split('T')[0], // Format as YYYY-MM-DD
            staff_profile_ids: staff_profile_ids
        };

        if (type) {
            // Validate type if provided
            const validTypes = Object.values(SampleMethodEnum);
            if (!validTypes.includes(type as SampleMethodEnum)) {
                throw new HttpException(HttpStatus.BadRequest, `Invalid type. Must be one of: ${validTypes.join(', ')}`);
            }
            queryParams.type = type;
        }

        // Use the getSlots method with role-based filtering
        return this.getSlots(queryParams, userRole, userId);
    }
}


================================================
FILE: src/modules/slot/dtos/createSlot.dto.ts
================================================
import { Type } from "class-transformer";
import { IsNotEmpty, IsNumber, IsString, IsOptional, IsArray, ValidateNested } from "class-validator";
import { ITimeSlot, TimePoint } from "../slot.interface";

export class TimePointDto implements TimePoint {
    constructor(hour: number, minute: number) {
        this.hour = hour;
        this.minute = minute;
    }

    @IsNotEmpty()
    @IsNumber()
    hour: number;

    @IsNotEmpty()
    @IsNumber()
    minute: number;
}

export class TimeSlotDto implements ITimeSlot {
    constructor(
        year: number,
        month: number,
        day: number,
        start_time: TimePointDto,
        end_time: TimePointDto
    ) {
        this.year = year;
        this.month = month;
        this.day = day;
        this.start_time = start_time;
        this.end_time = end_time;
    }

    @IsNotEmpty()
    @IsNumber()
    year: number;

    @IsNotEmpty()
    @IsNumber()
    month: number;

    @IsNotEmpty()
    @IsNumber()
    day: number;

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TimePointDto)
    start_time: TimePointDto;

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TimePointDto)
    end_time: TimePointDto;
}

export class CreateSlotDto {
    constructor(
        staff_profile_ids: string[],
        time_slots: TimeSlotDto[],
        appointment_limit: number
    ) {
        this.staff_profile_ids = staff_profile_ids;
        this.time_slots = time_slots;
        this.appointment_limit = appointment_limit;
    }

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    staff_profile_ids: string[];

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimeSlotDto)
    time_slots: TimeSlotDto[];

    @IsNotEmpty()
    @IsNumber()
    appointment_limit: number;
} 


================================================
FILE: src/modules/slot/dtos/timeSlot.dto.ts
================================================
import { IsNotEmpty, IsNumber } from "class-validator";

export default class TimeSlotDto {
    constructor(
        start_hour: number,
        start_minute: number,
        end_hour: number,
        end_minute: number
    ) {
        this.start_hour = start_hour;
        this.start_minute = start_minute;
        this.end_hour = end_hour;
        this.end_minute = end_minute;
    }

    @IsNotEmpty()
    @IsNumber()
    start_hour: number;

    @IsNotEmpty()
    @IsNumber()
    start_minute: number;

    @IsNotEmpty()
    @IsNumber()
    end_hour: number;

    @IsNotEmpty()
    @IsNumber()
    end_minute: number;
}



================================================
FILE: src/modules/slot/dtos/updateSlot.dto.ts
================================================
import { Type } from "class-transformer";
import { IsEnum, IsNotEmpty, IsOptional, IsNumber, IsString, IsArray, ValidateNested } from "class-validator";
import mongoose, { Schema } from "mongoose";
import { TimePointDto, TimeSlotDto } from "./createSlot.dto";

export class UpdateSlotDto {
    constructor(
        staff_profile_ids: string[],
        time_slots: TimeSlotDto[],
        appointment_limit: number,
        status?: string,
    ) {
        this.staff_profile_ids = staff_profile_ids;
        this.time_slots = time_slots;
        this.appointment_limit = appointment_limit;
        this.status = status;
    }

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    staff_profile_ids: string[];

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimeSlotDto)
    time_slots: TimeSlotDto[];

    @IsNotEmpty()
    @IsNumber()
    appointment_limit: number;

    @IsOptional()
    @IsString()
    status?: string;
}



================================================
FILE: src/modules/slot/swagger/slot.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     TimePoint:
 *       type: object
 *       required:
 *         - hour
 *         - minute
 *       properties:
 *         hour:
 *           type: integer
 *           minimum: 0
 *           maximum: 23
 *           description: Hour (0-23)
 *           example: 9
 *         minute:
 *           type: integer
 *           minimum: 0
 *           maximum: 59
 *           description: Minute (0-59)
 *           example: 30
 *
 *     TimeSlot:
 *       type: object
 *       required:
 *         - year
 *         - month
 *         - day
 *         - start_time
 *         - end_time
 *       properties:
 *         year:
 *           type: integer
 *           description: Year
 *           example: 2025
 *         month:
 *           type: integer
 *           minimum: 1
 *           maximum: 12
 *           description: Month (1-12)
 *           example: 10
 *         day:
 *           type: integer
 *           minimum: 1
 *           maximum: 31
 *           description: Day (1-31)
 *           example: 15
 *         start_time:
 *           $ref: '#/components/schemas/TimePoint'
 *         end_time:
 *           $ref: '#/components/schemas/TimePoint'
 *
 *     CreateSlotDto:
 *       type: object
 *       required:
 *         - staff_profile_ids
 *         - time_slots
 *         - appointment_limit
 *       properties:
 *         staff_profile_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Array of staff profile IDs assigned to this slot
 *           example: ["60d5ec9af682fbd12a0f4a1b"]
 *         time_slots:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/TimeSlot'
 *           description: Array of time slots
 *         appointment_limit:
 *           type: integer
 *           minimum: 1
 *           description: Maximum number of appointments allowed for this slot
 *           example: 1
 *
 *     UpdateSlotDto:
 *       type: object
 *       required:
 *         - staff_profile_ids
 *         - time_slots
 *         - appointment_limit
 *       properties:
 *         staff_profile_ids:
 *           type: array
 *           items:
 *             type: string
 *           description: Array of staff profile IDs assigned to this slot
 *           example: ["60d5ec9af682fbd12a0f4a1b"]
 *         time_slots:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/TimeSlot'
 *           description: Array of time slots
 *         appointment_limit:
 *           type: integer
 *           minimum: 1
 *           description: Maximum number of appointments allowed for this slot
 *           example: 1
 *         status:
 *           type: string
 *           enum: [available, booked, unavailable]
 *           description: Slot status
 *           example: "available"
 *
 *     SlotResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Slot ID
 *           example: "60d5ec9af682fbd12a0f4a3d"
 *         staff_profile_ids:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               _id:
 *                 type: string
 *                 example: "60d5ec9af682fbd12a0f4a1b"
 *               employee_id:
 *                 type: string
 *                 example: "EMP-2023-001"
 *               job_title:
 *                 type: string
 *                 example: "Laboratory Technician"
 *               user_id:
 *                 type: object
 *                 properties:
 *                   _id:
 *                     type: string
 *                     example: "60d5ec9af682fbd12a0f4a1a"
 *                   first_name:
 *                     type: string
 *                     example: "John"
 *                   last_name:
 *                     type: string
 *                     example: "Doe"
 *                   email:
 *                     type: string
 *                     example: "john.doe@example.com"
 *         service_id:
 *           type: string
 *           description: Service ID associated with this slot
 *           example: "60d5ec9af682fbd12a0f4a2c"
 *         appointment_id:
 *           type: string
 *           description: Associated appointment ID (if booked)
 *           example: "60d5ec9af682fbd12a0f4a4d"
 *         appointment_limit:
 *           type: integer
 *           description: Maximum number of appointments allowed for this slot
 *           example: 1
 *         time_slots:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/TimeSlot'
 *           description: Array of time slots
 *         status:
 *           type: string
 *           enum: [available, booked, unavailable]
 *           description: Slot status
 *           example: "available"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Creation date
 *           example: "2023-07-15T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Last update date
 *           example: "2023-07-16T14:20:00.000Z"
 *
 *     SlotPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/SlotResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 45
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 5
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     DepartmentPerformanceResponse:
 *       type: object
 *       properties:
 *         totalStaff:
 *           type: integer
 *           description: Total number of active staff in the department
 *           example: 10
 *         totalSlots:
 *           type: integer
 *           description: Total number of slots in the department
 *           example: 120
 *         bookedSlots:
 *           type: integer
 *           description: Number of booked slots in the department
 *           example: 85
 *         bookingRate:
 *           type: number
 *           format: float
 *           description: Booking rate as a percentage (bookedSlots/totalSlots * 100)
 *           example: 70.83
 *
 *     StatusChangeRequest:
 *       type: object
 *       required:
 *         - status
 *       properties:
 *         status:
 *           type: string
 *           enum: [available, booked, unavailable]
 *           description: New slot status
 *           example: "available"
 */



================================================
FILE: src/modules/slot/swagger/slot.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: slots
 *   description: Slot management
 */

/**
 * @swagger
 * /api/slot/create:
 *   post:
 *     tags:
 *       - slots
 *     summary: Create a new slot (Admin, Manager only)
 *     description: Create a new time slot for staff profiles
 *     operationId: createSlot
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateSlotDto'
 *     responses:
 *       201:
 *         description: Slot created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       409:
 *         description: Slot overlaps with an existing slot
 */

/**
 * @swagger
 * /api/slot/search:
 *   get:
 *     tags:
 *       - slots
 *     summary: Search slots with filters (Admin, Manager, Laboratory Technician, Staff only)
 *     description: Search for slots with pagination and filtering by multiple criteria
 *     operationId: getSlots
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: staff_profile_ids
 *         schema:
 *           type: string
 *         description: Filter by staff profile IDs (comma-separated or single value)
 *       - in: query
 *         name: department_id
 *         schema:
 *           type: string
 *         description: Filter by department ID
 *       - in: query
 *         name: appointment_id
 *         schema:
 *           type: string
 *         description: Filter by appointment ID
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, booked, unavailable]
 *         description: Filter by slot status
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *       - in: query
 *         name: sort_by
 *         schema:
 *           type: string
 *           default: start_time
 *         description: Field to sort by
 *       - in: query
 *         name: sort_order
 *         schema:
 *           type: string
 *           default: asc
 *           enum: [asc, desc]
 *         description: "Sort order (asc: ascending, desc: descending)"
 *     responses:
 *       200:
 *         description: List of slots with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/slot/available:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get available slots for booking
 *     description: Retrieve available slots for booking with optional filters
 *     operationId: getAvailableSlots
 *     parameters:
 *       - in: query
 *         name: start_date
 *         schema:
 *           type: string
 *           format: date
 *         required: true
 *         description: Start date to search for available slots
 *       - in: query
 *         name: end_date
 *         schema:
 *           type: string
 *           format: date
 *         description: End date to search for available slots (defaults to 7 days from start_date if not provided)
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [self_collected, facility_collected, home_collected]
 *         description: Filter by sample collection method
 *     responses:
 *       200:
 *         description: Available slots with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       400:
 *         description: Invalid input (e.g., missing required parameters)
 */

/**
 * @swagger
 * /api/slot/{id}:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get slot by ID (Admin, Manager, Laboratory Technician, Staff only)
 *     description: Retrieve slot details by ID
 *     operationId: getSlotById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *     responses:
 *       200:
 *         description: Slot details
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid slot ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Slot not found
 *
 *   put:
 *     tags:
 *       - slots
 *     summary: Update slot (Admin, Manager only)
 *     description: Update slot information
 *     operationId: updateSlot
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateSlotDto'
 *     responses:
 *       200:
 *         description: Slot updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Slot not found
 *       409:
 *         description: Slot overlaps with an existing slot
 */

/**
 * @swagger
 * /api/slot/{id}/status:
 *   patch:
 *     tags:
 *       - slots
 *     summary: Change slot status (Admin, Manager only)
 *     description: Change the status of a slot
 *     operationId: changeSlotStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Slot ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/StatusChangeRequest'
 *     responses:
 *       200:
 *         description: Slot status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotResponse'
 *       400:
 *         description: Invalid input or cannot change status of a booked slot
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Slot not found
 */

/**
 * @swagger
 * /api/slot/staff/{id}:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get slots by user ID (Admin, Manager, Laboratory Technician, Staff only)
 *     description: Retrieve slots associated with a specific user's staff profile
 *     operationId: getSlotsByUser
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, booked, unavailable]
 *         description: Filter by slot status
 *     responses:
 *       200:
 *         description: List of slots for the user
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       400:
 *         description: Invalid user ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: User not found or staff profile not found for this user
 */

/**
 * @swagger
 * /api/slot/department/{departmentId}:
 *   get:
 *     tags:
 *       - slots
 *     summary: Get slots by department ID (Admin, Manager only)
 *     description: Retrieve slots associated with a specific department
 *     operationId: getSlotsByDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: departmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: staff_profile_ids
 *         schema:
 *           type: string
 *         description: Filter by specific staff profile IDs within department
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [available, booked, unavailable]
 *         description: Filter by slot status
 *     responses:
 *       200:
 *         description: List of slots for the department
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SlotPaginationResponse'
 *       400:
 *         description: Invalid department ID
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/department/{departmentId}/statistics:
 *   get:
 *     tags:
 *       - slots
 *       - departments
 *     summary: Get department performance statistics (Admin, Manager only)
 *     description: Retrieve performance statistics for a specific department
 *     operationId: getDepartmentPerformance
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: departmentId
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *       - in: query
 *         name: date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by start date (inclusive)
 *       - in: query
 *         name: date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by end date (inclusive)
 *     responses:
 *       200:
 *         description: Department performance statistics
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DepartmentPerformanceResponse'
 *       400:
 *         description: Invalid department ID
 *       401:
 *         description: Unauthorized
 */



================================================
FILE: src/modules/staff_profile/index.ts
================================================
import StaffProfileSchema from './staff_profile.model';
import { IStaffProfile, StaffStatus, IQualification } from './staff_profile.interface';
import { StaffStatusEnum } from './staff_profile.enum';
import { StaffStatuses } from './staff_profile.constant';
import StaffProfileController from './staff_profile.controller';
import StaffProfileService from './staff_profile.service';
import StaffProfileRoute from './staff_profile.route';

export {
    StaffProfileSchema,
    IStaffProfile,
    StaffStatus,
    IQualification,
    StaffStatusEnum,
    StaffStatuses,
    StaffProfileController,
    StaffProfileService,
    StaffProfileRoute
}; 


================================================
FILE: src/modules/staff_profile/staff_profile.constant.ts
================================================
import { StaffStatusEnum } from './staff_profile.enum';

export const StaffStatuses = [
    '',
    StaffStatusEnum.ACTIVE,
    StaffStatusEnum.ON_LEAVE,
    StaffStatusEnum.TERMINATED
]; 


================================================
FILE: src/modules/staff_profile/staff_profile.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { HttpStatus } from '../../core/enums';
import { formatResponse } from '../../core/utils';
import StaffProfileService from './staff_profile.service';
import CreateStaffProfileDto from './dtos/createStaffProfile.dto';
import UpdateStaffProfileDto from './dtos/updateStaffProfile.dto';
import { IStaffProfile } from './staff_profile.interface';
import { SearchPaginationResponseModel } from '../../core/models/searchPagination.model';
import { HttpException } from '../../core/exceptions';


export default class StaffProfileController {
    private staffProfileService = new StaffProfileService();

    public createStaffProfile = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: CreateStaffProfileDto = req.body;
            const staffProfile = await this.staffProfileService.createStaffProfile(model);
            res.status(HttpStatus.Created).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

    public getStaffProfiles = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const queryParams = req.query;
            const staffProfiles = await this.staffProfileService.getStaffProfiles(queryParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IStaffProfile>>(staffProfiles));
        } catch (error) {
            next(error);
        }
    }

    public getStaffProfilesByDepartment = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const queryParams = req.query;
            const staffProfiles = await this.staffProfileService.getStaffProfilesByDepartment(id, queryParams);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IStaffProfile>>(staffProfiles));
        } catch (error) {
            next(error);
        }
    }

    public getStaffProfileById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const staffProfile = await this.staffProfileService.getStaffProfileById(id);
            res.status(HttpStatus.Success).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

    public updateStaffProfile = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const model: UpdateStaffProfileDto = req.body;
            const staffProfile = await this.staffProfileService.updateStaffProfile(id, model);
            res.status(HttpStatus.Success).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

    public changeStaffStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const { id } = req.params;
            const { status } = req.body;
            const staffProfile = await this.staffProfileService.changeStaffStatus(id, status);
            res.status(HttpStatus.Success).json(formatResponse<IStaffProfile>(staffProfile));
        } catch (error) {
            next(error);
        }
    }

}




================================================
FILE: src/modules/staff_profile/staff_profile.enum.ts
================================================
export enum StaffStatusEnum {
    ACTIVE = 'active',
    ON_LEAVE = 'on_leave',
    TERMINATED = 'terminated'
} 


================================================
FILE: src/modules/staff_profile/staff_profile.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { StaffStatusEnum } from './staff_profile.enum';

export type StaffStatus =
    StaffStatusEnum.ACTIVE |
    StaffStatusEnum.ON_LEAVE |
    StaffStatusEnum.TERMINATED;

export interface IQualification {
    name: string;
    institution: string;
    issue_date: Date;
    expiry_date?: Date;
    description?: string;
}

export interface IStaffProfile extends Document {
    _id: string;
    user_id: string | undefined;
    department_id: string | undefined;
    job_title: string;
    hire_date: Date;
    employee_id: string; //unique
    salary: number;
    status: StaffStatus;
    qualifications: IQualification[];
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/staff_profile/staff_profile.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { StaffStatuses } from './staff_profile.constant';
import { IStaffProfile } from './staff_profile.interface';
import { StaffStatusEnum } from './staff_profile.enum';
const QualificationSchema = new Schema({
    name: { type: String, required: true },
    institution: { type: String, required: true },
    issue_date: { type: Date, required: true },
    expiry_date: { type: Date },
    description: { type: String }
});

const StaffProfileSchemaEntity: Schema<IStaffProfile> = new Schema({
    user_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER, required: true, unique: true },
    department_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.DEPARTMENT, required: true },
    job_title: { type: String, required: true },
    hire_date: { type: Date, required: true },
    employee_id: { type: String, required: true, unique: true },
    salary: { type: Number, required: true, default: 0 },
    status: {
        type: String,
        enum: StaffStatuses,
        required: true,
        default: StaffStatusEnum.ACTIVE
    },
    qualifications: [QualificationSchema],
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const StaffProfileSchema = mongoose.model<IStaffProfile & mongoose.Document>(
    COLLECTION_NAME.STAFF_PROFILE,
    StaffProfileSchemaEntity
);

export default StaffProfileSchema; 


================================================
FILE: src/modules/staff_profile/staff_profile.repository.ts
================================================
import StaffProfileSchema from './staff_profile.model';
import { IStaffProfile } from './staff_profile.interface';

export default class StaffProfileRepository {
    public async createStaffProfile(data: Partial<IStaffProfile>): Promise<IStaffProfile> {
        return StaffProfileSchema.create(data);
    }

    public async findOne(query: any): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findOne(query);
    }

    public async findById(id: string): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findById(id);
    }

    public async findByIdAndUpdate(id: string, update: Partial<IStaffProfile>, options: any = {}): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findByIdAndUpdate(id, update, options);
    }

    public async countDocuments(query: any): Promise<number> {
        return StaffProfileSchema.countDocuments(query);
    }

    public async find(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IStaffProfile[]> {
        return StaffProfileSchema.find(query).sort(sort).skip(skip).limit(limit);
    }

    public async findAll(query: any): Promise<IStaffProfile[]> {
        return StaffProfileSchema.find(query);
    }

    public async findWithPopulate(query: any, sort: any = {}, skip = 0, limit = 10): Promise<IStaffProfile[]> {
        return StaffProfileSchema.find(query)
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .populate('user_id', 'first_name last_name email')
            .populate('department_id', 'name');
    }

    public async findByIdWithPopulate(id: string): Promise<IStaffProfile | null> {
        return StaffProfileSchema.findById(id)
            .populate('user_id', 'first_name last_name email')
            .populate('department_id', 'name');
    }
}



================================================
FILE: src/modules/staff_profile/staff_profile.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware } from '../../core/middleware';
import StaffProfileController from './staff_profile.controller';
import CreateStaffProfileDto from './dtos/createStaffProfile.dto';
import UpdateStaffProfileDto from './dtos/updateStaffProfile.dto';
import { UserRoleEnum } from '../user/user.enum';


export default class StaffProfileRoute implements IRoute {
    public path = API_PATH.STAFF_PROFILE;
    public router = Router();
    private staffProfileController = new StaffProfileController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST: domain: /api/staff-profile/create -> Create staff profile
        this.router.post(
            `${this.path}/create`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(CreateStaffProfileDto),
            this.staffProfileController.createStaffProfile
        );

        // GET: domain: /api/staff-profile/search -> Get all staff profiles
        this.router.get(
            `${this.path}/search`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.getStaffProfiles
        );

        // GET: domain: /api/staff-profile/department/:id -> Get staff profiles by department id
        this.router.get(
            `${this.path}/department/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.getStaffProfilesByDepartment
        );

        // GET: domain: /api/staff-profile/:id -> Get staff profile by id
        this.router.get(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.getStaffProfileById
        );

        // PUT: domain: /api/staff-profile/:id -> Update staff profile
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            validationMiddleware(UpdateStaffProfileDto),
            this.staffProfileController.updateStaffProfile
        );

        // PUT: domain: /api/staff-profile/:id/status -> Change staff status
        this.router.put(
            `${this.path}/:id/status`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.staffProfileController.changeStaffStatus
        );

    }
}








================================================
FILE: src/modules/staff_profile/staff_profile.service.ts
================================================
import mongoose, { Schema } from "mongoose";
import { HttpStatus } from "../../core/enums";
import { HttpException } from "../../core/exceptions";
import { SearchPaginationResponseModel } from "../../core/models";
import { IStaffProfile, StaffStatus } from "./staff_profile.interface";
import { StaffStatusEnum } from "./staff_profile.enum";
import { SlotStatusEnum } from "../slot/slot.enum";
import SlotSchema from "../slot/slot.model";
import DepartmentSchema from "../department/department.model";
import UserSchema from "../user/user.model";
import CreateStaffProfileDto from "./dtos/createStaffProfile.dto";
import UpdateStaffProfileDto from "./dtos/updateStaffProfile.dto";
import { isEmptyObject } from "../../core/utils";
import { UserRoleEnum } from "../user/user.enum";
import StaffProfileRepository from './staff_profile.repository';

export default class StaffProfileService {
    private staffProfileRepository = new StaffProfileRepository();
    private departmentSchema = DepartmentSchema;
    private userSchema = UserSchema;
    private slotSchema = SlotSchema;

    /**
     * Táº¡o há»“ sÆ¡ nhÃ¢n viÃªn má»›i
     */
    public async createStaffProfile(model: CreateStaffProfileDto): Promise<IStaffProfile> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Data is required');
        }

        // Kiá»ƒm tra user_id cÃ³ tá»“n táº¡i vÃ  cÃ³ role STAFF hoáº·c LABORATORY TECHNICIAN  
        const user = await this.userSchema.findById(model.user_id);
        if (!user || user.role !== UserRoleEnum.STAFF && user.role !== UserRoleEnum.LABORATORY_TECHNICIAN) {
            throw new HttpException(HttpStatus.BadRequest, 'User does not exist or does not have Staff or Laboratory Technician role');
        }

        // Kiá»ƒm tra user Ä‘Ã£ cÃ³ há»“ sÆ¡ nhÃ¢n viÃªn chÆ°a
        const existingProfile = await this.staffProfileRepository.findOne({ user_id: model.user_id });
        if (existingProfile) {
            throw new HttpException(HttpStatus.Conflict, 'User already has a staff profile');
        }

        // Kiá»ƒm tra department_id cÃ³ tá»“n táº¡i
        const department = await this.departmentSchema.findById(model.department_id);
        if (!department || department.is_deleted) {
            throw new HttpException(HttpStatus.BadRequest, 'Department does not exist');
        }

        // Táº¡o employee_id duy nháº¥t
        const employeeId = await this.generateEmployeeId();

        // Táº¡o há»“ sÆ¡ nhÃ¢n viÃªn má»›i vá»›i cÃ¡c giÃ¡ trá»‹ máº·c Ä‘á»‹nh
        const newProfile = await this.staffProfileRepository.createStaffProfile({
            ...model,
            user_id: model.user_id,
            department_id: model.department_id,
            employee_id: employeeId,
            status: StaffStatusEnum.ACTIVE,
            salary: model.salary || 0,
            qualifications: model.qualifications || [],
            created_at: new Date(),
            updated_at: new Date()
        });

        return newProfile;
    }

    /**
     * Táº¡o employee_id duy nháº¥t 
     */
    private async generateEmployeeId(): Promise<string> {
        const prefix = 'EMP';
        const currentYear = new Date().getFullYear().toString().substr(-2);

        // Äáº¿m sá»‘ nhÃ¢n viÃªn Ä‘Ã£ táº¡o trong nÄƒm hiá»‡n táº¡i
        const count = await this.staffProfileRepository.countDocuments({
            employee_id: { $regex: `^${prefix}${currentYear}` }
        });

        // Format: EMP23001, EMP23002, ...
        let sequenceNumber = (count + 1).toString().padStart(3, '0');
        let employeeId = `${prefix}${currentYear}${sequenceNumber}`;

        // Kiá»ƒm tra xem ID Ä‘Ã£ tá»“n táº¡i chÆ°a Ä‘á»ƒ Ä‘áº£m báº£o tÃ­nh duy nháº¥t
        let existingProfile = await this.staffProfileRepository.findOne({ employee_id: employeeId });
        while (existingProfile) {
            // Náº¿u ID Ä‘Ã£ tá»“n táº¡i, tÄƒng sá»‘ thá»© tá»± vÃ  thá»­ láº¡i
            sequenceNumber = (parseInt(sequenceNumber) + 1).toString().padStart(3, '0');
            employeeId = `${prefix}${currentYear}${sequenceNumber}`;
            existingProfile = await this.staffProfileRepository.findOne({ employee_id: employeeId });
        }

        return employeeId;
    }

    /**
     * TÃ¬m kiáº¿m há»“ sÆ¡ nhÃ¢n viÃªn vá»›i bá»™ lá»c
     */
    public async getStaffProfiles(queryParams: any = {}): Promise<SearchPaginationResponseModel<IStaffProfile>> {
        try {
            // Xá»­ lÃ½ tham sá»‘ truy váº¥n
            const {
                pageNum,
                pageSize,
                sort_by,
                sort_order,
                department_id,
                status,
                keyword,
                hire_date_from,
                hire_date_to
            } = this.processQueryParams(queryParams);

            const skip = (pageNum - 1) * pageSize;

            // XÃ¢y dá»±ng truy váº¥n
            const query: any = {};

            // Lá»c theo phÃ²ng ban
            if (department_id) {
                query.department_id = department_id;
            }

            // Lá»c theo tráº¡ng thÃ¡i
            if (status) {
                query.status = status;
            }

            // Lá»c theo ngÃ y tuyá»ƒn dá»¥ng
            if (hire_date_from || hire_date_to) { // Náº¿u cÃ³ ngÃ y tuyá»ƒn dá»¥ng tá»« hoáº·c Ä‘áº¿n
                query.hire_date = {}; // Khá»Ÿi táº¡o Ä‘á»‘i tÆ°á»£ng ngÃ y tuyá»ƒn dá»¥ng
                if (hire_date_from) {
                    query.hire_date.$gte = new Date(hire_date_from); // hire_date >= hire_date_from
                }
                if (hire_date_to) {
                    const endDate = new Date(hire_date_to);
                    endDate.setHours(23, 59, 59, 999); // Äáº·t giá», phÃºt, giÃ¢y, mili giÃ¢y lÃ  23:59:59.999
                    query.hire_date.$lte = endDate; // hire_date <= hire_date_to
                }
            }

            // TÃ¬m kiáº¿m theo tá»« khÃ³a
            if (keyword) {
                query.$or = [
                    { employee_id: { $regex: keyword, $options: 'i' } },
                    { job_title: { $regex: keyword, $options: 'i' } },
                ];
            }

            // Äáº¿m tá»•ng sá»‘ nhÃ¢n viÃªn
            const totalItems = await this.staffProfileRepository.countDocuments(query);

            // Xá»­ lÃ½ sáº¯p xáº¿p
            const sortOptions: any = {};
            sortOptions[sort_by] = sort_order === 'asc' ? 1 : -1;

            // Láº¥y dá»¯ liá»‡u vá»›i phÃ¢n trang vÃ  populate
            const staffProfiles = await this.staffProfileRepository.findWithPopulate(query, sortOptions, skip, pageSize);

            const totalPages = Math.ceil(totalItems / pageSize);

            return {
                pageData: staffProfiles,
                pageInfo: {
                    totalItems,
                    totalPages,
                    pageNum,
                    pageSize
                }
            };
        } catch (error) {
            console.error('Error in getStaffProfiles:', error);
            throw error;
        }
    }

    /**
     * Láº¥y nhÃ¢n viÃªn theo phÃ²ng ban
     */
    public async getStaffProfilesByDepartment(departmentId: string, queryParams: any = {}): Promise<SearchPaginationResponseModel<IStaffProfile>> {
        // Kiá»ƒm tra department_id há»£p lá»‡
        if (!mongoose.Types.ObjectId.isValid(departmentId)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid department ID');
        }

        const department = await this.departmentSchema.findById(departmentId);
        if (!department) {
            throw new HttpException(HttpStatus.NotFound, 'Department does not exist');
        }

        // ThÃªm department_id vÃ o query params vÃ  gá»i láº¡i hÃ m getStaffProfiles
        const newQueryParams = { ...queryParams, department_id: departmentId };
        return this.getStaffProfiles(newQueryParams);
    }

    /**
     * Láº¥y nhÃ¢n viÃªn theo id
     */
    public async getStaffProfileById(id: string): Promise<IStaffProfile> {
        const staffProfile = await this.staffProfileRepository.findByIdWithPopulate(id);
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }
        return staffProfile;
    }

    /**
     * Cáº­p nháº­t há»“ sÆ¡ nhÃ¢n viÃªn
     */
    public async updateStaffProfile(id: string, model: UpdateStaffProfileDto): Promise<IStaffProfile> {
        // Kiá»ƒm tra há»“ sÆ¡ tá»“n táº¡i
        const staffProfile = await this.staffProfileRepository.findById(id);
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        // kiá»ƒm tra department_id cÃ³ tá»“n táº¡i, náº¿u khÃ´ng thay Ä‘á»•i thÃ¬ láº¥y department_id cÅ©
        if (model.department_id) {
            const department = await this.departmentSchema.findById(model.department_id);
            if (!department) {
                throw new HttpException(HttpStatus.NotFound, 'Department does not exist');
            }
        }

        // Cáº­p nháº­t thÃ´ng tin há»“ sÆ¡
        const updatedProfile = await this.staffProfileRepository.findByIdAndUpdate(
            id,
            {
                ...model,
                // user_id: model.user_id,
                department_id: model.department_id,
                updated_at: new Date()
            },
            { new: true }
        );

        if (!updatedProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        return updatedProfile;
    }

    /**
     * Thay Ä‘á»•i tráº¡ng thÃ¡i nhÃ¢n viÃªn
     */
    public async changeStaffStatus(id: string, status: StaffStatus): Promise<IStaffProfile> {
        // Kiá»ƒm tra há»“ sÆ¡ tá»“n táº¡i
        const staffProfile = await this.staffProfileRepository.findById(id);
        if (!staffProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        // Kiá»ƒm tra tráº¡ng thÃ¡i cÃ³ há»£p lá»‡ khÃ´ng
        if (!Object.values(StaffStatusEnum).includes(status)) {
            throw new HttpException(HttpStatus.BadRequest, 'Invalid status');
        }

        // Náº¿u chuyá»ƒn sang TERMINATED, há»§y táº¥t cáº£ slot trong tÆ°Æ¡ng lai
        if (status === StaffStatusEnum.TERMINATED) {
            const currentDate = new Date();
            await this.slotSchema.updateMany(
                {
                    staff_profile_id: id,
                    start_time: { $gt: currentDate }, // start_time > currentDate
                    status: SlotStatusEnum.AVAILABLE // status = AVAILABLE
                },
                { status: SlotStatusEnum.UNAVAILABLE } // status = UNAVAILABLE
            );
        }

        // Cáº­p nháº­t tráº¡ng thÃ¡i
        const updatedProfile = await this.staffProfileRepository.findByIdAndUpdate(
            id,
            { status, updated_at: new Date() },
            { new: true }
        );

        if (!updatedProfile) {
            throw new HttpException(HttpStatus.NotFound, 'Staff profile not found');
        }

        return updatedProfile;
    }

    /**
     * Xá»­ lÃ½ tham sá»‘ truy váº¥n
     */
    private processQueryParams(params: any): {
        pageNum: number;
        pageSize: number;
        sort_by: string;
        sort_order: string;
        department_id?: string;
        status?: string;
        keyword?: string;
        hire_date_from?: string;
        hire_date_to?: string;
    } {
        return {
            pageNum: params.pageNum || 1,
            pageSize: params.pageSize || 10,
            sort_by: params.sort_by || 'created_at',
            sort_order: params.sort_order || 'desc',
            department_id: params.department_id,
            status: params.status,
            keyword: params.keyword,
            hire_date_from: params.hire_date_from,
            hire_date_to: params.hire_date_to
        };
    }

}


================================================
FILE: src/modules/staff_profile/dtos/createStaffProfile.dto.ts
================================================
import { IsArray, IsDate, IsNotEmpty, IsNumber, IsOptional, IsString } from "class-validator";
import { IQualification } from "../staff_profile.interface";
import { Type } from "class-transformer";

export default class CreateStaffProfileDto {
    constructor(
        user_id: string,
        department_id: string,
        job_title: string,
        hire_date: Date,
        salary: number,
        qualifications: IQualification[] = []
    ) {
        this.user_id = user_id;
        this.department_id = department_id;
        this.job_title = job_title;
        this.hire_date = hire_date;
        this.salary = salary;
        this.qualifications = qualifications;
    }

    @IsNotEmpty()
    @IsString()
    public user_id: string;

    @IsNotEmpty()
    @IsString()
    public department_id: string;

    @IsNotEmpty()
    @IsString()
    public job_title: string;

    @IsNotEmpty()
    @IsDate()
    @Type(() => Date)
    public hire_date: Date;

    @IsNotEmpty()
    @IsNumber()
    public salary: number;

    @IsOptional()
    @IsArray()
    public qualifications: IQualification[] = [];

    // CÃ¡c trÆ°á»ng sau sáº½ Ä‘Æ°á»£c táº¡o tá»± Ä‘á»™ng trong service
    // employee_id: string;
    // status: string;
}



================================================
FILE: src/modules/staff_profile/dtos/updateStaffProfile.dto.ts
================================================
import { IsArray, IsDate, IsNotEmpty, IsNumber, IsOptional, IsString } from "class-validator";
import { IQualification } from "../staff_profile.interface";
import { Type } from "class-transformer";

export default class UpdateStaffProfileDto {
    constructor(
        user_id: string,
        department_id: string,
        job_title: string,
        hire_date: Date,
        salary: number,
        qualifications: IQualification[]
    ) {
        this.user_id = user_id;
        this.department_id = department_id;
        this.job_title = job_title;
        this.hire_date = hire_date;
        this.salary = salary;
        this.qualifications = qualifications;
    }

    @IsOptional()
    @IsString()
    public user_id: string;

    @IsNotEmpty()
    @IsString()
    public department_id: string;

    @IsNotEmpty()
    @IsString()
    public job_title: string;

    @IsNotEmpty()
    @IsDate()
    @Type(() => Date)
    public hire_date: Date;

    @IsNotEmpty()
    @IsNumber()
    public salary: number;

    @IsNotEmpty()
    @IsArray()
    public qualifications: IQualification[];
}



================================================
FILE: src/modules/staff_profile/swagger/staff_profile.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Qualification:
 *       type: object
 *       required:
 *         - name
 *         - institution
 *         - issue_date
 *       properties:
 *         name:
 *           type: string
 *           description: Name of the qualification or certification
 *           example: "Medical Laboratory Technician Certification"
 *         institution:
 *           type: string
 *           description: Institution that issued the qualification
 *           example: "American Medical Technologists"
 *         issue_date:
 *           type: string
 *           format: date
 *           description: Date when the qualification was issued
 *           example: "2020-01-15"
 *         expiry_date:
 *           type: string
 *           format: date
 *           description: Date when the qualification expires (if applicable)
 *           example: "2025-01-15"
 *         description:
 *           type: string
 *           description: Additional details about the qualification
 *           example: "National certification for laboratory technicians"
 *
 *     CreateStaffProfileDto:
 *       type: object
 *       required:
 *         - user_id
 *         - department_id
 *         - job_title
 *         - hire_date
 *         - salary
 *       properties:
 *         user_id:
 *           type: string
 *           description: ID of the user to associate with this staff profile
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         department_id:
 *           type: string
 *           description: ID of the department where the staff works
 *           example: "60d5ec9af682fbd12a0f4b2b"
 *         job_title:
 *           type: string
 *           description: Job title or position of the staff
 *           example: "Laboratory Technician"
 *         hire_date:
 *           type: string
 *           format: date
 *           description: Date when the staff was hired
 *           example: "2023-06-01"
 *         salary:
 *           type: number
 *           description: Monthly salary amount
 *           example: 5000
 *         qualifications:
 *           type: array
 *           description: List of qualifications and certifications
 *           items:
 *             $ref: '#/components/schemas/Qualification'
 *
 *     UpdateStaffProfileDto:
 *       type: object
 *       required:
 *         - department_id
 *         - job_title
 *         - hire_date
 *         - salary
 *         - qualifications
 *       properties:
 *         department_id:
 *           type: string
 *           description: ID of the department where the staff works
 *           example: "60d5ec9af682fbd12a0f4b2b"
 *         job_title:
 *           type: string
 *           description: Job title or position of the staff
 *           example: "Senior Laboratory Technician"
 *         hire_date:
 *           type: string
 *           format: date
 *           description: Date when the staff was hired
 *           example: "2023-06-01"
 *         salary:
 *           type: number
 *           description: Monthly salary amount
 *           example: 5500
 *         qualifications:
 *           type: array
 *           description: List of qualifications and certifications
 *           items:
 *             $ref: '#/components/schemas/Qualification'
 *
 *     StaffProfileResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: Staff profile ID
 *           example: "60d5ec9af682fbd12a0f4c3c"
 *         user_id:
 *           type: object
 *           description: User information
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4a1a"
 *             first_name:
 *               type: string
 *               example: "John"
 *             last_name:
 *               type: string
 *               example: "Doe"
 *             email:
 *               type: string
 *               example: "john.doe@example.com"
 *         department_id:
 *           type: object
 *           description: Department information
 *           properties:
 *             _id:
 *               type: string
 *               example: "60d5ec9af682fbd12a0f4b2b"
 *             name:
 *               type: string
 *               example: "Laboratory"
 *         job_title:
 *           type: string
 *           description: Job title or position
 *           example: "Laboratory Technician"
 *         hire_date:
 *           type: string
 *           format: date
 *           description: Date when the staff was hired
 *           example: "2023-06-01"
 *         employee_id:
 *           type: string
 *           description: Unique employee identifier
 *           example: "EMP-2023-001"
 *         salary:
 *           type: number
 *           description: Monthly salary amount
 *           example: 5000
 *         status:
 *           type: string
 *           enum: [active, on_leave, terminated]
 *           description: Current employment status
 *           example: "active"
 *         qualifications:
 *           type: array
 *           description: List of qualifications and certifications
 *           items:
 *             $ref: '#/components/schemas/Qualification'
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Date and time when the record was created
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Date and time when the record was last updated
 *           example: "2023-07-15T14:20:00.000Z"
 *
 *     StaffProfilePaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/StaffProfileResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             totalItems:
 *               type: integer
 *               description: Total number of staff profiles
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *
 *     StatusChangeRequest:
 *       type: object
 *       required:
 *         - status
 *       properties:
 *         status:
 *           type: string
 *           enum: [active, on_leave, terminated]
 *           description: New staff status
 *           example: "on_leave"
 */



================================================
FILE: src/modules/staff_profile/swagger/staff_profile.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: staff_profiles
 *   description: Staff profile management
 */

/**
 * @swagger
 * /api/staff-profile/create:
 *   post:
 *     tags:
 *       - staff_profiles
 *     summary: Create a new staff profile (Admin, Manager only)
 *     description: Create a new staff profile with user and department association
 *     operationId: createStaffProfile
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateStaffProfileDto'
 *     responses:
 *       201:
 *         description: Staff profile created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       409:
 *         description: User already has a staff profile
 */

/**
 * @swagger
 * /api/staff-profile/search:
 *   get:
 *     tags:
 *       - staff_profiles
 *     summary: Search staff profiles (Admin, Manager only)
 *     description: Search for staff profiles with pagination and filtering
 *     operationId: getStaffProfiles
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: query
 *         name: pageNum
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: pageSize
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *       - in: query
 *         name: department_id
 *         schema:
 *           type: string
 *         description: Filter by department ID
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [active, on_leave, terminated]
 *         description: Filter by staff status
 *       - in: query
 *         name: keyword
 *         schema:
 *           type: string
 *         description: Search by employee ID or job title
 *       - in: query
 *         name: hire_date_from
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by hire date (start)
 *       - in: query
 *         name: hire_date_to
 *         schema:
 *           type: string
 *           format: date
 *         description: Filter by hire date (end)
 *     responses:
 *       200:
 *         description: List of staff profiles with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfilePaginationResponse'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/staff-profile/department/{id}:
 *   get:
 *     tags:
 *       - staff_profiles
 *     summary: Get staff profiles by department ID (Admin, Manager only)
 *     description: Retrieve staff profiles associated with a specific department
 *     operationId: getStaffProfilesByDepartment
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Department ID
 *     responses:
 *       200:
 *         description: List of staff profiles in the department
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfilePaginationResponse'
 *       400:
 *         description: Invalid department ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Department not found
 */

/**
 * @swagger
 * /api/staff-profile/{id}:
 *   get:
 *     tags:
 *       - staff_profiles
 *     summary: Get staff profile by ID (Admin, Manager only)
 *     description: Retrieve staff profile details by ID
 *     operationId: getStaffProfileById
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Staff profile ID
 *     responses:
 *       200:
 *         description: Staff profile details
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid staff profile ID
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Staff profile not found
 *   
 *   put:
 *     tags:
 *       - staff_profiles
 *     summary: Update staff profile (Admin, Manager only)
 *     description: Update staff profile information
 *     operationId: updateStaffProfile
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Staff profile ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateStaffProfileDto'
 *     responses:
 *       200:
 *         description: Staff profile updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Staff profile not found
 */

/**
 * @swagger
 * /api/staff-profile/{id}/status:
 *   put:
 *     tags:
 *       - staff_profiles
 *     summary: Change staff status (Admin, Manager only)
 *     description: Change the status of a staff profile
 *     operationId: changeStaffStatus
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: Staff profile ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/StatusChangeRequest'
 *     responses:
 *       200:
 *         description: Staff status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/StaffProfileResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Staff profile not found
 */



================================================
FILE: src/modules/transaction/index.ts
================================================
import TransactionSchema from './transaction.model';
import { ITransaction } from './transaction.interface';

export {
    TransactionSchema,
    ITransaction
}; 


================================================
FILE: src/modules/transaction/transaction.constant.ts
================================================
import { TransactionStatusEnum } from './transaction.enum';

export const TransactionStatuses = [
    '',
    TransactionStatusEnum.PENDING,
    TransactionStatusEnum.SUCCESS,
    TransactionStatusEnum.FAILED,
    TransactionStatusEnum.CANCELLED
];



================================================
FILE: src/modules/transaction/transaction.enum.ts
================================================
export enum TransactionStatusEnum {
    PENDING = 'pending',
    SUCCESS = 'success',
    FAILED = 'failed',
    CANCELLED = 'cancelled',
    REFUNDED = 'refunded'
}




================================================
FILE: src/modules/transaction/transaction.interface.ts
================================================
import { Document, Schema } from 'mongoose';
import { TransactionStatusEnum } from './transaction.enum';
export interface ITransaction extends Document {
    _id: string;
    payment_id: string | undefined;
    staff_id: string | undefined;
    customer_id: string | undefined;
    sample_id: string | undefined;
    receipt_number: string;
    payos_transaction_id?: string;
    payos_payment_status?: TransactionStatusEnum;
    payos_webhook_received_at?: Date;
    payos_payment_status_message?: string;
    payos_payment_status_code?: string;
    payos_payment_status_detail?: string;
    payos_payment_status_time?: Date;
    transaction_date: Date;
    created_at: Date;
    updated_at: Date;
} 


================================================
FILE: src/modules/transaction/transaction.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { ITransaction } from './transaction.interface';
import { TransactionStatusEnum } from './transaction.enum';

const TransactionSchemaEntity: Schema<ITransaction> = new Schema({
    payment_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.PAYMENT, required: true },
    staff_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    customer_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.USER },
    sample_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.SAMPLE },
    receipt_number: { type: String, required: true },
    payos_transaction_id: { type: String },
    payos_payment_status: {
        type: String,
        enum: Object.values(TransactionStatusEnum),
        default: TransactionStatusEnum.PENDING
    },
    payos_webhook_received_at: { type: Date },
    payos_payment_status_message: { type: String },
    payos_payment_status_code: { type: String },
    payos_payment_status_detail: { type: String },
    payos_payment_status_time: { type: Date },
    transaction_date: { type: Date, required: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

const TransactionSchema = mongoose.model<ITransaction & mongoose.Document>(
    COLLECTION_NAME.TRANSACTION,
    TransactionSchemaEntity
);

export default TransactionSchema; 


================================================
FILE: src/modules/transaction/swagger/transaction.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     Transaction:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a1"
 *         payment_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a2"
 *         staff_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a3"
 *         customer_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a4"
 *         sample_id:
 *           type: string
 *           example: "5f8d0e0e9d3b9a0017c1a7a5"
 *         receipt_number:
 *           type: string
 *           example: "PAY-12345-123456-abc123"
 *         payos_transaction_id:
 *           type: string
 *           example: "payos_12345"
 *         payos_payment_status:
 *           type: string
 *           enum: [pending, success, failed, cancelled, refunded]
 *           example: "success"
 *         payos_webhook_received_at:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         payos_payment_status_message:
 *           type: string
 *           example: "Payment successful"
 *         payos_payment_status_code:
 *           type: string
 *           example: "00"
 *         payos_payment_status_detail:
 *           type: string
 *           example: "Transaction completed successfully"
 *         payos_payment_status_time:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         transaction_date:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         created_at:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           example: "2023-01-01T00:00:00.000Z"
 */ 


================================================
FILE: src/modules/transaction/swagger/transaction.tag.js
================================================
/**
 * @swagger
 * tags:
 *   - name: transaction
 *     description: Transaction management
 */ 


================================================
FILE: src/modules/user/index.ts
================================================
import { UserRoleEnum } from "./user.enum";
import { IUser, UserRole } from "./user.interface";
import UserSchema from "./user.model";
import UserRoute from "./user.route";

export { IUser, UserRole, UserRoleEnum, UserRoute, UserSchema };



================================================
FILE: src/modules/user/user.constant.ts
================================================
import { UserRoleEnum, UserGenderEnum } from './user.enum';

export const UserRoles = ['', UserRoleEnum.ALL, UserRoleEnum.ADMIN, UserRoleEnum.MANAGER, UserRoleEnum.STAFF, UserRoleEnum.CUSTOMER, UserRoleEnum.LABORATORY_TECHNICIAN];
export const UserGenders = ['', UserGenderEnum.MALE, UserGenderEnum.FEMALE, UserGenderEnum.OTHER];


================================================
FILE: src/modules/user/user.controller.ts
================================================
import { NextFunction, Request, Response } from 'express';
import { API_PATH } from '../../core/constants';
import { HttpStatus } from '../../core/enums';
import { SearchPaginationResponseModel } from '../../core/models';
import { formatResponse } from '../../core/utils';
import ChangePasswordDto from './dtos/changePassword.dto';
import ChangeRoleDto from './dtos/changeRole.dto';
import ChangeStatusDto from './dtos/changeStatus.dto';
import RegisterDto from './dtos/register.dto';
import SearchPaginationUserDto from './dtos/searchPaginationUser.dto';
import UpdateUserDto from './dtos/updateUser.dto';
import { UserRoleEnum } from './user.enum';
import { IUser } from './user.interface';
import UserService from './user.service';
import ReviewProfileDto from './dtos/reviewProfileDto';
import { HttpException } from '../../core/exceptions';

export default class UserController {
    private userService = new UserService();

    public generateUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model = new RegisterDto(
                '',
                'TÃ´i lÃ ',
                'Admin',
                'admin@gmail.com',
                '123456',
                UserRoleEnum.ADMIN,
                true,
                '0869872830',
                'https://yt3.googleusercontent.com/zlWYSmjS34cnOH94qZYmWEeCkU_DnrFl5G-dCd66i3jqTElMvdwBtsOyMJPpoNXfdpHKPjYrmA=s900-c-k-c0x00ffffff-no-rj',
                new Date(),
                '',
                '',
                true,
                '',
                new Date(),
                0,
                new Date(),
                new Date(),
                false
            );
            const user: IUser = await this.userService.createUser(model, false, false);
            res.status(HttpStatus.Created).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public register = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: RegisterDto = req.body;
            const file = req.file; // Get the uploaded file from multer
            const routerPath = req.route.path;
            const isGoogle = routerPath === API_PATH.USERS_GOOGLE;
            const isRegister = !(routerPath === API_PATH.CREATE_USERS);

            const user: IUser = await this.userService.createUser(model, isGoogle, isRegister, file);
            res.status(HttpStatus.Created).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public getUsers = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: SearchPaginationUserDto = req.body;
            const result: SearchPaginationResponseModel<IUser> = await this.userService.getUsers(model);
            res.status(HttpStatus.Success).json(formatResponse<SearchPaginationResponseModel<IUser>>(result));
        } catch (error) {
            next(error);
        }
    };

    public getUserById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const user: IUser = await this.userService.getUserById(req.params.id, true, req.user);
            res.status(HttpStatus.Success).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public changePassword = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ChangePasswordDto = req.body;
            await this.userService.changePassword(model);
            res.status(HttpStatus.Success).json(formatResponse<string>('Change password successfully'));
        } catch (error) {
            next(error);
        }
    };

    public changeStatus = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ChangeStatusDto = req.body;
            await this.userService.changeStatus(model);
            res.status(HttpStatus.Success).json(formatResponse<string>('Change status successfully'));
        } catch (error) {
            next(error);
        }
    };

    public changeRole = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ChangeRoleDto = req.body;
            await this.userService.changeRole(model);
            res.status(HttpStatus.Success).json(formatResponse<null>(null));
        } catch (error) {
            next(error);
        }
    };

    public reviewProfileAccount = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: ReviewProfileDto = req.body;
            await this.userService.reviewProfileAccount(model);
            res.status(HttpStatus.Success).json(formatResponse<string>('Review profile account successfully'));
        } catch (error) {
            next(error);
        }
    };

    public updateUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const model: UpdateUserDto = req.body;
            const file = req.file; // Get the uploaded file from multer
            const user: IUser = await this.userService.updateUser(req.params.id, model, file);
            res.status(HttpStatus.Success).json(formatResponse<IUser>(user));
        } catch (error) {
            next(error);
        }
    };

    public deleteUser = async (req: Request, res: Response, next: NextFunction) => {
        try {
            await this.userService.deleteUser(req.params.id);
            res.status(HttpStatus.Success).json(formatResponse<string>('Delete user successfully'));
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get staff and laboratory technician users
     */
    public getStaffAndLabTechUsers = async (req: Request, res: Response, next: NextFunction) => {
        try {
            const userRole = req.user.role;
            if (userRole !== UserRoleEnum.MANAGER && userRole !== UserRoleEnum.ADMIN) {
                throw new HttpException(HttpStatus.Forbidden, 'Only Admin and Managers can view staff and laboratory technician users');
            }

            const users = await this.userService.getStaffAndLabTechUsers();
            res.status(HttpStatus.Success).json(formatResponse<any[]>(users));
        } catch (error) {
            next(error);
        }
    }
}



================================================
FILE: src/modules/user/user.enum.ts
================================================
export enum UserRoleEnum {
    ALL = 'all',
    CUSTOMER = 'customer',
    STAFF = 'staff',
    MANAGER = 'manager',
    LABORATORY_TECHNICIAN = 'laboratory_technician',
    ADMIN = 'admin',
}

export enum UserReviewStatusEnum {
    APPROVE = 'approve',
    REJECT = 'reject',
}

export enum UserGenderEnum {
    MALE = 'male',
    FEMALE = 'female',
    OTHER = 'other'
}




================================================
FILE: src/modules/user/user.interface.ts
================================================
import { Document } from 'mongoose';
import { UserReviewStatusEnum, UserRoleEnum, UserGenderEnum } from './user.enum';

export type UserRole = UserRoleEnum.ADMIN | UserRoleEnum.CUSTOMER | UserRoleEnum.STAFF | UserRoleEnum.MANAGER | UserRoleEnum.ALL | UserRoleEnum.LABORATORY_TECHNICIAN;
export type UserReviewStatus = UserReviewStatusEnum.APPROVE | UserReviewStatusEnum.REJECT;
export type UserGender = UserGenderEnum.MALE | UserGenderEnum.FEMALE | UserGenderEnum.OTHER;

export interface IUser extends Document {
    _id: string;
    first_name: string; // required
    last_name: string; // required
    gender: UserGender; // male, female, other
    email: string; // unique
    phone_number: string; // unique
    password?: string; // required if google_id is null or empty
    dob?: Date; // date of birth
    role: UserRole; // default is "client"
    status: boolean; // active, inactive, suspended
    is_verified?: boolean; // default false
    verification_token?: string; // default empty
    verification_token_expires?: Date; // default new Date()
    token_version: number; // default 0
    google_id?: string; // default empty
    avatar_url?: string; // url
    address?: string; // address

    // bank account info
    balance: number; // default 0
    balance_total: number; // default 0
    withdrawn_amount: number; // default 0
    bank_name: string; // default empty
    bank_account_no: string; // default empty
    bank_account_name: string; // default empty

    created_at?: Date; // default new Date()
    updated_at?: Date; // default new Date()
    is_deleted?: boolean; // flag remove logic when user is deleted, default is false


    // citizen id
    citizen_id?: string;
    citizen_id_url?: string;
    birth_certificate?: string; // giáº¥y khai sinh
    divorce_certificate?: string; // giáº¥y ly hÃ´n

    full_name?: string;
    phone?: string;
    administrative_cases?: any[];
}


================================================
FILE: src/modules/user/user.model.ts
================================================
import mongoose, { Schema } from 'mongoose';
import { COLLECTION_NAME } from '../../core/constants';
import { UserRoles, UserGenders } from './user.constant';
import { UserRoleEnum, UserGenderEnum } from './user.enum';
import { IUser } from './user.interface';

const UserSchemaEntity: Schema<IUser> = new Schema({
    email: { type: String, unique: true, index: true, required: true },
    password: { type: String },
    first_name: { type: String, required: true },
    last_name: { type: String, required: true },
    gender: {
        type: String,
        enum: UserGenders,
        default: UserGenderEnum.OTHER
    },
    google_id: { type: String },
    role: {
        type: String,
        enum: UserRoles,
        default: UserRoleEnum.CUSTOMER,
        required: true,
    },
    status: { type: Boolean, default: true },
    phone_number: { type: String, unique: true },
    avatar_url: { type: String },
    dob: { type: Date },
    address: { type: String },

    is_verified: { type: Boolean, default: false },
    verification_token: { type: String },
    verification_token_expires: { type: Date },
    token_version: { type: Number, default: 0 },

    // TODO: change to table
    // transactions: [
    //     {
    //         payout_id: { type: Schema.Types.ObjectId, ref: COLLECTION_NAME.PAYOUT, required: true },
    //         payout_no: { type: String },
    //         payout_amount: { type: Number },
    //         created_at: { type: Date, default: Date.now },
    //     },
    // ],

    balance: { type: Number, default: 0 },
    balance_total: { type: Number, default: 0 },
    withdrawn_amount: { type: Number, default: 0 },
    bank_name: { type: String },
    bank_account_no: { type: String },
    bank_account_name: { type: String },

    // citizen id
    citizen_id: { type: String },
    citizen_id_url: { type: String },
    birth_certificate: { type: String },
    divorce_certificate: { type: String },

    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
    is_deleted: { type: Boolean, default: false },
    administrative_cases: [{ type: String }],
});

// ThÃªm virtual field vÃ o UserSchema - virtual field lÃ  má»™t trÆ°á»ng áº£o, khÃ´ng Ä‘Æ°á»£c lÆ°u trá»¯ trong database
UserSchemaEntity.virtual('staff_profile', {
    ref: COLLECTION_NAME.STAFF_PROFILE,
    localField: '_id',
    foreignField: 'user_id',
    justOne: true,
});

// Äáº£m báº£o virtuals Ä‘Æ°á»£c bao gá»“m khi chuyá»ƒn Ä‘á»•i sang JSON
UserSchemaEntity.set('toJSON', { virtuals: true });
UserSchemaEntity.set('toObject', { virtuals: true });

const UserSchema = mongoose.model<IUser & mongoose.Document>(COLLECTION_NAME.USER, UserSchemaEntity);
export default UserSchema;



================================================
FILE: src/modules/user/user.repository.ts
================================================
import UserSchema from './user.model';
import { IUser } from './user.interface';
// import { SearchPaginationUserDto } from './dtos/searchPaginationUser.dto';

export default class UserRepository {
    public async findUserByEmail(email: string): Promise<IUser | null> {
        return UserSchema.findOne({
            email: { $regex: new RegExp('^' + email + '$', 'i') },
            is_deleted: false,
        });
    }

    public async createUser(user: Partial<IUser>): Promise<IUser> {
        return UserSchema.create(user);
    }

    public async findUserById(userId: string): Promise<IUser | null> {
        return UserSchema.findOne({ _id: userId, is_deleted: false, is_verified: true }).lean();
    }

    public async updateUser(userId: string, updateData: Partial<IUser>): Promise<boolean> {
        const result = await UserSchema.updateOne({ _id: userId }, updateData);
        return result.acknowledged;
    }

    public async deleteUser(userId: string): Promise<boolean> {
        const result = await UserSchema.updateOne({ _id: userId }, { is_deleted: true, updated_at: new Date() });
        return result.acknowledged;
    }

    public async getUsers(query: any, pageNum: number, pageSize: number): Promise<IUser[]> {
        return UserSchema.find(query)
            .sort({ updated_at: -1 })
            .select('-password')
            .skip((pageNum - 1) * pageSize)
            .limit(pageSize)
            .exec();
    }

    public async countUsers(query: any): Promise<number> {
        return UserSchema.find(query).countDocuments().exec();
    }

    public async updatePassword(userId: string, newPassword: string): Promise<boolean> {
        const result = await UserSchema.updateOne(
            { _id: userId },
            { password: newPassword, updated_at: new Date() }
        );
        return result.acknowledged;
    }

    public async updateStatus(userId: string, status: boolean): Promise<boolean> {
        const result = await UserSchema.updateOne(
            { _id: userId },
            { status: status, updated_at: new Date() }
        );
        return result.acknowledged;
    }

    public async updateRole(userId: string, role: string): Promise<boolean> {
        const result = await UserSchema.updateOne(
            { _id: userId },
            { role, updated_at: new Date() }
        );
        return result.acknowledged;
    }

    public async findUserByIdWithStaffProfile(userId: string): Promise<IUser | null> {
        return UserSchema.findOne({ _id: userId, is_deleted: false })
            .populate({
                path: 'staff_profile',
                select: '-__v',
                populate: {
                    path: 'department_id',
                    select: 'name'
                }
            })
            .lean();
    }

    public async getUsersWithStaffProfile(query: any, pageNum: number, pageSize: number): Promise<IUser[]> {
        return UserSchema.find(query)
            .sort({ updated_at: -1 })
            .select('-password')
            .populate({
                path: 'staff_profile',
                select: '-__v',
                populate: {
                    path: 'department_id',
                    select: 'name'
                }
            })
            .skip((pageNum - 1) * pageSize)
            .limit(pageSize)
            .lean();
    }
}


================================================
FILE: src/modules/user/user.route.ts
================================================
import { Router } from 'express';
import { API_PATH } from '../../core/constants';
import { IRoute } from '../../core/interfaces';
import { authMiddleWare, validationMiddleware, uploadSingleFile } from '../../core/middleware';
import ChangePasswordDto from './dtos/changePassword.dto';
import ChangeStatusDto from './dtos/changeStatus.dto';
import RegisterDto from './dtos/register.dto';
import SearchPaginationUserDto from './dtos/searchPaginationUser.dto';
import UpdateUserDto from './dtos/updateUser.dto';
import UserController from './user.controller';
import { UserRoleEnum } from './user.enum';
import ChangeRoleDto from './dtos/changeRole.dto';
import ReviewProfileDto from './dtos/reviewProfileDto';

export default class UserRoute implements IRoute {
    public path = API_PATH.USERS;
    public router = Router();
    public userController = new UserController();

    constructor() {
        this.initializeRoutes();
    }

    private initializeRoutes() {
        // POST domain:/api/users/generate -> Create admin user default
        this.router.post(API_PATH.GENERATE_USERS, this.userController.generateUser);

        // POST domain:/api/users -> Register normal user
        this.router.post(
            this.path,
            uploadSingleFile('avatar_image', false),
            validationMiddleware(RegisterDto),
            this.userController.register
        );

        // POST domain:/api/users/google -> Register google user
        this.router.post(API_PATH.USERS_GOOGLE, this.userController.register);

        // POST domain:/api/users -> Create normal user
        this.router.post(
            API_PATH.CREATE_USERS,
            authMiddleWare([UserRoleEnum.ADMIN]),
            uploadSingleFile('avatar_image', false),
            validationMiddleware(RegisterDto),
            this.userController.register,
        );

        // POST domain:/api/users/search -> Get all users includes params: keyword, status, role
        this.router.post(
            API_PATH.SEARCH_USERS,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(SearchPaginationUserDto),
            this.userController.getUsers,
        );

        // PUT domain:/api/users/review-profile-account -> Review profile account
        this.router.put(
            API_PATH.REVIEW_PROFILE_ACCOUNT,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(ReviewProfileDto),
            this.userController.reviewProfileAccount,
        );

        // GET: domain:/api/users/staff-lab-tech -> Get staff and laboratory technician users
        this.router.get(
            `${this.path}/staff-lab-tech`,
            authMiddleWare([UserRoleEnum.ADMIN, UserRoleEnum.MANAGER]),
            this.userController.getStaffAndLabTechUsers
        );

        // GET domain:/api/users/:id -> Get user by id
        this.router.get(`${this.path}/:id`, authMiddleWare([], true), this.userController.getUserById);

        // PUT domain:/api/users/:id -> Update user
        this.router.put(
            `${this.path}/:id`,
            authMiddleWare(),
            uploadSingleFile('avatar_image', false),
            validationMiddleware(UpdateUserDto),
            this.userController.updateUser,
        );

        // POST domain:/api/users/:id -> Delete user logic
        this.router.delete(`${this.path}/:id`, authMiddleWare([UserRoleEnum.ADMIN]), this.userController.deleteUser);

        // PUT domain:/api/users/change-password -> Change password
        this.router.put(
            API_PATH.CHANGE_PASSWORD_USERS,
            authMiddleWare(),
            validationMiddleware(ChangePasswordDto),
            this.userController.changePassword,
        );

        // PUT domain:/api/users/change-status -> Change user status (block/unBlock)
        this.router.put(
            API_PATH.CHANGE_STATUS_USERS,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(ChangeStatusDto),
            this.userController.changeStatus,
        );

        // PUT domain:/api/users/change-role -> Change user role
        this.router.put(
            API_PATH.CHANGE_ROLE_USER,
            authMiddleWare([UserRoleEnum.ADMIN]),
            validationMiddleware(ChangeRoleDto),
            this.userController.changeRole,
        );
    }
}



================================================
FILE: src/modules/user/user.service.ts
================================================
import bcryptjs from 'bcryptjs';
import { OAuth2Client } from 'google-auth-library';
import { HttpStatus } from '../../core/enums';
import { HttpException } from '../../core/exceptions';
import { IError } from '../../core/interfaces';
import { SearchPaginationResponseModel } from '../../core/models';
import {
    checkValidUrl,
    createTokenVerifiedUser,
    encodePasswordUserNormal,
    isEmptyObject,
    sendMail,
    createVerificationEmailTemplate
} from '../../core/utils';
import { uploadFileToS3, s3Folders } from '../../core/utils/s3Upload';
import ChangePasswordDto from './dtos/changePassword.dto';
import ChangeRoleDto from './dtos/changeRole.dto';
import ChangeStatusDto from './dtos/changeStatus.dto';
import RegisterDto from './dtos/register.dto';
import ReviewProfileDto from './dtos/reviewProfileDto';
import SearchPaginationUserDto from './dtos/searchPaginationUser.dto';
import SearchUserDto from './dtos/searchUser.dto';
import UpdateUserDto from './dtos/updateUser.dto';
import { UserReviewStatusEnum, UserRoleEnum } from './user.enum';
import { IUser } from './user.interface';
import UserSchema from './user.model';
import { StaffProfileSchema, StaffStatusEnum } from '../staff_profile';
// import { SubscriptionSchema } from '../subscription';
import { DataStoredInToken, UserInfoInTokenDefault } from '../auth';
import UserRepository from './user.repository';
import { AdministrativeCaseSchema } from '../administrative_cases/administrative_cases.model';

export default class UserService {
    private userRepository = new UserRepository();
    public userSchema = UserSchema;
    // public subscriptionSchema = SubscriptionSchema;

    public async createUser(
        model: RegisterDto,
        isGoogle = false,
        isRegister = true,
        avatarFile?: Express.Multer.File
    ): Promise<IUser> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        let newUser = {
            ...model,
            role: model.role || UserRoleEnum.CUSTOMER,
            google_id: model.google_id || '',
            phone_number: model.phone_number || '',
            avatar_url: model.avatar_url || '',
            token_version: 0,
        };

        // Handle avatar file upload if provided
        if (avatarFile) {
            try {
                // Upload to S3 and get the URL
                const avatarUrl = await uploadFileToS3(avatarFile, undefined, s3Folders.personImages);
                newUser.avatar_url = avatarUrl;
            } catch (error) {
                console.error('Error uploading avatar to S3:', error);
                throw new HttpException(HttpStatus.BadRequest, 'Failed to upload avatar image');
            }
        } else if (newUser.avatar_url && !checkValidUrl(model.avatar_url)) {
            throw new HttpException(HttpStatus.BadRequest, `The URL '${model.avatar_url}' is not valid`);
        }

        if (isRegister && newUser.role === UserRoleEnum.ADMIN) {
            throw new HttpException(
                HttpStatus.BadRequest,
                `You can only register with the Customer or Staff or Manager role!`,
            );
        }

        // create a new user by google
        if (isGoogle) {
            if (model.google_id) {
                newUser = await this.formatUserByGoogle(model.google_id, newUser);
            } else {
                throw new HttpException(
                    HttpStatus.BadRequest,
                    'Field google_id via IdToken is empty, please send google_id!',
                );
            }
        }

        // check email duplicates
        const existingUserByEmail = await this.userRepository.findUserByEmail(newUser.email);
        if (existingUserByEmail) {
            throw new HttpException(HttpStatus.BadRequest, `Your email: '${newUser.email}' already exists!`);
        }

        // create a new user normal
        if (!isGoogle && model.password) {
            // handle encode password
            newUser.password = await encodePasswordUserNormal(model.password);
        }

        // send mail with token
        if (!newUser.is_verified && newUser.role !== UserRoleEnum.ADMIN) {
            let subject: string = 'Verify your email address';
            let content: string = `Hello, ${newUser.first_name} ${newUser.last_name}.`;
            let htmlContent: string = '';

            // for customer, manager, staff
            if (newUser.role === UserRoleEnum.CUSTOMER || newUser.role === UserRoleEnum.MANAGER || newUser.role === UserRoleEnum.STAFF || newUser.role === UserRoleEnum.LABORATORY_TECHNICIAN) {
                // create token verification
                const tokenData = createTokenVerifiedUser();
                newUser.verification_token = tokenData.verification_token;
                newUser.verification_token_expires = tokenData.verification_token_expires;
                const domain = process.env.DOMAIN_FE;
                const verificationLink = `${domain}/verify-email/${tokenData.verification_token}`;
                content = `${content}\nPlease click the following link to verify your email address:\n${verificationLink}`;

                // Generate HTML template for email
                const userName = `${newUser.first_name} ${newUser.last_name}`;
                htmlContent = createVerificationEmailTemplate(userName, verificationLink);
            }

            const sendMailResult = await sendMail({
                toMail: newUser.email,
                subject: subject,
                content: content,
                html: htmlContent
            });

            if (!sendMailResult) {
                throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${newUser.email}`);
            }
        }

        const createdUser: IUser = await this.userRepository.createUser(newUser as IUser);
        if (!createdUser) {
            throw new HttpException(HttpStatus.Accepted, `Create item failed!`);
        }
        const resultUser: IUser = createdUser.toObject(); // convert to plain object
        delete resultUser.password;
        return resultUser;
    }

    public async getUsers(model: SearchPaginationUserDto): Promise<SearchPaginationResponseModel<IUser>> {
        const searchCondition = { ...new SearchUserDto(), ...model.searchCondition };
        const { keyword, role, is_verified, status, is_deleted } = searchCondition;
        const { pageNum, pageSize } = model.pageInfo;

        let query: any = {
            role: { $ne: UserRoleEnum.ADMIN },
            is_deleted: is_deleted
        };

        if (keyword) {
            const keywordValue = keyword.toLowerCase().trim();
            query.$or = [
                { email: { $regex: keywordValue, $options: 'i' } },
                { first_name: { $regex: keywordValue, $options: 'i' } },
                { last_name: { $regex: keywordValue, $options: 'i' } },
            ];
        }

        // Handle role filtering with array support
        if (role && Array.isArray(role) && role.length > 0) {
            // Filter out 'all' role if present
            const filteredRoles = role.filter(r => r !== UserRoleEnum.ALL);

            // Only apply role filter if there are specific roles to filter by
            if (filteredRoles.length > 0) {
                query.role = { $in: filteredRoles };
            }
        }

        if (is_verified !== '') {
            query.is_verified = is_verified;
        }

        if (status !== undefined) {
            query.status = status;
        }

        const resultQuery = await this.userRepository.getUsersWithStaffProfile(query, pageNum, pageSize);
        const rowCount = await this.userRepository.countUsers(query);

        const result = new SearchPaginationResponseModel<IUser>();
        result.pageInfo.pageNum = pageNum;
        result.pageInfo.pageSize = pageSize;
        if (rowCount > 0) {
            result.pageData = resultQuery;
            result.pageInfo.totalItems = rowCount;
            result.pageInfo.totalPages = Math.ceil(rowCount / pageSize);
        }

        return result;
    }

    public async getUserById(
        userId: string,
        is_deletedPassword = true,
        userData: DataStoredInToken = UserInfoInTokenDefault,
    ): Promise<IUser & { administrative_cases?: any[] }> {
        const user = await this.userRepository.findUserByIdWithStaffProfile(userId);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Item is not exists.`);
        }

        if (user.role === UserRoleEnum.MANAGER || user.role === UserRoleEnum.STAFF) {
            user.is_verified = true;
        }

        if (is_deletedPassword) {
            delete user.password;
        }
        // Láº¥y cÃ¡c administrative cases mÃ  user lÃ  applicant_id
        const administrative_cases = await AdministrativeCaseSchema.find({ applicant_id: userId });
        user.administrative_cases = administrative_cases;
        return user;
    }

    public async updateUser(
        userId: string,
        model: UpdateUserDto,
        avatarFile?: Express.Multer.File
    ): Promise<IUser> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        // check user exits
        const item = await this.getUserById(userId);

        const errorResults: IError[] = [];

        if (model.dob) {
            const dobDate = new Date(model.dob);
            if (isNaN(dobDate.getTime())) {
                errorResults.push({
                    message: 'Please provide value with date type!',
                    field: 'dob',
                });
            }
        }

        // check valid
        if (errorResults.length) {
            throw new HttpException(HttpStatus.BadRequest, '', errorResults);
        }

        // Handle avatar file upload if provided
        let avatarUrl = model.avatar_url || item.avatar_url;
        if (avatarFile) {
            try {
                // Upload to S3 and get the URL
                avatarUrl = await uploadFileToS3(avatarFile, undefined, s3Folders.personImages);
            } catch (error) {
                console.error('Error uploading avatar to S3:', error);
                throw new HttpException(HttpStatus.BadRequest, 'Failed to upload avatar image');
            }
        } else if (model.avatar_url && !checkValidUrl(model.avatar_url)) {
            throw new HttpException(HttpStatus.BadRequest, `The URL '${model.avatar_url}' is not valid`);
        }

        const updateData = {
            first_name: model.first_name,
            last_name: model.last_name,
            phone_number: model.phone_number || item.phone_number,
            avatar_url: avatarUrl,
            dob: model.dob || item.dob,
            address: model.address || item.address,
            gender: model.gender || item.gender,
            updated_at: new Date(),
        };

        const updateUserId = await this.userRepository.updateUser(userId, updateData as Partial<IUser>);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Update user info failed!');
        }

        const updateUser = await this.getUserById(userId);
        return updateUser;
    }

    public async changePassword(model: ChangePasswordDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.getUserById(userId, false);

        if (!user.password) {
            throw new HttpException(HttpStatus.BadRequest, `User created by google cannot change password.`);
        }

        // check old_password
        if (model.old_password) {
            const isMatchPassword = await bcryptjs.compare(model.old_password, user.password!);
            if (!isMatchPassword) {
                throw new HttpException(HttpStatus.BadRequest, `Your old password is not valid!`);
            }
        }

        // compare new_password vs old_password
        if (model.new_password === model.old_password) {
            throw new HttpException(HttpStatus.BadRequest, `New password and old password must not be the same!`);
        }

        // handle encode password
        const newPassword = await encodePasswordUserNormal(model.new_password);
        const updatePasswordUser = await this.userRepository.updatePassword(userId, newPassword);

        if (!updatePasswordUser) throw new HttpException(HttpStatus.BadRequest, 'Change password failed!');

        return true;
    }

    public async changeStatus(model: ChangeStatusDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.getUserById(userId);

        // check change status
        if (user.status === model.status) {
            throw new HttpException(HttpStatus.BadRequest, `User status is already ${model.status}`);
        }

        const updateUserId = await this.userRepository.updateStatus(userId, model.status);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Update user status failed!');
        }

        return true;
    }

    public async changeRole(model: ChangeRoleDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.getUserById(userId);

        // check change role
        if (user.role === model.role) {
            throw new HttpException(HttpStatus.BadRequest, `User role is already ${model.role}`);
        }

        const updateUserId = await this.userRepository.updateRole(userId, model.role);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Update user status failed!');
        }

        return true;
    }

    public async reviewProfileAccount(model: ReviewProfileDto): Promise<boolean> {
        if (isEmptyObject(model)) {
            throw new HttpException(HttpStatus.BadRequest, 'Model data is empty');
        }

        const userId = model.user_id;

        // check user exits
        const user = await this.userRepository.findUserById(userId);

        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, 'User is not manager or staff or not exist or already verified!');
        }

        if (model.status === UserReviewStatusEnum.REJECT && !model.comment) {
            throw new HttpException(HttpStatus.BadRequest, 'Please enter reason reject profile manager or staff!');
        }

        // create token verification
        const tokenData = createTokenVerifiedUser();
        const domain = process.env.DOMAIN_FE;

        let subject: string = '';
        let content: string = `Hello, ${user.first_name} ${user.last_name}.`;

        if (model.status === UserReviewStatusEnum.APPROVE) {
            user.verification_token = tokenData.verification_token;
            user.verification_token_expires = tokenData.verification_token_expires;
            user.updated_at = new Date();
            subject = 'Register manager or staff success and verify your email address';
            content = `${content}\nYour manager or staff registration profile has been approved by admin.\nPlease click the following link to verify your email address:\n${domain}/verify-email/${tokenData.verification_token}`;
        } else {
            subject = 'Register manager or staff is rejected';
            content = `${content}\nYour manager or staff registration profile has been reject by admin.\nReason: '${model.comment}'.\nIf you have any questions please send email for admin!`;
        }

        const sendMailResult = await sendMail({
            toMail: user.email,
            subject,
            content,
        });

        if (!sendMailResult) {
            throw new HttpException(HttpStatus.BadRequest, `Cannot send mail for ${user.email}`);
        }

        const updateUserId = await user.save();
        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Cannot update user!');
        }

        return true;
    }

    public async deleteUser(userId: string): Promise<boolean> {
        const user = await this.getUserById(userId);
        if (!user) {
            throw new HttpException(HttpStatus.BadRequest, `Item is not exists.`);
        }

        const updateUserId = await this.userRepository.deleteUser(userId);

        if (!updateUserId) {
            throw new HttpException(HttpStatus.BadRequest, 'Delete item failed!');
        }

        return true;
    }

    // get user info from google by idToken, after get user info, format user info to RegisterDto
    private async formatUserByGoogle(google_id: string, newUser: RegisterDto): Promise<RegisterDto> {
        const client = new OAuth2Client();
        // check google_id is valid
        const ticket = await client.verifyIdToken({
            idToken: google_id,
        });
        // get user info from ticket
        const payload = ticket.getPayload();
        // If payload already exists, format user info to RegisterDto
        if (payload) {
            // newUser.last_name = newUser.first_name = payload.name!;
            newUser.first_name = payload.given_name!;
            newUser.last_name = payload.family_name!;
            newUser.email = payload.email!;
            newUser.avatar_url = payload.picture!;
            newUser.google_id = payload.sub!;
        }
        return newUser;
    }

    /**
     * Get staff and laboratory technician users
     */
    public async getStaffAndLabTechUsers(): Promise<any[]> {
        try {
            // Get users with STAFF or LABORATORY_TECHNICIAN role
            const users = await UserSchema.find({
                role: { $in: [UserRoleEnum.STAFF, UserRoleEnum.LABORATORY_TECHNICIAN] },
                is_deleted: { $ne: true } // Exclude deleted users
            }).select('_id first_name last_name email phone_number role').lean();

            if (!users || users.length === 0) {
                return [];
            }

            // Get staff profiles for these users
            const userIds = users.map(user => user._id);
            const staffProfiles = await StaffProfileSchema.find({
                user_id: { $in: userIds },
                status: StaffStatusEnum.ACTIVE
            }).lean().select('user_id status department');

            // Combine user and profile information
            const usersWithProfiles = users.map(user => {
                const profile = staffProfiles.find(p =>
                    p.user_id &&
                    user._id &&
                    p.user_id.toString() === user._id.toString()
                );

                return {
                    _id: user._id,
                    first_name: user.first_name,
                    last_name: user.last_name,
                    email: user.email,
                    phone_number: user.phone_number,
                    role: user.role,
                    staff_profile: profile ? {
                        status: profile.status,
                        department: profile.department_id
                    } : null
                };
            });

            return usersWithProfiles;
        } catch (error) {
            console.error('Error in getStaffAndLabTechUsers:', error);
            if (error instanceof HttpException) {
                throw error;
            }
            throw new HttpException(HttpStatus.InternalServerError, 'Error getting staff and laboratory technician users');
        }
    }
}



================================================
FILE: src/modules/user/dtos/changePassword.dto.ts
================================================
import { IsNotEmpty, MinLength } from "class-validator";

export default class ChangePasswordDto {
    constructor(user_id: string, old_password: string, new_password: string) {
        this.user_id = user_id;
        this.old_password = old_password;
        this.new_password = new_password;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsNotEmpty()
    @MinLength(6)
    public old_password: string;

    @IsNotEmpty()
    @MinLength(6)
    public new_password: string;
}



================================================
FILE: src/modules/user/dtos/changeRole.dto.ts
================================================
import { IsIn, IsNotEmpty } from "class-validator";
import { UserRoles } from "../user.constant";
import { UserRole } from "../user.interface";

export default class ChangeRoleDto {
    constructor(user_id: string, role: UserRole) {
        this.user_id = user_id;
        this.role = role;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsIn(UserRoles)
    public role: UserRole;
}



================================================
FILE: src/modules/user/dtos/changeStatus.dto.ts
================================================
import { IsBoolean, IsNotEmpty } from 'class-validator';

export default class ChangeStatusDto {
    constructor(user_id: string, status: boolean) {
        this.user_id = user_id;
        this.status = status;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsNotEmpty()
    @IsBoolean()
    public status: boolean;
}



================================================
FILE: src/modules/user/dtos/register.dto.ts
================================================
import { IsBoolean, IsDate, IsEmail, IsIn, IsNotEmpty, IsOptional, IsString, MinLength } from 'class-validator';
import { Type } from 'class-transformer';
import { UserRoles } from '../user.constant';
import { UserRole } from '../user.interface';
import { UserRoleEnum } from './../user.enum';

export default class RegisterDto {
    constructor(
        google_id: string = '',
        first_name: string,
        last_name: string,
        email: string,
        password: string,
        role: UserRole = UserRoleEnum.CUSTOMER,
        status: boolean = true,
        phone_number: string = '',
        avatar_url: string = '',
        dob: Date = new Date(),
        address: string = '',
        gender: string = '',

        is_verified: boolean = false,
        verification_token: string = '',
        verification_token_expires: Date = new Date(),
        token_version: number = 0,

        created_at: Date = new Date(),
        updated_at: Date = new Date(),
        is_deleted: boolean = false,
    ) {
        this.google_id = google_id;
        this.first_name = first_name;
        this.last_name = last_name;
        this.email = email;
        this.password = password;
        this.role = role;
        this.status = status;
        this.phone_number = phone_number;
        this.avatar_url = avatar_url;
        this.dob = dob;
        this.address = address;
        this.gender = gender;
        this.is_verified = is_verified;
        this.verification_token = verification_token;
        this.verification_token_expires = verification_token_expires;
        this.token_version = token_version;
        this.created_at = created_at;
        this.updated_at = updated_at;
        this.is_deleted = is_deleted;
    }

    public google_id: string;

    @IsNotEmpty()
    public first_name: string;

    @IsNotEmpty()
    public last_name: string;

    @IsNotEmpty()
    @IsEmail()
    public email: string;

    @IsNotEmpty()
    @MinLength(6)
    public password: string;

    @IsIn(UserRoles)
    @IsOptional()
    public role: UserRole;

    @IsBoolean()
    public status: boolean;

    @IsNotEmpty()
    public phone_number: string;

    @IsOptional()
    public avatar_url: string;

    @IsDate()
    @Type(() => Date)
    @IsOptional()
    public dob: Date;

    @IsString()
    @IsOptional()
    public address: string;

    @IsString()
    @IsOptional()
    public gender: string

    public is_verified: boolean;
    public verification_token: string;
    public verification_token_expires: Date;
    public token_version: number;

    @IsDate()
    public created_at: Date;

    @IsDate()
    public updated_at: Date;

    @IsBoolean()
    public is_deleted: boolean;
}



================================================
FILE: src/modules/user/dtos/reviewProfileDto.ts
================================================
import { IsIn, IsNotEmpty } from 'class-validator';
import { UserReviewStatusEnum } from '../user.enum';
import { UserReviewStatus } from '../user.interface';

export default class ReviewProfileDto {
    constructor(user_id: string, status: UserReviewStatus, comment: string) {
        this.user_id = user_id;
        this.status = status;
        this.comment = comment;
    }

    @IsNotEmpty()
    public user_id: string;

    @IsIn([UserReviewStatusEnum.APPROVE, UserReviewStatusEnum.REJECT])
    public status: UserReviewStatus;

    public comment: string;
}



================================================
FILE: src/modules/user/dtos/searchPaginationUser.dto.ts
================================================
import { Type } from 'class-transformer';
import { SearchPaginationRequestModel } from '../../../core/models';
import { PaginationRequestModel } from '../../../core/models/pagination.model';
import SearchUserDto from './searchUser.dto';

export default class SearchPaginationUserDto extends SearchPaginationRequestModel<SearchUserDto> {
    constructor(pageInfo: PaginationRequestModel, searchCondition: SearchUserDto) {
        super(pageInfo, searchCondition);
    }

    @Type(() => SearchUserDto)
    public searchCondition!: SearchUserDto;
}



================================================
FILE: src/modules/user/dtos/searchUser.dto.ts
================================================
import { IsBoolean, IsIn, IsString, IsArray } from 'class-validator';
import { UserRoles } from '../user.constant';
import { UserRole } from '../user.interface';
import { UserRoleEnum } from '../user.enum';

export default class SearchUserDto {
    constructor(
        keyword: string = '',
        role: UserRole[] | string[] = [],
        status: boolean = true,
        is_verified: boolean | string = '',
        is_deleted: boolean = false,
    ) {
        this.keyword = keyword;
        this.role = role;
        this.status = status;
        this.is_verified = is_verified;
        this.is_deleted = is_deleted;
    }

    @IsString()
    public keyword: string;

    @IsArray()
    public role: UserRole[] | string[];

    public is_verified: boolean | string;

    @IsBoolean()
    public status: boolean;

    @IsBoolean()
    public is_deleted: boolean;
}



================================================
FILE: src/modules/user/dtos/updateUser.dto.ts
================================================
import { IsDate, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { Type } from 'class-transformer';

export default class UpdateUserDto {
    constructor(
        first_name: string,
        last_name: string,
        phone_number: string,
        avatar_url: string,
        dob: Date | string,
        address: string,
        gender: string
    ) {
        this.first_name = first_name;
        this.last_name = last_name;
        this.phone_number = phone_number;
        this.avatar_url = avatar_url;
        this.dob = dob;
        this.address = address;
        this.gender = gender;
    }

    @IsNotEmpty()
    public first_name: string;

    @IsNotEmpty()
    public last_name: string;

    @IsString()
    public phone_number: string;

    @IsString()
    public avatar_url: string;

    @IsDate()
    @Type(() => Date)
    public dob: Date | string;

    @IsString()
    @IsOptional()
    public address: string;

    @IsString()
    @IsOptional()
    public gender: string;
}



================================================
FILE: src/modules/user/swagger/user.schema.js
================================================
/**
 * @swagger
 * components:
 *   schemas:
 *     UserResponse:
 *       type: object
 *       properties:
 *         _id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         first_name:
 *           type: string
 *           description: User's first name
 *           example: "John"
 *         last_name:
 *           type: string
 *           description: User's last name
 *           example: "Doe"
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *           example: "john.doe@example.com"
 *         google_id:
 *           type: string
 *           description: Google ID (if applicable)
 *           example: ""
 *         role:
 *           type: string
 *           enum: [admin, manager, staff, customer, laboratory_technician]
 *           description: User role
 *           example: "customer"
 *         status:
 *           type: boolean
 *           description: User account status (true = active, false = inactive)
 *           example: true
 *         phone_number:
 *           type: string
 *           description: User's phone number
 *           example: "+84912345678"
 *         avatar_url:
 *           type: string
 *           description: URL to user's avatar
 *           example: "https://example.com/avatars/user123.jpg"
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *           example: "1990-01-15"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: User's gender
 *           example: "male"
 *         address:
 *           type: string
 *           description: User's address
 *           example: "123 Main Street, City, Country"
 *         is_verified:
 *           type: boolean
 *           description: Email verification status
 *           example: true
 *         balance:
 *           type: number
 *           description: Current account balance
 *           example: 1000
 *         balance_total:
 *           type: number
 *           description: Total account balance
 *           example: 5000
 *         withdrawn_amount:
 *           type: number
 *           description: Total withdrawn amount
 *           example: 4000
 *         bank_name:
 *           type: string
 *           description: Bank name
 *           example: "Example Bank"
 *         bank_account_no:
 *           type: string
 *           description: Bank account number
 *           example: "1234567890"
 *         bank_account_name:
 *           type: string
 *           description: Bank account name
 *           example: "John Doe"
 *         created_at:
 *           type: string
 *           format: date-time
 *           description: Account creation date
 *           example: "2023-06-01T09:30:00.000Z"
 *         updated_at:
 *           type: string
 *           format: date-time
 *           description: Account last update date
 *           example: "2023-07-15T14:20:00.000Z"
 *
 *     RegisterDto:
 *       type: object
 *       required:
 *         - first_name
 *         - last_name
 *         - email
 *         - password
 *         - phone_number
 *       properties:
 *         google_id:
 *           type: string
 *           description: Google ID (optional)
 *           example: ""
 *         first_name:
 *           type: string
 *           description: User's first name
 *           example: "John"
 *         last_name:
 *           type: string
 *           description: User's last name
 *           example: "Doe"
 *         email:
 *           type: string
 *           format: email
 *           description: User's email address
 *           example: "john.doe@example.com"
 *         password:
 *           type: string
 *           minLength: 6
 *           description: User's password (minimum 6 characters)
 *           example: "password123"
 *         role:
 *           type: string
 *           enum: [customer, manager, staff, admin, laboratory_technician]
 *           description: User role (defaults to customer if not specified)
 *           example: "customer"
 *         phone_number:
 *           type: string
 *           description: User's phone number
 *           example: "+84912345678"
 *         avatar_url:
 *           type: string
 *           description: URL to user's avatar
 *           example: "https://example.com/avatars/user123.jpg"
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *           example: "1990-01-15"
 *         address:
 *           type: string
 *           description: User's address
 *           example: "123 Main Street, City, Country"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: User's gender
 *           example: "male"
 *
 *     UpdateUserDto:
 *       type: object
 *       required:
 *         - first_name
 *         - last_name
 *       properties:
 *         first_name:
 *           type: string
 *           description: User's first name
 *           example: "John"
 *         last_name:
 *           type: string
 *           description: User's last name
 *           example: "Doe"
 *         phone_number:
 *           type: string
 *           description: User's phone number
 *           example: "+84912345678"
 *         avatar_url:
 *           type: string
 *           description: URL to user's avatar
 *           example: "https://example.com/avatars/user123.jpg"
 *         dob:
 *           type: string
 *           format: date
 *           description: Date of birth
 *           example: "1990-01-15"
 *         address:
 *           type: string
 *           description: User's address
 *           example: "123 Main Street, City, Country"
 *         gender:
 *           type: string
 *           enum: [male, female, other]
 *           description: User's gender
 *           example: "male"
 *
 *     ChangePasswordDto:
 *       type: object
 *       required:
 *         - user_id
 *         - old_password
 *         - new_password
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         old_password:
 *           type: string
 *           description: Current password
 *           minLength: 6
 *           example: "oldPassword123"
 *         new_password:
 *           type: string
 *           description: New password
 *           minLength: 6
 *           example: "newPassword456"
 *
 *     ChangeStatusDto:
 *       type: object
 *       required:
 *         - user_id
 *         - status
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         status:
 *           type: boolean
 *           description: New status (true=active, false=inactive)
 *           example: true
 *
 *     ChangeRoleDto:
 *       type: object
 *       required:
 *         - user_id
 *         - role
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         role:
 *           type: string
 *           enum: [admin, manager, staff, customer, laboratory_technician]
 *           description: New user role
 *           example: "staff"
 *
 *     ReviewProfileDto:
 *       type: object
 *       required:
 *         - user_id
 *         - is_approved
 *       properties:
 *         user_id:
 *           type: string
 *           description: User ID
 *           example: "60d5ec9af682fbd12a0f4a1a"
 *         is_approved:
 *           type: boolean
 *           description: Approval status
 *           example: true
 *         notes:
 *           type: string
 *           description: Review notes
 *           example: "Profile information verified and approved"
 *
 *     SearchUserDto:
 *       type: object
 *       properties:
 *         keyword:
 *           type: string
 *           description: Search keyword (email, first name, last name)
 *           example: "john"
 *         role:
 *           type: array
 *           description: Filter by multiple roles
 *           items:
 *             type: string
 *             enum: ["", all, admin, manager, staff, customer, laboratory_technician]
 *           example: ["customer", "staff"]
 *         is_verified:
 *           type: boolean
 *           description: Filter by verification status
 *           example: true
 *         status:
 *           type: boolean
 *           description: Filter by user status
 *           example: true
 *         is_deleted:
 *           type: boolean
 *           description: Include deleted users
 *           example: false
 *
 *     PaginationRequestModel:
 *       type: object
 *       properties:
 *         pageNum:
 *           type: integer
 *           minimum: 1
 *           description: Page number (starting from 1)
 *           default: 1
 *           example: 1
 *         pageSize:
 *           type: integer
 *           minimum: 1
 *           description: Number of items per page
 *           default: 10
 *           example: 10
 *
 *     SearchPaginationUserDto:
 *       type: object
 *       properties:
 *         pageInfo:
 *           $ref: '#/components/schemas/PaginationRequestModel'
 *         searchCondition:
 *           $ref: '#/components/schemas/SearchUserDto'
 *
 *     SearchPaginationResponse:
 *       type: object
 *       properties:
 *         pageData:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/UserResponse'
 *         pageInfo:
 *           type: object
 *           properties:
 *             pageNum:
 *               type: integer
 *               description: Current page number
 *               example: 1
 *             pageSize:
 *               type: integer
 *               description: Number of items per page
 *               example: 10
 *             totalItems:
 *               type: integer
 *               description: Total number of items
 *               example: 25
 *             totalPages:
 *               type: integer
 *               description: Total number of pages
 *               example: 3
 */ 


================================================
FILE: src/modules/user/swagger/user.swagger.js
================================================
/**
 * @swagger
 * tags:
 *   name: users
 *   description: User management APIs
 */

/**
 * @swagger
 * /api/users:
 *   post:
 *     summary: Register new user
 *     description: Register a new user account with email and password, with optional avatar upload
 *     tags: [users]
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - first_name
 *               - last_name
 *               - email
 *               - password
 *               - phone_number
 *             properties:
 *               first_name:
 *                 type: string
 *                 example: "John"
 *               last_name:
 *                 type: string
 *                 example: "Doe"
 *               email:
 *                 type: string
 *                 format: email
 *                 example: "john.doe@example.com"
 *               password:
 *                 type: string
 *                 format: password
 *                 example: "password123"
 *               role:
 *                 type: string
 *                 enum: [customer, manager, staff, laboratory_technician]
 *                 example: "customer"
 *               phone_number:
 *                 type: string
 *                 example: "+84912345678"
 *               avatar_image:
 *                 type: string
 *                 format: binary
 *                 description: User's avatar image (jpg, jpeg, png, gif) - optional
 *               avatar_url:
 *                 type: string
 *                 description: URL to avatar (can be provided directly or uploaded via avatar_image field)
 *                 example: "https://example.com/avatars/user123.jpg"
 *               dob:
 *                 type: string
 *                 format: date
 *                 example: "1990-01-15"
 *               address:
 *                 type: string
 *                 example: "123 Main Street, City, Country"
 *               gender:
 *                 type: string
 *                 enum: [male, female, other]
 *                 example: "male"
 *     responses:
 *       201:
 *         description: User registered successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input or email already in use
 *       409:
 *         description: User with this email already exists
 */

/**
 * @swagger
 * /api/users/google:
 *   post:
 *     summary: Register with Google
 *     description: Register a new user with Google account or login if account exists
 *     tags: [users]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - google_id
 *             properties:
 *               google_id:
 *                 type: string
 *                 description: Google account ID
 *     responses:
 *       201:
 *         description: User registered successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       200:
 *         description: User logged in successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input
 */

/**
 * @swagger
 * /api/users/create:
 *   post:
 *     summary: Create user (Admin only)
 *     description: Create a new user with specified role (Admin only), with optional avatar upload
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - first_name
 *               - last_name
 *               - email
 *               - password
 *               - phone_number
 *             properties:
 *               first_name:
 *                 type: string
 *                 example: "John"
 *               last_name:
 *                 type: string
 *                 example: "Doe"
 *               email:
 *                 type: string
 *                 format: email
 *                 example: "john.doe@example.com"
 *               password:
 *                 type: string
 *                 format: password
 *                 example: "password123"
 *               role:
 *                 type: string
 *                 enum: [customer, manager, staff, admin, laboratory_technician]
 *                 example: "customer"
 *               phone_number:
 *                 type: string
 *                 example: "+84912345678"
 *               avatar_image:
 *                 type: string
 *                 format: binary
 *                 description: User's avatar image (jpg, jpeg, png, gif) - optional
 *               avatar_url:
 *                 type: string
 *                 description: URL to avatar (can be provided directly or uploaded via avatar_image field)
 *                 example: "https://example.com/avatars/user123.jpg"
 *               dob:
 *                 type: string
 *                 format: date
 *                 example: "1990-01-15"
 *               address:
 *                 type: string
 *                 example: "123 Main Street, City, Country"
 *               gender:
 *                 type: string
 *                 enum: [male, female, other]
 *                 example: "male"
 *     responses:
 *       201:
 *         description: User created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input or email already in use
 *       401:
 *         description: Unauthorized - Admin access required
 *       409:
 *         description: User with this email already exists
 */

/**
 * @swagger
 * /api/users/search:
 *   post:
 *     summary: Search users (Admin only)
 *     description: Search for users with pagination and filtering options
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/SearchPaginationUserDto'
 *     responses:
 *       200:
 *         description: Search results with pagination
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SearchPaginationResponse'
 *       400:
 *         description: Invalid input parameters
 *       401:
 *         description: Unauthorized - Admin access required
 */

/**
 * @swagger
 * /api/users/{id}:
 *   get:
 *     summary: Get user by ID
 *     description: Get user information by ID (own profile or Admin access)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     responses:
 *       200:
 *         description: User information retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid ID format
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Cannot access other user's profile
 *       404:
 *         description: User not found
 *
 *   put:
 *     summary: Update user profile
 *     description: Update user profile information (own profile or Admin access), with optional avatar upload
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - first_name
 *               - last_name
 *             properties:
 *               first_name:
 *                 type: string
 *                 example: "John"
 *               last_name:
 *                 type: string
 *                 example: "Doe"
 *               phone_number:
 *                 type: string
 *                 example: "+84912345678"
 *               avatar_image:
 *                 type: string
 *                 format: binary
 *                 description: User's avatar image (jpg, jpeg, png, gif) - optional
 *               avatar_url:
 *                 type: string
 *                 description: URL to avatar (can be provided directly or uploaded via avatar_image field)
 *                 example: "https://example.com/avatars/user123.jpg"
 *               dob:
 *                 type: string
 *                 format: date
 *                 example: "1990-01-15"
 *               address:
 *                 type: string
 *                 example: "123 Main Street, City, Country"
 *               gender:
 *                 type: string
 *                 enum: [male, female, other]
 *                 example: "male"
 *     responses:
 *       200:
 *         description: User profile updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Cannot update other user's profile
 *       404:
 *         description: User not found
 *
 *   delete:
 *     summary: Delete user (Admin only)
 *     description: Delete user by ID (soft delete - Admin only)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: User ID
 *         example: "60d5ec9af682fbd12a0f4a1a"
 *     responses:
 *       200:
 *         description: User deleted successfully
 *       400:
 *         description: Invalid ID format
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/change-password:
 *   put:
 *     summary: Change password
 *     description: Change user password (requires old password verification)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangePasswordDto'
 *     responses:
 *       200:
 *         description: Password changed successfully
 *       400:
 *         description: Invalid input or incorrect old password
 *       401:
 *         description: Unauthorized - Authentication required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/change-status:
 *   put:
 *     summary: Change user status (Admin only)
 *     description: Enable or disable a user account (Admin only)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangeStatusDto'
 *     responses:
 *       200:
 *         description: User status changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/change-role:
 *   put:
 *     summary: Change user role (Admin only)
 *     description: Change the role of a user account (Admin only)
 *     tags: [users]
 *     security:
 *       - Bearer: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChangeRoleDto'
 *     responses:
 *       200:
 *         description: User role changed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid input data
 *       401:
 *         description: Unauthorized - Admin access required
 *       404:
 *         description: User not found
 */

/**
 * @swagger
 * /api/users/staff-lab-tech:
 *   get:
 *     tags: [users]
 *     summary: Get staff and laboratory technician users (Admin and Manager only)
 *     description: Retrieve list of all staff and laboratory technician users with their profiles
 *     security:
 *       - Bearer: []
 *     responses:
 *       200:
 *         description: Users retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       _id:
 *                         type: string
 *                         description: User ID
 *                       first_name:
 *                         type: string
 *                         description: User's first name
 *                       last_name:
 *                         type: string
 *                         description: User's last name
 *                       email:
 *                         type: string
 *                         description: User's email
 *                       phone_number:
 *                         type: string
 *                         description: User's phone number
 *                       role:
 *                         type: string
 *                         enum: [STAFF, LABORATORY_TECHNICIAN]
 *                         description: User's role
 *                       staff_profile:
 *                         type: object
 *                         properties:
 *                           status:
 *                             type: string
 *                             enum: [ACTIVE, INACTIVE]
 *                             description: Staff profile status
 *                           department:
 *                             type: string
 *                             description: Department ID
 *       401:
 *         description: Unauthorized - Authentication required
 *       403:
 *         description: Forbidden - Manager access required
 *       500:
 *         description: Internal server error
 */


================================================
FILE: src/types/express.d.ts
================================================
import 'express';

declare global {
    namespace Express {
        namespace Multer {
            interface File {
                fieldname: string;
                originalname: string;
                encoding: string;
                mimetype: string;
                size: number;
                destination: string;
                filename: string;
                path: string;
                buffer: Buffer;
            }
        }

        interface Request {
            file?: Multer.File;
            files?: Multer.File[] | { [fieldname: string]: Multer.File[] };
        }
    }
} 


================================================
FILE: src/types/express/index.d.ts
================================================
declare namespace Express {
    interface Request {
        user: {
            id: string;
            role: UserRole;
            version: number;
        };
    }
}



================================================
FILE: .cursor/README.md
================================================
# Cursor IDE Rules for RestAPI Project

This directory contains custom rules and settings for the Cursor IDE that help enforce coding standards, best practices, and detect potential issues in the codebase.

## Rule Sets

The rules are organized into the following categories:

### 1. TypeScript ESLint Rules (`rules/eslint-typescript.json`)
- Basic TypeScript linting rules
- Type safety enforcement
- Interface naming conventions
- Function return type requirements

### 2. Module Structure Rules (`rules/module-structure.json`) 
- Enforces proper naming conventions for services, controllers, and models
- Prevents importing from internal module folders
- Prevents circular dependencies
- Enforces module export patterns

### 3. Code Style Rules (`rules/code-style.json`)
- Consistent indentation (4 spaces)
- Trailing semicolons
- No trailing whitespace
- Single quotes preference
- Import spacing and organization
- Line length limits (240 characters)

### 4. Security Rules (`rules/security.json`)
- Detects hardcoded secrets
- Identifies potential SQL injection vulnerabilities
- Flags insecure JWT implementations
- Ensures proper input validation
- Detects security issues with CORS and cookies

### 5. Performance Rules (`rules/performance.json`)
- Avoids nested promises
- Encourages use of `.lean()` for read-only Mongoose operations
- Detects unnecessary async/await usage
- Identifies inefficient database queries
- Warns about potentially large responses without pagination

## Usage

The rules are automatically loaded by Cursor IDE when opening the project. The main configuration file `.cursor/rules.json` references all the rule sets and provides global settings.

## Settings

Custom editor settings are defined in `.cursor/settings.json` which configures:

- Format on save
- Tab size (4 spaces)
- Maximum line length (240 characters)
- TypeScript preferences
- File associations

## Customization

To modify these rules:

1. Edit the specific rule file in the `.cursor/rules/` directory
2. Adjust severity levels as needed (error, warning, info)
3. Add or remove rules based on project requirements

For more information on Cursor IDE custom rules, refer to the [Cursor Documentation](mdc:https:/cursor.sh/docs). 


================================================
FILE: .cursor/rules.json
================================================
{
    "name": "RestAPI Project Rules",
    "description": "A comprehensive set of rules for the Node.js Express MongoDB TypeScript project",
    "rulesets": [
        "rules/eslint-typescript.json",
        "rules/module-structure.json",
        "rules/code-style.json",
        "rules/security.json",
        "rules/performance.json"
    ],
    "settings": {
        "enabledByDefault": true,
        "ignorePatterns": [
            "node_modules/**",
            "dist/**",
            "**/*.test.ts",
            "**/*.spec.ts"
        ]
    }
}


================================================
FILE: .cursor/settings.json
================================================
{
    "editor": {
        "formatOnSave": true,
        "tabSize": 4,
        "insertSpaces": true,
        "detectIndentation": true,
        "rulers": [
            240
        ],
        "wordWrap": "off",
        "trimTrailingWhitespace": true,
        "insertFinalNewline": true
    },
    "typescript": {
        "suggest.completeFunctionCalls": true,
        "preferences.importModuleSpecifier": "relative",
        "preferences.quoteStyle": "single",
        "updateImportsOnFileMove.enabled": "always",
        "suggest.autoImports": true
    },
    "linting": {
        "enable": true,
        "mode": "background"
    },
    "files": {
        "exclude": {
            "**/.git": true,
            "**/node_modules": true,
            "**/dist": true,
            "**/.DS_Store": true
        },
        "associations": {
            "*.route.ts": "typescript",
            "*.controller.ts": "typescript",
            "*.service.ts": "typescript",
            "*.model.ts": "typescript",
            "*.middleware.ts": "typescript",
            "*.dto.ts": "typescript"
        }
    },
    "cursor": {
        "rules": {
            "enableCustomRules": true,
            "rulesFile": ".cursor/rules.json"
        }
    }
}


================================================
FILE: .cursor/rules/code-style.json
================================================
{
    "name": "Code Style Rules",
    "description": "Code style and formatting rules for the project",
    "language": "typescript",
    "rules": [
        {
            "name": "consistent-indentation",
            "description": "Use 4 spaces for indentation",
            "severity": "warning",
            "pattern": "^(\\t+)",
            "message": "Use 4 spaces instead of tabs for indentation"
        },
        {
            "name": "trailing-semicolon",
            "description": "Always use semicolons",
            "severity": "warning",
            "pattern": "\\}\\s*$|\\w\\s*$",
            "message": "Missing semicolon at the end of statement"
        },
        {
            "name": "trailing-whitespace",
            "description": "No trailing whitespace",
            "severity": "warning",
            "pattern": "[ \\t]+$",
            "message": "Remove trailing whitespace"
        },
        {
            "name": "single-quotes",
            "description": "Use single quotes instead of double quotes",
            "severity": "warning",
            "pattern": "\"(?!\\{)(?!\\.\\*)(?!\\\\')(?!\\$\\{)(?!\\\\\")(?:\\\\[^']|[^\\\\\"])*\"",
            "message": "Use single quotes instead of double quotes"
        },
        {
            "name": "import-spacing",
            "description": "Group imports with newlines between different types",
            "severity": "warning",
            "pattern": "import.*from.*\\nimport",
            "message": "Group imports with newlines between different types"
        },
        {
            "name": "max-line-length",
            "description": "Maximum line length should be 240 characters",
            "severity": "warning",
            "pattern": "^.{241,}$",
            "message": "Line is too long (>240 characters)"
        },
        {
            "name": "no-multiple-empty-lines",
            "description": "No more than 2 consecutive empty lines",
            "severity": "warning",
            "pattern": "\\n\\s*\\n\\s*\\n\\s*\\n",
            "message": "Too many consecutive empty lines"
        }
    ]
}


================================================
FILE: .cursor/rules/dna-testing.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
# DNA Testing Service API Documentation

This project implements a RESTful API for a Bloodline DNA Testing Service using Node.js, Express, MongoDB, and TypeScript. The API provides endpoints for user authentication, test management, laboratory processing, and result reporting.

## Key Features

- **User Authentication**: Complete authentication system with email/password and Google OAuth
- **Test Ordering**: API endpoints for ordering various types of DNA tests
- **Sample Collection**: Tracking of sample collection kits and status
- **Laboratory Processing**: Backend integration with lab processes 
- **Result Reporting**: Secure delivery of test results to authorized users
- **Admin Dashboard**: Administrative interfaces for managing tests and users

## API Structure

The API follows a modular architecture with clear separation of concerns:
- **Auth Module**: User registration, login, verification
- **Tests Module**: Test ordering, status tracking
- **Samples Module**: Sample collection, tracking
- **Results Module**: Test results and reporting
- **Admin Module**: Administrative functions

## Documentation

API documentation is available through Swagger UI at the `/api-docs` endpoint.

## Security Features

- JWT authentication
- Role-based access control
- Input validation
- Data encryption
- Secure password storage





================================================
FILE: .cursor/rules/eslint-typescript.json
================================================
{
    "name": "TypeScript ESLint Rules",
    "description": "ESLint rules for TypeScript files in the project",
    "language": "typescript",
    "rules": [
        {
            "name": "no-explicit-any",
            "description": "Disallow usage of the any type",
            "severity": "error",
            "pattern": "any(?!where|thing|one|more|\\w)"
        },
        {
            "name": "no-console",
            "description": "Disallow console.log statements",
            "severity": "warning",
            "pattern": "console\\.(log|info|warn|error)\\("
        },
        {
            "name": "interface-naming",
            "description": "Interface names must start with 'I' and use PascalCase",
            "severity": "error",
            "pattern": "interface\\s+(?!I[A-Z])[A-Za-z]+"
        },
        {
            "name": "explicit-function-return-type",
            "description": "Functions should have explicit return types",
            "severity": "warning",
            "pattern": "function\\s+[a-zA-Z0-9_]+\\s*\\([^\\)]*\\)\\s*\\{"
        },
        {
            "name": "require-await",
            "description": "Async functions should use await",
            "severity": "warning",
            "pattern": "async\\s+function[^{]*\\{(?!\\s*[^}]*await)[^}]*\\}"
        },
        {
            "name": "model-naming",
            "description": "Model variables should use PascalCase",
            "severity": "warning",
            "pattern": "const\\s+([a-z][a-zA-Z0-9_]*(Model|Schema))\\s*="
        },
        {
            "name": "no-unused-imports",
            "description": "Detect unused imports",
            "severity": "warning",
            "pattern": "import\\s+\\{[^\\}]*\\}\\s+from\\s+['\"][^'\"]+['\"];"
        }
    ]
}


================================================
FILE: .cursor/rules/module-structure.json
================================================
{
    "name": "Module Structure Rules",
    "description": "Rules to enforce module structure and organization patterns",
    "language": "typescript",
    "rules": [
        {
            "name": "service-class-naming",
            "description": "Service classes should follow the [Name]Service pattern",
            "severity": "warning",
            "pattern": "class\\s+(?!.*Service)[A-Z][A-Za-z0-9_]*\\s+(?:implements|extends).*\\{",
            "filePattern": "src/modules/.*/services/.*\\.ts"
        },
        {
            "name": "controller-class-naming",
            "description": "Controller classes should follow the [Name]Controller pattern",
            "severity": "warning",
            "pattern": "class\\s+(?!.*Controller)[A-Z][A-Za-z0-9_]*\\s+(?:implements|extends).*\\{",
            "filePattern": "src/modules/.*/controllers/.*\\.ts"
        },
        {
            "name": "model-class-naming",
            "description": "Model schema should follow the [Name]Schema pattern",
            "severity": "warning",
            "pattern": "const\\s+(?!.*Schema)[a-zA-Z0-9_]*\\s*=\\s*new\\s+mongoose\\.Schema",
            "filePattern": "src/modules/.*/models/.*\\.ts"
        },
        {
            "name": "internal-module-import",
            "description": "Do not import from internal module folders",
            "severity": "error",
            "pattern": "import\\s+.*from\\s+['\"]modules/.*/internal/[^'\"]+['\"]"
        },
        {
            "name": "circular-imports-prevention",
            "description": "Prevent circular dependencies in routes",
            "severity": "error",
            "pattern": "import\\s+.*from\\s+['\"]\\.\\./(controllers|services)/[^'\"]+['\"]",
            "filePattern": "src/modules/.*/routes/.*\\.ts"
        },
        {
            "name": "module-export-pattern",
            "description": "Modules should have a proper export pattern",
            "severity": "warning",
            "pattern": "export\\s+default\\s+router",
            "filePattern": "src/modules/.*/routes/.*\\.ts"
        }
    ]
}


================================================
FILE: .cursor/rules/performance.json
================================================
{
    "name": "Performance Rules",
    "description": "Rules for identifying performance issues in the codebase",
    "language": "typescript",
    "rules": [
        {
            "name": "nested-promises",
            "description": "Avoid nesting promises, use async/await or chain them",
            "severity": "warning",
            "pattern": "\\.(then|catch)\\([^)]*\\)\\.(then|catch)"
        },
        {
            "name": "mongoose-lean",
            "description": "Use .lean() for read-only operations with Mongoose",
            "severity": "warning",
            "pattern": "\\.(find|findOne|findById)\\([^)]*\\)(?!\\.lean\\(\\))",
            "excludePattern": "\\.(populate|exec|sort|limit|skip)"
        },
        {
            "name": "unused-async-await",
            "description": "Unnecessary async/await usage",
            "severity": "warning",
            "pattern": "async\\s+[^(]*\\([^)]*\\)\\s*{[^}]*return\\s+[^;]*;[^}]*}"
        },
        {
            "name": "array-foreach",
            "description": "Consider using for...of instead of forEach for better performance",
            "severity": "info",
            "pattern": "\\.forEach\\("
        },
        {
            "name": "heavy-computation-in-loop",
            "description": "Avoid heavy computations inside loops",
            "severity": "warning",
            "pattern": "(for|while)\\s*\\([^)]*\\)\\s*\\{[^}]*\\.(map|filter|reduce|find|some|every)\\("
        },
        {
            "name": "inefficient-db-query",
            "description": "Potentially inefficient database query",
            "severity": "warning",
            "pattern": "\\.(find|findOne)\\(\\{\\s*\\$or:\\s*\\["
        },
        {
            "name": "large-response",
            "description": "Returning potentially large responses without pagination",
            "severity": "warning",
            "pattern": "res\\.(?:json|send)\\([^)]*\\.find\\([^)]*\\)(?!\\.limit)",
            "filePattern": "src/modules/.*/controllers/.*\\.ts"
        }
    ]
}


================================================
FILE: .cursor/rules/security.json
================================================
{
    "name": "Security Rules",
    "description": "Rules for identifying security issues in the codebase",
    "language": "typescript",
    "rules": [
        {
            "name": "hardcoded-secrets",
            "description": "No hardcoded secrets or credentials",
            "severity": "error",
            "pattern": "(password|secret|key|token|auth)\\s*[:=]\\s*['\"][^'\"]+['\"]",
            "excludePattern": "process\\.env\\."
        },
        {
            "name": "sql-injection",
            "description": "Potential SQL injection vulnerability",
            "severity": "error",
            "pattern": "(?:exec|execute|query|where)\\(`[^`]*\\$\\{(?!.*\\?\\s*\\[).*\\}`\\)"
        },
        {
            "name": "insecure-jwt",
            "description": "Insecure JWT implementation",
            "severity": "error",
            "pattern": "jwt\\.sign\\(.*,\\s*['\"][^'\"]+['\"]\\s*,\\s*\\{\\s*expiresIn"
        },
        {
            "name": "missing-input-validation",
            "description": "Missing input validation for user data",
            "severity": "warning",
            "pattern": "req\\.body\\.[a-zA-Z0-9_]+",
            "filePattern": "src/modules/.*/controllers/.*\\.ts",
            "excludePattern": "validate|check|sanitize|escape"
        },
        {
            "name": "cors-all-origins",
            "description": "CORS configured to allow all origins",
            "severity": "warning",
            "pattern": "cors\\(\\{\\s*origin:\\s*['\"]\\*['\"]"
        },
        {
            "name": "insecure-cookies",
            "description": "Cookies without secure or httpOnly flags",
            "severity": "warning",
            "pattern": "\\.cookie\\(['\"][^'\"]+['\"]\\s*,\\s*[^,]+\\s*,\\s*\\{(?!.*secure: true)(?!.*httpOnly: true)"
        },
        {
            "name": "eval-usage",
            "description": "Using eval which can lead to code injection",
            "severity": "error",
            "pattern": "eval\\([^)]*\\)"
        }
    ]
}


================================================
FILE: .husky/pre-commit
================================================
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged 
